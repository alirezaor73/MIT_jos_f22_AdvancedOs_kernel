
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
	
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

    movw $0x1234,0x472			# warm boot	
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax	
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 b0 22 04 80 	movabs $0x800422b038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 b0 22 04 80 	movabs $0x800422b000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 60 b7 22 04 80 	movabs $0x800422b760,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 04 61 21 04 80 	movabs $0x8004216104,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <i386_init>:



void
i386_init(void)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420009d:	48 ba 10 70 45 04 80 	movabs $0x8004457010,%rdx
  80042000a4:	00 00 00 
  80042000a7:	48 b8 6a 21 3d 04 80 	movabs $0x80043d216a,%rax
  80042000ae:	00 00 00 
  80042000b1:	48 29 c2             	sub    %rax,%rdx
  80042000b4:	48 89 d0             	mov    %rdx,%rax
  80042000b7:	48 89 c2             	mov    %rax,%rdx
  80042000ba:	be 00 00 00 00       	mov    $0x0,%esi
  80042000bf:	48 bf 6a 21 3d 04 80 	movabs $0x80043d216a,%rdi
  80042000c6:	00 00 00 
  80042000c9:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  80042000d0:	00 00 00 
  80042000d3:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042000d5:	48 b8 24 11 20 04 80 	movabs $0x8004201124,%rax
  80042000dc:	00 00 00 
  80042000df:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000e1:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000e6:	48 bf 40 64 21 04 80 	movabs $0x8004216440,%rdi
  80042000ed:	00 00 00 
  80042000f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000f5:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042000fc:	00 00 00 
  80042000ff:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
  8004200101:	48 b8 10 70 45 04 80 	movabs $0x8004457010,%rax
  8004200108:	00 00 00 
  800420010b:	48 89 c6             	mov    %rax,%rsi
  800420010e:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200115:	00 00 00 
  8004200118:	48 b8 fd 47 21 04 80 	movabs $0x80042147fd,%rax
  800420011f:	00 00 00 
  8004200122:	ff d0                	callq  *%rax
  8004200124:	48 ba 08 47 3d 04 80 	movabs $0x80043d4708,%rdx
  800420012b:	00 00 00 
  800420012e:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200131:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200136:	48 ba e0 21 20 04 80 	movabs $0x80042021e0,%rdx
  800420013d:	00 00 00 
  8004200140:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200142:	48 b8 34 73 20 04 80 	movabs $0x8004207334,%rax
  8004200149:	00 00 00 
  800420014c:	ff d0                	callq  *%rax
	trap_init();
  800420014e:	48 b8 3a 89 20 04 80 	movabs $0x800420893a,%rax
  8004200155:	00 00 00 
  8004200158:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  800420015a:	48 b8 85 57 21 04 80 	movabs $0x8004215785,%rax
  8004200161:	00 00 00 
  8004200164:	ff d0                	callq  *%rax
	lapic_init();
  8004200166:	48 b8 82 5b 21 04 80 	movabs $0x8004215b82,%rax
  800420016d:	00 00 00 
  8004200170:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200172:	48 b8 f2 84 20 04 80 	movabs $0x80042084f2,%rax
  8004200179:	00 00 00 
  800420017c:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:


	lock_kernel();
  800420017e:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200185:	00 00 00 
  8004200188:	ff d0                	callq  *%rax

	// Starting non-boot CPUs
	boot_aps();
  800420018a:	48 b8 bd 01 20 04 80 	movabs $0x80042001bd,%rax
  8004200191:	00 00 00 
  8004200194:	ff d0                	callq  *%rax



#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  8004200196:	be 00 00 00 00       	mov    $0x0,%esi
  800420019b:	48 bf 78 12 3c 04 80 	movabs $0x80043c1278,%rdi
  80042001a2:	00 00 00 
  80042001a5:	48 b8 cd 7a 20 04 80 	movabs $0x8004207acd,%rax
  80042001ac:	00 00 00 
  80042001af:	ff d0                	callq  *%rax

	ENV_CREATE(user_primes, ENV_TYPE_USER);
#endif // TEST*

	// Schedule and run the first user environment!
	sched_yield();
  80042001b1:	48 b8 5f c3 20 04 80 	movabs $0x800420c35f,%rax
  80042001b8:	00 00 00 
  80042001bb:	ff d0                	callq  *%rax

00000080042001bd <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  80042001bd:	55                   	push   %rbp
  80042001be:	48 89 e5             	mov    %rsp,%rbp
  80042001c1:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  80042001c5:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  80042001cc:	00 
  80042001cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042001d1:	48 c1 e8 0c          	shr    $0xc,%rax
  80042001d5:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042001d8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042001db:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042001e2:	00 00 00 
  80042001e5:	48 8b 00             	mov    (%rax),%rax
  80042001e8:	48 39 c2             	cmp    %rax,%rdx
  80042001eb:	72 32                	jb     800420021f <boot_aps+0x62>
  80042001ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042001f1:	48 89 c1             	mov    %rax,%rcx
  80042001f4:	48 ba 60 64 21 04 80 	movabs $0x8004216460,%rdx
  80042001fb:	00 00 00 
  80042001fe:	be 68 00 00 00       	mov    $0x68,%esi
  8004200203:	48 bf 83 64 21 04 80 	movabs $0x8004216483,%rdi
  800420020a:	00 00 00 
  800420020d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200212:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004200219:	00 00 00 
  800420021c:	41 ff d0             	callq  *%r8
  800420021f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004200226:	00 00 00 
  8004200229:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420022d:	48 01 d0             	add    %rdx,%rax
  8004200230:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  8004200234:	48 ba ae 52 21 04 80 	movabs $0x80042152ae,%rdx
  800420023b:	00 00 00 
  800420023e:	48 b8 c8 51 21 04 80 	movabs $0x80042151c8,%rax
  8004200245:	00 00 00 
  8004200248:	48 29 c2             	sub    %rax,%rdx
  800420024b:	48 89 d0             	mov    %rdx,%rax
  800420024e:	48 89 c2             	mov    %rax,%rdx
  8004200251:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200255:	48 be c8 51 21 04 80 	movabs $0x80042151c8,%rsi
  800420025c:	00 00 00 
  800420025f:	48 89 c7             	mov    %rax,%rdi
  8004200262:	48 b8 68 ee 20 04 80 	movabs $0x800420ee68,%rax
  8004200269:	00 00 00 
  800420026c:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  800420026e:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  8004200275:	00 00 00 
  8004200278:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420027c:	e9 0b 01 00 00       	jmpq   800420038c <boot_aps+0x1cf>
		if (c == cpus + cpunum())  // We've started already.
  8004200281:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004200288:	00 00 00 
  800420028b:	ff d0                	callq  *%rax
  800420028d:	48 98                	cltq   
  800420028f:	48 c1 e0 03          	shl    $0x3,%rax
  8004200293:	48 89 c2             	mov    %rax,%rdx
  8004200296:	48 c1 e2 04          	shl    $0x4,%rdx
  800420029a:	48 29 c2             	sub    %rax,%rdx
  800420029d:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  80042002a4:	00 00 00 
  80042002a7:	48 01 d0             	add    %rdx,%rax
  80042002aa:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042002ae:	75 05                	jne    80042002b5 <boot_aps+0xf8>
			continue;
  80042002b0:	e9 d2 00 00 00       	jmpq   8004200387 <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  80042002b5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042002b9:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  80042002c0:	00 00 00 
  80042002c3:	48 29 c2             	sub    %rax,%rdx
  80042002c6:	48 89 d0             	mov    %rdx,%rax
  80042002c9:	48 c1 f8 03          	sar    $0x3,%rax
  80042002cd:	48 89 c2             	mov    %rax,%rdx
  80042002d0:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  80042002d7:	ee ee ee 
  80042002da:	48 0f af c2          	imul   %rdx,%rax
  80042002de:	48 83 c0 01          	add    $0x1,%rax
  80042002e2:	48 c1 e0 10          	shl    $0x10,%rax
  80042002e6:	48 89 c2             	mov    %rax,%rdx
  80042002e9:	48 b8 00 70 3d 04 80 	movabs $0x80043d7000,%rax
  80042002f0:	00 00 00 
  80042002f3:	48 01 c2             	add    %rax,%rdx
  80042002f6:	48 b8 18 47 3d 04 80 	movabs $0x80043d4718,%rax
  80042002fd:	00 00 00 
  8004200300:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  8004200303:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200307:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420030b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200312:	00 00 00 
  8004200315:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004200319:	77 32                	ja     800420034d <boot_aps+0x190>
  800420031b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420031f:	48 89 c1             	mov    %rax,%rcx
  8004200322:	48 ba 90 64 21 04 80 	movabs $0x8004216490,%rdx
  8004200329:	00 00 00 
  800420032c:	be 72 00 00 00       	mov    $0x72,%esi
  8004200331:	48 bf 83 64 21 04 80 	movabs $0x8004216483,%rdi
  8004200338:	00 00 00 
  800420033b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200340:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004200347:	00 00 00 
  800420034a:	41 ff d0             	callq  *%r8
  800420034d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004200354:	ff ff ff 
  8004200357:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420035b:	48 01 d0             	add    %rdx,%rax
  800420035e:	89 c2                	mov    %eax,%edx
  8004200360:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200364:	0f b6 00             	movzbl (%rax),%eax
  8004200367:	0f b6 c0             	movzbl %al,%eax
  800420036a:	89 d6                	mov    %edx,%esi
  800420036c:	89 c7                	mov    %eax,%edi
  800420036e:	48 b8 e9 5d 21 04 80 	movabs $0x8004215de9,%rax
  8004200375:	00 00 00 
  8004200378:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  800420037a:	90                   	nop
  800420037b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420037f:	8b 40 04             	mov    0x4(%rax),%eax
  8004200382:	83 f8 01             	cmp    $0x1,%eax
  8004200385:	75 f4                	jne    800420037b <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200387:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  800420038c:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  8004200393:	00 00 00 
  8004200396:	8b 00                	mov    (%rax),%eax
  8004200398:	48 98                	cltq   
  800420039a:	48 c1 e0 03          	shl    $0x3,%rax
  800420039e:	48 89 c2             	mov    %rax,%rdx
  80042003a1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003a5:	48 29 c2             	sub    %rax,%rdx
  80042003a8:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  80042003af:	00 00 00 
  80042003b2:	48 01 d0             	add    %rdx,%rax
  80042003b5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042003b9:	0f 87 c2 fe ff ff    	ja     8004200281 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  80042003bf:	c9                   	leaveq 
  80042003c0:	c3                   	retq   

00000080042003c1 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  80042003c1:	55                   	push   %rbp
  80042003c2:	48 89 e5             	mov    %rsp,%rbp
  80042003c5:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir
	lcr3(boot_cr3);
  80042003c9:	48 b8 20 47 3d 04 80 	movabs $0x80043d4720,%rax
  80042003d0:	00 00 00 
  80042003d3:	48 8b 00             	mov    (%rax),%rax
  80042003d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  80042003da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003de:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  80042003e1:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042003e8:	00 00 00 
  80042003eb:	ff d0                	callq  *%rax
  80042003ed:	89 c6                	mov    %eax,%esi
  80042003ef:	48 bf b4 64 21 04 80 	movabs $0x80042164b4,%rdi
  80042003f6:	00 00 00 
  80042003f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003fe:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004200405:	00 00 00 
  8004200408:	ff d2                	callq  *%rdx

	lapic_init();
  800420040a:	48 b8 82 5b 21 04 80 	movabs $0x8004215b82,%rax
  8004200411:	00 00 00 
  8004200414:	ff d0                	callq  *%rax
	env_init_percpu();
  8004200416:	48 b8 84 74 20 04 80 	movabs $0x8004207484,%rax
  800420041d:	00 00 00 
  8004200420:	ff d0                	callq  *%rax
	trap_init_percpu();
  8004200422:	48 b8 ea b0 20 04 80 	movabs $0x800420b0ea,%rax
  8004200429:	00 00 00 
  800420042c:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  800420042e:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004200435:	00 00 00 
  8004200438:	ff d0                	callq  *%rax
  800420043a:	48 98                	cltq   
  800420043c:	48 c1 e0 03          	shl    $0x3,%rax
  8004200440:	48 89 c2             	mov    %rax,%rdx
  8004200443:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200447:	48 29 c2             	sub    %rax,%rdx
  800420044a:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  8004200451:	00 00 00 
  8004200454:	48 01 d0             	add    %rdx,%rax
  8004200457:	48 83 c0 04          	add    $0x4,%rax
  800420045b:	be 01 00 00 00       	mov    $0x1,%esi
  8004200460:	48 89 c7             	mov    %rax,%rdi
  8004200463:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  800420046a:	00 00 00 
  800420046d:	ff d0                	callq  *%rax
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:


	lock_kernel();
  800420046f:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200476:	00 00 00 
  8004200479:	ff d0                	callq  *%rax
	sched_yield();
  800420047b:	48 b8 5f c3 20 04 80 	movabs $0x800420c35f,%rax
  8004200482:	00 00 00 
  8004200485:	ff d0                	callq  *%rax

0000008004200487 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8004200487:	55                   	push   %rbp
  8004200488:	48 89 e5             	mov    %rsp,%rbp
  800420048b:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200492:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200499:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  800420049f:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042004a6:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042004ad:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042004b4:	84 c0                	test   %al,%al
  80042004b6:	74 20                	je     80042004d8 <_panic+0x51>
  80042004b8:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042004bc:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042004c0:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042004c4:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042004c8:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042004cc:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042004d0:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042004d4:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042004d8:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  80042004df:	48 b8 10 47 3d 04 80 	movabs $0x80043d4710,%rax
  80042004e6:	00 00 00 
  80042004e9:	48 8b 00             	mov    (%rax),%rax
  80042004ec:	48 85 c0             	test   %rax,%rax
  80042004ef:	74 05                	je     80042004f6 <_panic+0x6f>
		goto dead;
  80042004f1:	e9 b5 00 00 00       	jmpq   80042005ab <_panic+0x124>
	panicstr = fmt;
  80042004f6:	48 b8 10 47 3d 04 80 	movabs $0x80043d4710,%rax
  80042004fd:	00 00 00 
  8004200500:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004200507:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  800420050a:	fa                   	cli    
  800420050b:	fc                   	cld    

	va_start(ap, fmt);
  800420050c:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200513:	00 00 00 
  8004200516:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420051d:	00 00 00 
  8004200520:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200524:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420052b:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200532:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  8004200539:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004200540:	00 00 00 
  8004200543:	ff d0                	callq  *%rax
  8004200545:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  800420054b:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004200552:	89 c6                	mov    %eax,%esi
  8004200554:	48 bf d0 64 21 04 80 	movabs $0x80042164d0,%rdi
  800420055b:	00 00 00 
  800420055e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200563:	49 b8 c2 87 20 04 80 	movabs $0x80042087c2,%r8
  800420056a:	00 00 00 
  800420056d:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  8004200570:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200577:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420057e:	48 89 d6             	mov    %rdx,%rsi
  8004200581:	48 89 c7             	mov    %rax,%rdi
  8004200584:	48 b8 63 87 20 04 80 	movabs $0x8004208763,%rax
  800420058b:	00 00 00 
  800420058e:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200590:	48 bf f2 64 21 04 80 	movabs $0x80042164f2,%rdi
  8004200597:	00 00 00 
  800420059a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420059f:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042005a6:	00 00 00 
  80042005a9:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  80042005ab:	bf 00 00 00 00       	mov    $0x0,%edi
  80042005b0:	48 b8 1f 16 20 04 80 	movabs $0x800420161f,%rax
  80042005b7:	00 00 00 
  80042005ba:	ff d0                	callq  *%rax
  80042005bc:	eb ed                	jmp    80042005ab <_panic+0x124>

00000080042005be <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  80042005be:	55                   	push   %rbp
  80042005bf:	48 89 e5             	mov    %rsp,%rbp
  80042005c2:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042005c9:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042005d0:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042005d6:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042005dd:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042005e4:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042005eb:	84 c0                	test   %al,%al
  80042005ed:	74 20                	je     800420060f <_warn+0x51>
  80042005ef:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042005f3:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042005f7:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042005fb:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042005ff:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200603:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200607:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420060b:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420060f:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004200616:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420061d:	00 00 00 
  8004200620:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200627:	00 00 00 
  800420062a:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420062e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200635:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420063c:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  8004200643:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200649:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200650:	48 89 c6             	mov    %rax,%rsi
  8004200653:	48 bf f4 64 21 04 80 	movabs $0x80042164f4,%rdi
  800420065a:	00 00 00 
  800420065d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200662:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  8004200669:	00 00 00 
  800420066c:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  800420066e:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200675:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420067c:	48 89 d6             	mov    %rdx,%rsi
  800420067f:	48 89 c7             	mov    %rax,%rdi
  8004200682:	48 b8 63 87 20 04 80 	movabs $0x8004208763,%rax
  8004200689:	00 00 00 
  800420068c:	ff d0                	callq  *%rax
	cprintf("\n");
  800420068e:	48 bf f2 64 21 04 80 	movabs $0x80042164f2,%rdi
  8004200695:	00 00 00 
  8004200698:	b8 00 00 00 00       	mov    $0x0,%eax
  800420069d:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042006a4:	00 00 00 
  80042006a7:	ff d2                	callq  *%rdx
	va_end(ap);
}
  80042006a9:	c9                   	leaveq 
  80042006aa:	c3                   	retq   

00000080042006ab <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  80042006ab:	55                   	push   %rbp
  80042006ac:	48 89 e5             	mov    %rsp,%rbp
  80042006af:	48 83 ec 20          	sub    $0x20,%rsp
  80042006b3:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042006ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042006bd:	89 c2                	mov    %eax,%edx
  80042006bf:	ec                   	in     (%dx),%al
  80042006c0:	88 45 fb             	mov    %al,-0x5(%rbp)
  80042006c3:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  80042006ca:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042006cd:	89 c2                	mov    %eax,%edx
  80042006cf:	ec                   	in     (%dx),%al
  80042006d0:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042006d3:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  80042006da:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042006dd:	89 c2                	mov    %eax,%edx
  80042006df:	ec                   	in     (%dx),%al
  80042006e0:	88 45 eb             	mov    %al,-0x15(%rbp)
  80042006e3:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  80042006ea:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042006ed:	89 c2                	mov    %eax,%edx
  80042006ef:	ec                   	in     (%dx),%al
  80042006f0:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  80042006f3:	c9                   	leaveq 
  80042006f4:	c3                   	retq   

00000080042006f5 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  80042006f5:	55                   	push   %rbp
  80042006f6:	48 89 e5             	mov    %rsp,%rbp
  80042006f9:	48 83 ec 10          	sub    $0x10,%rsp
  80042006fd:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  8004200704:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200707:	89 c2                	mov    %eax,%edx
  8004200709:	ec                   	in     (%dx),%al
  800420070a:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  800420070d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200711:	0f b6 c0             	movzbl %al,%eax
  8004200714:	83 e0 01             	and    $0x1,%eax
  8004200717:	85 c0                	test   %eax,%eax
  8004200719:	75 07                	jne    8004200722 <serial_proc_data+0x2d>
		return -1;
  800420071b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200720:	eb 17                	jmp    8004200739 <serial_proc_data+0x44>
  8004200722:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200729:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420072c:	89 c2                	mov    %eax,%edx
  800420072e:	ec                   	in     (%dx),%al
  800420072f:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200732:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  8004200736:	0f b6 c0             	movzbl %al,%eax
}
  8004200739:	c9                   	leaveq 
  800420073a:	c3                   	retq   

000000800420073b <serial_intr>:

void
serial_intr(void)
{
  800420073b:	55                   	push   %rbp
  800420073c:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  800420073f:	48 b8 00 30 3d 04 80 	movabs $0x80043d3000,%rax
  8004200746:	00 00 00 
  8004200749:	0f b6 00             	movzbl (%rax),%eax
  800420074c:	84 c0                	test   %al,%al
  800420074e:	74 16                	je     8004200766 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  8004200750:	48 bf f5 06 20 04 80 	movabs $0x80042006f5,%rdi
  8004200757:	00 00 00 
  800420075a:	48 b8 a7 0f 20 04 80 	movabs $0x8004200fa7,%rax
  8004200761:	00 00 00 
  8004200764:	ff d0                	callq  *%rax
}
  8004200766:	5d                   	pop    %rbp
  8004200767:	c3                   	retq   

0000008004200768 <serial_putc>:

static void
serial_putc(int c)
{
  8004200768:	55                   	push   %rbp
  8004200769:	48 89 e5             	mov    %rsp,%rbp
  800420076c:	48 83 ec 28          	sub    $0x28,%rsp
  8004200770:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  8004200773:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420077a:	eb 10                	jmp    800420078c <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  800420077c:	48 b8 ab 06 20 04 80 	movabs $0x80042006ab,%rax
  8004200783:	00 00 00 
  8004200786:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  8004200788:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420078c:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200793:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200796:	89 c2                	mov    %eax,%edx
  8004200798:	ec                   	in     (%dx),%al
  8004200799:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  800420079c:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007a0:	0f b6 c0             	movzbl %al,%eax
  80042007a3:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  80042007a6:	85 c0                	test   %eax,%eax
  80042007a8:	75 09                	jne    80042007b3 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007aa:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042007b1:	7e c9                	jle    800420077c <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  80042007b3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042007b6:	0f b6 c0             	movzbl %al,%eax
  80042007b9:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  80042007c0:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042007c3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042007c7:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042007ca:	ee                   	out    %al,(%dx)
}
  80042007cb:	c9                   	leaveq 
  80042007cc:	c3                   	retq   

00000080042007cd <serial_init>:

static void
serial_init(void)
{
  80042007cd:	55                   	push   %rbp
  80042007ce:	48 89 e5             	mov    %rsp,%rbp
  80042007d1:	48 83 ec 50          	sub    $0x50,%rsp
  80042007d5:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  80042007dc:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  80042007e0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042007e4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042007e7:	ee                   	out    %al,(%dx)
  80042007e8:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  80042007ef:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  80042007f3:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042007f7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042007fa:	ee                   	out    %al,(%dx)
  80042007fb:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  8004200802:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  8004200806:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420080a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420080d:	ee                   	out    %al,(%dx)
  800420080e:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  8004200815:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  8004200819:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800420081d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200820:	ee                   	out    %al,(%dx)
  8004200821:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  8004200828:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  800420082c:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200830:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200833:	ee                   	out    %al,(%dx)
  8004200834:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  800420083b:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  800420083f:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200843:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200846:	ee                   	out    %al,(%dx)
  8004200847:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  800420084e:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  8004200852:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004200856:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200859:	ee                   	out    %al,(%dx)
  800420085a:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200861:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004200864:	89 c2                	mov    %eax,%edx
  8004200866:	ec                   	in     (%dx),%al
  8004200867:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  800420086a:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  800420086e:	3c ff                	cmp    $0xff,%al
  8004200870:	0f 95 c2             	setne  %dl
  8004200873:	48 b8 00 30 3d 04 80 	movabs $0x80043d3000,%rax
  800420087a:	00 00 00 
  800420087d:	88 10                	mov    %dl,(%rax)
  800420087f:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200886:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004200889:	89 c2                	mov    %eax,%edx
  800420088b:	ec                   	in     (%dx),%al
  800420088c:	88 45 bb             	mov    %al,-0x45(%rbp)
  800420088f:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  8004200896:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004200899:	89 c2                	mov    %eax,%edx
  800420089b:	ec                   	in     (%dx),%al
  800420089c:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

}
  800420089f:	c9                   	leaveq 
  80042008a0:	c3                   	retq   

00000080042008a1 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  80042008a1:	55                   	push   %rbp
  80042008a2:	48 89 e5             	mov    %rsp,%rbp
  80042008a5:	48 83 ec 38          	sub    $0x38,%rsp
  80042008a9:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  80042008ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042008b3:	eb 10                	jmp    80042008c5 <lpt_putc+0x24>
		delay();
  80042008b5:	48 b8 ab 06 20 04 80 	movabs $0x80042006ab,%rax
  80042008bc:	00 00 00 
  80042008bf:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  80042008c1:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042008c5:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  80042008cc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042008cf:	89 c2                	mov    %eax,%edx
  80042008d1:	ec                   	in     (%dx),%al
  80042008d2:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042008d5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042008d9:	84 c0                	test   %al,%al
  80042008db:	78 09                	js     80042008e6 <lpt_putc+0x45>
  80042008dd:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042008e4:	7e cf                	jle    80042008b5 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  80042008e6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042008e9:	0f b6 c0             	movzbl %al,%eax
  80042008ec:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  80042008f3:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042008f6:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042008fa:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042008fd:	ee                   	out    %al,(%dx)
  80042008fe:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200905:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  8004200909:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420090d:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200910:	ee                   	out    %al,(%dx)
  8004200911:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200918:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  800420091c:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200920:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200923:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200924:	c9                   	leaveq 
  8004200925:	c3                   	retq   

0000008004200926 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200926:	55                   	push   %rbp
  8004200927:	48 89 e5             	mov    %rsp,%rbp
  800420092a:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  800420092e:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200935:	00 00 00 
  8004200938:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  800420093c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200940:	0f b7 00             	movzwl (%rax),%eax
  8004200943:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200947:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420094b:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200950:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200954:	0f b7 00             	movzwl (%rax),%eax
  8004200957:	66 3d 5a a5          	cmp    $0xa55a,%ax
  800420095b:	74 20                	je     800420097d <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  800420095d:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200964:	00 00 00 
  8004200967:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  800420096b:	48 b8 04 30 3d 04 80 	movabs $0x80043d3004,%rax
  8004200972:	00 00 00 
  8004200975:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  800420097b:	eb 1b                	jmp    8004200998 <cga_init+0x72>
	} else {
		*cp = was;
  800420097d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200981:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200985:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200988:	48 b8 04 30 3d 04 80 	movabs $0x80043d3004,%rax
  800420098f:	00 00 00 
  8004200992:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200998:	48 b8 04 30 3d 04 80 	movabs $0x80043d3004,%rax
  800420099f:	00 00 00 
  80042009a2:	8b 00                	mov    (%rax),%eax
  80042009a4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042009a7:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  80042009ab:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042009af:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042009b2:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  80042009b3:	48 b8 04 30 3d 04 80 	movabs $0x80043d3004,%rax
  80042009ba:	00 00 00 
  80042009bd:	8b 00                	mov    (%rax),%eax
  80042009bf:	83 c0 01             	add    $0x1,%eax
  80042009c2:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042009c5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042009c8:	89 c2                	mov    %eax,%edx
  80042009ca:	ec                   	in     (%dx),%al
  80042009cb:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  80042009ce:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042009d2:	0f b6 c0             	movzbl %al,%eax
  80042009d5:	c1 e0 08             	shl    $0x8,%eax
  80042009d8:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  80042009db:	48 b8 04 30 3d 04 80 	movabs $0x80043d3004,%rax
  80042009e2:	00 00 00 
  80042009e5:	8b 00                	mov    (%rax),%eax
  80042009e7:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042009ea:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042009ee:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042009f2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042009f5:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  80042009f6:	48 b8 04 30 3d 04 80 	movabs $0x80043d3004,%rax
  80042009fd:	00 00 00 
  8004200a00:	8b 00                	mov    (%rax),%eax
  8004200a02:	83 c0 01             	add    $0x1,%eax
  8004200a05:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a08:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200a0b:	89 c2                	mov    %eax,%edx
  8004200a0d:	ec                   	in     (%dx),%al
  8004200a0e:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200a11:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200a15:	0f b6 c0             	movzbl %al,%eax
  8004200a18:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200a1b:	48 b8 08 30 3d 04 80 	movabs $0x80043d3008,%rax
  8004200a22:	00 00 00 
  8004200a25:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200a29:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200a2c:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200a2f:	89 c2                	mov    %eax,%edx
  8004200a31:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200a38:	00 00 00 
  8004200a3b:	66 89 10             	mov    %dx,(%rax)
}
  8004200a3e:	c9                   	leaveq 
  8004200a3f:	c3                   	retq   

0000008004200a40 <cga_putc>:



static void
cga_putc(int c)
{
  8004200a40:	55                   	push   %rbp
  8004200a41:	48 89 e5             	mov    %rsp,%rbp
  8004200a44:	48 83 ec 40          	sub    $0x40,%rsp
  8004200a48:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200a4b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200a4e:	b0 00                	mov    $0x0,%al
  8004200a50:	85 c0                	test   %eax,%eax
  8004200a52:	75 07                	jne    8004200a5b <cga_putc+0x1b>
		c |= 0x0700;
  8004200a54:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200a5b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200a5e:	0f b6 c0             	movzbl %al,%eax
  8004200a61:	83 f8 09             	cmp    $0x9,%eax
  8004200a64:	0f 84 f6 00 00 00    	je     8004200b60 <cga_putc+0x120>
  8004200a6a:	83 f8 09             	cmp    $0x9,%eax
  8004200a6d:	7f 0a                	jg     8004200a79 <cga_putc+0x39>
  8004200a6f:	83 f8 08             	cmp    $0x8,%eax
  8004200a72:	74 18                	je     8004200a8c <cga_putc+0x4c>
  8004200a74:	e9 3e 01 00 00       	jmpq   8004200bb7 <cga_putc+0x177>
  8004200a79:	83 f8 0a             	cmp    $0xa,%eax
  8004200a7c:	74 75                	je     8004200af3 <cga_putc+0xb3>
  8004200a7e:	83 f8 0d             	cmp    $0xd,%eax
  8004200a81:	0f 84 89 00 00 00    	je     8004200b10 <cga_putc+0xd0>
  8004200a87:	e9 2b 01 00 00       	jmpq   8004200bb7 <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200a8c:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200a93:	00 00 00 
  8004200a96:	0f b7 00             	movzwl (%rax),%eax
  8004200a99:	66 85 c0             	test   %ax,%ax
  8004200a9c:	74 50                	je     8004200aee <cga_putc+0xae>
			crt_pos--;
  8004200a9e:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200aa5:	00 00 00 
  8004200aa8:	0f b7 00             	movzwl (%rax),%eax
  8004200aab:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200aae:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200ab5:	00 00 00 
  8004200ab8:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200abb:	48 b8 08 30 3d 04 80 	movabs $0x80043d3008,%rax
  8004200ac2:	00 00 00 
  8004200ac5:	48 8b 10             	mov    (%rax),%rdx
  8004200ac8:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200acf:	00 00 00 
  8004200ad2:	0f b7 00             	movzwl (%rax),%eax
  8004200ad5:	0f b7 c0             	movzwl %ax,%eax
  8004200ad8:	48 01 c0             	add    %rax,%rax
  8004200adb:	48 01 c2             	add    %rax,%rdx
  8004200ade:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ae1:	b0 00                	mov    $0x0,%al
  8004200ae3:	83 c8 20             	or     $0x20,%eax
  8004200ae6:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200ae9:	e9 04 01 00 00       	jmpq   8004200bf2 <cga_putc+0x1b2>
  8004200aee:	e9 ff 00 00 00       	jmpq   8004200bf2 <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200af3:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200afa:	00 00 00 
  8004200afd:	0f b7 00             	movzwl (%rax),%eax
  8004200b00:	8d 50 50             	lea    0x50(%rax),%edx
  8004200b03:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200b0a:	00 00 00 
  8004200b0d:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200b10:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200b17:	00 00 00 
  8004200b1a:	0f b7 30             	movzwl (%rax),%esi
  8004200b1d:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200b24:	00 00 00 
  8004200b27:	0f b7 08             	movzwl (%rax),%ecx
  8004200b2a:	0f b7 c1             	movzwl %cx,%eax
  8004200b2d:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200b33:	c1 e8 10             	shr    $0x10,%eax
  8004200b36:	89 c2                	mov    %eax,%edx
  8004200b38:	66 c1 ea 06          	shr    $0x6,%dx
  8004200b3c:	89 d0                	mov    %edx,%eax
  8004200b3e:	c1 e0 02             	shl    $0x2,%eax
  8004200b41:	01 d0                	add    %edx,%eax
  8004200b43:	c1 e0 04             	shl    $0x4,%eax
  8004200b46:	29 c1                	sub    %eax,%ecx
  8004200b48:	89 ca                	mov    %ecx,%edx
  8004200b4a:	29 d6                	sub    %edx,%esi
  8004200b4c:	89 f2                	mov    %esi,%edx
  8004200b4e:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200b55:	00 00 00 
  8004200b58:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200b5b:	e9 92 00 00 00       	jmpq   8004200bf2 <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200b60:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200b65:	48 b8 e4 10 20 04 80 	movabs $0x80042010e4,%rax
  8004200b6c:	00 00 00 
  8004200b6f:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200b71:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200b76:	48 b8 e4 10 20 04 80 	movabs $0x80042010e4,%rax
  8004200b7d:	00 00 00 
  8004200b80:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200b82:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200b87:	48 b8 e4 10 20 04 80 	movabs $0x80042010e4,%rax
  8004200b8e:	00 00 00 
  8004200b91:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200b93:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200b98:	48 b8 e4 10 20 04 80 	movabs $0x80042010e4,%rax
  8004200b9f:	00 00 00 
  8004200ba2:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200ba4:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200ba9:	48 b8 e4 10 20 04 80 	movabs $0x80042010e4,%rax
  8004200bb0:	00 00 00 
  8004200bb3:	ff d0                	callq  *%rax
		break;
  8004200bb5:	eb 3b                	jmp    8004200bf2 <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200bb7:	48 b8 08 30 3d 04 80 	movabs $0x80043d3008,%rax
  8004200bbe:	00 00 00 
  8004200bc1:	48 8b 30             	mov    (%rax),%rsi
  8004200bc4:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200bcb:	00 00 00 
  8004200bce:	0f b7 00             	movzwl (%rax),%eax
  8004200bd1:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200bd4:	48 ba 10 30 3d 04 80 	movabs $0x80043d3010,%rdx
  8004200bdb:	00 00 00 
  8004200bde:	66 89 0a             	mov    %cx,(%rdx)
  8004200be1:	0f b7 c0             	movzwl %ax,%eax
  8004200be4:	48 01 c0             	add    %rax,%rax
  8004200be7:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200beb:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bee:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200bf1:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200bf2:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200bf9:	00 00 00 
  8004200bfc:	0f b7 00             	movzwl (%rax),%eax
  8004200bff:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200c03:	0f 86 89 00 00 00    	jbe    8004200c92 <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200c09:	48 b8 08 30 3d 04 80 	movabs $0x80043d3008,%rax
  8004200c10:	00 00 00 
  8004200c13:	48 8b 00             	mov    (%rax),%rax
  8004200c16:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200c1d:	48 b8 08 30 3d 04 80 	movabs $0x80043d3008,%rax
  8004200c24:	00 00 00 
  8004200c27:	48 8b 00             	mov    (%rax),%rax
  8004200c2a:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200c2f:	48 89 ce             	mov    %rcx,%rsi
  8004200c32:	48 89 c7             	mov    %rax,%rdi
  8004200c35:	48 b8 68 ee 20 04 80 	movabs $0x800420ee68,%rax
  8004200c3c:	00 00 00 
  8004200c3f:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200c41:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200c48:	eb 22                	jmp    8004200c6c <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200c4a:	48 b8 08 30 3d 04 80 	movabs $0x80043d3008,%rax
  8004200c51:	00 00 00 
  8004200c54:	48 8b 00             	mov    (%rax),%rax
  8004200c57:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200c5a:	48 63 d2             	movslq %edx,%rdx
  8004200c5d:	48 01 d2             	add    %rdx,%rdx
  8004200c60:	48 01 d0             	add    %rdx,%rax
  8004200c63:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200c68:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200c6c:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200c73:	7e d5                	jle    8004200c4a <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200c75:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200c7c:	00 00 00 
  8004200c7f:	0f b7 00             	movzwl (%rax),%eax
  8004200c82:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200c85:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200c8c:	00 00 00 
  8004200c8f:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200c92:	48 b8 04 30 3d 04 80 	movabs $0x80043d3004,%rax
  8004200c99:	00 00 00 
  8004200c9c:	8b 00                	mov    (%rax),%eax
  8004200c9e:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200ca1:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200ca5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200ca9:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200cac:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200cad:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200cb4:	00 00 00 
  8004200cb7:	0f b7 00             	movzwl (%rax),%eax
  8004200cba:	66 c1 e8 08          	shr    $0x8,%ax
  8004200cbe:	0f b6 c0             	movzbl %al,%eax
  8004200cc1:	48 ba 04 30 3d 04 80 	movabs $0x80043d3004,%rdx
  8004200cc8:	00 00 00 
  8004200ccb:	8b 12                	mov    (%rdx),%edx
  8004200ccd:	83 c2 01             	add    $0x1,%edx
  8004200cd0:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200cd3:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200cd6:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200cda:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200cdd:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200cde:	48 b8 04 30 3d 04 80 	movabs $0x80043d3004,%rax
  8004200ce5:	00 00 00 
  8004200ce8:	8b 00                	mov    (%rax),%eax
  8004200cea:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200ced:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200cf1:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200cf5:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200cf8:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200cf9:	48 b8 10 30 3d 04 80 	movabs $0x80043d3010,%rax
  8004200d00:	00 00 00 
  8004200d03:	0f b7 00             	movzwl (%rax),%eax
  8004200d06:	0f b6 c0             	movzbl %al,%eax
  8004200d09:	48 ba 04 30 3d 04 80 	movabs $0x80043d3004,%rdx
  8004200d10:	00 00 00 
  8004200d13:	8b 12                	mov    (%rdx),%edx
  8004200d15:	83 c2 01             	add    $0x1,%edx
  8004200d18:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200d1b:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200d1e:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200d22:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200d25:	ee                   	out    %al,(%dx)
}
  8004200d26:	c9                   	leaveq 
  8004200d27:	c3                   	retq   

0000008004200d28 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200d28:	55                   	push   %rbp
  8004200d29:	48 89 e5             	mov    %rsp,%rbp
  8004200d2c:	48 83 ec 20          	sub    $0x20,%rsp
  8004200d30:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200d37:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200d3a:	89 c2                	mov    %eax,%edx
  8004200d3c:	ec                   	in     (%dx),%al
  8004200d3d:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200d40:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200d44:	0f b6 c0             	movzbl %al,%eax
  8004200d47:	83 e0 01             	and    $0x1,%eax
  8004200d4a:	85 c0                	test   %eax,%eax
  8004200d4c:	75 0a                	jne    8004200d58 <kbd_proc_data+0x30>
		return -1;
  8004200d4e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200d53:	e9 fc 01 00 00       	jmpq   8004200f54 <kbd_proc_data+0x22c>
  8004200d58:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200d5f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200d62:	89 c2                	mov    %eax,%edx
  8004200d64:	ec                   	in     (%dx),%al
  8004200d65:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200d68:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200d6c:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200d6f:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200d73:	75 27                	jne    8004200d9c <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200d75:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200d7c:	00 00 00 
  8004200d7f:	8b 00                	mov    (%rax),%eax
  8004200d81:	83 c8 40             	or     $0x40,%eax
  8004200d84:	89 c2                	mov    %eax,%edx
  8004200d86:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200d8d:	00 00 00 
  8004200d90:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200d92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200d97:	e9 b8 01 00 00       	jmpq   8004200f54 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200d9c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200da0:	84 c0                	test   %al,%al
  8004200da2:	79 65                	jns    8004200e09 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200da4:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200dab:	00 00 00 
  8004200dae:	8b 00                	mov    (%rax),%eax
  8004200db0:	83 e0 40             	and    $0x40,%eax
  8004200db3:	85 c0                	test   %eax,%eax
  8004200db5:	75 09                	jne    8004200dc0 <kbd_proc_data+0x98>
  8004200db7:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200dbb:	83 e0 7f             	and    $0x7f,%eax
  8004200dbe:	eb 04                	jmp    8004200dc4 <kbd_proc_data+0x9c>
  8004200dc0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200dc4:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200dc7:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200dcb:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200dd2:	00 00 00 
  8004200dd5:	48 98                	cltq   
  8004200dd7:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200ddb:	83 c8 40             	or     $0x40,%eax
  8004200dde:	0f b6 c0             	movzbl %al,%eax
  8004200de1:	f7 d0                	not    %eax
  8004200de3:	89 c2                	mov    %eax,%edx
  8004200de5:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200dec:	00 00 00 
  8004200def:	8b 00                	mov    (%rax),%eax
  8004200df1:	21 c2                	and    %eax,%edx
  8004200df3:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200dfa:	00 00 00 
  8004200dfd:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200dff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e04:	e9 4b 01 00 00       	jmpq   8004200f54 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200e09:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200e10:	00 00 00 
  8004200e13:	8b 00                	mov    (%rax),%eax
  8004200e15:	83 e0 40             	and    $0x40,%eax
  8004200e18:	85 c0                	test   %eax,%eax
  8004200e1a:	74 21                	je     8004200e3d <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200e1c:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200e20:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200e27:	00 00 00 
  8004200e2a:	8b 00                	mov    (%rax),%eax
  8004200e2c:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200e2f:	89 c2                	mov    %eax,%edx
  8004200e31:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200e38:	00 00 00 
  8004200e3b:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200e3d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e41:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200e48:	00 00 00 
  8004200e4b:	48 98                	cltq   
  8004200e4d:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e51:	0f b6 d0             	movzbl %al,%edx
  8004200e54:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200e5b:	00 00 00 
  8004200e5e:	8b 00                	mov    (%rax),%eax
  8004200e60:	09 c2                	or     %eax,%edx
  8004200e62:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200e69:	00 00 00 
  8004200e6c:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200e6e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e72:	48 ba 60 b1 22 04 80 	movabs $0x800422b160,%rdx
  8004200e79:	00 00 00 
  8004200e7c:	48 98                	cltq   
  8004200e7e:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e82:	0f b6 d0             	movzbl %al,%edx
  8004200e85:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200e8c:	00 00 00 
  8004200e8f:	8b 00                	mov    (%rax),%eax
  8004200e91:	31 c2                	xor    %eax,%edx
  8004200e93:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200e9a:	00 00 00 
  8004200e9d:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200e9f:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200ea6:	00 00 00 
  8004200ea9:	8b 00                	mov    (%rax),%eax
  8004200eab:	83 e0 03             	and    $0x3,%eax
  8004200eae:	89 c2                	mov    %eax,%edx
  8004200eb0:	48 b8 60 b5 22 04 80 	movabs $0x800422b560,%rax
  8004200eb7:	00 00 00 
  8004200eba:	89 d2                	mov    %edx,%edx
  8004200ebc:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200ec0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ec4:	48 01 d0             	add    %rdx,%rax
  8004200ec7:	0f b6 00             	movzbl (%rax),%eax
  8004200eca:	0f b6 c0             	movzbl %al,%eax
  8004200ecd:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200ed0:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200ed7:	00 00 00 
  8004200eda:	8b 00                	mov    (%rax),%eax
  8004200edc:	83 e0 08             	and    $0x8,%eax
  8004200edf:	85 c0                	test   %eax,%eax
  8004200ee1:	74 22                	je     8004200f05 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200ee3:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200ee7:	7e 0c                	jle    8004200ef5 <kbd_proc_data+0x1cd>
  8004200ee9:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200eed:	7f 06                	jg     8004200ef5 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200eef:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200ef3:	eb 10                	jmp    8004200f05 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200ef5:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200ef9:	7e 0a                	jle    8004200f05 <kbd_proc_data+0x1dd>
  8004200efb:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200eff:	7f 04                	jg     8004200f05 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200f01:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200f05:	48 b8 28 32 3d 04 80 	movabs $0x80043d3228,%rax
  8004200f0c:	00 00 00 
  8004200f0f:	8b 00                	mov    (%rax),%eax
  8004200f11:	f7 d0                	not    %eax
  8004200f13:	83 e0 06             	and    $0x6,%eax
  8004200f16:	85 c0                	test   %eax,%eax
  8004200f18:	75 37                	jne    8004200f51 <kbd_proc_data+0x229>
  8004200f1a:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200f21:	75 2e                	jne    8004200f51 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200f23:	48 bf 0e 65 21 04 80 	movabs $0x800421650e,%rdi
  8004200f2a:	00 00 00 
  8004200f2d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f32:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004200f39:	00 00 00 
  8004200f3c:	ff d2                	callq  *%rdx
  8004200f3e:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004200f45:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200f49:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200f4d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200f50:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
	return c;
  8004200f51:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200f54:	c9                   	leaveq 
  8004200f55:	c3                   	retq   

0000008004200f56 <kbd_intr>:

void
kbd_intr(void)
{
  8004200f56:	55                   	push   %rbp
  8004200f57:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004200f5a:	48 bf 28 0d 20 04 80 	movabs $0x8004200d28,%rdi
  8004200f61:	00 00 00 
  8004200f64:	48 b8 a7 0f 20 04 80 	movabs $0x8004200fa7,%rax
  8004200f6b:	00 00 00 
  8004200f6e:	ff d0                	callq  *%rax
}
  8004200f70:	5d                   	pop    %rbp
  8004200f71:	c3                   	retq   

0000008004200f72 <kbd_init>:

static void
kbd_init(void)
{
  8004200f72:	55                   	push   %rbp
  8004200f73:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004200f76:	48 b8 56 0f 20 04 80 	movabs $0x8004200f56,%rax
  8004200f7d:	00 00 00 
  8004200f80:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004200f82:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  8004200f89:	00 00 00 
  8004200f8c:	0f b7 00             	movzwl (%rax),%eax
  8004200f8f:	0f b7 c0             	movzwl %ax,%eax
  8004200f92:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004200f97:	89 c7                	mov    %eax,%edi
  8004200f99:	48 b8 44 86 20 04 80 	movabs $0x8004208644,%rax
  8004200fa0:	00 00 00 
  8004200fa3:	ff d0                	callq  *%rax
}
  8004200fa5:	5d                   	pop    %rbp
  8004200fa6:	c3                   	retq   

0000008004200fa7 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004200fa7:	55                   	push   %rbp
  8004200fa8:	48 89 e5             	mov    %rsp,%rbp
  8004200fab:	48 83 ec 20          	sub    $0x20,%rsp
  8004200faf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004200fb3:	eb 6a                	jmp    800420101f <cons_intr+0x78>
		if (c == 0)
  8004200fb5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004200fb9:	75 02                	jne    8004200fbd <cons_intr+0x16>
			continue;
  8004200fbb:	eb 62                	jmp    800420101f <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004200fbd:	48 b8 20 30 3d 04 80 	movabs $0x80043d3020,%rax
  8004200fc4:	00 00 00 
  8004200fc7:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004200fcd:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200fd0:	48 ba 20 30 3d 04 80 	movabs $0x80043d3020,%rdx
  8004200fd7:	00 00 00 
  8004200fda:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  8004200fe0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200fe3:	89 d1                	mov    %edx,%ecx
  8004200fe5:	48 ba 20 30 3d 04 80 	movabs $0x80043d3020,%rdx
  8004200fec:	00 00 00 
  8004200fef:	89 c0                	mov    %eax,%eax
  8004200ff1:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  8004200ff4:	48 b8 20 30 3d 04 80 	movabs $0x80043d3020,%rax
  8004200ffb:	00 00 00 
  8004200ffe:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201004:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201009:	75 14                	jne    800420101f <cons_intr+0x78>
			cons.wpos = 0;
  800420100b:	48 b8 20 30 3d 04 80 	movabs $0x80043d3020,%rax
  8004201012:	00 00 00 
  8004201015:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  800420101c:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  800420101f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201023:	ff d0                	callq  *%rax
  8004201025:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201028:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420102c:	75 87                	jne    8004200fb5 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  800420102e:	c9                   	leaveq 
  800420102f:	c3                   	retq   

0000008004201030 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  8004201030:	55                   	push   %rbp
  8004201031:	48 89 e5             	mov    %rsp,%rbp
  8004201034:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201038:	48 b8 3b 07 20 04 80 	movabs $0x800420073b,%rax
  800420103f:	00 00 00 
  8004201042:	ff d0                	callq  *%rax
	kbd_intr();
  8004201044:	48 b8 56 0f 20 04 80 	movabs $0x8004200f56,%rax
  800420104b:	00 00 00 
  800420104e:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  8004201050:	48 b8 20 30 3d 04 80 	movabs $0x80043d3020,%rax
  8004201057:	00 00 00 
  800420105a:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  8004201060:	48 b8 20 30 3d 04 80 	movabs $0x80043d3020,%rax
  8004201067:	00 00 00 
  800420106a:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201070:	39 c2                	cmp    %eax,%edx
  8004201072:	74 69                	je     80042010dd <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201074:	48 b8 20 30 3d 04 80 	movabs $0x80043d3020,%rax
  800420107b:	00 00 00 
  800420107e:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201084:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201087:	48 ba 20 30 3d 04 80 	movabs $0x80043d3020,%rdx
  800420108e:	00 00 00 
  8004201091:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004201097:	48 ba 20 30 3d 04 80 	movabs $0x80043d3020,%rdx
  800420109e:	00 00 00 
  80042010a1:	89 c0                	mov    %eax,%eax
  80042010a3:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80042010a7:	0f b6 c0             	movzbl %al,%eax
  80042010aa:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  80042010ad:	48 b8 20 30 3d 04 80 	movabs $0x80043d3020,%rax
  80042010b4:	00 00 00 
  80042010b7:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042010bd:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042010c2:	75 14                	jne    80042010d8 <cons_getc+0xa8>
			cons.rpos = 0;
  80042010c4:	48 b8 20 30 3d 04 80 	movabs $0x80043d3020,%rax
  80042010cb:	00 00 00 
  80042010ce:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042010d5:	00 00 00 
		return c;
  80042010d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042010db:	eb 05                	jmp    80042010e2 <cons_getc+0xb2>
	}
	return 0;
  80042010dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042010e2:	c9                   	leaveq 
  80042010e3:	c3                   	retq   

00000080042010e4 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042010e4:	55                   	push   %rbp
  80042010e5:	48 89 e5             	mov    %rsp,%rbp
  80042010e8:	48 83 ec 10          	sub    $0x10,%rsp
  80042010ec:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042010ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042010f2:	89 c7                	mov    %eax,%edi
  80042010f4:	48 b8 68 07 20 04 80 	movabs $0x8004200768,%rax
  80042010fb:	00 00 00 
  80042010fe:	ff d0                	callq  *%rax
	lpt_putc(c);
  8004201100:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201103:	89 c7                	mov    %eax,%edi
  8004201105:	48 b8 a1 08 20 04 80 	movabs $0x80042008a1,%rax
  800420110c:	00 00 00 
  800420110f:	ff d0                	callq  *%rax
	cga_putc(c);
  8004201111:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201114:	89 c7                	mov    %eax,%edi
  8004201116:	48 b8 40 0a 20 04 80 	movabs $0x8004200a40,%rax
  800420111d:	00 00 00 
  8004201120:	ff d0                	callq  *%rax
}
  8004201122:	c9                   	leaveq 
  8004201123:	c3                   	retq   

0000008004201124 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004201124:	55                   	push   %rbp
  8004201125:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004201128:	48 b8 26 09 20 04 80 	movabs $0x8004200926,%rax
  800420112f:	00 00 00 
  8004201132:	ff d0                	callq  *%rax
	kbd_init();
  8004201134:	48 b8 72 0f 20 04 80 	movabs $0x8004200f72,%rax
  800420113b:	00 00 00 
  800420113e:	ff d0                	callq  *%rax
	serial_init();
  8004201140:	48 b8 cd 07 20 04 80 	movabs $0x80042007cd,%rax
  8004201147:	00 00 00 
  800420114a:	ff d0                	callq  *%rax

	if (!serial_exists)
  800420114c:	48 b8 00 30 3d 04 80 	movabs $0x80043d3000,%rax
  8004201153:	00 00 00 
  8004201156:	0f b6 00             	movzbl (%rax),%eax
  8004201159:	83 f0 01             	xor    $0x1,%eax
  800420115c:	84 c0                	test   %al,%al
  800420115e:	74 1b                	je     800420117b <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  8004201160:	48 bf 1a 65 21 04 80 	movabs $0x800421651a,%rdi
  8004201167:	00 00 00 
  800420116a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420116f:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004201176:	00 00 00 
  8004201179:	ff d2                	callq  *%rdx
}
  800420117b:	5d                   	pop    %rbp
  800420117c:	c3                   	retq   

000000800420117d <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  800420117d:	55                   	push   %rbp
  800420117e:	48 89 e5             	mov    %rsp,%rbp
  8004201181:	48 83 ec 10          	sub    $0x10,%rsp
  8004201185:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  8004201188:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420118b:	89 c7                	mov    %eax,%edi
  800420118d:	48 b8 e4 10 20 04 80 	movabs $0x80042010e4,%rax
  8004201194:	00 00 00 
  8004201197:	ff d0                	callq  *%rax
}
  8004201199:	c9                   	leaveq 
  800420119a:	c3                   	retq   

000000800420119b <getchar>:

int
getchar(void)
{
  800420119b:	55                   	push   %rbp
  800420119c:	48 89 e5             	mov    %rsp,%rbp
  800420119f:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  80042011a3:	48 b8 30 10 20 04 80 	movabs $0x8004201030,%rax
  80042011aa:	00 00 00 
  80042011ad:	ff d0                	callq  *%rax
  80042011af:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042011b2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042011b6:	74 eb                	je     80042011a3 <getchar+0x8>
		/* do nothing */;
	return c;
  80042011b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042011bb:	c9                   	leaveq 
  80042011bc:	c3                   	retq   

00000080042011bd <iscons>:

int
iscons(int fdnum)
{
  80042011bd:	55                   	push   %rbp
  80042011be:	48 89 e5             	mov    %rsp,%rbp
  80042011c1:	48 83 ec 04          	sub    $0x4,%rsp
  80042011c5:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042011c8:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042011cd:	c9                   	leaveq 
  80042011ce:	c3                   	retq   

00000080042011cf <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042011cf:	55                   	push   %rbp
  80042011d0:	48 89 e5             	mov    %rsp,%rbp
  80042011d3:	48 83 ec 30          	sub    $0x30,%rsp
  80042011d7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042011da:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042011de:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042011e2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042011e9:	eb 6c                	jmp    8004201257 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042011eb:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  80042011f2:	00 00 00 
  80042011f5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011f8:	48 63 d0             	movslq %eax,%rdx
  80042011fb:	48 89 d0             	mov    %rdx,%rax
  80042011fe:	48 01 c0             	add    %rax,%rax
  8004201201:	48 01 d0             	add    %rdx,%rax
  8004201204:	48 c1 e0 03          	shl    $0x3,%rax
  8004201208:	48 01 c8             	add    %rcx,%rax
  800420120b:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800420120f:	48 be 80 b5 22 04 80 	movabs $0x800422b580,%rsi
  8004201216:	00 00 00 
  8004201219:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420121c:	48 63 d0             	movslq %eax,%rdx
  800420121f:	48 89 d0             	mov    %rdx,%rax
  8004201222:	48 01 c0             	add    %rax,%rax
  8004201225:	48 01 d0             	add    %rdx,%rax
  8004201228:	48 c1 e0 03          	shl    $0x3,%rax
  800420122c:	48 01 f0             	add    %rsi,%rax
  800420122f:	48 8b 00             	mov    (%rax),%rax
  8004201232:	48 89 ca             	mov    %rcx,%rdx
  8004201235:	48 89 c6             	mov    %rax,%rsi
  8004201238:	48 bf 8d 65 21 04 80 	movabs $0x800421658d,%rdi
  800420123f:	00 00 00 
  8004201242:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201247:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  800420124e:	00 00 00 
  8004201251:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201253:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201257:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420125a:	83 f8 01             	cmp    $0x1,%eax
  800420125d:	76 8c                	jbe    80042011eb <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  800420125f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201264:	c9                   	leaveq 
  8004201265:	c3                   	retq   

0000008004201266 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201266:	55                   	push   %rbp
  8004201267:	48 89 e5             	mov    %rsp,%rbp
  800420126a:	48 83 ec 30          	sub    $0x30,%rsp
  800420126e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201271:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201275:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  8004201279:	48 bf 96 65 21 04 80 	movabs $0x8004216596,%rdi
  8004201280:	00 00 00 
  8004201283:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201288:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420128f:	00 00 00 
  8004201292:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201294:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420129b:	00 00 00 
  800420129e:	48 bf b0 65 21 04 80 	movabs $0x80042165b0,%rdi
  80042012a5:	00 00 00 
  80042012a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012ad:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042012b4:	00 00 00 
  80042012b7:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  80042012b9:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042012c0:	00 00 00 
  80042012c3:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042012ca:	00 00 00 
  80042012cd:	48 bf d8 65 21 04 80 	movabs $0x80042165d8,%rdi
  80042012d4:	00 00 00 
  80042012d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012dc:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  80042012e3:	00 00 00 
  80042012e6:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042012e8:	48 ba 25 64 21 00 00 	movabs $0x216425,%rdx
  80042012ef:	00 00 00 
  80042012f2:	48 be 25 64 21 04 80 	movabs $0x8004216425,%rsi
  80042012f9:	00 00 00 
  80042012fc:	48 bf 00 66 21 04 80 	movabs $0x8004216600,%rdi
  8004201303:	00 00 00 
  8004201306:	b8 00 00 00 00       	mov    $0x0,%eax
  800420130b:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  8004201312:	00 00 00 
  8004201315:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201317:	48 ba 6a 21 3d 00 00 	movabs $0x3d216a,%rdx
  800420131e:	00 00 00 
  8004201321:	48 be 6a 21 3d 04 80 	movabs $0x80043d216a,%rsi
  8004201328:	00 00 00 
  800420132b:	48 bf 28 66 21 04 80 	movabs $0x8004216628,%rdi
  8004201332:	00 00 00 
  8004201335:	b8 00 00 00 00       	mov    $0x0,%eax
  800420133a:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  8004201341:	00 00 00 
  8004201344:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201346:	48 ba 10 70 45 00 00 	movabs $0x457010,%rdx
  800420134d:	00 00 00 
  8004201350:	48 be 10 70 45 04 80 	movabs $0x8004457010,%rsi
  8004201357:	00 00 00 
  800420135a:	48 bf 50 66 21 04 80 	movabs $0x8004216650,%rdi
  8004201361:	00 00 00 
  8004201364:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201369:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  8004201370:	00 00 00 
  8004201373:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201375:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800420137c:	00 
  800420137d:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201384:	00 00 00 
  8004201387:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420138b:	48 29 c2             	sub    %rax,%rdx
  800420138e:	48 b8 10 70 45 04 80 	movabs $0x8004457010,%rax
  8004201395:	00 00 00 
  8004201398:	48 83 e8 01          	sub    $0x1,%rax
  800420139c:	48 01 d0             	add    %rdx,%rax
  800420139f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042013a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042013a7:	ba 00 00 00 00       	mov    $0x0,%edx
  80042013ac:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042013b0:	48 89 d0             	mov    %rdx,%rax
  80042013b3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042013b7:	48 29 c2             	sub    %rax,%rdx
  80042013ba:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042013bd:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042013c4:	48 85 c0             	test   %rax,%rax
  80042013c7:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042013cb:	48 c1 f8 0a          	sar    $0xa,%rax
  80042013cf:	48 89 c6             	mov    %rax,%rsi
  80042013d2:	48 bf 78 66 21 04 80 	movabs $0x8004216678,%rdi
  80042013d9:	00 00 00 
  80042013dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013e1:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042013e8:	00 00 00 
  80042013eb:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042013ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042013f2:	c9                   	leaveq 
  80042013f3:	c3                   	retq   

00000080042013f4 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  80042013f4:	55                   	push   %rbp
  80042013f5:	48 89 e5             	mov    %rsp,%rbp
  80042013f8:	48 83 ec 18          	sub    $0x18,%rsp
  80042013fc:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042013ff:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004201403:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// Your code here.
	return 0;
  8004201407:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420140c:	c9                   	leaveq 
  800420140d:	c3                   	retq   

000000800420140e <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  800420140e:	55                   	push   %rbp
  800420140f:	48 89 e5             	mov    %rsp,%rbp
  8004201412:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201419:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004201420:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201427:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  800420142e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201431:	48 98                	cltq   
  8004201433:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  800420143a:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  800420143f:	eb 15                	jmp    8004201456 <runcmd+0x48>
			*buf++ = 0;
  8004201441:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201448:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420144c:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004201453:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201456:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420145d:	0f b6 00             	movzbl (%rax),%eax
  8004201460:	84 c0                	test   %al,%al
  8004201462:	74 2a                	je     800420148e <runcmd+0x80>
  8004201464:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420146b:	0f b6 00             	movzbl (%rax),%eax
  800420146e:	0f be c0             	movsbl %al,%eax
  8004201471:	89 c6                	mov    %eax,%esi
  8004201473:	48 bf a2 66 21 04 80 	movabs $0x80042166a2,%rdi
  800420147a:	00 00 00 
  800420147d:	48 b8 6a ed 20 04 80 	movabs $0x800420ed6a,%rax
  8004201484:	00 00 00 
  8004201487:	ff d0                	callq  *%rax
  8004201489:	48 85 c0             	test   %rax,%rax
  800420148c:	75 b3                	jne    8004201441 <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  800420148e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201495:	0f b6 00             	movzbl (%rax),%eax
  8004201498:	84 c0                	test   %al,%al
  800420149a:	75 21                	jne    80042014bd <runcmd+0xaf>
			break;
  800420149c:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  800420149d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042014a0:	48 98                	cltq   
  80042014a2:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042014a9:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042014ae:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042014b2:	0f 85 a1 00 00 00    	jne    8004201559 <runcmd+0x14b>
  80042014b8:	e9 92 00 00 00       	jmpq   800420154f <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042014bd:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042014c1:	75 2a                	jne    80042014ed <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042014c3:	be 10 00 00 00       	mov    $0x10,%esi
  80042014c8:	48 bf a7 66 21 04 80 	movabs $0x80042166a7,%rdi
  80042014cf:	00 00 00 
  80042014d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014d7:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042014de:	00 00 00 
  80042014e1:	ff d2                	callq  *%rdx
			return 0;
  80042014e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014e8:	e9 30 01 00 00       	jmpq   800420161d <runcmd+0x20f>
		}
		argv[argc++] = buf;
  80042014ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042014f0:	8d 50 01             	lea    0x1(%rax),%edx
  80042014f3:	89 55 fc             	mov    %edx,-0x4(%rbp)
  80042014f6:	48 98                	cltq   
  80042014f8:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  80042014ff:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201506:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201507:	eb 08                	jmp    8004201511 <runcmd+0x103>
			buf++;
  8004201509:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201510:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201511:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201518:	0f b6 00             	movzbl (%rax),%eax
  800420151b:	84 c0                	test   %al,%al
  800420151d:	74 2a                	je     8004201549 <runcmd+0x13b>
  800420151f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201526:	0f b6 00             	movzbl (%rax),%eax
  8004201529:	0f be c0             	movsbl %al,%eax
  800420152c:	89 c6                	mov    %eax,%esi
  800420152e:	48 bf a2 66 21 04 80 	movabs $0x80042166a2,%rdi
  8004201535:	00 00 00 
  8004201538:	48 b8 6a ed 20 04 80 	movabs $0x800420ed6a,%rax
  800420153f:	00 00 00 
  8004201542:	ff d0                	callq  *%rax
  8004201544:	48 85 c0             	test   %rax,%rax
  8004201547:	74 c0                	je     8004201509 <runcmd+0xfb>
			buf++;
	}
  8004201549:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  800420154a:	e9 07 ff ff ff       	jmpq   8004201456 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  800420154f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201554:	e9 c4 00 00 00       	jmpq   800420161d <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201559:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201560:	e9 82 00 00 00       	jmpq   80042015e7 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201565:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  800420156c:	00 00 00 
  800420156f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201572:	48 63 d0             	movslq %eax,%rdx
  8004201575:	48 89 d0             	mov    %rdx,%rax
  8004201578:	48 01 c0             	add    %rax,%rax
  800420157b:	48 01 d0             	add    %rdx,%rax
  800420157e:	48 c1 e0 03          	shl    $0x3,%rax
  8004201582:	48 01 c8             	add    %rcx,%rax
  8004201585:	48 8b 10             	mov    (%rax),%rdx
  8004201588:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420158f:	48 89 d6             	mov    %rdx,%rsi
  8004201592:	48 89 c7             	mov    %rax,%rdi
  8004201595:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  800420159c:	00 00 00 
  800420159f:	ff d0                	callq  *%rax
  80042015a1:	85 c0                	test   %eax,%eax
  80042015a3:	75 3e                	jne    80042015e3 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  80042015a5:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  80042015ac:	00 00 00 
  80042015af:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042015b2:	48 63 d0             	movslq %eax,%rdx
  80042015b5:	48 89 d0             	mov    %rdx,%rax
  80042015b8:	48 01 c0             	add    %rax,%rax
  80042015bb:	48 01 d0             	add    %rdx,%rax
  80042015be:	48 c1 e0 03          	shl    $0x3,%rax
  80042015c2:	48 01 c8             	add    %rcx,%rax
  80042015c5:	48 83 c0 10          	add    $0x10,%rax
  80042015c9:	48 8b 00             	mov    (%rax),%rax
  80042015cc:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042015d3:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  80042015da:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042015dd:	89 cf                	mov    %ecx,%edi
  80042015df:	ff d0                	callq  *%rax
  80042015e1:	eb 3a                	jmp    800420161d <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  80042015e3:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  80042015e7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042015ea:	83 f8 01             	cmp    $0x1,%eax
  80042015ed:	0f 86 72 ff ff ff    	jbe    8004201565 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  80042015f3:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042015fa:	48 89 c6             	mov    %rax,%rsi
  80042015fd:	48 bf c4 66 21 04 80 	movabs $0x80042166c4,%rdi
  8004201604:	00 00 00 
  8004201607:	b8 00 00 00 00       	mov    $0x0,%eax
  800420160c:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004201613:	00 00 00 
  8004201616:	ff d2                	callq  *%rdx
	return 0;
  8004201618:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420161d:	c9                   	leaveq 
  800420161e:	c3                   	retq   

000000800420161f <monitor>:

void
monitor(struct Trapframe *tf)
{
  800420161f:	55                   	push   %rbp
  8004201620:	48 89 e5             	mov    %rsp,%rbp
  8004201623:	48 83 ec 20          	sub    $0x20,%rsp
  8004201627:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  800420162b:	48 bf e0 66 21 04 80 	movabs $0x80042166e0,%rdi
  8004201632:	00 00 00 
  8004201635:	b8 00 00 00 00       	mov    $0x0,%eax
  800420163a:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004201641:	00 00 00 
  8004201644:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201646:	48 bf 08 67 21 04 80 	movabs $0x8004216708,%rdi
  800420164d:	00 00 00 
  8004201650:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201655:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420165c:	00 00 00 
  800420165f:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201661:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201666:	74 13                	je     800420167b <monitor+0x5c>
		print_trapframe(tf);
  8004201668:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420166c:	48 89 c7             	mov    %rax,%rdi
  800420166f:	48 b8 49 b3 20 04 80 	movabs $0x800420b349,%rax
  8004201676:	00 00 00 
  8004201679:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  800420167b:	48 bf 2d 67 21 04 80 	movabs $0x800421672d,%rdi
  8004201682:	00 00 00 
  8004201685:	48 b8 89 e9 20 04 80 	movabs $0x800420e989,%rax
  800420168c:	00 00 00 
  800420168f:	ff d0                	callq  *%rax
  8004201691:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201695:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420169a:	74 20                	je     80042016bc <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  800420169c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042016a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042016a4:	48 89 d6             	mov    %rdx,%rsi
  80042016a7:	48 89 c7             	mov    %rax,%rdi
  80042016aa:	48 b8 0e 14 20 04 80 	movabs $0x800420140e,%rax
  80042016b1:	00 00 00 
  80042016b4:	ff d0                	callq  *%rax
  80042016b6:	85 c0                	test   %eax,%eax
  80042016b8:	79 02                	jns    80042016bc <monitor+0x9d>
				break;
  80042016ba:	eb 02                	jmp    80042016be <monitor+0x9f>
	}
  80042016bc:	eb bd                	jmp    800420167b <monitor+0x5c>
}
  80042016be:	c9                   	leaveq 
  80042016bf:	c3                   	retq   

00000080042016c0 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042016c0:	55                   	push   %rbp
  80042016c1:	48 89 e5             	mov    %rsp,%rbp
  80042016c4:	48 83 ec 08          	sub    $0x8,%rsp
  80042016c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042016cc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042016d0:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  80042016d7:	00 00 00 
  80042016da:	48 8b 00             	mov    (%rax),%rax
  80042016dd:	48 29 c2             	sub    %rax,%rdx
  80042016e0:	48 89 d0             	mov    %rdx,%rax
  80042016e3:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042016e7:	c9                   	leaveq 
  80042016e8:	c3                   	retq   

00000080042016e9 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042016e9:	55                   	push   %rbp
  80042016ea:	48 89 e5             	mov    %rsp,%rbp
  80042016ed:	48 83 ec 08          	sub    $0x8,%rsp
  80042016f1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042016f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042016f9:	48 89 c7             	mov    %rax,%rdi
  80042016fc:	48 b8 c0 16 20 04 80 	movabs $0x80042016c0,%rax
  8004201703:	00 00 00 
  8004201706:	ff d0                	callq  *%rax
  8004201708:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420170c:	c9                   	leaveq 
  800420170d:	c3                   	retq   

000000800420170e <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420170e:	55                   	push   %rbp
  800420170f:	48 89 e5             	mov    %rsp,%rbp
  8004201712:	48 83 ec 10          	sub    $0x10,%rsp
  8004201716:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  800420171a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420171e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201722:	48 89 c2             	mov    %rax,%rdx
  8004201725:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  800420172c:	00 00 00 
  800420172f:	48 8b 00             	mov    (%rax),%rax
  8004201732:	48 39 c2             	cmp    %rax,%rdx
  8004201735:	72 2a                	jb     8004201761 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201737:	48 ba 38 67 21 04 80 	movabs $0x8004216738,%rdx
  800420173e:	00 00 00 
  8004201741:	be 54 00 00 00       	mov    $0x54,%esi
  8004201746:	48 bf 57 67 21 04 80 	movabs $0x8004216757,%rdi
  800420174d:	00 00 00 
  8004201750:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201755:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  800420175c:	00 00 00 
  800420175f:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201761:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004201768:	00 00 00 
  800420176b:	48 8b 00             	mov    (%rax),%rax
  800420176e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201772:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201776:	48 c1 e2 04          	shl    $0x4,%rdx
  800420177a:	48 01 d0             	add    %rdx,%rax
}
  800420177d:	c9                   	leaveq 
  800420177e:	c3                   	retq   

000000800420177f <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800420177f:	55                   	push   %rbp
  8004201780:	48 89 e5             	mov    %rsp,%rbp
  8004201783:	48 83 ec 20          	sub    $0x20,%rsp
  8004201787:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420178b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420178f:	48 89 c7             	mov    %rax,%rdi
  8004201792:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004201799:	00 00 00 
  800420179c:	ff d0                	callq  *%rax
  800420179e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042017a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017a6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042017aa:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042017ad:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042017b0:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042017b7:	00 00 00 
  80042017ba:	48 8b 00             	mov    (%rax),%rax
  80042017bd:	48 39 c2             	cmp    %rax,%rdx
  80042017c0:	72 32                	jb     80042017f4 <page2kva+0x75>
  80042017c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017c6:	48 89 c1             	mov    %rax,%rcx
  80042017c9:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042017d0:	00 00 00 
  80042017d3:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042017d8:	48 bf 57 67 21 04 80 	movabs $0x8004216757,%rdi
  80042017df:	00 00 00 
  80042017e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017e7:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042017ee:	00 00 00 
  80042017f1:	41 ff d0             	callq  *%r8
  80042017f4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042017fb:	00 00 00 
  80042017fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201802:	48 01 d0             	add    %rdx,%rax
}
  8004201805:	c9                   	leaveq 
  8004201806:	c3                   	retq   

0000008004201807 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201807:	55                   	push   %rbp
  8004201808:	48 89 e5             	mov    %rsp,%rbp
  800420180b:	48 83 ec 08          	sub    $0x8,%rsp
  800420180f:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201812:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201815:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201819:	74 06                	je     8004201821 <restrictive_type+0x1a>
  800420181b:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  800420181f:	75 07                	jne    8004201828 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201821:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201826:	eb 3e                	jmp    8004201866 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201828:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  800420182c:	74 06                	je     8004201834 <restrictive_type+0x2d>
  800420182e:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201832:	75 07                	jne    800420183b <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201834:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201839:	eb 2b                	jmp    8004201866 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  800420183b:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  800420183f:	74 06                	je     8004201847 <restrictive_type+0x40>
  8004201841:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201845:	75 07                	jne    800420184e <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201847:	b8 02 00 00 00       	mov    $0x2,%eax
  800420184c:	eb 18                	jmp    8004201866 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  800420184e:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201852:	74 06                	je     800420185a <restrictive_type+0x53>
  8004201854:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201858:	75 07                	jne    8004201861 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  800420185a:	b8 03 00 00 00       	mov    $0x3,%eax
  800420185f:	eb 05                	jmp    8004201866 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201861:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201866:	c9                   	leaveq 
  8004201867:	c3                   	retq   

0000008004201868 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201868:	55                   	push   %rbp
  8004201869:	48 89 e5             	mov    %rsp,%rbp
  800420186c:	53                   	push   %rbx
  800420186d:	48 83 ec 18          	sub    $0x18,%rsp
  8004201871:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201874:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201877:	89 c7                	mov    %eax,%edi
  8004201879:	48 b8 76 84 20 04 80 	movabs $0x8004208476,%rax
  8004201880:	00 00 00 
  8004201883:	ff d0                	callq  *%rax
  8004201885:	89 c3                	mov    %eax,%ebx
  8004201887:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420188a:	83 c0 01             	add    $0x1,%eax
  800420188d:	89 c7                	mov    %eax,%edi
  800420188f:	48 b8 76 84 20 04 80 	movabs $0x8004208476,%rax
  8004201896:	00 00 00 
  8004201899:	ff d0                	callq  *%rax
  800420189b:	c1 e0 08             	shl    $0x8,%eax
  800420189e:	09 d8                	or     %ebx,%eax
}
  80042018a0:	48 83 c4 18          	add    $0x18,%rsp
  80042018a4:	5b                   	pop    %rbx
  80042018a5:	5d                   	pop    %rbp
  80042018a6:	c3                   	retq   

00000080042018a7 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  80042018a7:	55                   	push   %rbp
  80042018a8:	48 89 e5             	mov    %rsp,%rbp
  80042018ab:	41 54                	push   %r12
  80042018ad:	53                   	push   %rbx
  80042018ae:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80042018b5:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  80042018bc:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  80042018c3:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  80042018ca:	48 89 e0             	mov    %rsp,%rax
  80042018cd:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  80042018d0:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042018d7:	8b 40 30             	mov    0x30(%rax),%eax
  80042018da:	89 c0                	mov    %eax,%eax
  80042018dc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  80042018e0:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042018e7:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042018ea:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042018ef:	f7 e2                	mul    %edx
  80042018f1:	89 d0                	mov    %edx,%eax
  80042018f3:	c1 e8 04             	shr    $0x4,%eax
  80042018f6:	89 c0                	mov    %eax,%eax
  80042018f8:	48 89 c2             	mov    %rax,%rdx
  80042018fb:	48 83 ea 01          	sub    $0x1,%rdx
  80042018ff:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201903:	49 89 c0             	mov    %rax,%r8
  8004201906:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420190c:	48 89 c1             	mov    %rax,%rcx
  800420190f:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004201914:	48 c1 e0 03          	shl    $0x3,%rax
  8004201918:	48 8d 50 07          	lea    0x7(%rax),%rdx
  800420191c:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201921:	48 83 e8 01          	sub    $0x1,%rax
  8004201925:	48 01 d0             	add    %rdx,%rax
  8004201928:	bb 10 00 00 00       	mov    $0x10,%ebx
  800420192d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201932:	48 f7 f3             	div    %rbx
  8004201935:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201939:	48 29 c4             	sub    %rax,%rsp
  800420193c:	48 89 e0             	mov    %rsp,%rax
  800420193f:	48 83 c0 07          	add    $0x7,%rax
  8004201943:	48 c1 e8 03          	shr    $0x3,%rax
  8004201947:	48 c1 e0 03          	shl    $0x3,%rax
  800420194b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  800420194f:	48 bf 8b 67 21 04 80 	movabs $0x800421678b,%rdi
  8004201956:	00 00 00 
  8004201959:	b8 00 00 00 00       	mov    $0x0,%eax
  800420195e:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004201965:	00 00 00 
  8004201968:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420196a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201971:	e9 6c 01 00 00       	jmpq   8004201ae2 <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201976:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201979:	48 63 d0             	movslq %eax,%rdx
  800420197c:	48 89 d0             	mov    %rdx,%rax
  800420197f:	48 01 c0             	add    %rax,%rax
  8004201982:	48 01 d0             	add    %rdx,%rax
  8004201985:	48 c1 e0 03          	shl    $0x3,%rax
  8004201989:	48 89 c2             	mov    %rax,%rdx
  800420198c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201990:	48 01 d0             	add    %rdx,%rax
  8004201993:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201997:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420199b:	8b 40 08             	mov    0x8(%rax),%eax
  800420199e:	89 c0                	mov    %eax,%eax
  80042019a0:	48 c1 e0 20          	shl    $0x20,%rax
  80042019a4:	48 89 c2             	mov    %rax,%rdx
  80042019a7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042019ab:	8b 40 04             	mov    0x4(%rax),%eax
  80042019ae:	89 c0                	mov    %eax,%eax
  80042019b0:	48 01 d0             	add    %rdx,%rax
  80042019b3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  80042019b7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042019bb:	8b 40 10             	mov    0x10(%rax),%eax
  80042019be:	89 c0                	mov    %eax,%eax
  80042019c0:	48 c1 e0 20          	shl    $0x20,%rax
  80042019c4:	48 89 c2             	mov    %rax,%rdx
  80042019c7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042019cb:	8b 40 0c             	mov    0xc(%rax),%eax
  80042019ce:	89 c0                	mov    %eax,%eax
  80042019d0:	48 01 d0             	add    %rdx,%rax
  80042019d3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size,
  80042019d7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042019db:	8b 70 14             	mov    0x14(%rax),%esi
  80042019de:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042019e2:	8b 00                	mov    (%rax),%eax
  80042019e4:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042019e8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042019ec:	41 89 f0             	mov    %esi,%r8d
  80042019ef:	89 c6                	mov    %eax,%esi
  80042019f1:	48 bf a0 67 21 04 80 	movabs $0x80042167a0,%rdi
  80042019f8:	00 00 00 
  80042019fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a00:	49 b9 c2 87 20 04 80 	movabs $0x80042087c2,%r9
  8004201a07:	00 00 00 
  8004201a0a:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201a0d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a11:	8b 40 14             	mov    0x14(%rax),%eax
  8004201a14:	83 f8 05             	cmp    $0x5,%eax
  8004201a17:	77 0b                	ja     8004201a24 <multiboot_read+0x17d>
  8004201a19:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a1d:	8b 40 14             	mov    0x14(%rax),%eax
  8004201a20:	85 c0                	test   %eax,%eax
  8004201a22:	75 0b                	jne    8004201a2f <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004201a24:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a28:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)

		//Insert into the sorted list
		int j = 0;
  8004201a2f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201a36:	e9 85 00 00 00       	jmpq   8004201ac0 <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004201a3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201a3f:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201a42:	48 63 d2             	movslq %edx,%rdx
  8004201a45:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201a49:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201a4d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201a51:	8b 40 08             	mov    0x8(%rax),%eax
  8004201a54:	89 c0                	mov    %eax,%eax
  8004201a56:	48 c1 e0 20          	shl    $0x20,%rax
  8004201a5a:	48 89 c2             	mov    %rax,%rdx
  8004201a5d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201a61:	8b 40 04             	mov    0x4(%rax),%eax
  8004201a64:	89 c0                	mov    %eax,%eax
  8004201a66:	48 01 d0             	add    %rdx,%rax
  8004201a69:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201a6d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201a71:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201a75:	76 45                	jbe    8004201abc <multiboot_read+0x215>
				int last = i+1;
  8004201a77:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201a7a:	83 c0 01             	add    $0x1,%eax
  8004201a7d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201a80:	eb 30                	jmp    8004201ab2 <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201a82:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201a86:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201a89:	48 63 d2             	movslq %edx,%rdx
  8004201a8c:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201a90:	48 01 c2             	add    %rax,%rdx
  8004201a93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201a97:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201a9a:	48 63 c9             	movslq %ecx,%rcx
  8004201a9d:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201aa1:	48 83 e9 08          	sub    $0x8,%rcx
  8004201aa5:	48 01 c8             	add    %rcx,%rax
  8004201aa8:	48 8b 00             	mov    (%rax),%rax
  8004201aab:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201aae:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201ab2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201ab5:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201ab8:	75 c8                	jne    8004201a82 <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break;
  8004201aba:	eb 10                	jmp    8004201acc <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;

		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201abc:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201ac0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201ac3:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201ac6:	0f 8c 6f ff ff ff    	jl     8004201a3b <multiboot_read+0x194>
					last--;
				}
				break;
			}
		}
		mmap_list[j] = mmap;
  8004201acc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201ad0:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201ad3:	48 63 d2             	movslq %edx,%rdx
  8004201ad6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201ada:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201ade:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201ae2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ae5:	48 63 c8             	movslq %eax,%rcx
  8004201ae8:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201aef:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201af2:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201af7:	f7 e2                	mul    %edx
  8004201af9:	89 d0                	mov    %edx,%eax
  8004201afb:	c1 e8 04             	shr    $0x4,%eax
  8004201afe:	89 c0                	mov    %eax,%eax
  8004201b00:	48 39 c1             	cmp    %rax,%rcx
  8004201b03:	0f 82 6d fe ff ff    	jb     8004201976 <multiboot_read+0xcf>
				break;
			}
		}
		mmap_list[j] = mmap;
	}
	cprintf("\n");
  8004201b09:	48 bf d7 67 21 04 80 	movabs $0x80042167d7,%rdi
  8004201b10:	00 00 00 
  8004201b13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b18:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004201b1f:	00 00 00 
  8004201b22:	ff d2                	callq  *%rdx

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201b24:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004201b2b:	e9 93 01 00 00       	jmpq   8004201cc3 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  8004201b30:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201b33:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201b36:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201b3a:	48 63 d2             	movslq %edx,%rdx
  8004201b3d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201b41:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004201b45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201b49:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201b4c:	48 63 d2             	movslq %edx,%rdx
  8004201b4f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201b53:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201b57:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201b5b:	8b 40 08             	mov    0x8(%rax),%eax
  8004201b5e:	89 c0                	mov    %eax,%eax
  8004201b60:	48 c1 e0 20          	shl    $0x20,%rax
  8004201b64:	48 89 c2             	mov    %rax,%rdx
  8004201b67:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201b6b:	8b 40 04             	mov    0x4(%rax),%eax
  8004201b6e:	89 c0                	mov    %eax,%eax
  8004201b70:	48 01 d0             	add    %rdx,%rax
  8004201b73:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004201b77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201b7b:	8b 40 08             	mov    0x8(%rax),%eax
  8004201b7e:	89 c0                	mov    %eax,%eax
  8004201b80:	48 c1 e0 20          	shl    $0x20,%rax
  8004201b84:	48 89 c2             	mov    %rax,%rdx
  8004201b87:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201b8b:	8b 40 04             	mov    0x4(%rax),%eax
  8004201b8e:	89 c0                	mov    %eax,%eax
  8004201b90:	48 01 d0             	add    %rdx,%rax
  8004201b93:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004201b97:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201b9b:	8b 40 10             	mov    0x10(%rax),%eax
  8004201b9e:	89 c0                	mov    %eax,%eax
  8004201ba0:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ba4:	48 89 c2             	mov    %rax,%rdx
  8004201ba7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201bab:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201bae:	89 c0                	mov    %eax,%eax
  8004201bb0:	48 01 d0             	add    %rdx,%rax
  8004201bb3:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004201bba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201bbe:	8b 40 10             	mov    0x10(%rax),%eax
  8004201bc1:	89 c0                	mov    %eax,%eax
  8004201bc3:	48 c1 e0 20          	shl    $0x20,%rax
  8004201bc7:	48 89 c2             	mov    %rax,%rdx
  8004201bca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201bce:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201bd1:	89 c0                	mov    %eax,%eax
  8004201bd3:	48 01 d0             	add    %rdx,%rax
  8004201bd6:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004201bdd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201be4:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201be8:	48 01 d0             	add    %rdx,%rax
  8004201beb:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201bef:	75 7c                	jne    8004201c6d <multiboot_read+0x3c6>
  8004201bf1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201bf5:	8b 50 14             	mov    0x14(%rax),%edx
  8004201bf8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201bfc:	8b 40 14             	mov    0x14(%rax),%eax
  8004201bff:	39 c2                	cmp    %eax,%edx
  8004201c01:	75 6a                	jne    8004201c6d <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004201c03:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201c0a:	89 c2                	mov    %eax,%edx
  8004201c0c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201c13:	01 c2                	add    %eax,%edx
  8004201c15:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c19:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004201c1c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201c23:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004201c2a:	48 01 d0             	add    %rdx,%rax
  8004201c2d:	48 c1 e8 20          	shr    $0x20,%rax
  8004201c31:	89 c2                	mov    %eax,%edx
  8004201c33:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c37:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004201c3a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201c3e:	8b 50 04             	mov    0x4(%rax),%edx
  8004201c41:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c45:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004201c48:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201c4c:	8b 50 08             	mov    0x8(%rax),%edx
  8004201c4f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c53:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004201c56:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201c59:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201c5c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201c60:	48 63 d2             	movslq %edx,%rdx
  8004201c63:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004201c6a:	00 
  8004201c6b:	eb 52                	jmp    8004201cbf <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  8004201c6d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201c74:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201c78:	48 01 d0             	add    %rdx,%rax
  8004201c7b:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201c7f:	76 3e                	jbe    8004201cbf <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004201c81:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c85:	8b 50 14             	mov    0x14(%rax),%edx
  8004201c88:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201c8c:	8b 40 14             	mov    0x14(%rax),%eax
  8004201c8f:	89 d6                	mov    %edx,%esi
  8004201c91:	89 c7                	mov    %eax,%edi
  8004201c93:	48 b8 07 18 20 04 80 	movabs $0x8004201807,%rax
  8004201c9a:	00 00 00 
  8004201c9d:	ff d0                	callq  *%rax
  8004201c9f:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004201ca5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201ca9:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201caf:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004201cb2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201cb6:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201cbc:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;
	}
	cprintf("\n");

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201cbf:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201cc3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201cc6:	48 63 c8             	movslq %eax,%rcx
  8004201cc9:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201cd0:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201cd3:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201cd8:	f7 e2                	mul    %edx
  8004201cda:	89 d0                	mov    %edx,%eax
  8004201cdc:	c1 e8 04             	shr    $0x4,%eax
  8004201cdf:	89 c0                	mov    %eax,%eax
  8004201ce1:	48 39 c1             	cmp    %rax,%rcx
  8004201ce4:	0f 82 46 fe ff ff    	jb     8004201b30 <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201cea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201cf1:	e9 dc 00 00 00       	jmpq   8004201dd2 <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004201cf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201cfa:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201cfd:	48 63 d2             	movslq %edx,%rdx
  8004201d00:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201d04:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004201d0b:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004201d12:	00 
  8004201d13:	0f 84 b5 00 00 00    	je     8004201dce <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004201d19:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d20:	8b 40 14             	mov    0x14(%rax),%eax
  8004201d23:	83 f8 01             	cmp    $0x1,%eax
  8004201d26:	74 13                	je     8004201d3b <multiboot_read+0x494>
  8004201d28:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d2f:	8b 40 14             	mov    0x14(%rax),%eax
  8004201d32:	83 f8 03             	cmp    $0x3,%eax
  8004201d35:	0f 85 93 00 00 00    	jne    8004201dce <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004201d3b:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d42:	8b 40 04             	mov    0x4(%rax),%eax
  8004201d45:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004201d4a:	77 49                	ja     8004201d95 <multiboot_read+0x4ee>
  8004201d4c:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d53:	8b 40 08             	mov    0x8(%rax),%eax
  8004201d56:	85 c0                	test   %eax,%eax
  8004201d58:	75 3b                	jne    8004201d95 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201d5a:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201d61:	48 8b 10             	mov    (%rax),%rdx
  8004201d64:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d6b:	8b 40 10             	mov    0x10(%rax),%eax
  8004201d6e:	89 c0                	mov    %eax,%eax
  8004201d70:	48 c1 e0 20          	shl    $0x20,%rax
  8004201d74:	48 89 c1             	mov    %rax,%rcx
  8004201d77:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d7e:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201d81:	89 c0                	mov    %eax,%eax
  8004201d83:	48 01 c8             	add    %rcx,%rax
  8004201d86:	48 01 c2             	add    %rax,%rdx
  8004201d89:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201d90:	48 89 10             	mov    %rdx,(%rax)
  8004201d93:	eb 39                	jmp    8004201dce <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201d95:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201d9c:	48 8b 10             	mov    (%rax),%rdx
  8004201d9f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201da6:	8b 40 10             	mov    0x10(%rax),%eax
  8004201da9:	89 c0                	mov    %eax,%eax
  8004201dab:	48 c1 e0 20          	shl    $0x20,%rax
  8004201daf:	48 89 c1             	mov    %rax,%rcx
  8004201db2:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201db9:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201dbc:	89 c0                	mov    %eax,%eax
  8004201dbe:	48 01 c8             	add    %rcx,%rax
  8004201dc1:	48 01 c2             	add    %rax,%rdx
  8004201dc4:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201dcb:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201dce:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201dd2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201dd5:	48 63 c8             	movslq %eax,%rcx
  8004201dd8:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201ddf:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201de2:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201de7:	f7 e2                	mul    %edx
  8004201de9:	89 d0                	mov    %edx,%eax
  8004201deb:	c1 e8 04             	shr    $0x4,%eax
  8004201dee:	89 c0                	mov    %eax,%eax
  8004201df0:	48 39 c1             	cmp    %rax,%rcx
  8004201df3:	0f 82 fd fe ff ff    	jb     8004201cf6 <multiboot_read+0x44f>
  8004201df9:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004201dfc:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004201e00:	5b                   	pop    %rbx
  8004201e01:	41 5c                	pop    %r12
  8004201e03:	5d                   	pop    %rbp
  8004201e04:	c3                   	retq   

0000008004201e05 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004201e05:	55                   	push   %rbp
  8004201e06:	48 89 e5             	mov    %rsp,%rbp
  8004201e09:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004201e0d:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004201e14:	00 
	size_t extmem = 0;
  8004201e15:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004201e1c:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004201e1d:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004201e24:	00 00 00 
  8004201e27:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004201e2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201e2f:	48 8b 00             	mov    (%rax),%rax
  8004201e32:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004201e36:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201e3b:	74 2d                	je     8004201e6a <i386_detect_memory+0x65>
  8004201e3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201e41:	8b 00                	mov    (%rax),%eax
  8004201e43:	83 e0 40             	and    $0x40,%eax
  8004201e46:	85 c0                	test   %eax,%eax
  8004201e48:	74 20                	je     8004201e6a <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004201e4a:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8004201e4e:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8004201e52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201e56:	48 89 ce             	mov    %rcx,%rsi
  8004201e59:	48 89 c7             	mov    %rax,%rdi
  8004201e5c:	48 b8 a7 18 20 04 80 	movabs $0x80042018a7,%rax
  8004201e63:	00 00 00 
  8004201e66:	ff d0                	callq  *%rax
  8004201e68:	eb 34                	jmp    8004201e9e <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004201e6a:	bf 15 00 00 00       	mov    $0x15,%edi
  8004201e6f:	48 b8 68 18 20 04 80 	movabs $0x8004201868,%rax
  8004201e76:	00 00 00 
  8004201e79:	ff d0                	callq  *%rax
  8004201e7b:	c1 e0 0a             	shl    $0xa,%eax
  8004201e7e:	48 98                	cltq   
  8004201e80:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004201e84:	bf 17 00 00 00       	mov    $0x17,%edi
  8004201e89:	48 b8 68 18 20 04 80 	movabs $0x8004201868,%rax
  8004201e90:	00 00 00 
  8004201e93:	ff d0                	callq  *%rax
  8004201e95:	c1 e0 0a             	shl    $0xa,%eax
  8004201e98:	48 98                	cltq   
  8004201e9a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  8004201e9e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ea2:	48 85 c0             	test   %rax,%rax
  8004201ea5:	75 35                	jne    8004201edc <i386_detect_memory+0xd7>
  8004201ea7:	48 b9 d9 67 21 04 80 	movabs $0x80042167d9,%rcx
  8004201eae:	00 00 00 
  8004201eb1:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004201eb8:	00 00 00 
  8004201ebb:	be 86 00 00 00       	mov    $0x86,%esi
  8004201ec0:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004201ec7:	00 00 00 
  8004201eca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ecf:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004201ed6:	00 00 00 
  8004201ed9:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004201edc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ee0:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201ee4:	48 89 c2             	mov    %rax,%rdx
  8004201ee7:	48 b8 30 32 3d 04 80 	movabs $0x80043d3230,%rax
  8004201eee:	00 00 00 
  8004201ef1:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004201ef4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201ef8:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201efc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004201f00:	bf 17 00 00 00       	mov    $0x17,%edi
  8004201f05:	48 b8 68 18 20 04 80 	movabs $0x8004201868,%rax
  8004201f0c:	00 00 00 
  8004201f0f:	ff d0                	callq  *%rax
  8004201f11:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004201f16:	75 2c                	jne    8004201f44 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004201f18:	bf 34 00 00 00       	mov    $0x34,%edi
  8004201f1d:	48 b8 68 18 20 04 80 	movabs $0x8004201868,%rax
  8004201f24:	00 00 00 
  8004201f27:	ff d0                	callq  *%rax
  8004201f29:	c1 e0 10             	shl    $0x10,%eax
  8004201f2c:	48 98                	cltq   
  8004201f2e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004201f32:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201f36:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004201f3c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201f40:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004201f44:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201f49:	74 1a                	je     8004201f65 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004201f4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201f4f:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004201f56:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004201f5d:	00 00 00 
  8004201f60:	48 89 10             	mov    %rdx,(%rax)
  8004201f63:	eb 1a                	jmp    8004201f7f <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004201f65:	48 b8 30 32 3d 04 80 	movabs $0x80043d3230,%rax
  8004201f6c:	00 00 00 
  8004201f6f:	48 8b 10             	mov    (%rax),%rdx
  8004201f72:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004201f79:	00 00 00 
  8004201f7c:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201f7f:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004201f86:	00 00 00 
  8004201f89:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004201f8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201f90:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201f94:	48 c1 e8 0a          	shr    $0xa,%rax
  8004201f98:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004201f9b:	48 b8 30 32 3d 04 80 	movabs $0x80043d3230,%rax
  8004201fa2:	00 00 00 
  8004201fa5:	48 8b 00             	mov    (%rax),%rax
  8004201fa8:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201fac:	48 c1 e8 0a          	shr    $0xa,%rax
  8004201fb0:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  8004201fb3:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004201fba:	00 00 00 
  8004201fbd:	48 8b 00             	mov    (%rax),%rax
  8004201fc0:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201fc4:	48 c1 e8 14          	shr    $0x14,%rax
  8004201fc8:	49 89 f0             	mov    %rsi,%r8
  8004201fcb:	48 89 c6             	mov    %rax,%rsi
  8004201fce:	48 bf 08 68 21 04 80 	movabs $0x8004216808,%rdi
  8004201fd5:	00 00 00 
  8004201fd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201fdd:	49 b9 c2 87 20 04 80 	movabs $0x80042087c2,%r9
  8004201fe4:	00 00 00 
  8004201fe7:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004201fea:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  8004201ff1:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004201ff2:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004201ff9:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004201ffa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201ffe:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  8004202002:	48 c1 e8 14          	shr    $0x14,%rax
  8004202006:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202009:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420200d:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  8004202011:	48 c1 e8 14          	shr    $0x14,%rax
  8004202015:	48 89 c6             	mov    %rax,%rsi
  8004202018:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420201c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202020:	49 89 c8             	mov    %rcx,%r8
  8004202023:	48 89 d1             	mov    %rdx,%rcx
  8004202026:	48 89 f2             	mov    %rsi,%rdx
  8004202029:	48 89 c6             	mov    %rax,%rsi
  800420202c:	48 bf 58 68 21 04 80 	movabs $0x8004216858,%rdi
  8004202033:	00 00 00 
  8004202036:	b8 00 00 00 00       	mov    $0x0,%eax
  800420203b:	49 b9 c2 87 20 04 80 	movabs $0x80042087c2,%r9
  8004202042:	00 00 00 
  8004202045:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202048:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420204c:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202050:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004202055:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004202059:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004202060:	00 00 00 
  8004202063:	48 8b 00             	mov    (%rax),%rax
  8004202066:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420206a:	76 3a                	jbe    80042020a6 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  800420206c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202070:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  8004202077:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  800420207e:	00 00 00 
  8004202081:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  8004202084:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202088:	48 89 c6             	mov    %rax,%rsi
  800420208b:	48 bf c0 68 21 04 80 	movabs $0x80042168c0,%rdi
  8004202092:	00 00 00 
  8004202095:	b8 00 00 00 00       	mov    $0x0,%eax
  800420209a:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042020a1:	00 00 00 
  80042020a4:	ff d2                	callq  *%rdx
	}
}
  80042020a6:	c9                   	leaveq 
  80042020a7:	c3                   	retq   

00000080042020a8 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042020a8:	55                   	push   %rbp
  80042020a9:	48 89 e5             	mov    %rsp,%rbp
  80042020ac:	48 83 ec 40          	sub    $0x40,%rsp
  80042020b0:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042020b3:	48 b8 48 32 3d 04 80 	movabs $0x80043d3248,%rax
  80042020ba:	00 00 00 
  80042020bd:	48 8b 00             	mov    (%rax),%rax
  80042020c0:	48 85 c0             	test   %rax,%rax
  80042020c3:	75 4b                	jne    8004202110 <boot_alloc+0x68>
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  80042020c5:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042020cc:	00 
  80042020cd:	48 b8 10 70 45 04 80 	movabs $0x8004457010,%rax
  80042020d4:	00 00 00 
  80042020d7:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042020db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042020df:	48 01 d0             	add    %rdx,%rax
  80042020e2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042020e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042020ea:	ba 00 00 00 00       	mov    $0x0,%edx
  80042020ef:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042020f3:	48 89 d0             	mov    %rdx,%rax
  80042020f6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042020fa:	48 29 c2             	sub    %rax,%rdx
  80042020fd:	48 89 d0             	mov    %rdx,%rax
  8004202100:	48 89 c2             	mov    %rax,%rdx
  8004202103:	48 b8 48 32 3d 04 80 	movabs $0x80043d3248,%rax
  800420210a:	00 00 00 
  800420210d:	48 89 10             	mov    %rdx,(%rax)
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.

		if((uint64_t)(nextfree + n) > (npages * PGSIZE + KERNBASE)){
  8004202110:	48 b8 48 32 3d 04 80 	movabs $0x80043d3248,%rax
  8004202117:	00 00 00 
  800420211a:	48 8b 10             	mov    (%rax),%rdx
  800420211d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202120:	48 01 d0             	add    %rdx,%rax
  8004202123:	48 89 c2             	mov    %rax,%rdx
  8004202126:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  800420212d:	00 00 00 
  8004202130:	48 8b 00             	mov    (%rax),%rax
  8004202133:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004202139:	48 c1 e0 0c          	shl    $0xc,%rax
  800420213d:	48 39 c2             	cmp    %rax,%rdx
  8004202140:	76 2a                	jbe    800420216c <boot_alloc+0xc4>
			panic("out of memory in boot_alloc");
  8004202142:	48 ba e9 68 21 04 80 	movabs $0x80042168e9,%rdx
  8004202149:	00 00 00 
  800420214c:	be e0 00 00 00       	mov    $0xe0,%esi
  8004202151:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004202158:	00 00 00 
  800420215b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202160:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  8004202167:	00 00 00 
  800420216a:	ff d1                	callq  *%rcx
		}
		result = nextfree;
  800420216c:	48 b8 48 32 3d 04 80 	movabs $0x80043d3248,%rax
  8004202173:	00 00 00 
  8004202176:	48 8b 00             	mov    (%rax),%rax
  8004202179:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(n != 0)
  800420217d:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004202181:	74 57                	je     80042021da <boot_alloc+0x132>
			nextfree = ROUNDUP(nextfree + n, PGSIZE);
  8004202183:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420218a:	00 
  800420218b:	48 b8 48 32 3d 04 80 	movabs $0x80043d3248,%rax
  8004202192:	00 00 00 
  8004202195:	48 8b 10             	mov    (%rax),%rdx
  8004202198:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420219b:	48 01 d0             	add    %rdx,%rax
  800420219e:	48 89 c2             	mov    %rax,%rdx
  80042021a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042021a5:	48 01 d0             	add    %rdx,%rax
  80042021a8:	48 83 e8 01          	sub    $0x1,%rax
  80042021ac:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042021b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042021b4:	ba 00 00 00 00       	mov    $0x0,%edx
  80042021b9:	48 f7 75 e0          	divq   -0x20(%rbp)
  80042021bd:	48 89 d0             	mov    %rdx,%rax
  80042021c0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042021c4:	48 29 c2             	sub    %rax,%rdx
  80042021c7:	48 89 d0             	mov    %rdx,%rax
  80042021ca:	48 89 c2             	mov    %rax,%rdx
  80042021cd:	48 b8 48 32 3d 04 80 	movabs $0x80043d3248,%rax
  80042021d4:	00 00 00 
  80042021d7:	48 89 10             	mov    %rdx,(%rax)
		return result;
  80042021da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042021de:	c9                   	leaveq 
  80042021df:	c3                   	retq   

00000080042021e0 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  80042021e0:	55                   	push   %rbp
  80042021e1:	48 89 e5             	mov    %rsp,%rbp
  80042021e4:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  80042021eb:	48 b8 05 1e 20 04 80 	movabs $0x8004201e05,%rax
  80042021f2:	00 00 00 
  80042021f5:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  80042021f7:	bf 00 10 00 00       	mov    $0x1000,%edi
  80042021fc:	48 b8 a8 20 20 04 80 	movabs $0x80042020a8,%rax
  8004202203:	00 00 00 
  8004202206:	ff d0                	callq  *%rax
  8004202208:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  800420220c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202210:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202215:	be 00 00 00 00       	mov    $0x0,%esi
  800420221a:	48 89 c7             	mov    %rax,%rdi
  800420221d:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004202224:	00 00 00 
  8004202227:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004202229:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004202230:	00 00 00 
  8004202233:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202237:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  800420223a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420223e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202242:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202249:	00 00 00 
  800420224c:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004202250:	77 32                	ja     8004202284 <x64_vm_init+0xa4>
  8004202252:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202256:	48 89 c1             	mov    %rax,%rcx
  8004202259:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  8004202260:	00 00 00 
  8004202263:	be 01 01 00 00       	mov    $0x101,%esi
  8004202268:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420226f:	00 00 00 
  8004202272:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202277:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420227e:	00 00 00 
  8004202281:	41 ff d0             	callq  *%r8
  8004202284:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420228b:	ff ff ff 
  800420228e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202292:	48 01 c2             	add    %rax,%rdx
  8004202295:	48 b8 20 47 3d 04 80 	movabs $0x80043d4720,%rax
  800420229c:	00 00 00 
  800420229f:	48 89 10             	mov    %rdx,(%rax)
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:

		n = ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE);
  80042022a2:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  80042022a9:	00 
  80042022aa:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042022b1:	00 00 00 
  80042022b4:	48 8b 00             	mov    (%rax),%rax
  80042022b7:	48 c1 e0 04          	shl    $0x4,%rax
  80042022bb:	48 89 c2             	mov    %rax,%rdx
  80042022be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042022c2:	48 01 d0             	add    %rdx,%rax
  80042022c5:	48 83 e8 01          	sub    $0x1,%rax
  80042022c9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042022cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042022d1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042022d6:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042022da:	48 89 d0             	mov    %rdx,%rax
  80042022dd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042022e1:	48 29 c2             	sub    %rax,%rdx
  80042022e4:	48 89 d0             	mov    %rdx,%rax
  80042022e7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		pages = boot_alloc(n);
  80042022eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042022ef:	89 c7                	mov    %eax,%edi
  80042022f1:	48 b8 a8 20 20 04 80 	movabs $0x80042020a8,%rax
  80042022f8:	00 00 00 
  80042022fb:	ff d0                	callq  *%rax
  80042022fd:	48 ba 38 47 3d 04 80 	movabs $0x80043d4738,%rdx
  8004202304:	00 00 00 
  8004202307:	48 89 02             	mov    %rax,(%rdx)
		memset(pages, 0, n);
  800420230a:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004202311:	00 00 00 
  8004202314:	48 8b 00             	mov    (%rax),%rax
  8004202317:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420231b:	be 00 00 00 00       	mov    $0x0,%esi
  8004202320:	48 89 c7             	mov    %rax,%rdi
  8004202323:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  800420232a:	00 00 00 
  800420232d:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	uint32_t env_size = sizeof(struct Env) * NENV;
  800420232f:	c7 45 d4 00 80 04 00 	movl   $0x48000,-0x2c(%rbp)
	envs = boot_alloc(env_size);
  8004202336:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004202339:	89 c7                	mov    %eax,%edi
  800420233b:	48 b8 a8 20 20 04 80 	movabs $0x80042020a8,%rax
  8004202342:	00 00 00 
  8004202345:	ff d0                	callq  *%rax
  8004202347:	48 ba 50 32 3d 04 80 	movabs $0x80043d3250,%rdx
  800420234e:	00 00 00 
  8004202351:	48 89 02             	mov    %rax,(%rdx)
	env = envs;
  8004202354:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420235b:	00 00 00 
  800420235e:	48 8b 00             	mov    (%rax),%rax
  8004202361:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004202365:	48 b8 5c 28 20 04 80 	movabs $0x800420285c,%rax
  800420236c:	00 00 00 
  800420236f:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
	n = npages*sizeof(struct PageInfo);
  8004202371:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004202378:	00 00 00 
  800420237b:	48 8b 00             	mov    (%rax),%rax
  800420237e:	48 c1 e0 04          	shl    $0x4,%rax
  8004202382:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	boot_map_region(boot_pml4e, UPAGES, n, PADDR(pages), PTE_U);
  8004202386:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  800420238d:	00 00 00 
  8004202390:	48 8b 00             	mov    (%rax),%rax
  8004202393:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202397:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420239e:	00 00 00 
  80042023a1:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  80042023a5:	77 32                	ja     80042023d9 <x64_vm_init+0x1f9>
  80042023a7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023ab:	48 89 c1             	mov    %rax,%rcx
  80042023ae:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  80042023b5:	00 00 00 
  80042023b8:	be 26 01 00 00       	mov    $0x126,%esi
  80042023bd:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042023c4:	00 00 00 
  80042023c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042023cc:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042023d3:	00 00 00 
  80042023d6:	41 ff d0             	callq  *%r8
  80042023d9:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042023e0:	ff ff ff 
  80042023e3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023e7:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042023eb:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042023f2:	00 00 00 
  80042023f5:	48 8b 00             	mov    (%rax),%rax
  80042023f8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042023fc:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  8004202402:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202409:	00 00 00 
  800420240c:	48 89 c7             	mov    %rax,%rdi
  800420240f:	48 b8 9b 2f 20 04 80 	movabs $0x8004202f9b,%rax
  8004202416:	00 00 00 
  8004202419:	ff d0                	callq  *%rax

	boot_map_region(pml4e, (uintptr_t) pages, PGSIZE, PADDR(pages), PTE_W);
  800420241b:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004202422:	00 00 00 
  8004202425:	48 8b 00             	mov    (%rax),%rax
  8004202428:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  800420242c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202433:	00 00 00 
  8004202436:	48 39 45 b8          	cmp    %rax,-0x48(%rbp)
  800420243a:	77 32                	ja     800420246e <x64_vm_init+0x28e>
  800420243c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202440:	48 89 c1             	mov    %rax,%rcx
  8004202443:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  800420244a:	00 00 00 
  800420244d:	be 28 01 00 00       	mov    $0x128,%esi
  8004202452:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004202459:	00 00 00 
  800420245c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202461:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004202468:	00 00 00 
  800420246b:	41 ff d0             	callq  *%r8
  800420246e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202475:	ff ff ff 
  8004202478:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420247c:	48 01 c2             	add    %rax,%rdx
  800420247f:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004202486:	00 00 00 
  8004202489:	48 8b 00             	mov    (%rax),%rax
  800420248c:	48 89 c6             	mov    %rax,%rsi
  800420248f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202493:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  8004202499:	48 89 d1             	mov    %rdx,%rcx
  800420249c:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042024a1:	48 89 c7             	mov    %rax,%rdi
  80042024a4:	48 b8 9b 2f 20 04 80 	movabs $0x8004202f9b,%rax
  80042024ab:	00 00 00 
  80042024ae:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(boot_pml4e, UENVS, env_size, PADDR(env), PTE_U);
  80042024b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042024b4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042024b8:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042024bf:	00 00 00 
  80042024c2:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  80042024c6:	77 32                	ja     80042024fa <x64_vm_init+0x31a>
  80042024c8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042024cc:	48 89 c1             	mov    %rax,%rcx
  80042024cf:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  80042024d6:	00 00 00 
  80042024d9:	be 31 01 00 00       	mov    $0x131,%esi
  80042024de:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042024e5:	00 00 00 
  80042024e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042024ed:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042024f4:	00 00 00 
  80042024f7:	41 ff d0             	callq  *%r8
  80042024fa:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202501:	ff ff ff 
  8004202504:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202508:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  800420250c:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420250f:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004202516:	00 00 00 
  8004202519:	48 8b 00             	mov    (%rax),%rax
  800420251c:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  8004202522:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202529:	00 00 00 
  800420252c:	48 89 c7             	mov    %rax,%rdi
  800420252f:	48 b8 9b 2f 20 04 80 	movabs $0x8004202f9b,%rax
  8004202536:	00 00 00 
  8004202539:	ff d0                	callq  *%rax
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(pml4e, KSTACKTOP-KSTKSIZE, 16*PGSIZE, PADDR(bootstack), PTE_W);
  800420253b:	48 b8 00 b0 21 04 80 	movabs $0x800421b000,%rax
  8004202542:	00 00 00 
  8004202545:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004202549:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202550:	00 00 00 
  8004202553:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  8004202557:	77 32                	ja     800420258b <x64_vm_init+0x3ab>
  8004202559:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420255d:	48 89 c1             	mov    %rax,%rcx
  8004202560:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  8004202567:	00 00 00 
  800420256a:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420256f:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004202576:	00 00 00 
  8004202579:	b8 00 00 00 00       	mov    $0x0,%eax
  800420257e:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004202585:	00 00 00 
  8004202588:	41 ff d0             	callq  *%r8
  800420258b:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202592:	ff ff ff 
  8004202595:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202599:	48 01 c2             	add    %rax,%rdx
  800420259c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042025a0:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  80042025a6:	48 89 d1             	mov    %rdx,%rcx
  80042025a9:	ba 00 00 01 00       	mov    $0x10000,%edx
  80042025ae:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  80042025b5:	00 00 00 
  80042025b8:	48 89 c7             	mov    %rax,%rdi
  80042025bb:	48 b8 9b 2f 20 04 80 	movabs $0x8004202f9b,%rax
  80042025c2:	00 00 00 
  80042025c5:	ff d0                	callq  *%rax
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(pml4e, KERNBASE, npages * PGSIZE, (physaddr_t)0x0, PTE_W);;
  80042025c7:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042025ce:	00 00 00 
  80042025d1:	48 8b 00             	mov    (%rax),%rax
  80042025d4:	48 c1 e0 0c          	shl    $0xc,%rax
  80042025d8:	48 89 c2             	mov    %rax,%rdx
  80042025db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042025df:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  80042025e5:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042025ea:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  80042025f1:	00 00 00 
  80042025f4:	48 89 c7             	mov    %rax,%rdi
  80042025f7:	48 b8 9b 2f 20 04 80 	movabs $0x8004202f9b,%rax
  80042025fe:	00 00 00 
  8004202601:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202603:	48 b8 7c 27 20 04 80 	movabs $0x800420277c,%rax
  800420260a:	00 00 00 
  800420260d:	ff d0                	callq  *%rax

	check_page_free_list(1);
  800420260f:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202614:	48 b8 ac 35 20 04 80 	movabs $0x80042035ac,%rax
  800420261b:	00 00 00 
  800420261e:	ff d0                	callq  *%rax
	check_page_alloc();
  8004202620:	48 b8 d9 3a 20 04 80 	movabs $0x8004203ad9,%rax
  8004202627:	00 00 00 
  800420262a:	ff d0                	callq  *%rax
	page_check();
  800420262c:	48 b8 8d 4e 20 04 80 	movabs $0x8004204e8d,%rax
  8004202633:	00 00 00 
  8004202636:	ff d0                	callq  *%rax
	check_page_free_list(0);
  8004202638:	bf 00 00 00 00       	mov    $0x0,%edi
  800420263d:	48 b8 ac 35 20 04 80 	movabs $0x80042035ac,%rax
  8004202644:	00 00 00 
  8004202647:	ff d0                	callq  *%rax
	check_boot_pml4e(boot_pml4e);
  8004202649:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004202650:	00 00 00 
  8004202653:	48 8b 00             	mov    (%rax),%rax
  8004202656:	48 89 c7             	mov    %rax,%rdi
  8004202659:	48 b8 c5 44 20 04 80 	movabs $0x80042044c5,%rax
  8004202660:	00 00 00 
  8004202663:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202665:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202669:	48 83 c0 08          	add    $0x8,%rax
  800420266d:	48 8b 00             	mov    (%rax),%rax
  8004202670:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202676:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420267a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420267e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202682:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004202685:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202688:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  800420268f:	00 00 00 
  8004202692:	48 8b 00             	mov    (%rax),%rax
  8004202695:	48 39 c2             	cmp    %rax,%rdx
  8004202698:	72 32                	jb     80042026cc <x64_vm_init+0x4ec>
  800420269a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420269e:	48 89 c1             	mov    %rax,%rcx
  80042026a1:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042026a8:	00 00 00 
  80042026ab:	be 57 01 00 00       	mov    $0x157,%esi
  80042026b0:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042026b7:	00 00 00 
  80042026ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042026bf:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042026c6:	00 00 00 
  80042026c9:	41 ff d0             	callq  *%r8
  80042026cc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042026d3:	00 00 00 
  80042026d6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042026da:	48 01 d0             	add    %rdx,%rax
  80042026dd:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  80042026e1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042026e5:	48 8b 00             	mov    (%rax),%rax
  80042026e8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042026ee:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042026f2:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042026f6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042026fa:	89 45 84             	mov    %eax,-0x7c(%rbp)
  80042026fd:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004202700:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004202707:	00 00 00 
  800420270a:	48 8b 00             	mov    (%rax),%rax
  800420270d:	48 39 c2             	cmp    %rax,%rdx
  8004202710:	72 32                	jb     8004202744 <x64_vm_init+0x564>
  8004202712:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202716:	48 89 c1             	mov    %rax,%rcx
  8004202719:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004202720:	00 00 00 
  8004202723:	be 58 01 00 00       	mov    $0x158,%esi
  8004202728:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420272f:	00 00 00 
  8004202732:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202737:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420273e:	00 00 00 
  8004202741:	41 ff d0             	callq  *%r8
  8004202744:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420274b:	00 00 00 
  800420274e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202752:	48 01 d0             	add    %rdx,%rax
  8004202755:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	lcr3(boot_cr3);
  800420275c:	48 b8 20 47 3d 04 80 	movabs $0x80043d4720,%rax
  8004202763:	00 00 00 
  8004202766:	48 8b 00             	mov    (%rax),%rax
  8004202769:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202770:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202777:	0f 22 d8             	mov    %rax,%cr3
}
  800420277a:	c9                   	leaveq 
  800420277b:	c3                   	retq   

000000800420277c <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  800420277c:	55                   	push   %rbp
  800420277d:	48 89 e5             	mov    %rsp,%rbp
  8004202780:	48 83 ec 20          	sub    $0x20,%rsp
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int cpu_num;
	uintptr_t top = KSTACKTOP;
  8004202784:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420278b:	00 00 00 
  800420278e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (cpu_num = 0; cpu_num < NCPU; ++cpu_num)
  8004202792:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004202799:	e9 b2 00 00 00       	jmpq   8004202850 <mem_init_mp+0xd4>
	{
		top -= KSTKSIZE;
  800420279e:	48 81 6d f0 00 00 01 	subq   $0x10000,-0x10(%rbp)
  80042027a5:	00 
		boot_map_region(boot_pml4e, top, KSTKSIZE, PADDR(percpu_kstacks[cpu_num]), PTE_W);
  80042027a6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042027a9:	48 98                	cltq   
  80042027ab:	48 c1 e0 10          	shl    $0x10,%rax
  80042027af:	48 89 c2             	mov    %rax,%rdx
  80042027b2:	48 b8 00 70 3d 04 80 	movabs $0x80043d7000,%rax
  80042027b9:	00 00 00 
  80042027bc:	48 01 d0             	add    %rdx,%rax
  80042027bf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042027c3:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042027ca:	00 00 00 
  80042027cd:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042027d1:	77 32                	ja     8004202805 <mem_init_mp+0x89>
  80042027d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042027d7:	48 89 c1             	mov    %rax,%rcx
  80042027da:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  80042027e1:	00 00 00 
  80042027e4:	be 78 01 00 00       	mov    $0x178,%esi
  80042027e9:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042027f0:	00 00 00 
  80042027f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027f8:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042027ff:	00 00 00 
  8004202802:	41 ff d0             	callq  *%r8
  8004202805:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420280c:	ff ff ff 
  800420280f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202813:	48 01 c2             	add    %rax,%rdx
  8004202816:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420281d:	00 00 00 
  8004202820:	48 8b 00             	mov    (%rax),%rax
  8004202823:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004202827:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  800420282d:	48 89 d1             	mov    %rdx,%rcx
  8004202830:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202835:	48 89 c7             	mov    %rax,%rdi
  8004202838:	48 b8 9b 2f 20 04 80 	movabs $0x8004202f9b,%rax
  800420283f:	00 00 00 
  8004202842:	ff d0                	callq  *%rax
		top -= KSTKGAP;
  8004202844:	48 81 6d f0 00 80 00 	subq   $0x8000,-0x10(%rbp)
  800420284b:	00 
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int cpu_num;
	uintptr_t top = KSTACKTOP;
	for (cpu_num = 0; cpu_num < NCPU; ++cpu_num)
  800420284c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202850:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  8004202854:	0f 8e 44 ff ff ff    	jle    800420279e <mem_init_mp+0x22>
		top -= KSTKSIZE;
		boot_map_region(boot_pml4e, top, KSTKSIZE, PADDR(percpu_kstacks[cpu_num]), PTE_W);
		top -= KSTKGAP;
	}

}
  800420285a:	c9                   	leaveq 
  800420285b:	c3                   	retq   

000000800420285c <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  800420285c:	55                   	push   %rbp
  800420285d:	48 89 e5             	mov    %rsp,%rbp
  8004202860:	48 83 ec 10          	sub    $0x10,%rsp
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	// page_free_list = NULL;

	int num_alloc = ((uint64_t)boot_alloc(0) - KERNBASE) / PGSIZE;
  8004202864:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202869:	48 b8 a8 20 20 04 80 	movabs $0x80042020a8,%rax
  8004202870:	00 00 00 
  8004202873:	ff d0                	callq  *%rax
  8004202875:	48 89 c2             	mov    %rax,%rdx
  8004202878:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420287f:	ff ff ff 
  8004202882:	48 01 d0             	add    %rdx,%rax
  8004202885:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202889:	89 45 f4             	mov    %eax,-0xc(%rbp)
	int num_iohole = 96;
  800420288c:	c7 45 f0 60 00 00 00 	movl   $0x60,-0x10(%rbp)

	// pages[0].pp_ref = 1;
	for(i = 1; i < MPENTRY_PADDR/PGSIZE; i++)
  8004202893:	48 c7 45 f8 01 00 00 	movq   $0x1,-0x8(%rbp)
  800420289a:	00 
  800420289b:	eb 70                	jmp    800420290d <page_init+0xb1>
	{
	  pages[i].pp_ref = 0;
  800420289d:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  80042028a4:	00 00 00 
  80042028a7:	48 8b 00             	mov    (%rax),%rax
  80042028aa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042028ae:	48 c1 e2 04          	shl    $0x4,%rdx
  80042028b2:	48 01 d0             	add    %rdx,%rax
  80042028b5:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
	  pages[i].pp_link = page_free_list;
  80042028bb:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  80042028c2:	00 00 00 
  80042028c5:	48 8b 00             	mov    (%rax),%rax
  80042028c8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042028cc:	48 c1 e2 04          	shl    $0x4,%rdx
  80042028d0:	48 01 c2             	add    %rax,%rdx
  80042028d3:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042028da:	00 00 00 
  80042028dd:	48 8b 00             	mov    (%rax),%rax
  80042028e0:	48 89 02             	mov    %rax,(%rdx)
	  page_free_list = &pages[i];
  80042028e3:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  80042028ea:	00 00 00 
  80042028ed:	48 8b 00             	mov    (%rax),%rax
  80042028f0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042028f4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042028f8:	48 01 c2             	add    %rax,%rdx
  80042028fb:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004202902:	00 00 00 
  8004202905:	48 89 10             	mov    %rdx,(%rax)

	int num_alloc = ((uint64_t)boot_alloc(0) - KERNBASE) / PGSIZE;
	int num_iohole = 96;

	// pages[0].pp_ref = 1;
	for(i = 1; i < MPENTRY_PADDR/PGSIZE; i++)
  8004202908:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420290d:	48 83 7d f8 06       	cmpq   $0x6,-0x8(%rbp)
  8004202912:	76 89                	jbe    800420289d <page_init+0x41>
	  pages[i].pp_ref = 0;
	  pages[i].pp_link = page_free_list;
	  page_free_list = &pages[i];
	}

	for(i = npages_basemem; i < npages_basemem + num_iohole + num_alloc; i++)
  8004202914:	48 b8 30 32 3d 04 80 	movabs $0x80043d3230,%rax
  800420291b:	00 00 00 
  800420291e:	48 8b 00             	mov    (%rax),%rax
  8004202921:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004202925:	eb 23                	jmp    800420294a <page_init+0xee>
	  pages[i].pp_ref = 1;
  8004202927:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  800420292e:	00 00 00 
  8004202931:	48 8b 00             	mov    (%rax),%rax
  8004202934:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202938:	48 c1 e2 04          	shl    $0x4,%rdx
  800420293c:	48 01 d0             	add    %rdx,%rax
  800420293f:	66 c7 40 08 01 00    	movw   $0x1,0x8(%rax)
	  pages[i].pp_ref = 0;
	  pages[i].pp_link = page_free_list;
	  page_free_list = &pages[i];
	}

	for(i = npages_basemem; i < npages_basemem + num_iohole + num_alloc; i++)
  8004202945:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420294a:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800420294d:	48 63 d0             	movslq %eax,%rdx
  8004202950:	48 b8 30 32 3d 04 80 	movabs $0x80043d3230,%rax
  8004202957:	00 00 00 
  800420295a:	48 8b 00             	mov    (%rax),%rax
  800420295d:	48 01 c2             	add    %rax,%rdx
  8004202960:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004202963:	48 98                	cltq   
  8004202965:	48 01 d0             	add    %rdx,%rax
  8004202968:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420296c:	77 b9                	ja     8004202927 <page_init+0xcb>
	  pages[i].pp_ref = 1;
	for(; i < npages; i++)
  800420296e:	eb 70                	jmp    80042029e0 <page_init+0x184>
	{
	  pages[i].pp_ref = 0;
  8004202970:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004202977:	00 00 00 
  800420297a:	48 8b 00             	mov    (%rax),%rax
  800420297d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202981:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202985:	48 01 d0             	add    %rdx,%rax
  8004202988:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
	  pages[i].pp_link = page_free_list;
  800420298e:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004202995:	00 00 00 
  8004202998:	48 8b 00             	mov    (%rax),%rax
  800420299b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420299f:	48 c1 e2 04          	shl    $0x4,%rdx
  80042029a3:	48 01 c2             	add    %rax,%rdx
  80042029a6:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042029ad:	00 00 00 
  80042029b0:	48 8b 00             	mov    (%rax),%rax
  80042029b3:	48 89 02             	mov    %rax,(%rdx)
	  page_free_list = &pages[i];
  80042029b6:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  80042029bd:	00 00 00 
  80042029c0:	48 8b 00             	mov    (%rax),%rax
  80042029c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042029c7:	48 c1 e2 04          	shl    $0x4,%rdx
  80042029cb:	48 01 c2             	add    %rax,%rdx
  80042029ce:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042029d5:	00 00 00 
  80042029d8:	48 89 10             	mov    %rdx,(%rax)
	  page_free_list = &pages[i];
	}

	for(i = npages_basemem; i < npages_basemem + num_iohole + num_alloc; i++)
	  pages[i].pp_ref = 1;
	for(; i < npages; i++)
  80042029db:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042029e0:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042029e7:	00 00 00 
  80042029ea:	48 8b 00             	mov    (%rax),%rax
  80042029ed:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042029f1:	0f 82 79 ff ff ff    	jb     8004202970 <page_init+0x114>
	{
	  pages[i].pp_ref = 0;
	  pages[i].pp_link = page_free_list;
	  page_free_list = &pages[i];
	}
}
  80042029f7:	c9                   	leaveq 
  80042029f8:	c3                   	retq   

00000080042029f9 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  80042029f9:	55                   	push   %rbp
  80042029fa:	48 89 e5             	mov    %rsp,%rbp
  80042029fd:	48 83 ec 20          	sub    $0x20,%rsp
  8004202a01:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	if (!page_free_list)
  8004202a04:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004202a0b:	00 00 00 
  8004202a0e:	48 8b 00             	mov    (%rax),%rax
  8004202a11:	48 85 c0             	test   %rax,%rax
  8004202a14:	75 07                	jne    8004202a1d <page_alloc+0x24>
	 		return NULL;
  8004202a16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a1b:	eb 6a                	jmp    8004202a87 <page_alloc+0x8e>

	 	struct PageInfo *page = page_free_list;
  8004202a1d:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004202a24:	00 00 00 
  8004202a27:	48 8b 00             	mov    (%rax),%rax
  8004202a2a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	 	page_free_list = page->pp_link;
  8004202a2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202a32:	48 8b 10             	mov    (%rax),%rdx
  8004202a35:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004202a3c:	00 00 00 
  8004202a3f:	48 89 10             	mov    %rdx,(%rax)

	 	if (alloc_flags & ALLOC_ZERO)
  8004202a42:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202a45:	83 e0 01             	and    $0x1,%eax
  8004202a48:	85 c0                	test   %eax,%eax
  8004202a4a:	74 2c                	je     8004202a78 <page_alloc+0x7f>
			memset(page2kva(page), '\0', PGSIZE);
  8004202a4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202a50:	48 89 c7             	mov    %rax,%rdi
  8004202a53:	48 b8 7f 17 20 04 80 	movabs $0x800420177f,%rax
  8004202a5a:	00 00 00 
  8004202a5d:	ff d0                	callq  *%rax
  8004202a5f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202a64:	be 00 00 00 00       	mov    $0x0,%esi
  8004202a69:	48 89 c7             	mov    %rax,%rdi
  8004202a6c:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004202a73:	00 00 00 
  8004202a76:	ff d0                	callq  *%rax

		page->pp_link = NULL;
  8004202a78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202a7c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

		return page;
  8004202a83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004202a87:	c9                   	leaveq 
  8004202a88:	c3                   	retq   

0000008004202a89 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202a89:	55                   	push   %rbp
  8004202a8a:	48 89 e5             	mov    %rsp,%rbp
  8004202a8d:	48 83 ec 10          	sub    $0x10,%rsp
  8004202a91:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202a95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202a99:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202a9e:	be 00 00 00 00       	mov    $0x0,%esi
  8004202aa3:	48 89 c7             	mov    %rax,%rdi
  8004202aa6:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004202aad:	00 00 00 
  8004202ab0:	ff d0                	callq  *%rax
}
  8004202ab2:	c9                   	leaveq 
  8004202ab3:	c3                   	retq   

0000008004202ab4 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004202ab4:	55                   	push   %rbp
  8004202ab5:	48 89 e5             	mov    %rsp,%rbp
  8004202ab8:	48 83 ec 10          	sub    $0x10,%rsp
  8004202abc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref != 0 || pp->pp_link)
  8004202ac0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ac4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202ac8:	66 85 c0             	test   %ax,%ax
  8004202acb:	75 0c                	jne    8004202ad9 <page_free+0x25>
  8004202acd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ad1:	48 8b 00             	mov    (%rax),%rax
  8004202ad4:	48 85 c0             	test   %rax,%rax
  8004202ad7:	74 2a                	je     8004202b03 <page_free+0x4f>
		panic("'the page could not be free");
  8004202ad9:	48 ba 2c 69 21 04 80 	movabs $0x800421692c,%rdx
  8004202ae0:	00 00 00 
  8004202ae3:	be f0 01 00 00       	mov    $0x1f0,%esi
  8004202ae8:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004202aef:	00 00 00 
  8004202af2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202af7:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  8004202afe:	00 00 00 
  8004202b01:	ff d1                	callq  *%rcx

	pp->pp_link = page_free_list;
  8004202b03:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004202b0a:	00 00 00 
  8004202b0d:	48 8b 10             	mov    (%rax),%rdx
  8004202b10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b14:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  8004202b17:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004202b1e:	00 00 00 
  8004202b21:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202b25:	48 89 10             	mov    %rdx,(%rax)
}
  8004202b28:	c9                   	leaveq 
  8004202b29:	c3                   	retq   

0000008004202b2a <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004202b2a:	55                   	push   %rbp
  8004202b2b:	48 89 e5             	mov    %rsp,%rbp
  8004202b2e:	48 83 ec 10          	sub    $0x10,%rsp
  8004202b32:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004202b36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b3a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202b3e:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202b41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b45:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004202b49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b4d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202b51:	66 85 c0             	test   %ax,%ax
  8004202b54:	75 13                	jne    8004202b69 <page_decref+0x3f>
		page_free(pp);
  8004202b56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b5a:	48 89 c7             	mov    %rax,%rdi
  8004202b5d:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  8004202b64:	00 00 00 
  8004202b67:	ff d0                	callq  *%rax
}
  8004202b69:	c9                   	leaveq 
  8004202b6a:	c3                   	retq   

0000008004202b6b <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004202b6b:	55                   	push   %rbp
  8004202b6c:	48 89 e5             	mov    %rsp,%rbp
  8004202b6f:	48 83 ec 50          	sub    $0x50,%rsp
  8004202b73:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202b77:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202b7b:	89 55 bc             	mov    %edx,-0x44(%rbp)
	pdpe_t *pdpe;
 	struct PageInfo *page = NULL;
  8004202b7e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202b85:	00 
 	pml4e_t *current_pml4e = &pml4e[PML4(va)];
  8004202b86:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202b8a:	48 c1 e8 27          	shr    $0x27,%rax
  8004202b8e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202b93:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202b9a:	00 
  8004202b9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202b9f:	48 01 d0             	add    %rdx,%rax
  8004202ba2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

 	if(create && !(*current_pml4e & PTE_P)) {
  8004202ba6:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004202baa:	74 69                	je     8004202c15 <pml4e_walk+0xaa>
  8004202bac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202bb0:	48 8b 00             	mov    (%rax),%rax
  8004202bb3:	83 e0 01             	and    $0x1,%eax
  8004202bb6:	48 85 c0             	test   %rax,%rax
  8004202bb9:	75 5a                	jne    8004202c15 <pml4e_walk+0xaa>
 		page = page_alloc(ALLOC_ZERO);
  8004202bbb:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202bc0:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004202bc7:	00 00 00 
  8004202bca:	ff d0                	callq  *%rax
  8004202bcc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 		if (!page)
  8004202bd0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202bd5:	75 0a                	jne    8004202be1 <pml4e_walk+0x76>
			return NULL;
  8004202bd7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202bdc:	e9 fd 00 00 00       	jmpq   8004202cde <pml4e_walk+0x173>

		page->pp_ref++;
  8004202be1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202be5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202be9:	8d 50 01             	lea    0x1(%rax),%edx
  8004202bec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bf0:	66 89 50 08          	mov    %dx,0x8(%rax)


		*current_pml4e = (pml4e_t) page2pa(page)| PTE_P | PTE_W | PTE_U;
  8004202bf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bf8:	48 89 c7             	mov    %rax,%rdi
  8004202bfb:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004202c02:	00 00 00 
  8004202c05:	ff d0                	callq  *%rax
  8004202c07:	48 83 c8 07          	or     $0x7,%rax
  8004202c0b:	48 89 c2             	mov    %rax,%rdx
  8004202c0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c12:	48 89 10             	mov    %rdx,(%rax)
	}

	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*current_pml4e));
  8004202c15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c19:	48 8b 00             	mov    (%rax),%rax
  8004202c1c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202c22:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202c26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c2a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202c2e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004202c31:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004202c34:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004202c3b:	00 00 00 
  8004202c3e:	48 8b 00             	mov    (%rax),%rax
  8004202c41:	48 39 c2             	cmp    %rax,%rdx
  8004202c44:	72 32                	jb     8004202c78 <pml4e_walk+0x10d>
  8004202c46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c4a:	48 89 c1             	mov    %rax,%rcx
  8004202c4d:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004202c54:	00 00 00 
  8004202c57:	be 2c 02 00 00       	mov    $0x22c,%esi
  8004202c5c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004202c63:	00 00 00 
  8004202c66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c6b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004202c72:	00 00 00 
  8004202c75:	41 ff d0             	callq  *%r8
  8004202c78:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202c7f:	00 00 00 
  8004202c82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c86:	48 01 d0             	add    %rdx,%rax
  8004202c89:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	pte_t *pte = pdpe_walk(pdpe, va, create);
  8004202c8d:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202c90:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202c94:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202c98:	48 89 ce             	mov    %rcx,%rsi
  8004202c9b:	48 89 c7             	mov    %rax,%rdi
  8004202c9e:	48 b8 e0 2c 20 04 80 	movabs $0x8004202ce0,%rax
  8004202ca5:	00 00 00 
  8004202ca8:	ff d0                	callq  *%rax
  8004202caa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	if (!pte && page) {
  8004202cae:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004202cb3:	75 25                	jne    8004202cda <pml4e_walk+0x16f>
  8004202cb5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202cba:	74 1e                	je     8004202cda <pml4e_walk+0x16f>
		*current_pml4e = 0x0;
  8004202cbc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202cc0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(page);
  8004202cc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ccb:	48 89 c7             	mov    %rax,%rdi
  8004202cce:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004202cd5:	00 00 00 
  8004202cd8:	ff d0                	callq  *%rax
	}

	return pte;
  8004202cda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8004202cde:	c9                   	leaveq 
  8004202cdf:	c3                   	retq   

0000008004202ce0 <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  8004202ce0:	55                   	push   %rbp
  8004202ce1:	48 89 e5             	mov    %rsp,%rbp
  8004202ce4:	48 83 ec 50          	sub    $0x50,%rsp
  8004202ce8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202cec:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202cf0:	89 55 bc             	mov    %edx,-0x44(%rbp)
	pde_t *pde;
		struct PageInfo *page = NULL;
  8004202cf3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202cfa:	00 
		pdpe_t *current_pdpe = &pdpe[PDPE(va)];
  8004202cfb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202cff:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202d03:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202d08:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202d0f:	00 
  8004202d10:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d14:	48 01 d0             	add    %rdx,%rax
  8004202d17:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		if(create && !(*current_pdpe & PTE_P)) {
  8004202d1b:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004202d1f:	74 69                	je     8004202d8a <pdpe_walk+0xaa>
  8004202d21:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202d25:	48 8b 00             	mov    (%rax),%rax
  8004202d28:	83 e0 01             	and    $0x1,%eax
  8004202d2b:	48 85 c0             	test   %rax,%rax
  8004202d2e:	75 5a                	jne    8004202d8a <pdpe_walk+0xaa>
			page = page_alloc(ALLOC_ZERO);
  8004202d30:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202d35:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004202d3c:	00 00 00 
  8004202d3f:	ff d0                	callq  *%rax
  8004202d41:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			if (!page)
  8004202d45:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202d4a:	75 0a                	jne    8004202d56 <pdpe_walk+0x76>
				return NULL;
  8004202d4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d51:	e9 fd 00 00 00       	jmpq   8004202e53 <pdpe_walk+0x173>
			page->pp_ref++;
  8004202d56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d5a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202d5e:	8d 50 01             	lea    0x1(%rax),%edx
  8004202d61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d65:	66 89 50 08          	mov    %dx,0x8(%rax)
			*current_pdpe = (pdpe_t) page2pa(page) | PTE_P | PTE_W | PTE_U;
  8004202d69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d6d:	48 89 c7             	mov    %rax,%rdi
  8004202d70:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004202d77:	00 00 00 
  8004202d7a:	ff d0                	callq  *%rax
  8004202d7c:	48 83 c8 07          	or     $0x7,%rax
  8004202d80:	48 89 c2             	mov    %rax,%rdx
  8004202d83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202d87:	48 89 10             	mov    %rdx,(%rax)
		}

		pde = (pde_t *) KADDR(PTE_ADDR(*current_pdpe));
  8004202d8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202d8e:	48 8b 00             	mov    (%rax),%rax
  8004202d91:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202d97:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202d9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202d9f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202da3:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004202da6:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004202da9:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004202db0:	00 00 00 
  8004202db3:	48 8b 00             	mov    (%rax),%rax
  8004202db6:	48 39 c2             	cmp    %rax,%rdx
  8004202db9:	72 32                	jb     8004202ded <pdpe_walk+0x10d>
  8004202dbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202dbf:	48 89 c1             	mov    %rax,%rcx
  8004202dc2:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004202dc9:	00 00 00 
  8004202dcc:	be 4b 02 00 00       	mov    $0x24b,%esi
  8004202dd1:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004202dd8:	00 00 00 
  8004202ddb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202de0:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004202de7:	00 00 00 
  8004202dea:	41 ff d0             	callq  *%r8
  8004202ded:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202df4:	00 00 00 
  8004202df7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202dfb:	48 01 d0             	add    %rdx,%rax
  8004202dfe:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		pte_t *pte = pgdir_walk(pde, va, create);
  8004202e02:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202e05:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202e09:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202e0d:	48 89 ce             	mov    %rcx,%rsi
  8004202e10:	48 89 c7             	mov    %rax,%rdi
  8004202e13:	48 b8 55 2e 20 04 80 	movabs $0x8004202e55,%rax
  8004202e1a:	00 00 00 
  8004202e1d:	ff d0                	callq  *%rax
  8004202e1f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

		if (!pte && page) {
  8004202e23:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004202e28:	75 25                	jne    8004202e4f <pdpe_walk+0x16f>
  8004202e2a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202e2f:	74 1e                	je     8004202e4f <pdpe_walk+0x16f>
			*current_pdpe = 0x0;
  8004202e31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e35:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(page);
  8004202e3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e40:	48 89 c7             	mov    %rax,%rdi
  8004202e43:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004202e4a:	00 00 00 
  8004202e4d:	ff d0                	callq  *%rax
		}

		return pte;
  8004202e4f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8004202e53:	c9                   	leaveq 
  8004202e54:	c3                   	retq   

0000008004202e55 <pgdir_walk>:
// The logic here is slightly different, in that it needs to look
// not just at the page directory, but also get the last-level page table entry.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004202e55:	55                   	push   %rbp
  8004202e56:	48 89 e5             	mov    %rsp,%rbp
  8004202e59:	48 83 ec 50          	sub    $0x50,%rsp
  8004202e5d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202e61:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202e65:	89 55 bc             	mov    %edx,-0x44(%rbp)
	// Fill this function in
	pde_t *current_pde = &pgdir[PDX(va)];
  8004202e68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202e6c:	48 c1 e8 15          	shr    $0x15,%rax
  8004202e70:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202e75:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202e7c:	00 
  8004202e7d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202e81:	48 01 d0             	add    %rdx,%rax
  8004202e84:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte_t *pte;

	if(create && !(*current_pde & PTE_P)) {
  8004202e88:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004202e8c:	74 69                	je     8004202ef7 <pgdir_walk+0xa2>
  8004202e8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e92:	48 8b 00             	mov    (%rax),%rax
  8004202e95:	83 e0 01             	and    $0x1,%eax
  8004202e98:	48 85 c0             	test   %rax,%rax
  8004202e9b:	75 5a                	jne    8004202ef7 <pgdir_walk+0xa2>
		struct PageInfo *page = page_alloc(ALLOC_ZERO);
  8004202e9d:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202ea2:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004202ea9:	00 00 00 
  8004202eac:	ff d0                	callq  *%rax
  8004202eae:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (!page)
  8004202eb2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202eb7:	75 0a                	jne    8004202ec3 <pgdir_walk+0x6e>
			return NULL;
  8004202eb9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ebe:	e9 d6 00 00 00       	jmpq   8004202f99 <pgdir_walk+0x144>

		page->pp_ref++;
  8004202ec3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202ec7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202ecb:	8d 50 01             	lea    0x1(%rax),%edx
  8004202ece:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202ed2:	66 89 50 08          	mov    %dx,0x8(%rax)
		*current_pde = (pde_t) page2pa(page) | PTE_P | PTE_W | PTE_U;
  8004202ed6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202eda:	48 89 c7             	mov    %rax,%rdi
  8004202edd:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004202ee4:	00 00 00 
  8004202ee7:	ff d0                	callq  *%rax
  8004202ee9:	48 83 c8 07          	or     $0x7,%rax
  8004202eed:	48 89 c2             	mov    %rax,%rdx
  8004202ef0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ef4:	48 89 10             	mov    %rdx,(%rax)
	}

	pte = (pte_t *) KADDR(PTE_ADDR(*current_pde));
  8004202ef7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202efb:	48 8b 00             	mov    (%rax),%rax
  8004202efe:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202f04:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202f08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f0c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202f10:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004202f13:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004202f16:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004202f1d:	00 00 00 
  8004202f20:	48 8b 00             	mov    (%rax),%rax
  8004202f23:	48 39 c2             	cmp    %rax,%rdx
  8004202f26:	72 32                	jb     8004202f5a <pgdir_walk+0x105>
  8004202f28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f2c:	48 89 c1             	mov    %rax,%rcx
  8004202f2f:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004202f36:	00 00 00 
  8004202f39:	be 6e 02 00 00       	mov    $0x26e,%esi
  8004202f3e:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004202f45:	00 00 00 
  8004202f48:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f4d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004202f54:	00 00 00 
  8004202f57:	41 ff d0             	callq  *%r8
  8004202f5a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202f61:	00 00 00 
  8004202f64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f68:	48 01 d0             	add    %rdx,%rax
  8004202f6b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	if(!pte)
  8004202f6f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004202f74:	75 07                	jne    8004202f7d <pgdir_walk+0x128>
		return NULL;
  8004202f76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f7b:	eb 1c                	jmp    8004202f99 <pgdir_walk+0x144>

	return &pte[PTX(va)];
  8004202f7d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202f81:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202f85:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202f8a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202f91:	00 
  8004202f92:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202f96:	48 01 d0             	add    %rdx,%rax
}
  8004202f99:	c9                   	leaveq 
  8004202f9a:	c3                   	retq   

0000008004202f9b <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004202f9b:	55                   	push   %rbp
  8004202f9c:	48 89 e5             	mov    %rsp,%rbp
  8004202f9f:	48 83 ec 40          	sub    $0x40,%rsp
  8004202fa3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004202fa7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004202fab:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004202faf:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004202fb3:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
	// Fill this function in
	pte_t *pte;
	int i;
 	for(i = 0; i < size; i += PGSIZE) {
  8004202fb7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004202fbe:	e9 8a 00 00 00       	jmpq   800420304d <boot_map_region+0xb2>
 		pte = pml4e_walk(pml4e, (void *)la + i, true);
  8004202fc3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202fc6:	48 63 d0             	movslq %eax,%rdx
  8004202fc9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202fcd:	48 01 d0             	add    %rdx,%rax
  8004202fd0:	48 89 c1             	mov    %rax,%rcx
  8004202fd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202fd7:	ba 01 00 00 00       	mov    $0x1,%edx
  8004202fdc:	48 89 ce             	mov    %rcx,%rsi
  8004202fdf:	48 89 c7             	mov    %rax,%rdi
  8004202fe2:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004202fe9:	00 00 00 
  8004202fec:	ff d0                	callq  *%rax
  8004202fee:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
 		if (!pte)
  8004202ff2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202ff7:	75 2a                	jne    8004203023 <boot_map_region+0x88>
 			panic("failed to find the physical memory");
  8004202ff9:	48 ba 48 69 21 04 80 	movabs $0x8004216948,%rdx
  8004203000:	00 00 00 
  8004203003:	be 89 02 00 00       	mov    $0x289,%esi
  8004203008:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420300f:	00 00 00 
  8004203012:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203017:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  800420301e:	00 00 00 
  8004203021:	ff d1                	callq  *%rcx
 		*pte = (pa + i) | perm | PTE_P;
  8004203023:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203026:	48 63 d0             	movslq %eax,%rdx
  8004203029:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420302d:	48 01 c2             	add    %rax,%rdx
  8004203030:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004203033:	48 98                	cltq   
  8004203035:	48 09 d0             	or     %rdx,%rax
  8004203038:	48 83 c8 01          	or     $0x1,%rax
  800420303c:	48 89 c2             	mov    %rax,%rdx
  800420303f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203043:	48 89 10             	mov    %rdx,(%rax)
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t *pte;
	int i;
 	for(i = 0; i < size; i += PGSIZE) {
  8004203046:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  800420304d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203050:	48 98                	cltq   
  8004203052:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203056:	0f 82 67 ff ff ff    	jb     8004202fc3 <boot_map_region+0x28>
 		pte = pml4e_walk(pml4e, (void *)la + i, true);
 		if (!pte)
 			panic("failed to find the physical memory");
 		*pte = (pa + i) | perm | PTE_P;
 	}
}
  800420305c:	c9                   	leaveq 
  800420305d:	c3                   	retq   

000000800420305e <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  800420305e:	55                   	push   %rbp
  800420305f:	48 89 e5             	mov    %rsp,%rbp
  8004203062:	48 83 ec 30          	sub    $0x30,%rsp
  8004203066:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420306a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420306e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004203072:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in
	pte_t *pte = pml4e_walk(pml4e, va, true);
  8004203075:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203079:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420307d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203082:	48 89 ce             	mov    %rcx,%rsi
  8004203085:	48 89 c7             	mov    %rax,%rdi
  8004203088:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800420308f:	00 00 00 
  8004203092:	ff d0                	callq  *%rax
  8004203094:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!pte)
  8004203098:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420309d:	75 07                	jne    80042030a6 <page_insert+0x48>
		return -E_NO_MEM;
  800420309f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042030a4:	eb 6b                	jmp    8004203111 <page_insert+0xb3>

	pp->pp_ref++;
  80042030a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030aa:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042030ae:	8d 50 01             	lea    0x1(%rax),%edx
  80042030b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030b5:	66 89 50 08          	mov    %dx,0x8(%rax)
	if (*pte & PTE_P)
  80042030b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030bd:	48 8b 00             	mov    (%rax),%rax
  80042030c0:	83 e0 01             	and    $0x1,%eax
  80042030c3:	48 85 c0             	test   %rax,%rax
  80042030c6:	74 1a                	je     80042030e2 <page_insert+0x84>
		page_remove(pml4e, va);
  80042030c8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042030cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042030d0:	48 89 d6             	mov    %rdx,%rsi
  80042030d3:	48 89 c7             	mov    %rax,%rdi
  80042030d6:	48 b8 8a 31 20 04 80 	movabs $0x800420318a,%rax
  80042030dd:	00 00 00 
  80042030e0:	ff d0                	callq  *%rax
	*pte = page2pa(pp) | perm | PTE_P;
  80042030e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030e6:	48 89 c7             	mov    %rax,%rdi
  80042030e9:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  80042030f0:	00 00 00 
  80042030f3:	ff d0                	callq  *%rax
  80042030f5:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042030f8:	48 63 d2             	movslq %edx,%rdx
  80042030fb:	48 09 d0             	or     %rdx,%rax
  80042030fe:	48 83 c8 01          	or     $0x1,%rax
  8004203102:	48 89 c2             	mov    %rax,%rdx
  8004203105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203109:	48 89 10             	mov    %rdx,(%rax)

	return 0;
  800420310c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203111:	c9                   	leaveq 
  8004203112:	c3                   	retq   

0000008004203113 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203113:	55                   	push   %rbp
  8004203114:	48 89 e5             	mov    %rsp,%rbp
  8004203117:	48 83 ec 30          	sub    $0x30,%rsp
  800420311b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420311f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203123:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t *pte = pml4e_walk(pml4e, va, true);
  8004203127:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420312b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420312f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203134:	48 89 ce             	mov    %rcx,%rsi
  8004203137:	48 89 c7             	mov    %rax,%rdi
  800420313a:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004203141:	00 00 00 
  8004203144:	ff d0                	callq  *%rax
  8004203146:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!pte)
  800420314a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420314f:	75 07                	jne    8004203158 <page_lookup+0x45>
		return NULL;
  8004203151:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203156:	eb 30                	jmp    8004203188 <page_lookup+0x75>

	physaddr_t pa = (physaddr_t) *pte;
  8004203158:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420315c:	48 8b 00             	mov    (%rax),%rax
  800420315f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	if (pte_store)
  8004203163:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203168:	74 0b                	je     8004203175 <page_lookup+0x62>
		*pte_store = pte;
  800420316a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420316e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203172:	48 89 10             	mov    %rdx,(%rax)

	return pa2page(pa);
  8004203175:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203179:	48 89 c7             	mov    %rax,%rdi
  800420317c:	48 b8 0e 17 20 04 80 	movabs $0x800420170e,%rax
  8004203183:	00 00 00 
  8004203186:	ff d0                	callq  *%rax
}
  8004203188:	c9                   	leaveq 
  8004203189:	c3                   	retq   

000000800420318a <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  800420318a:	55                   	push   %rbp
  800420318b:	48 89 e5             	mov    %rsp,%rbp
  800420318e:	48 83 ec 20          	sub    $0x20,%rsp
  8004203192:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203196:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	pte_t *pte = NULL;
  800420319a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042031a1:	00 
	struct PageInfo *page = page_lookup(pml4e, va, &pte);
  80042031a2:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80042031a6:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80042031aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042031ae:	48 89 ce             	mov    %rcx,%rsi
  80042031b1:	48 89 c7             	mov    %rax,%rdi
  80042031b4:	48 b8 13 31 20 04 80 	movabs $0x8004203113,%rax
  80042031bb:	00 00 00 
  80042031be:	ff d0                	callq  *%rax
  80042031c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (page) {
  80042031c4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042031c9:	74 41                	je     800420320c <page_remove+0x82>
		page_decref(page);
  80042031cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031cf:	48 89 c7             	mov    %rax,%rdi
  80042031d2:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  80042031d9:	00 00 00 
  80042031dc:	ff d0                	callq  *%rax
		if (pte) {
  80042031de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031e2:	48 85 c0             	test   %rax,%rax
  80042031e5:	74 25                	je     800420320c <page_remove+0x82>
			*pte = 0;
  80042031e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031eb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			tlb_invalidate(pml4e, va);
  80042031f2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042031f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042031fa:	48 89 d6             	mov    %rdx,%rsi
  80042031fd:	48 89 c7             	mov    %rax,%rdi
  8004203200:	48 b8 0e 32 20 04 80 	movabs $0x800420320e,%rax
  8004203207:	00 00 00 
  800420320a:	ff d0                	callq  *%rax
		}
	}
}
  800420320c:	c9                   	leaveq 
  800420320d:	c3                   	retq   

000000800420320e <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  800420320e:	55                   	push   %rbp
  800420320f:	48 89 e5             	mov    %rsp,%rbp
  8004203212:	48 83 ec 20          	sub    $0x20,%rsp
  8004203216:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420321a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  800420321e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203223:	75 35                	jne    800420325a <tlb_invalidate+0x4c>
  8004203225:	48 b9 6b 69 21 04 80 	movabs $0x800421696b,%rcx
  800420322c:	00 00 00 
  800420322f:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203236:	00 00 00 
  8004203239:	be f8 02 00 00       	mov    $0x2f8,%esi
  800420323e:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203245:	00 00 00 
  8004203248:	b8 00 00 00 00       	mov    $0x0,%eax
  800420324d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203254:	00 00 00 
  8004203257:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  800420325a:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004203261:	00 00 00 
  8004203264:	ff d0                	callq  *%rax
  8004203266:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420326d:	00 00 00 
  8004203270:	48 98                	cltq   
  8004203272:	48 c1 e0 03          	shl    $0x3,%rax
  8004203276:	48 89 c2             	mov    %rax,%rdx
  8004203279:	48 c1 e2 04          	shl    $0x4,%rdx
  800420327d:	48 29 c2             	sub    %rax,%rdx
  8004203280:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203284:	48 83 c0 08          	add    $0x8,%rax
  8004203288:	48 8b 00             	mov    (%rax),%rax
  800420328b:	48 85 c0             	test   %rax,%rax
  800420328e:	74 3e                	je     80042032ce <tlb_invalidate+0xc0>
  8004203290:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004203297:	00 00 00 
  800420329a:	ff d0                	callq  *%rax
  800420329c:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042032a3:	00 00 00 
  80042032a6:	48 98                	cltq   
  80042032a8:	48 c1 e0 03          	shl    $0x3,%rax
  80042032ac:	48 89 c2             	mov    %rax,%rdx
  80042032af:	48 c1 e2 04          	shl    $0x4,%rdx
  80042032b3:	48 29 c2             	sub    %rax,%rdx
  80042032b6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042032ba:	48 83 c0 08          	add    $0x8,%rax
  80042032be:	48 8b 00             	mov    (%rax),%rax
  80042032c1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042032c8:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042032cc:	75 0f                	jne    80042032dd <tlb_invalidate+0xcf>
  80042032ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042032d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  80042032d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042032da:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  80042032dd:	c9                   	leaveq 
  80042032de:	c3                   	retq   

00000080042032df <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  80042032df:	55                   	push   %rbp
  80042032e0:	48 89 e5             	mov    %rsp,%rbp
  80042032e3:	48 83 ec 30          	sub    $0x30,%rsp
  80042032e7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042032eb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// okay to simply panic if this happens).
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	uint64_t s_size = (size_t)ROUNDUP(pa + size, PGSIZE);
  80042032ef:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042032f6:	00 
  80042032f7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042032fb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042032ff:	48 01 c2             	add    %rax,%rdx
  8004203302:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203306:	48 01 d0             	add    %rdx,%rax
  8004203309:	48 83 e8 01          	sub    $0x1,%rax
  800420330d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203311:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203315:	ba 00 00 00 00       	mov    $0x0,%edx
  800420331a:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420331e:	48 89 d0             	mov    %rdx,%rax
  8004203321:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203325:	48 29 c2             	sub    %rax,%rdx
  8004203328:	48 89 d0             	mov    %rdx,%rax
  800420332b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	pa = (physaddr_t)ROUNDDOWN(pa, PGSIZE);
  800420332f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203333:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203337:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420333b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203341:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	s_size = s_size - pa;
  8004203345:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203349:	48 29 45 e8          	sub    %rax,-0x18(%rbp)
	if(base + s_size >= MMIOLIM)
  800420334d:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  8004203354:	00 00 00 
  8004203357:	48 8b 10             	mov    (%rax),%rdx
  800420335a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420335e:	48 01 c2             	add    %rax,%rdx
  8004203361:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004203368:	00 00 00 
  800420336b:	48 39 c2             	cmp    %rax,%rdx
  800420336e:	76 2a                	jbe    800420339a <mmio_map_region+0xbb>
		panic("cant assign memory to mmio\n");
  8004203370:	48 ba 77 69 21 04 80 	movabs $0x8004216977,%rdx
  8004203377:	00 00 00 
  800420337a:	be 21 03 00 00       	mov    $0x321,%esi
  800420337f:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203386:	00 00 00 
  8004203389:	b8 00 00 00 00       	mov    $0x0,%eax
  800420338e:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  8004203395:	00 00 00 
  8004203398:	ff d1                	callq  *%rcx
	boot_map_region(boot_pml4e, base, s_size, pa, PTE_PCD | PTE_PWT | PTE_W);
  800420339a:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  80042033a1:	00 00 00 
  80042033a4:	48 8b 30             	mov    (%rax),%rsi
  80042033a7:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042033ae:	00 00 00 
  80042033b1:	48 8b 00             	mov    (%rax),%rax
  80042033b4:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042033b8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042033bc:	41 b8 1a 00 00 00    	mov    $0x1a,%r8d
  80042033c2:	48 89 c7             	mov    %rax,%rdi
  80042033c5:	48 b8 9b 2f 20 04 80 	movabs $0x8004202f9b,%rax
  80042033cc:	00 00 00 
  80042033cf:	ff d0                	callq  *%rax
	base += s_size;
  80042033d1:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  80042033d8:	00 00 00 
  80042033db:	48 8b 10             	mov    (%rax),%rdx
  80042033de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042033e2:	48 01 c2             	add    %rax,%rdx
  80042033e5:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  80042033ec:	00 00 00 
  80042033ef:	48 89 10             	mov    %rdx,(%rax)
	return (void *)(base - s_size);
  80042033f2:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  80042033f9:	00 00 00 
  80042033fc:	48 8b 00             	mov    (%rax),%rax
  80042033ff:	48 2b 45 e8          	sub    -0x18(%rbp),%rax
	//panic("mmio_map_region not implemented");
}
  8004203403:	c9                   	leaveq 
  8004203404:	c3                   	retq   

0000008004203405 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203405:	55                   	push   %rbp
  8004203406:	48 89 e5             	mov    %rsp,%rbp
  8004203409:	48 83 ec 50          	sub    $0x50,%rsp
  800420340d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203411:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203415:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004203419:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	uint64_t end = ROUNDUP((uint64_t)va+len,PGSIZE),start = ROUNDDOWN((uint64_t)va, PGSIZE);
  800420341c:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203423:	00 
  8004203424:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004203428:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420342c:	48 01 c2             	add    %rax,%rdx
  800420342f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203433:	48 01 d0             	add    %rdx,%rax
  8004203436:	48 83 e8 01          	sub    $0x1,%rax
  800420343a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420343e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203442:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203447:	48 f7 75 f0          	divq   -0x10(%rbp)
  800420344b:	48 89 d0             	mov    %rdx,%rax
  800420344e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203452:	48 29 c2             	sub    %rax,%rdx
  8004203455:	48 89 d0             	mov    %rdx,%rax
  8004203458:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420345c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203460:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203464:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203468:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420346e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	for (; start < end; start += PGSIZE)
  8004203472:	e9 99 00 00 00       	jmpq   8004203510 <user_mem_check+0x10b>
	{
		pte_t *pte = pml4e_walk(env->env_pml4e, (const void *)start, false);
  8004203477:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420347b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420347f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203486:	ba 00 00 00 00       	mov    $0x0,%edx
  800420348b:	48 89 ce             	mov    %rcx,%rsi
  800420348e:	48 89 c7             	mov    %rax,%rdi
  8004203491:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004203498:	00 00 00 
  800420349b:	ff d0                	callq  *%rax
  800420349d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (start >= ULIM || pte == NULL || ((*pte & perm) != perm) || ((*pte & PTE_P) == 0))
  80042034a1:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042034a8:	00 00 00 
  80042034ab:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042034af:	77 2f                	ja     80042034e0 <user_mem_check+0xdb>
  80042034b1:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042034b6:	74 28                	je     80042034e0 <user_mem_check+0xdb>
  80042034b8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042034bc:	48 8b 10             	mov    (%rax),%rdx
  80042034bf:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042034c2:	48 98                	cltq   
  80042034c4:	48 21 c2             	and    %rax,%rdx
  80042034c7:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042034ca:	48 98                	cltq   
  80042034cc:	48 39 c2             	cmp    %rax,%rdx
  80042034cf:	75 0f                	jne    80042034e0 <user_mem_check+0xdb>
  80042034d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042034d5:	48 8b 00             	mov    (%rax),%rax
  80042034d8:	83 e0 01             	and    $0x1,%eax
  80042034db:	48 85 c0             	test   %rax,%rax
  80042034de:	75 28                	jne    8004203508 <user_mem_check+0x103>
		{
			user_mem_check_addr = start < (uintptr_t)va ? (uintptr_t)va : start;
  80042034e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034e4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042034e8:	76 06                	jbe    80042034f0 <user_mem_check+0xeb>
  80042034ea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034ee:	eb 04                	jmp    80042034f4 <user_mem_check+0xef>
  80042034f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042034f4:	48 ba 40 32 3d 04 80 	movabs $0x80043d3240,%rdx
  80042034fb:	00 00 00 
  80042034fe:	48 89 02             	mov    %rax,(%rdx)
			return -E_FAULT;
  8004203501:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203506:	eb 1b                	jmp    8004203523 <user_mem_check+0x11e>
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
	// LAB 3: Your code here.
	uint64_t end = ROUNDUP((uint64_t)va+len,PGSIZE),start = ROUNDDOWN((uint64_t)va, PGSIZE);

	for (; start < end; start += PGSIZE)
  8004203508:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420350f:	00 
  8004203510:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203514:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203518:	0f 82 59 ff ff ff    	jb     8004203477 <user_mem_check+0x72>
		{
			user_mem_check_addr = start < (uintptr_t)va ? (uintptr_t)va : start;
			return -E_FAULT;
		}
	}
	return 0;
  800420351e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203523:	c9                   	leaveq 
  8004203524:	c3                   	retq   

0000008004203525 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203525:	55                   	push   %rbp
  8004203526:	48 89 e5             	mov    %rsp,%rbp
  8004203529:	48 83 ec 20          	sub    $0x20,%rsp
  800420352d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203531:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203535:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203539:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  800420353c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420353f:	83 c8 04             	or     $0x4,%eax
  8004203542:	89 c1                	mov    %eax,%ecx
  8004203544:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203548:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420354c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203550:	48 89 c7             	mov    %rax,%rdi
  8004203553:	48 b8 05 34 20 04 80 	movabs $0x8004203405,%rax
  800420355a:	00 00 00 
  800420355d:	ff d0                	callq  *%rax
  800420355f:	85 c0                	test   %eax,%eax
  8004203561:	79 47                	jns    80042035aa <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203563:	48 b8 40 32 3d 04 80 	movabs $0x80043d3240,%rax
  800420356a:	00 00 00 
  800420356d:	48 8b 10             	mov    (%rax),%rdx
  8004203570:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203574:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420357a:	89 c6                	mov    %eax,%esi
  800420357c:	48 bf 98 69 21 04 80 	movabs $0x8004216998,%rdi
  8004203583:	00 00 00 
  8004203586:	b8 00 00 00 00       	mov    $0x0,%eax
  800420358b:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  8004203592:	00 00 00 
  8004203595:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004203597:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420359b:	48 89 c7             	mov    %rax,%rdi
  800420359e:	48 b8 af 80 20 04 80 	movabs $0x80042080af,%rax
  80042035a5:	00 00 00 
  80042035a8:	ff d0                	callq  *%rax
	}
}
  80042035aa:	c9                   	leaveq 
  80042035ab:	c3                   	retq   

00000080042035ac <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  80042035ac:	55                   	push   %rbp
  80042035ad:	48 89 e5             	mov    %rsp,%rbp
  80042035b0:	48 83 ec 60          	sub    $0x60,%rsp
  80042035b4:	89 f8                	mov    %edi,%eax
  80042035b6:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  80042035b9:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  80042035bd:	74 07                	je     80042035c6 <check_page_free_list+0x1a>
  80042035bf:	b8 01 00 00 00       	mov    $0x1,%eax
  80042035c4:	eb 05                	jmp    80042035cb <check_page_free_list+0x1f>
  80042035c6:	b8 00 02 00 00       	mov    $0x200,%eax
  80042035cb:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  80042035ce:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042035d5:	00 
  80042035d6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042035dd:	00 
	void *first_free_page;

	if (!page_free_list)
  80042035de:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042035e5:	00 00 00 
  80042035e8:	48 8b 00             	mov    (%rax),%rax
  80042035eb:	48 85 c0             	test   %rax,%rax
  80042035ee:	75 2a                	jne    800420361a <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  80042035f0:	48 ba d0 69 21 04 80 	movabs $0x80042169d0,%rdx
  80042035f7:	00 00 00 
  80042035fa:	be 71 03 00 00       	mov    $0x371,%esi
  80042035ff:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203606:	00 00 00 
  8004203609:	b8 00 00 00 00       	mov    $0x0,%eax
  800420360e:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  8004203615:	00 00 00 
  8004203618:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  800420361a:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  800420361e:	0f 84 a9 00 00 00    	je     80042036cd <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203624:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203628:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  800420362c:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203630:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203634:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  800420363b:	00 00 00 
  800420363e:	48 8b 00             	mov    (%rax),%rax
  8004203641:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203645:	eb 58                	jmp    800420369f <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203647:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420364b:	48 89 c7             	mov    %rax,%rdi
  800420364e:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203655:	00 00 00 
  8004203658:	ff d0                	callq  *%rax
  800420365a:	48 c1 e8 15          	shr    $0x15,%rax
  800420365e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203663:	48 89 c2             	mov    %rax,%rdx
  8004203666:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203669:	48 39 c2             	cmp    %rax,%rdx
  800420366c:	0f 93 c0             	setae  %al
  800420366f:	0f b6 c0             	movzbl %al,%eax
  8004203672:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203675:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203678:	48 98                	cltq   
  800420367a:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  800420367f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203683:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203686:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420368a:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420368d:	48 98                	cltq   
  800420368f:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203694:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203698:	48 8b 00             	mov    (%rax),%rax
  800420369b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420369f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042036a4:	75 a1                	jne    8004203647 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  80042036a6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042036aa:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  80042036b1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042036b5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042036b9:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  80042036bc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042036c0:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042036c7:	00 00 00 
  80042036ca:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  80042036cd:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042036d4:	00 00 00 
  80042036d7:	48 8b 00             	mov    (%rax),%rax
  80042036da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042036de:	eb 5e                	jmp    800420373e <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  80042036e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036e4:	48 89 c7             	mov    %rax,%rdi
  80042036e7:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  80042036ee:	00 00 00 
  80042036f1:	ff d0                	callq  *%rax
  80042036f3:	48 c1 e8 15          	shr    $0x15,%rax
  80042036f7:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036fc:	48 89 c2             	mov    %rax,%rdx
  80042036ff:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203702:	48 39 c2             	cmp    %rax,%rdx
  8004203705:	73 2c                	jae    8004203733 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203707:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420370b:	48 89 c7             	mov    %rax,%rdi
  800420370e:	48 b8 7f 17 20 04 80 	movabs $0x800420177f,%rax
  8004203715:	00 00 00 
  8004203718:	ff d0                	callq  *%rax
  800420371a:	ba 80 00 00 00       	mov    $0x80,%edx
  800420371f:	be 97 00 00 00       	mov    $0x97,%esi
  8004203724:	48 89 c7             	mov    %rax,%rdi
  8004203727:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  800420372e:	00 00 00 
  8004203731:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203733:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203737:	48 8b 00             	mov    (%rax),%rax
  800420373a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420373e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203743:	75 9b                	jne    80042036e0 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = boot_alloc(0);
  8004203745:	bf 00 00 00 00       	mov    $0x0,%edi
  800420374a:	48 b8 a8 20 20 04 80 	movabs $0x80042020a8,%rax
  8004203751:	00 00 00 
  8004203754:	ff d0                	callq  *%rax
  8004203756:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420375a:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004203761:	00 00 00 
  8004203764:	48 8b 00             	mov    (%rax),%rax
  8004203767:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420376b:	e9 20 03 00 00       	jmpq   8004203a90 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203770:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004203777:	00 00 00 
  800420377a:	48 8b 00             	mov    (%rax),%rax
  800420377d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203781:	73 35                	jae    80042037b8 <check_page_free_list+0x20c>
  8004203783:	48 b9 f4 69 21 04 80 	movabs $0x80042169f4,%rcx
  800420378a:	00 00 00 
  800420378d:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203794:	00 00 00 
  8004203797:	be 8b 03 00 00       	mov    $0x38b,%esi
  800420379c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042037a3:	00 00 00 
  80042037a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037ab:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042037b2:	00 00 00 
  80042037b5:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  80042037b8:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  80042037bf:	00 00 00 
  80042037c2:	48 8b 10             	mov    (%rax),%rdx
  80042037c5:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042037cc:	00 00 00 
  80042037cf:	48 8b 00             	mov    (%rax),%rax
  80042037d2:	48 c1 e0 04          	shl    $0x4,%rax
  80042037d6:	48 01 d0             	add    %rdx,%rax
  80042037d9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042037dd:	77 35                	ja     8004203814 <check_page_free_list+0x268>
  80042037df:	48 b9 00 6a 21 04 80 	movabs $0x8004216a00,%rcx
  80042037e6:	00 00 00 
  80042037e9:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042037f0:	00 00 00 
  80042037f3:	be 8c 03 00 00       	mov    $0x38c,%esi
  80042037f8:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042037ff:	00 00 00 
  8004203802:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203807:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420380e:	00 00 00 
  8004203811:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004203814:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203818:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  800420381f:	00 00 00 
  8004203822:	48 8b 00             	mov    (%rax),%rax
  8004203825:	48 29 c2             	sub    %rax,%rdx
  8004203828:	48 89 d0             	mov    %rdx,%rax
  800420382b:	83 e0 0f             	and    $0xf,%eax
  800420382e:	48 85 c0             	test   %rax,%rax
  8004203831:	74 35                	je     8004203868 <check_page_free_list+0x2bc>
  8004203833:	48 b9 18 6a 21 04 80 	movabs $0x8004216a18,%rcx
  800420383a:	00 00 00 
  800420383d:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203844:	00 00 00 
  8004203847:	be 8d 03 00 00       	mov    $0x38d,%esi
  800420384c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203853:	00 00 00 
  8004203856:	b8 00 00 00 00       	mov    $0x0,%eax
  800420385b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203862:	00 00 00 
  8004203865:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  8004203868:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420386c:	48 89 c7             	mov    %rax,%rdi
  800420386f:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203876:	00 00 00 
  8004203879:	ff d0                	callq  *%rax
  800420387b:	48 85 c0             	test   %rax,%rax
  800420387e:	75 35                	jne    80042038b5 <check_page_free_list+0x309>
  8004203880:	48 b9 4a 6a 21 04 80 	movabs $0x8004216a4a,%rcx
  8004203887:	00 00 00 
  800420388a:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203891:	00 00 00 
  8004203894:	be 90 03 00 00       	mov    $0x390,%esi
  8004203899:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042038a0:	00 00 00 
  80042038a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038a8:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042038af:	00 00 00 
  80042038b2:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  80042038b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038b9:	48 89 c7             	mov    %rax,%rdi
  80042038bc:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  80042038c3:	00 00 00 
  80042038c6:	ff d0                	callq  *%rax
  80042038c8:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042038ce:	75 35                	jne    8004203905 <check_page_free_list+0x359>
  80042038d0:	48 b9 5b 6a 21 04 80 	movabs $0x8004216a5b,%rcx
  80042038d7:	00 00 00 
  80042038da:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042038e1:	00 00 00 
  80042038e4:	be 91 03 00 00       	mov    $0x391,%esi
  80042038e9:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042038f0:	00 00 00 
  80042038f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038f8:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042038ff:	00 00 00 
  8004203902:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004203905:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203909:	48 89 c7             	mov    %rax,%rdi
  800420390c:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203913:	00 00 00 
  8004203916:	ff d0                	callq  *%rax
  8004203918:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  800420391e:	75 35                	jne    8004203955 <check_page_free_list+0x3a9>
  8004203920:	48 b9 78 6a 21 04 80 	movabs $0x8004216a78,%rcx
  8004203927:	00 00 00 
  800420392a:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203931:	00 00 00 
  8004203934:	be 92 03 00 00       	mov    $0x392,%esi
  8004203939:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203940:	00 00 00 
  8004203943:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203948:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420394f:	00 00 00 
  8004203952:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004203955:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203959:	48 89 c7             	mov    %rax,%rdi
  800420395c:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203963:	00 00 00 
  8004203966:	ff d0                	callq  *%rax
  8004203968:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  800420396e:	75 35                	jne    80042039a5 <check_page_free_list+0x3f9>
  8004203970:	48 b9 9b 6a 21 04 80 	movabs $0x8004216a9b,%rcx
  8004203977:	00 00 00 
  800420397a:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203981:	00 00 00 
  8004203984:	be 93 03 00 00       	mov    $0x393,%esi
  8004203989:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203990:	00 00 00 
  8004203993:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203998:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420399f:	00 00 00 
  80042039a2:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || page2kva(pp) >= first_free_page);
  80042039a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039a9:	48 89 c7             	mov    %rax,%rdi
  80042039ac:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  80042039b3:	00 00 00 
  80042039b6:	ff d0                	callq  *%rax
  80042039b8:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042039be:	76 4e                	jbe    8004203a0e <check_page_free_list+0x462>
  80042039c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039c4:	48 89 c7             	mov    %rax,%rdi
  80042039c7:	48 b8 7f 17 20 04 80 	movabs $0x800420177f,%rax
  80042039ce:	00 00 00 
  80042039d1:	ff d0                	callq  *%rax
  80042039d3:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042039d7:	73 35                	jae    8004203a0e <check_page_free_list+0x462>
  80042039d9:	48 b9 b8 6a 21 04 80 	movabs $0x8004216ab8,%rcx
  80042039e0:	00 00 00 
  80042039e3:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042039ea:	00 00 00 
  80042039ed:	be 94 03 00 00       	mov    $0x394,%esi
  80042039f2:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042039f9:	00 00 00 
  80042039fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a01:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203a08:	00 00 00 
  8004203a0b:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004203a0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a12:	48 89 c7             	mov    %rax,%rdi
  8004203a15:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203a1c:	00 00 00 
  8004203a1f:	ff d0                	callq  *%rax
  8004203a21:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004203a27:	75 35                	jne    8004203a5e <check_page_free_list+0x4b2>
  8004203a29:	48 b9 f4 6a 21 04 80 	movabs $0x8004216af4,%rcx
  8004203a30:	00 00 00 
  8004203a33:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203a3a:	00 00 00 
  8004203a3d:	be 96 03 00 00       	mov    $0x396,%esi
  8004203a42:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203a49:	00 00 00 
  8004203a4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a51:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203a58:	00 00 00 
  8004203a5b:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004203a5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a62:	48 89 c7             	mov    %rax,%rdi
  8004203a65:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203a6c:	00 00 00 
  8004203a6f:	ff d0                	callq  *%rax
  8004203a71:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203a77:	77 07                	ja     8004203a80 <check_page_free_list+0x4d4>
			++nfree_basemem;
  8004203a79:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004203a7e:	eb 05                	jmp    8004203a85 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  8004203a80:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203a85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a89:	48 8b 00             	mov    (%rax),%rax
  8004203a8c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203a90:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203a95:	0f 85 d5 fc ff ff    	jne    8004203770 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  8004203a9b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203aa0:	75 35                	jne    8004203ad7 <check_page_free_list+0x52b>
  8004203aa2:	48 b9 11 6b 21 04 80 	movabs $0x8004216b11,%rcx
  8004203aa9:	00 00 00 
  8004203aac:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203ab3:	00 00 00 
  8004203ab6:	be 9e 03 00 00       	mov    $0x39e,%esi
  8004203abb:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203ac2:	00 00 00 
  8004203ac5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203aca:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203ad1:	00 00 00 
  8004203ad4:	41 ff d0             	callq  *%r8
}
  8004203ad7:	c9                   	leaveq 
  8004203ad8:	c3                   	retq   

0000008004203ad9 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  8004203ad9:	55                   	push   %rbp
  8004203ada:	48 89 e5             	mov    %rsp,%rbp
  8004203add:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203ae1:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004203ae8:	00 00 00 
  8004203aeb:	48 8b 00             	mov    (%rax),%rax
  8004203aee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203af2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203af9:	eb 37                	jmp    8004203b32 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004203afb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203aff:	48 89 c7             	mov    %rax,%rdi
  8004203b02:	48 b8 7f 17 20 04 80 	movabs $0x800420177f,%rax
  8004203b09:	00 00 00 
  8004203b0c:	ff d0                	callq  *%rax
  8004203b0e:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004203b13:	be 97 00 00 00       	mov    $0x97,%esi
  8004203b18:	48 89 c7             	mov    %rax,%rdi
  8004203b1b:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004203b22:	00 00 00 
  8004203b25:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203b27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b2b:	48 8b 00             	mov    (%rax),%rax
  8004203b2e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203b32:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203b37:	75 c2                	jne    8004203afb <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203b39:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004203b40:	00 00 00 
  8004203b43:	48 8b 00             	mov    (%rax),%rax
  8004203b46:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203b4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203b51:	e9 ec 01 00 00       	jmpq   8004203d42 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004203b56:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004203b5d:	00 00 00 
  8004203b60:	48 8b 00             	mov    (%rax),%rax
  8004203b63:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203b67:	73 35                	jae    8004203b9e <check_page_alloc+0xc5>
  8004203b69:	48 b9 22 6b 21 04 80 	movabs $0x8004216b22,%rcx
  8004203b70:	00 00 00 
  8004203b73:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203b7a:	00 00 00 
  8004203b7d:	be b8 03 00 00       	mov    $0x3b8,%esi
  8004203b82:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203b89:	00 00 00 
  8004203b8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b91:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203b98:	00 00 00 
  8004203b9b:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004203b9e:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004203ba5:	00 00 00 
  8004203ba8:	48 8b 10             	mov    (%rax),%rdx
  8004203bab:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004203bb2:	00 00 00 
  8004203bb5:	48 8b 00             	mov    (%rax),%rax
  8004203bb8:	48 c1 e0 04          	shl    $0x4,%rax
  8004203bbc:	48 01 d0             	add    %rdx,%rax
  8004203bbf:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203bc3:	77 35                	ja     8004203bfa <check_page_alloc+0x121>
  8004203bc5:	48 b9 2f 6b 21 04 80 	movabs $0x8004216b2f,%rcx
  8004203bcc:	00 00 00 
  8004203bcf:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203bd6:	00 00 00 
  8004203bd9:	be b9 03 00 00       	mov    $0x3b9,%esi
  8004203bde:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203be5:	00 00 00 
  8004203be8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203bed:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203bf4:	00 00 00 
  8004203bf7:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004203bfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203bfe:	48 89 c7             	mov    %rax,%rdi
  8004203c01:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203c08:	00 00 00 
  8004203c0b:	ff d0                	callq  *%rax
  8004203c0d:	48 85 c0             	test   %rax,%rax
  8004203c10:	75 35                	jne    8004203c47 <check_page_alloc+0x16e>
  8004203c12:	48 b9 44 6b 21 04 80 	movabs $0x8004216b44,%rcx
  8004203c19:	00 00 00 
  8004203c1c:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203c23:	00 00 00 
  8004203c26:	be bc 03 00 00       	mov    $0x3bc,%esi
  8004203c2b:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203c32:	00 00 00 
  8004203c35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c3a:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203c41:	00 00 00 
  8004203c44:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004203c47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c4b:	48 89 c7             	mov    %rax,%rdi
  8004203c4e:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203c55:	00 00 00 
  8004203c58:	ff d0                	callq  *%rax
  8004203c5a:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203c60:	75 35                	jne    8004203c97 <check_page_alloc+0x1be>
  8004203c62:	48 b9 56 6b 21 04 80 	movabs $0x8004216b56,%rcx
  8004203c69:	00 00 00 
  8004203c6c:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203c73:	00 00 00 
  8004203c76:	be bd 03 00 00       	mov    $0x3bd,%esi
  8004203c7b:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203c82:	00 00 00 
  8004203c85:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c8a:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203c91:	00 00 00 
  8004203c94:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  8004203c97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c9b:	48 89 c7             	mov    %rax,%rdi
  8004203c9e:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203ca5:	00 00 00 
  8004203ca8:	ff d0                	callq  *%rax
  8004203caa:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203cb0:	75 35                	jne    8004203ce7 <check_page_alloc+0x20e>
  8004203cb2:	48 b9 70 6b 21 04 80 	movabs $0x8004216b70,%rcx
  8004203cb9:	00 00 00 
  8004203cbc:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203cc3:	00 00 00 
  8004203cc6:	be be 03 00 00       	mov    $0x3be,%esi
  8004203ccb:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203cd2:	00 00 00 
  8004203cd5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203cda:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203ce1:	00 00 00 
  8004203ce4:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004203ce7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ceb:	48 89 c7             	mov    %rax,%rdi
  8004203cee:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203cf5:	00 00 00 
  8004203cf8:	ff d0                	callq  *%rax
  8004203cfa:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004203d00:	75 35                	jne    8004203d37 <check_page_alloc+0x25e>
  8004203d02:	48 b9 94 6b 21 04 80 	movabs $0x8004216b94,%rcx
  8004203d09:	00 00 00 
  8004203d0c:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203d13:	00 00 00 
  8004203d16:	be bf 03 00 00       	mov    $0x3bf,%esi
  8004203d1b:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203d22:	00 00 00 
  8004203d25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d2a:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203d31:	00 00 00 
  8004203d34:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203d37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d3b:	48 8b 00             	mov    (%rax),%rax
  8004203d3e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203d42:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203d47:	0f 85 09 fe ff ff    	jne    8004203b56 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004203d4d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203d54:	00 
  8004203d55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203d59:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203d5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203d61:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004203d65:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203d6a:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004203d71:	00 00 00 
  8004203d74:	ff d0                	callq  *%rax
  8004203d76:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203d7a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203d7f:	75 35                	jne    8004203db6 <check_page_alloc+0x2dd>
  8004203d81:	48 b9 af 6b 21 04 80 	movabs $0x8004216baf,%rcx
  8004203d88:	00 00 00 
  8004203d8b:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203d92:	00 00 00 
  8004203d95:	be c3 03 00 00       	mov    $0x3c3,%esi
  8004203d9a:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203da1:	00 00 00 
  8004203da4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203da9:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203db0:	00 00 00 
  8004203db3:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004203db6:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203dbb:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004203dc2:	00 00 00 
  8004203dc5:	ff d0                	callq  *%rax
  8004203dc7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203dcb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203dd0:	75 35                	jne    8004203e07 <check_page_alloc+0x32e>
  8004203dd2:	48 b9 c5 6b 21 04 80 	movabs $0x8004216bc5,%rcx
  8004203dd9:	00 00 00 
  8004203ddc:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203de3:	00 00 00 
  8004203de6:	be c4 03 00 00       	mov    $0x3c4,%esi
  8004203deb:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203df2:	00 00 00 
  8004203df5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203dfa:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203e01:	00 00 00 
  8004203e04:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004203e07:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203e0c:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004203e13:	00 00 00 
  8004203e16:	ff d0                	callq  *%rax
  8004203e18:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203e1c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203e21:	75 35                	jne    8004203e58 <check_page_alloc+0x37f>
  8004203e23:	48 b9 db 6b 21 04 80 	movabs $0x8004216bdb,%rcx
  8004203e2a:	00 00 00 
  8004203e2d:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203e34:	00 00 00 
  8004203e37:	be c5 03 00 00       	mov    $0x3c5,%esi
  8004203e3c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203e43:	00 00 00 
  8004203e46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e4b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203e52:	00 00 00 
  8004203e55:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004203e58:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203e5d:	75 35                	jne    8004203e94 <check_page_alloc+0x3bb>
  8004203e5f:	48 b9 f1 6b 21 04 80 	movabs $0x8004216bf1,%rcx
  8004203e66:	00 00 00 
  8004203e69:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203e70:	00 00 00 
  8004203e73:	be c6 03 00 00       	mov    $0x3c6,%esi
  8004203e78:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203e7f:	00 00 00 
  8004203e82:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e87:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203e8e:	00 00 00 
  8004203e91:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004203e94:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203e99:	74 0a                	je     8004203ea5 <check_page_alloc+0x3cc>
  8004203e9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203e9f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203ea3:	75 35                	jne    8004203eda <check_page_alloc+0x401>
  8004203ea5:	48 b9 f5 6b 21 04 80 	movabs $0x8004216bf5,%rcx
  8004203eac:	00 00 00 
  8004203eaf:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203eb6:	00 00 00 
  8004203eb9:	be c7 03 00 00       	mov    $0x3c7,%esi
  8004203ebe:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203ec5:	00 00 00 
  8004203ec8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ecd:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203ed4:	00 00 00 
  8004203ed7:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004203eda:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203edf:	74 14                	je     8004203ef5 <check_page_alloc+0x41c>
  8004203ee1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203ee5:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203ee9:	74 0a                	je     8004203ef5 <check_page_alloc+0x41c>
  8004203eeb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203eef:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203ef3:	75 35                	jne    8004203f2a <check_page_alloc+0x451>
  8004203ef5:	48 b9 08 6c 21 04 80 	movabs $0x8004216c08,%rcx
  8004203efc:	00 00 00 
  8004203eff:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203f06:	00 00 00 
  8004203f09:	be c8 03 00 00       	mov    $0x3c8,%esi
  8004203f0e:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203f15:	00 00 00 
  8004203f18:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f1d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203f24:	00 00 00 
  8004203f27:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004203f2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f2e:	48 89 c7             	mov    %rax,%rdi
  8004203f31:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203f38:	00 00 00 
  8004203f3b:	ff d0                	callq  *%rax
  8004203f3d:	48 ba 30 47 3d 04 80 	movabs $0x80043d4730,%rdx
  8004203f44:	00 00 00 
  8004203f47:	48 8b 12             	mov    (%rdx),%rdx
  8004203f4a:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004203f4e:	48 39 d0             	cmp    %rdx,%rax
  8004203f51:	72 35                	jb     8004203f88 <check_page_alloc+0x4af>
  8004203f53:	48 b9 28 6c 21 04 80 	movabs $0x8004216c28,%rcx
  8004203f5a:	00 00 00 
  8004203f5d:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203f64:	00 00 00 
  8004203f67:	be c9 03 00 00       	mov    $0x3c9,%esi
  8004203f6c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203f73:	00 00 00 
  8004203f76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f7b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203f82:	00 00 00 
  8004203f85:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004203f88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203f8c:	48 89 c7             	mov    %rax,%rdi
  8004203f8f:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203f96:	00 00 00 
  8004203f99:	ff d0                	callq  *%rax
  8004203f9b:	48 ba 30 47 3d 04 80 	movabs $0x80043d4730,%rdx
  8004203fa2:	00 00 00 
  8004203fa5:	48 8b 12             	mov    (%rdx),%rdx
  8004203fa8:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004203fac:	48 39 d0             	cmp    %rdx,%rax
  8004203faf:	72 35                	jb     8004203fe6 <check_page_alloc+0x50d>
  8004203fb1:	48 b9 45 6c 21 04 80 	movabs $0x8004216c45,%rcx
  8004203fb8:	00 00 00 
  8004203fbb:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004203fc2:	00 00 00 
  8004203fc5:	be ca 03 00 00       	mov    $0x3ca,%esi
  8004203fca:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004203fd1:	00 00 00 
  8004203fd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fd9:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004203fe0:	00 00 00 
  8004203fe3:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004203fe6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203fea:	48 89 c7             	mov    %rax,%rdi
  8004203fed:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004203ff4:	00 00 00 
  8004203ff7:	ff d0                	callq  *%rax
  8004203ff9:	48 ba 30 47 3d 04 80 	movabs $0x80043d4730,%rdx
  8004204000:	00 00 00 
  8004204003:	48 8b 12             	mov    (%rdx),%rdx
  8004204006:	48 c1 e2 0c          	shl    $0xc,%rdx
  800420400a:	48 39 d0             	cmp    %rdx,%rax
  800420400d:	72 35                	jb     8004204044 <check_page_alloc+0x56b>
  800420400f:	48 b9 62 6c 21 04 80 	movabs $0x8004216c62,%rcx
  8004204016:	00 00 00 
  8004204019:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204020:	00 00 00 
  8004204023:	be cb 03 00 00       	mov    $0x3cb,%esi
  8004204028:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420402f:	00 00 00 
  8004204032:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204037:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420403e:	00 00 00 
  8004204041:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204044:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  800420404b:	00 00 00 
  800420404e:	48 8b 00             	mov    (%rax),%rax
  8004204051:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204055:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  800420405c:	00 00 00 
  800420405f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204066:	bf 00 00 00 00       	mov    $0x0,%edi
  800420406b:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004204072:	00 00 00 
  8004204075:	ff d0                	callq  *%rax
  8004204077:	48 85 c0             	test   %rax,%rax
  800420407a:	74 35                	je     80042040b1 <check_page_alloc+0x5d8>
  800420407c:	48 b9 7f 6c 21 04 80 	movabs $0x8004216c7f,%rcx
  8004204083:	00 00 00 
  8004204086:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420408d:	00 00 00 
  8004204090:	be d2 03 00 00       	mov    $0x3d2,%esi
  8004204095:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420409c:	00 00 00 
  800420409f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040a4:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042040ab:	00 00 00 
  80042040ae:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  80042040b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040b5:	48 89 c7             	mov    %rax,%rdi
  80042040b8:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  80042040bf:	00 00 00 
  80042040c2:	ff d0                	callq  *%rax
	page_free(pp1);
  80042040c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042040c8:	48 89 c7             	mov    %rax,%rdi
  80042040cb:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  80042040d2:	00 00 00 
  80042040d5:	ff d0                	callq  *%rax
	page_free(pp2);
  80042040d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042040db:	48 89 c7             	mov    %rax,%rdi
  80042040de:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  80042040e5:	00 00 00 
  80042040e8:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  80042040ea:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042040f1:	00 
  80042040f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042040f6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042040fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042040fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204102:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204107:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  800420410e:	00 00 00 
  8004204111:	ff d0                	callq  *%rax
  8004204113:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204117:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420411c:	75 35                	jne    8004204153 <check_page_alloc+0x67a>
  800420411e:	48 b9 af 6b 21 04 80 	movabs $0x8004216baf,%rcx
  8004204125:	00 00 00 
  8004204128:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420412f:	00 00 00 
  8004204132:	be d9 03 00 00       	mov    $0x3d9,%esi
  8004204137:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420413e:	00 00 00 
  8004204141:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204146:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420414d:	00 00 00 
  8004204150:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204153:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204158:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  800420415f:	00 00 00 
  8004204162:	ff d0                	callq  *%rax
  8004204164:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204168:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420416d:	75 35                	jne    80042041a4 <check_page_alloc+0x6cb>
  800420416f:	48 b9 c5 6b 21 04 80 	movabs $0x8004216bc5,%rcx
  8004204176:	00 00 00 
  8004204179:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204180:	00 00 00 
  8004204183:	be da 03 00 00       	mov    $0x3da,%esi
  8004204188:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420418f:	00 00 00 
  8004204192:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204197:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420419e:	00 00 00 
  80042041a1:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042041a4:	bf 00 00 00 00       	mov    $0x0,%edi
  80042041a9:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  80042041b0:	00 00 00 
  80042041b3:	ff d0                	callq  *%rax
  80042041b5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042041b9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042041be:	75 35                	jne    80042041f5 <check_page_alloc+0x71c>
  80042041c0:	48 b9 db 6b 21 04 80 	movabs $0x8004216bdb,%rcx
  80042041c7:	00 00 00 
  80042041ca:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042041d1:	00 00 00 
  80042041d4:	be db 03 00 00       	mov    $0x3db,%esi
  80042041d9:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042041e0:	00 00 00 
  80042041e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041e8:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042041ef:	00 00 00 
  80042041f2:	41 ff d0             	callq  *%r8
	assert(pp0);
  80042041f5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042041fa:	75 35                	jne    8004204231 <check_page_alloc+0x758>
  80042041fc:	48 b9 f1 6b 21 04 80 	movabs $0x8004216bf1,%rcx
  8004204203:	00 00 00 
  8004204206:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420420d:	00 00 00 
  8004204210:	be dc 03 00 00       	mov    $0x3dc,%esi
  8004204215:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420421c:	00 00 00 
  800420421f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204224:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420422b:	00 00 00 
  800420422e:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204231:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204236:	74 0a                	je     8004204242 <check_page_alloc+0x769>
  8004204238:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420423c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204240:	75 35                	jne    8004204277 <check_page_alloc+0x79e>
  8004204242:	48 b9 f5 6b 21 04 80 	movabs $0x8004216bf5,%rcx
  8004204249:	00 00 00 
  800420424c:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204253:	00 00 00 
  8004204256:	be dd 03 00 00       	mov    $0x3dd,%esi
  800420425b:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204262:	00 00 00 
  8004204265:	b8 00 00 00 00       	mov    $0x0,%eax
  800420426a:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204271:	00 00 00 
  8004204274:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204277:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420427c:	74 14                	je     8004204292 <check_page_alloc+0x7b9>
  800420427e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204282:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204286:	74 0a                	je     8004204292 <check_page_alloc+0x7b9>
  8004204288:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420428c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204290:	75 35                	jne    80042042c7 <check_page_alloc+0x7ee>
  8004204292:	48 b9 08 6c 21 04 80 	movabs $0x8004216c08,%rcx
  8004204299:	00 00 00 
  800420429c:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042042a3:	00 00 00 
  80042042a6:	be de 03 00 00       	mov    $0x3de,%esi
  80042042ab:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042042b2:	00 00 00 
  80042042b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042ba:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042042c1:	00 00 00 
  80042042c4:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  80042042c7:	bf 00 00 00 00       	mov    $0x0,%edi
  80042042cc:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  80042042d3:	00 00 00 
  80042042d6:	ff d0                	callq  *%rax
  80042042d8:	48 85 c0             	test   %rax,%rax
  80042042db:	74 35                	je     8004204312 <check_page_alloc+0x839>
  80042042dd:	48 b9 7f 6c 21 04 80 	movabs $0x8004216c7f,%rcx
  80042042e4:	00 00 00 
  80042042e7:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042042ee:	00 00 00 
  80042042f1:	be df 03 00 00       	mov    $0x3df,%esi
  80042042f6:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042042fd:	00 00 00 
  8004204300:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204305:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420430c:	00 00 00 
  800420430f:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204316:	48 89 c7             	mov    %rax,%rdi
  8004204319:	48 b8 7f 17 20 04 80 	movabs $0x800420177f,%rax
  8004204320:	00 00 00 
  8004204323:	ff d0                	callq  *%rax
  8004204325:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420432a:	be 01 00 00 00       	mov    $0x1,%esi
  800420432f:	48 89 c7             	mov    %rax,%rdi
  8004204332:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004204339:	00 00 00 
  800420433c:	ff d0                	callq  *%rax
	page_free(pp0);
  800420433e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204342:	48 89 c7             	mov    %rax,%rdi
  8004204345:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  800420434c:	00 00 00 
  800420434f:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204351:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204356:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  800420435d:	00 00 00 
  8004204360:	ff d0                	callq  *%rax
  8004204362:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204366:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420436b:	75 35                	jne    80042043a2 <check_page_alloc+0x8c9>
  800420436d:	48 b9 8e 6c 21 04 80 	movabs $0x8004216c8e,%rcx
  8004204374:	00 00 00 
  8004204377:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420437e:	00 00 00 
  8004204381:	be e4 03 00 00       	mov    $0x3e4,%esi
  8004204386:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420438d:	00 00 00 
  8004204390:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204395:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420439c:	00 00 00 
  800420439f:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  80042043a2:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042043a7:	74 0a                	je     80042043b3 <check_page_alloc+0x8da>
  80042043a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043ad:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042043b1:	74 35                	je     80042043e8 <check_page_alloc+0x90f>
  80042043b3:	48 b9 ac 6c 21 04 80 	movabs $0x8004216cac,%rcx
  80042043ba:	00 00 00 
  80042043bd:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042043c4:	00 00 00 
  80042043c7:	be e5 03 00 00       	mov    $0x3e5,%esi
  80042043cc:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042043d3:	00 00 00 
  80042043d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043db:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042043e2:	00 00 00 
  80042043e5:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  80042043e8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042043ec:	48 89 c7             	mov    %rax,%rdi
  80042043ef:	48 b8 7f 17 20 04 80 	movabs $0x800420177f,%rax
  80042043f6:	00 00 00 
  80042043f9:	ff d0                	callq  *%rax
  80042043fb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  80042043ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204406:	eb 4d                	jmp    8004204455 <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204408:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420440b:	48 63 d0             	movslq %eax,%rdx
  800420440e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204412:	48 01 d0             	add    %rdx,%rax
  8004204415:	0f b6 00             	movzbl (%rax),%eax
  8004204418:	84 c0                	test   %al,%al
  800420441a:	74 35                	je     8004204451 <check_page_alloc+0x978>
  800420441c:	48 b9 bc 6c 21 04 80 	movabs $0x8004216cbc,%rcx
  8004204423:	00 00 00 
  8004204426:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420442d:	00 00 00 
  8004204430:	be e8 03 00 00       	mov    $0x3e8,%esi
  8004204435:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420443c:	00 00 00 
  800420443f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204444:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420444b:	00 00 00 
  800420444e:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204451:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004204455:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  800420445c:	7e aa                	jle    8004204408 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  800420445e:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  8004204465:	00 00 00 
  8004204468:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420446c:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  800420446f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204473:	48 89 c7             	mov    %rax,%rdi
  8004204476:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  800420447d:	00 00 00 
  8004204480:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204482:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204486:	48 89 c7             	mov    %rax,%rdi
  8004204489:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  8004204490:	00 00 00 
  8004204493:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204495:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204499:	48 89 c7             	mov    %rax,%rdi
  800420449c:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  80042044a3:	00 00 00 
  80042044a6:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  80042044a8:	48 bf c8 6c 21 04 80 	movabs $0x8004216cc8,%rdi
  80042044af:	00 00 00 
  80042044b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044b7:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042044be:	00 00 00 
  80042044c1:	ff d2                	callq  *%rdx
}
  80042044c3:	c9                   	leaveq 
  80042044c4:	c3                   	retq   

00000080042044c5 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  80042044c5:	55                   	push   %rbp
  80042044c6:	48 89 e5             	mov    %rsp,%rbp
  80042044c9:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  80042044d0:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  80042044d7:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042044de:	00 00 00 
  80042044e1:	48 8b 00             	mov    (%rax),%rax
  80042044e4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  80042044e8:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  80042044ef:	00 
  80042044f0:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042044f7:	00 00 00 
  80042044fa:	48 8b 00             	mov    (%rax),%rax
  80042044fd:	48 c1 e0 04          	shl    $0x4,%rax
  8004204501:	48 89 c2             	mov    %rax,%rdx
  8004204504:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204508:	48 01 d0             	add    %rdx,%rax
  800420450b:	48 83 e8 01          	sub    $0x1,%rax
  800420450f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204513:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204517:	ba 00 00 00 00       	mov    $0x0,%edx
  800420451c:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004204520:	48 89 d0             	mov    %rdx,%rax
  8004204523:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204527:	48 29 c2             	sub    %rax,%rdx
  800420452a:	48 89 d0             	mov    %rdx,%rax
  800420452d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204531:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204538:	00 
  8004204539:	e9 d4 00 00 00       	jmpq   8004204612 <check_boot_pml4e+0x14d>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  800420453e:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  8004204545:	00 00 00 
  8004204548:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420454c:	48 01 c2             	add    %rax,%rdx
  800420454f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204553:	48 89 d6             	mov    %rdx,%rsi
  8004204556:	48 89 c7             	mov    %rax,%rdi
  8004204559:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004204560:	00 00 00 
  8004204563:	ff d0                	callq  *%rax
  8004204565:	48 ba 38 47 3d 04 80 	movabs $0x80043d4738,%rdx
  800420456c:	00 00 00 
  800420456f:	48 8b 12             	mov    (%rdx),%rdx
  8004204572:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004204576:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  800420457d:	00 00 00 
  8004204580:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004204584:	77 32                	ja     80042045b8 <check_boot_pml4e+0xf3>
  8004204586:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420458a:	48 89 c1             	mov    %rax,%rcx
  800420458d:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  8004204594:	00 00 00 
  8004204597:	be 08 04 00 00       	mov    $0x408,%esi
  800420459c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042045a3:	00 00 00 
  80042045a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045ab:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042045b2:	00 00 00 
  80042045b5:	41 ff d0             	callq  *%r8
  80042045b8:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042045bf:	ff ff ff 
  80042045c2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042045c6:	48 01 d1             	add    %rdx,%rcx
  80042045c9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042045cd:	48 01 ca             	add    %rcx,%rdx
  80042045d0:	48 39 d0             	cmp    %rdx,%rax
  80042045d3:	74 35                	je     800420460a <check_boot_pml4e+0x145>
  80042045d5:	48 b9 e8 6c 21 04 80 	movabs $0x8004216ce8,%rcx
  80042045dc:	00 00 00 
  80042045df:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042045e6:	00 00 00 
  80042045e9:	be 08 04 00 00       	mov    $0x408,%esi
  80042045ee:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042045f5:	00 00 00 
  80042045f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045fd:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204604:	00 00 00 
  8004204607:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  800420460a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204611:	00 
  8004204612:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204616:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420461a:	0f 82 1e ff ff ff    	jb     800420453e <check_boot_pml4e+0x79>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204620:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  8004204627:	00 
  8004204628:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420462c:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  8004204632:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204636:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420463a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420463f:	48 f7 75 c8          	divq   -0x38(%rbp)
  8004204643:	48 89 d0             	mov    %rdx,%rax
  8004204646:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420464a:	48 29 c2             	sub    %rax,%rdx
  800420464d:	48 89 d0             	mov    %rdx,%rax
  8004204650:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204654:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420465b:	00 
  800420465c:	e9 d4 00 00 00       	jmpq   8004204735 <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204661:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004204668:	00 00 00 
  800420466b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420466f:	48 01 c2             	add    %rax,%rdx
  8004204672:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204676:	48 89 d6             	mov    %rdx,%rsi
  8004204679:	48 89 c7             	mov    %rax,%rdi
  800420467c:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004204683:	00 00 00 
  8004204686:	ff d0                	callq  *%rax
  8004204688:	48 ba 50 32 3d 04 80 	movabs $0x80043d3250,%rdx
  800420468f:	00 00 00 
  8004204692:	48 8b 12             	mov    (%rdx),%rdx
  8004204695:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004204699:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042046a0:	00 00 00 
  80042046a3:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  80042046a7:	77 32                	ja     80042046db <check_boot_pml4e+0x216>
  80042046a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042046ad:	48 89 c1             	mov    %rax,%rcx
  80042046b0:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  80042046b7:	00 00 00 
  80042046ba:	be 0e 04 00 00       	mov    $0x40e,%esi
  80042046bf:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042046c6:	00 00 00 
  80042046c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046ce:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042046d5:	00 00 00 
  80042046d8:	41 ff d0             	callq  *%r8
  80042046db:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042046e2:	ff ff ff 
  80042046e5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042046e9:	48 01 d1             	add    %rdx,%rcx
  80042046ec:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042046f0:	48 01 ca             	add    %rcx,%rdx
  80042046f3:	48 39 d0             	cmp    %rdx,%rax
  80042046f6:	74 35                	je     800420472d <check_boot_pml4e+0x268>
  80042046f8:	48 b9 20 6d 21 04 80 	movabs $0x8004216d20,%rcx
  80042046ff:	00 00 00 
  8004204702:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204709:	00 00 00 
  800420470c:	be 0e 04 00 00       	mov    $0x40e,%esi
  8004204711:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204718:	00 00 00 
  800420471b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204720:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204727:	00 00 00 
  800420472a:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  800420472d:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204734:	00 
  8004204735:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204739:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420473d:	0f 82 1e ff ff ff    	jb     8004204661 <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204743:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420474a:	00 
  800420474b:	eb 6a                	jmp    80042047b7 <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  800420474d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204754:	00 00 00 
  8004204757:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420475b:	48 01 c2             	add    %rax,%rdx
  800420475e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204762:	48 89 d6             	mov    %rdx,%rsi
  8004204765:	48 89 c7             	mov    %rax,%rdi
  8004204768:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  800420476f:	00 00 00 
  8004204772:	ff d0                	callq  *%rax
  8004204774:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204778:	74 35                	je     80042047af <check_boot_pml4e+0x2ea>
  800420477a:	48 b9 58 6d 21 04 80 	movabs $0x8004216d58,%rcx
  8004204781:	00 00 00 
  8004204784:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420478b:	00 00 00 
  800420478e:	be 12 04 00 00       	mov    $0x412,%esi
  8004204793:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420479a:	00 00 00 
  800420479d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047a2:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042047a9:	00 00 00 
  80042047ac:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042047af:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042047b6:	00 
  80042047b7:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042047be:	00 00 00 
  80042047c1:	48 8b 00             	mov    (%rax),%rax
  80042047c4:	48 c1 e0 0c          	shl    $0xc,%rax
  80042047c8:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042047cc:	0f 87 7b ff ff ff    	ja     800420474d <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  80042047d2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042047d9:	00 
  80042047da:	e9 a1 01 00 00       	jmpq   8004204980 <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  80042047df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042047e3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042047e7:	48 89 d0             	mov    %rdx,%rax
  80042047ea:	48 01 c0             	add    %rax,%rax
  80042047ed:	48 01 d0             	add    %rdx,%rax
  80042047f0:	48 c1 e0 0f          	shl    $0xf,%rax
  80042047f4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042047fb:	00 00 00 
  80042047fe:	48 29 c2             	sub    %rax,%rdx
  8004204801:	48 89 d0             	mov    %rdx,%rax
  8004204804:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204808:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420480f:	00 
  8004204810:	e9 e0 00 00 00       	jmpq   80042048f5 <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004204815:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204819:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420481d:	48 01 d0             	add    %rdx,%rax
  8004204820:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004204827:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420482b:	48 89 d6             	mov    %rdx,%rsi
  800420482e:	48 89 c7             	mov    %rax,%rdi
  8004204831:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004204838:	00 00 00 
  800420483b:	ff d0                	callq  *%rax
  800420483d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004204841:	48 89 d1             	mov    %rdx,%rcx
  8004204844:	48 c1 e1 10          	shl    $0x10,%rcx
  8004204848:	48 ba 00 70 3d 04 80 	movabs $0x80043d7000,%rdx
  800420484f:	00 00 00 
  8004204852:	48 01 ca             	add    %rcx,%rdx
  8004204855:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004204859:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204860:	00 00 00 
  8004204863:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  8004204867:	77 32                	ja     800420489b <check_boot_pml4e+0x3d6>
  8004204869:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420486d:	48 89 c1             	mov    %rax,%rcx
  8004204870:	48 ba 08 69 21 04 80 	movabs $0x8004216908,%rdx
  8004204877:	00 00 00 
  800420487a:	be 1a 04 00 00       	mov    $0x41a,%esi
  800420487f:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204886:	00 00 00 
  8004204889:	b8 00 00 00 00       	mov    $0x0,%eax
  800420488e:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204895:	00 00 00 
  8004204898:	41 ff d0             	callq  *%r8
  800420489b:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042048a2:	ff ff ff 
  80042048a5:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042048a9:	48 01 d1             	add    %rdx,%rcx
  80042048ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042048b0:	48 01 ca             	add    %rcx,%rdx
  80042048b3:	48 39 d0             	cmp    %rdx,%rax
  80042048b6:	74 35                	je     80042048ed <check_boot_pml4e+0x428>
  80042048b8:	48 b9 80 6d 21 04 80 	movabs $0x8004216d80,%rcx
  80042048bf:	00 00 00 
  80042048c2:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042048c9:	00 00 00 
  80042048cc:	be 1a 04 00 00       	mov    $0x41a,%esi
  80042048d1:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042048d8:	00 00 00 
  80042048db:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048e0:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042048e7:	00 00 00 
  80042048ea:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  80042048ed:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042048f4:	00 
  80042048f5:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  80042048fc:	00 
  80042048fd:	0f 86 12 ff ff ff    	jbe    8004204815 <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204903:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420490a:	00 
  800420490b:	eb 64                	jmp    8004204971 <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  800420490d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204911:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204915:	48 01 c2             	add    %rax,%rdx
  8004204918:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420491c:	48 89 d6             	mov    %rdx,%rsi
  800420491f:	48 89 c7             	mov    %rax,%rdi
  8004204922:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004204929:	00 00 00 
  800420492c:	ff d0                	callq  *%rax
  800420492e:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004204932:	74 35                	je     8004204969 <check_boot_pml4e+0x4a4>
  8004204934:	48 b9 c8 6d 21 04 80 	movabs $0x8004216dc8,%rcx
  800420493b:	00 00 00 
  800420493e:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204945:	00 00 00 
  8004204948:	be 1c 04 00 00       	mov    $0x41c,%esi
  800420494d:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204954:	00 00 00 
  8004204957:	b8 00 00 00 00       	mov    $0x0,%eax
  800420495c:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204963:	00 00 00 
  8004204966:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204969:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204970:	00 
  8004204971:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  8004204978:	00 
  8004204979:	76 92                	jbe    800420490d <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  800420497b:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204980:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  8004204985:	0f 86 54 fe ff ff    	jbe    80042047df <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  800420498b:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004204992:	00 00 00 
  8004204995:	48 8b 00             	mov    (%rax),%rax
  8004204998:	48 83 c0 08          	add    $0x8,%rax
  800420499c:	48 8b 00             	mov    (%rax),%rax
  800420499f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042049a5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042049a9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042049ad:	48 c1 e8 0c          	shr    $0xc,%rax
  80042049b1:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042049b4:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042049b7:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042049be:	00 00 00 
  80042049c1:	48 8b 00             	mov    (%rax),%rax
  80042049c4:	48 39 c2             	cmp    %rax,%rdx
  80042049c7:	72 32                	jb     80042049fb <check_boot_pml4e+0x536>
  80042049c9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042049cd:	48 89 c1             	mov    %rax,%rcx
  80042049d0:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042049d7:	00 00 00 
  80042049da:	be 1f 04 00 00       	mov    $0x41f,%esi
  80042049df:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042049e6:	00 00 00 
  80042049e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049ee:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042049f5:	00 00 00 
  80042049f8:	41 ff d0             	callq  *%r8
  80042049fb:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204a02:	00 00 00 
  8004204a05:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204a09:	48 01 d0             	add    %rdx,%rax
  8004204a0c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004204a10:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204a14:	48 8b 00             	mov    (%rax),%rax
  8004204a17:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204a1d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004204a21:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204a25:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204a29:	89 45 84             	mov    %eax,-0x7c(%rbp)
  8004204a2c:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004204a2f:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004204a36:	00 00 00 
  8004204a39:	48 8b 00             	mov    (%rax),%rax
  8004204a3c:	48 39 c2             	cmp    %rax,%rdx
  8004204a3f:	72 32                	jb     8004204a73 <check_boot_pml4e+0x5ae>
  8004204a41:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204a45:	48 89 c1             	mov    %rax,%rcx
  8004204a48:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004204a4f:	00 00 00 
  8004204a52:	be 20 04 00 00       	mov    $0x420,%esi
  8004204a57:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204a5e:	00 00 00 
  8004204a61:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a66:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204a6d:	00 00 00 
  8004204a70:	41 ff d0             	callq  *%r8
  8004204a73:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204a7a:	00 00 00 
  8004204a7d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204a81:	48 01 d0             	add    %rdx,%rax
  8004204a84:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204a8b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204a92:	00 
  8004204a93:	e9 50 01 00 00       	jmpq   8004204be8 <check_boot_pml4e+0x723>
		switch (i) {
  8004204a98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a9c:	48 83 f8 04          	cmp    $0x4,%rax
  8004204aa0:	72 67                	jb     8004204b09 <check_boot_pml4e+0x644>
  8004204aa2:	48 83 f8 05          	cmp    $0x5,%rax
  8004204aa6:	76 06                	jbe    8004204aae <check_boot_pml4e+0x5e9>
  8004204aa8:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004204aac:	75 5b                	jne    8004204b09 <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  8004204aae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ab2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204ab9:	00 
  8004204aba:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204ac1:	48 01 d0             	add    %rdx,%rax
  8004204ac4:	48 8b 00             	mov    (%rax),%rax
  8004204ac7:	83 e0 01             	and    $0x1,%eax
  8004204aca:	48 85 c0             	test   %rax,%rax
  8004204acd:	75 35                	jne    8004204b04 <check_boot_pml4e+0x63f>
  8004204acf:	48 b9 eb 6d 21 04 80 	movabs $0x8004216deb,%rcx
  8004204ad6:	00 00 00 
  8004204ad9:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204ae0:	00 00 00 
  8004204ae3:	be 28 04 00 00       	mov    $0x428,%esi
  8004204ae8:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204aef:	00 00 00 
  8004204af2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204af7:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204afe:	00 00 00 
  8004204b01:	41 ff d0             	callq  *%r8
			break;
  8004204b04:	e9 da 00 00 00       	jmpq   8004204be3 <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  8004204b09:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004204b0e:	0f 86 ce 00 00 00    	jbe    8004204be2 <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  8004204b14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b18:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204b1f:	00 
  8004204b20:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204b27:	48 01 d0             	add    %rdx,%rax
  8004204b2a:	48 8b 00             	mov    (%rax),%rax
  8004204b2d:	83 e0 01             	and    $0x1,%eax
  8004204b30:	48 85 c0             	test   %rax,%rax
  8004204b33:	74 5a                	je     8004204b8f <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  8004204b35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b39:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204b40:	00 
  8004204b41:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204b48:	48 01 d0             	add    %rdx,%rax
  8004204b4b:	48 8b 00             	mov    (%rax),%rax
  8004204b4e:	83 e0 02             	and    $0x2,%eax
  8004204b51:	48 85 c0             	test   %rax,%rax
  8004204b54:	0f 85 88 00 00 00    	jne    8004204be2 <check_boot_pml4e+0x71d>
  8004204b5a:	48 b9 fc 6d 21 04 80 	movabs $0x8004216dfc,%rcx
  8004204b61:	00 00 00 
  8004204b64:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204b6b:	00 00 00 
  8004204b6e:	be 2d 04 00 00       	mov    $0x42d,%esi
  8004204b73:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204b7a:	00 00 00 
  8004204b7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b82:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204b89:	00 00 00 
  8004204b8c:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  8004204b8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b93:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204b9a:	00 
  8004204b9b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204ba2:	48 01 d0             	add    %rdx,%rax
  8004204ba5:	48 8b 00             	mov    (%rax),%rax
  8004204ba8:	48 85 c0             	test   %rax,%rax
  8004204bab:	74 35                	je     8004204be2 <check_boot_pml4e+0x71d>
  8004204bad:	48 b9 0d 6e 21 04 80 	movabs $0x8004216e0d,%rcx
  8004204bb4:	00 00 00 
  8004204bb7:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204bbe:	00 00 00 
  8004204bc1:	be 2f 04 00 00       	mov    $0x42f,%esi
  8004204bc6:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204bcd:	00 00 00 
  8004204bd0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bd5:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204bdc:	00 00 00 
  8004204bdf:	41 ff d0             	callq  *%r8
			}
			break;
  8004204be2:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204be3:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004204be8:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004204bef:	00 
  8004204bf0:	0f 86 a2 fe ff ff    	jbe    8004204a98 <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			}
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004204bf6:	48 bf 20 6e 21 04 80 	movabs $0x8004216e20,%rdi
  8004204bfd:	00 00 00 
  8004204c00:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c05:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004204c0c:	00 00 00 
  8004204c0f:	ff d2                	callq  *%rdx
}
  8004204c11:	c9                   	leaveq 
  8004204c12:	c3                   	retq   

0000008004204c13 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004204c13:	55                   	push   %rbp
  8004204c14:	48 89 e5             	mov    %rsp,%rbp
  8004204c17:	48 83 ec 60          	sub    $0x60,%rsp
  8004204c1b:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004204c1f:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  8004204c23:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204c27:	48 c1 e8 27          	shr    $0x27,%rax
  8004204c2b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204c30:	48 c1 e0 03          	shl    $0x3,%rax
  8004204c34:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  8004204c38:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204c3c:	48 8b 00             	mov    (%rax),%rax
  8004204c3f:	83 e0 01             	and    $0x1,%eax
  8004204c42:	48 85 c0             	test   %rax,%rax
  8004204c45:	75 0c                	jne    8004204c53 <check_va2pa+0x40>
		return ~0;
  8004204c47:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204c4e:	e9 38 02 00 00       	jmpq   8004204e8b <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004204c53:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204c57:	48 8b 00             	mov    (%rax),%rax
  8004204c5a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204c60:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204c64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c68:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204c6c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004204c6f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004204c72:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004204c79:	00 00 00 
  8004204c7c:	48 8b 00             	mov    (%rax),%rax
  8004204c7f:	48 39 c2             	cmp    %rax,%rdx
  8004204c82:	72 32                	jb     8004204cb6 <check_va2pa+0xa3>
  8004204c84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c88:	48 89 c1             	mov    %rax,%rcx
  8004204c8b:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004204c92:	00 00 00 
  8004204c95:	be 47 04 00 00       	mov    $0x447,%esi
  8004204c9a:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204ca1:	00 00 00 
  8004204ca4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ca9:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204cb0:	00 00 00 
  8004204cb3:	41 ff d0             	callq  *%r8
  8004204cb6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204cbd:	00 00 00 
  8004204cc0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204cc4:	48 01 d0             	add    %rdx,%rax
  8004204cc7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004204ccb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204ccf:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004204cd3:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204cd8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204cdf:	00 
  8004204ce0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ce4:	48 01 d0             	add    %rdx,%rax
  8004204ce7:	48 8b 00             	mov    (%rax),%rax
  8004204cea:	83 e0 01             	and    $0x1,%eax
  8004204ced:	48 85 c0             	test   %rax,%rax
  8004204cf0:	75 0c                	jne    8004204cfe <check_va2pa+0xeb>
		return ~0;
  8004204cf2:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204cf9:	e9 8d 01 00 00       	jmpq   8004204e8b <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004204cfe:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204d02:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004204d06:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204d0b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204d12:	00 
  8004204d13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d17:	48 01 d0             	add    %rdx,%rax
  8004204d1a:	48 8b 00             	mov    (%rax),%rax
  8004204d1d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204d23:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204d27:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d2b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204d2f:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004204d32:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004204d35:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004204d3c:	00 00 00 
  8004204d3f:	48 8b 00             	mov    (%rax),%rax
  8004204d42:	48 39 c2             	cmp    %rax,%rdx
  8004204d45:	72 32                	jb     8004204d79 <check_va2pa+0x166>
  8004204d47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d4b:	48 89 c1             	mov    %rax,%rcx
  8004204d4e:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004204d55:	00 00 00 
  8004204d58:	be 4b 04 00 00       	mov    $0x44b,%esi
  8004204d5d:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204d64:	00 00 00 
  8004204d67:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d6c:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204d73:	00 00 00 
  8004204d76:	41 ff d0             	callq  *%r8
  8004204d79:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204d80:	00 00 00 
  8004204d83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d87:	48 01 d0             	add    %rdx,%rax
  8004204d8a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004204d8e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204d92:	48 c1 e8 15          	shr    $0x15,%rax
  8004204d96:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204d9b:	48 c1 e0 03          	shl    $0x3,%rax
  8004204d9f:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004204da3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204da7:	48 8b 00             	mov    (%rax),%rax
  8004204daa:	83 e0 01             	and    $0x1,%eax
  8004204dad:	48 85 c0             	test   %rax,%rax
  8004204db0:	75 0c                	jne    8004204dbe <check_va2pa+0x1ab>
		return ~0;
  8004204db2:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204db9:	e9 cd 00 00 00       	jmpq   8004204e8b <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004204dbe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204dc2:	48 8b 00             	mov    (%rax),%rax
  8004204dc5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204dcb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204dcf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204dd3:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204dd7:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004204dda:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004204ddd:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004204de4:	00 00 00 
  8004204de7:	48 8b 00             	mov    (%rax),%rax
  8004204dea:	48 39 c2             	cmp    %rax,%rdx
  8004204ded:	72 32                	jb     8004204e21 <check_va2pa+0x20e>
  8004204def:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204df3:	48 89 c1             	mov    %rax,%rcx
  8004204df6:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004204dfd:	00 00 00 
  8004204e00:	be 50 04 00 00       	mov    $0x450,%esi
  8004204e05:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204e0c:	00 00 00 
  8004204e0f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e14:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204e1b:	00 00 00 
  8004204e1e:	41 ff d0             	callq  *%r8
  8004204e21:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204e28:	00 00 00 
  8004204e2b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204e2f:	48 01 d0             	add    %rdx,%rax
  8004204e32:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004204e36:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204e3a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204e3e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204e43:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204e4a:	00 
  8004204e4b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204e4f:	48 01 d0             	add    %rdx,%rax
  8004204e52:	48 8b 00             	mov    (%rax),%rax
  8004204e55:	83 e0 01             	and    $0x1,%eax
  8004204e58:	48 85 c0             	test   %rax,%rax
  8004204e5b:	75 09                	jne    8004204e66 <check_va2pa+0x253>
		return ~0;
  8004204e5d:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204e64:	eb 25                	jmp    8004204e8b <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004204e66:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204e6a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204e6e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204e73:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204e7a:	00 
  8004204e7b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204e7f:	48 01 d0             	add    %rdx,%rax
  8004204e82:	48 8b 00             	mov    (%rax),%rax
  8004204e85:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004204e8b:	c9                   	leaveq 
  8004204e8c:	c3                   	retq   

0000008004204e8d <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004204e8d:	55                   	push   %rbp
  8004204e8e:	48 89 e5             	mov    %rsp,%rbp
  8004204e91:	53                   	push   %rbx
  8004204e92:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004204e99:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004204ea0:	00 
  8004204ea1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204ea5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204ea9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204ead:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204eb1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204eb5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204eb9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204ebd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204ec1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204ec5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004204ec9:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ece:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004204ed5:	00 00 00 
  8004204ed8:	ff d0                	callq  *%rax
  8004204eda:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004204ede:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004204ee3:	75 35                	jne    8004204f1a <page_check+0x8d>
  8004204ee5:	48 b9 3f 6e 21 04 80 	movabs $0x8004216e3f,%rcx
  8004204eec:	00 00 00 
  8004204eef:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204ef6:	00 00 00 
  8004204ef9:	be 66 04 00 00       	mov    $0x466,%esi
  8004204efe:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204f05:	00 00 00 
  8004204f08:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f0d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204f14:	00 00 00 
  8004204f17:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004204f1a:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204f1f:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004204f26:	00 00 00 
  8004204f29:	ff d0                	callq  *%rax
  8004204f2b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204f2f:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004204f34:	75 35                	jne    8004204f6b <page_check+0xde>
  8004204f36:	48 b9 53 6e 21 04 80 	movabs $0x8004216e53,%rcx
  8004204f3d:	00 00 00 
  8004204f40:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204f47:	00 00 00 
  8004204f4a:	be 67 04 00 00       	mov    $0x467,%esi
  8004204f4f:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204f56:	00 00 00 
  8004204f59:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f5e:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204f65:	00 00 00 
  8004204f68:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004204f6b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204f70:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004204f77:	00 00 00 
  8004204f7a:	ff d0                	callq  *%rax
  8004204f7c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204f80:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004204f85:	75 35                	jne    8004204fbc <page_check+0x12f>
  8004204f87:	48 b9 67 6e 21 04 80 	movabs $0x8004216e67,%rcx
  8004204f8e:	00 00 00 
  8004204f91:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204f98:	00 00 00 
  8004204f9b:	be 68 04 00 00       	mov    $0x468,%esi
  8004204fa0:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204fa7:	00 00 00 
  8004204faa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204faf:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004204fb6:	00 00 00 
  8004204fb9:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004204fbc:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204fc1:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004204fc8:	00 00 00 
  8004204fcb:	ff d0                	callq  *%rax
  8004204fcd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204fd1:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204fd6:	75 35                	jne    800420500d <page_check+0x180>
  8004204fd8:	48 b9 7b 6e 21 04 80 	movabs $0x8004216e7b,%rcx
  8004204fdf:	00 00 00 
  8004204fe2:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004204fe9:	00 00 00 
  8004204fec:	be 69 04 00 00       	mov    $0x469,%esi
  8004204ff1:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004204ff8:	00 00 00 
  8004204ffb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205000:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205007:	00 00 00 
  800420500a:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  800420500d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205012:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004205019:	00 00 00 
  800420501c:	ff d0                	callq  *%rax
  800420501e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205022:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205027:	75 35                	jne    800420505e <page_check+0x1d1>
  8004205029:	48 b9 8f 6e 21 04 80 	movabs $0x8004216e8f,%rcx
  8004205030:	00 00 00 
  8004205033:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420503a:	00 00 00 
  800420503d:	be 6a 04 00 00       	mov    $0x46a,%esi
  8004205042:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205049:	00 00 00 
  800420504c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205051:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205058:	00 00 00 
  800420505b:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  800420505e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205063:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  800420506a:	00 00 00 
  800420506d:	ff d0                	callq  *%rax
  800420506f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205073:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205078:	75 35                	jne    80042050af <page_check+0x222>
  800420507a:	48 b9 a3 6e 21 04 80 	movabs $0x8004216ea3,%rcx
  8004205081:	00 00 00 
  8004205084:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420508b:	00 00 00 
  800420508e:	be 6b 04 00 00       	mov    $0x46b,%esi
  8004205093:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420509a:	00 00 00 
  800420509d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050a2:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042050a9:	00 00 00 
  80042050ac:	41 ff d0             	callq  *%r8

	assert(pp0);
  80042050af:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042050b4:	75 35                	jne    80042050eb <page_check+0x25e>
  80042050b6:	48 b9 f1 6b 21 04 80 	movabs $0x8004216bf1,%rcx
  80042050bd:	00 00 00 
  80042050c0:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042050c7:	00 00 00 
  80042050ca:	be 6d 04 00 00       	mov    $0x46d,%esi
  80042050cf:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042050d6:	00 00 00 
  80042050d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050de:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042050e5:	00 00 00 
  80042050e8:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042050eb:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042050f0:	74 0a                	je     80042050fc <page_check+0x26f>
  80042050f2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042050f6:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042050fa:	75 35                	jne    8004205131 <page_check+0x2a4>
  80042050fc:	48 b9 f5 6b 21 04 80 	movabs $0x8004216bf5,%rcx
  8004205103:	00 00 00 
  8004205106:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420510d:	00 00 00 
  8004205110:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004205115:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420511c:	00 00 00 
  800420511f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205124:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420512b:	00 00 00 
  800420512e:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205131:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205136:	74 14                	je     800420514c <page_check+0x2bf>
  8004205138:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420513c:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205140:	74 0a                	je     800420514c <page_check+0x2bf>
  8004205142:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205146:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420514a:	75 35                	jne    8004205181 <page_check+0x2f4>
  800420514c:	48 b9 08 6c 21 04 80 	movabs $0x8004216c08,%rcx
  8004205153:	00 00 00 
  8004205156:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420515d:	00 00 00 
  8004205160:	be 6f 04 00 00       	mov    $0x46f,%esi
  8004205165:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420516c:	00 00 00 
  800420516f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205174:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420517b:	00 00 00 
  800420517e:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205181:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205186:	74 1e                	je     80042051a6 <page_check+0x319>
  8004205188:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420518c:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205190:	74 14                	je     80042051a6 <page_check+0x319>
  8004205192:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205196:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420519a:	74 0a                	je     80042051a6 <page_check+0x319>
  800420519c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042051a0:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042051a4:	75 35                	jne    80042051db <page_check+0x34e>
  80042051a6:	48 b9 b8 6e 21 04 80 	movabs $0x8004216eb8,%rcx
  80042051ad:	00 00 00 
  80042051b0:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042051b7:	00 00 00 
  80042051ba:	be 70 04 00 00       	mov    $0x470,%esi
  80042051bf:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042051c6:	00 00 00 
  80042051c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051ce:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042051d5:	00 00 00 
  80042051d8:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  80042051db:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042051e0:	74 28                	je     800420520a <page_check+0x37d>
  80042051e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042051e6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042051ea:	74 1e                	je     800420520a <page_check+0x37d>
  80042051ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042051f0:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042051f4:	74 14                	je     800420520a <page_check+0x37d>
  80042051f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042051fa:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042051fe:	74 0a                	je     800420520a <page_check+0x37d>
  8004205200:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205204:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205208:	75 35                	jne    800420523f <page_check+0x3b2>
  800420520a:	48 b9 e8 6e 21 04 80 	movabs $0x8004216ee8,%rcx
  8004205211:	00 00 00 
  8004205214:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420521b:	00 00 00 
  800420521e:	be 71 04 00 00       	mov    $0x471,%esi
  8004205223:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420522a:	00 00 00 
  800420522d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205232:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205239:	00 00 00 
  800420523c:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  800420523f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205244:	74 32                	je     8004205278 <page_check+0x3eb>
  8004205246:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420524a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420524e:	74 28                	je     8004205278 <page_check+0x3eb>
  8004205250:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205254:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205258:	74 1e                	je     8004205278 <page_check+0x3eb>
  800420525a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420525e:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205262:	74 14                	je     8004205278 <page_check+0x3eb>
  8004205264:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205268:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420526c:	74 0a                	je     8004205278 <page_check+0x3eb>
  800420526e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205272:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205276:	75 35                	jne    80042052ad <page_check+0x420>
  8004205278:	48 b9 28 6f 21 04 80 	movabs $0x8004216f28,%rcx
  800420527f:	00 00 00 
  8004205282:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205289:	00 00 00 
  800420528c:	be 72 04 00 00       	mov    $0x472,%esi
  8004205291:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205298:	00 00 00 
  800420529b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052a0:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042052a7:	00 00 00 
  80042052aa:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  80042052ad:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042052b4:	00 00 00 
  80042052b7:	48 8b 00             	mov    (%rax),%rax
  80042052ba:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  80042052be:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042052c5:	00 00 00 
  80042052c8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  80042052cf:	bf 00 00 00 00       	mov    $0x0,%edi
  80042052d4:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  80042052db:	00 00 00 
  80042052de:	ff d0                	callq  *%rax
  80042052e0:	48 85 c0             	test   %rax,%rax
  80042052e3:	74 35                	je     800420531a <page_check+0x48d>
  80042052e5:	48 b9 7f 6c 21 04 80 	movabs $0x8004216c7f,%rcx
  80042052ec:	00 00 00 
  80042052ef:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042052f6:	00 00 00 
  80042052f9:	be 79 04 00 00       	mov    $0x479,%esi
  80042052fe:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205305:	00 00 00 
  8004205308:	b8 00 00 00 00       	mov    $0x0,%eax
  800420530d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205314:	00 00 00 
  8004205317:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  800420531a:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205321:	00 00 00 
  8004205324:	48 8b 00             	mov    (%rax),%rax
  8004205327:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  800420532e:	be 00 00 00 00       	mov    $0x0,%esi
  8004205333:	48 89 c7             	mov    %rax,%rdi
  8004205336:	48 b8 13 31 20 04 80 	movabs $0x8004203113,%rax
  800420533d:	00 00 00 
  8004205340:	ff d0                	callq  *%rax
  8004205342:	48 85 c0             	test   %rax,%rax
  8004205345:	74 35                	je     800420537c <page_check+0x4ef>
  8004205347:	48 b9 78 6f 21 04 80 	movabs $0x8004216f78,%rcx
  800420534e:	00 00 00 
  8004205351:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205358:	00 00 00 
  800420535b:	be 7c 04 00 00       	mov    $0x47c,%esi
  8004205360:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205367:	00 00 00 
  800420536a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420536f:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205376:	00 00 00 
  8004205379:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420537c:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205383:	00 00 00 
  8004205386:	48 8b 00             	mov    (%rax),%rax
  8004205389:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420538d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205392:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205397:	48 89 c7             	mov    %rax,%rdi
  800420539a:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  80042053a1:	00 00 00 
  80042053a4:	ff d0                	callq  *%rax
  80042053a6:	85 c0                	test   %eax,%eax
  80042053a8:	78 35                	js     80042053df <page_check+0x552>
  80042053aa:	48 b9 b0 6f 21 04 80 	movabs $0x8004216fb0,%rcx
  80042053b1:	00 00 00 
  80042053b4:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042053bb:	00 00 00 
  80042053be:	be 7f 04 00 00       	mov    $0x47f,%esi
  80042053c3:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042053ca:	00 00 00 
  80042053cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053d2:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042053d9:	00 00 00 
  80042053dc:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  80042053df:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042053e3:	48 89 c7             	mov    %rax,%rdi
  80042053e6:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  80042053ed:	00 00 00 
  80042053f0:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042053f2:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042053f9:	00 00 00 
  80042053fc:	48 8b 00             	mov    (%rax),%rax
  80042053ff:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205403:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205408:	ba 00 00 00 00       	mov    $0x0,%edx
  800420540d:	48 89 c7             	mov    %rax,%rdi
  8004205410:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  8004205417:	00 00 00 
  800420541a:	ff d0                	callq  *%rax
  800420541c:	85 c0                	test   %eax,%eax
  800420541e:	78 35                	js     8004205455 <page_check+0x5c8>
  8004205420:	48 b9 b0 6f 21 04 80 	movabs $0x8004216fb0,%rcx
  8004205427:	00 00 00 
  800420542a:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205431:	00 00 00 
  8004205434:	be 83 04 00 00       	mov    $0x483,%esi
  8004205439:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205440:	00 00 00 
  8004205443:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205448:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420544f:	00 00 00 
  8004205452:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205455:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205459:	48 89 c7             	mov    %rax,%rdi
  800420545c:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  8004205463:	00 00 00 
  8004205466:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205468:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420546c:	48 89 c7             	mov    %rax,%rdi
  800420546f:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  8004205476:	00 00 00 
  8004205479:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  800420547b:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205482:	00 00 00 
  8004205485:	48 8b 00             	mov    (%rax),%rax
  8004205488:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420548c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205491:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205496:	48 89 c7             	mov    %rax,%rdi
  8004205499:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  80042054a0:	00 00 00 
  80042054a3:	ff d0                	callq  *%rax
  80042054a5:	85 c0                	test   %eax,%eax
  80042054a7:	74 35                	je     80042054de <page_check+0x651>
  80042054a9:	48 b9 e0 6f 21 04 80 	movabs $0x8004216fe0,%rcx
  80042054b0:	00 00 00 
  80042054b3:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042054ba:	00 00 00 
  80042054bd:	be 89 04 00 00       	mov    $0x489,%esi
  80042054c2:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042054c9:	00 00 00 
  80042054cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054d1:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042054d8:	00 00 00 
  80042054db:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  80042054de:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042054e5:	00 00 00 
  80042054e8:	48 8b 00             	mov    (%rax),%rax
  80042054eb:	48 8b 00             	mov    (%rax),%rax
  80042054ee:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042054f4:	48 89 c3             	mov    %rax,%rbx
  80042054f7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042054fb:	48 89 c7             	mov    %rax,%rdi
  80042054fe:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004205505:	00 00 00 
  8004205508:	ff d0                	callq  *%rax
  800420550a:	48 39 c3             	cmp    %rax,%rbx
  800420550d:	0f 84 97 00 00 00    	je     80042055aa <page_check+0x71d>
  8004205513:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420551a:	00 00 00 
  800420551d:	48 8b 00             	mov    (%rax),%rax
  8004205520:	48 8b 00             	mov    (%rax),%rax
  8004205523:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205529:	48 89 c3             	mov    %rax,%rbx
  800420552c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205530:	48 89 c7             	mov    %rax,%rdi
  8004205533:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  800420553a:	00 00 00 
  800420553d:	ff d0                	callq  *%rax
  800420553f:	48 39 c3             	cmp    %rax,%rbx
  8004205542:	74 66                	je     80042055aa <page_check+0x71d>
  8004205544:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420554b:	00 00 00 
  800420554e:	48 8b 00             	mov    (%rax),%rax
  8004205551:	48 8b 00             	mov    (%rax),%rax
  8004205554:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420555a:	48 89 c3             	mov    %rax,%rbx
  800420555d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205561:	48 89 c7             	mov    %rax,%rdi
  8004205564:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  800420556b:	00 00 00 
  800420556e:	ff d0                	callq  *%rax
  8004205570:	48 39 c3             	cmp    %rax,%rbx
  8004205573:	74 35                	je     80042055aa <page_check+0x71d>
  8004205575:	48 b9 10 70 21 04 80 	movabs $0x8004217010,%rcx
  800420557c:	00 00 00 
  800420557f:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205586:	00 00 00 
  8004205589:	be 8a 04 00 00       	mov    $0x48a,%esi
  800420558e:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205595:	00 00 00 
  8004205598:	b8 00 00 00 00       	mov    $0x0,%eax
  800420559d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042055a4:	00 00 00 
  80042055a7:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  80042055aa:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042055b1:	00 00 00 
  80042055b4:	48 8b 00             	mov    (%rax),%rax
  80042055b7:	be 00 00 00 00       	mov    $0x0,%esi
  80042055bc:	48 89 c7             	mov    %rax,%rdi
  80042055bf:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  80042055c6:	00 00 00 
  80042055c9:	ff d0                	callq  *%rax
  80042055cb:	48 89 c3             	mov    %rax,%rbx
  80042055ce:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042055d2:	48 89 c7             	mov    %rax,%rdi
  80042055d5:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  80042055dc:	00 00 00 
  80042055df:	ff d0                	callq  *%rax
  80042055e1:	48 39 c3             	cmp    %rax,%rbx
  80042055e4:	74 35                	je     800420561b <page_check+0x78e>
  80042055e6:	48 b9 98 70 21 04 80 	movabs $0x8004217098,%rcx
  80042055ed:	00 00 00 
  80042055f0:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042055f7:	00 00 00 
  80042055fa:	be 8b 04 00 00       	mov    $0x48b,%esi
  80042055ff:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205606:	00 00 00 
  8004205609:	b8 00 00 00 00       	mov    $0x0,%eax
  800420560e:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205615:	00 00 00 
  8004205618:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  800420561b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420561f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205623:	66 83 f8 01          	cmp    $0x1,%ax
  8004205627:	74 35                	je     800420565e <page_check+0x7d1>
  8004205629:	48 b9 c5 70 21 04 80 	movabs $0x80042170c5,%rcx
  8004205630:	00 00 00 
  8004205633:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420563a:	00 00 00 
  800420563d:	be 8c 04 00 00       	mov    $0x48c,%esi
  8004205642:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205649:	00 00 00 
  800420564c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205651:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205658:	00 00 00 
  800420565b:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  800420565e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205662:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205666:	66 83 f8 01          	cmp    $0x1,%ax
  800420566a:	74 35                	je     80042056a1 <page_check+0x814>
  800420566c:	48 b9 d6 70 21 04 80 	movabs $0x80042170d6,%rcx
  8004205673:	00 00 00 
  8004205676:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420567d:	00 00 00 
  8004205680:	be 8d 04 00 00       	mov    $0x48d,%esi
  8004205685:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420568c:	00 00 00 
  800420568f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205694:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420569b:	00 00 00 
  800420569e:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  80042056a1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042056a5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042056a9:	66 83 f8 01          	cmp    $0x1,%ax
  80042056ad:	74 35                	je     80042056e4 <page_check+0x857>
  80042056af:	48 b9 e7 70 21 04 80 	movabs $0x80042170e7,%rcx
  80042056b6:	00 00 00 
  80042056b9:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042056c0:	00 00 00 
  80042056c3:	be 8e 04 00 00       	mov    $0x48e,%esi
  80042056c8:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042056cf:	00 00 00 
  80042056d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056d7:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042056de:	00 00 00 
  80042056e1:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042056e4:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042056eb:	00 00 00 
  80042056ee:	48 8b 00             	mov    (%rax),%rax
  80042056f1:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042056f5:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042056fa:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042056ff:	48 89 c7             	mov    %rax,%rdi
  8004205702:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  8004205709:	00 00 00 
  800420570c:	ff d0                	callq  *%rax
  800420570e:	85 c0                	test   %eax,%eax
  8004205710:	74 35                	je     8004205747 <page_check+0x8ba>
  8004205712:	48 b9 f8 70 21 04 80 	movabs $0x80042170f8,%rcx
  8004205719:	00 00 00 
  800420571c:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205723:	00 00 00 
  8004205726:	be 90 04 00 00       	mov    $0x490,%esi
  800420572b:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205732:	00 00 00 
  8004205735:	b8 00 00 00 00       	mov    $0x0,%eax
  800420573a:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205741:	00 00 00 
  8004205744:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205747:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420574e:	00 00 00 
  8004205751:	48 8b 00             	mov    (%rax),%rax
  8004205754:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205759:	48 89 c7             	mov    %rax,%rdi
  800420575c:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004205763:	00 00 00 
  8004205766:	ff d0                	callq  *%rax
  8004205768:	48 89 c3             	mov    %rax,%rbx
  800420576b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420576f:	48 89 c7             	mov    %rax,%rdi
  8004205772:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004205779:	00 00 00 
  800420577c:	ff d0                	callq  *%rax
  800420577e:	48 39 c3             	cmp    %rax,%rbx
  8004205781:	74 35                	je     80042057b8 <page_check+0x92b>
  8004205783:	48 b9 30 71 21 04 80 	movabs $0x8004217130,%rcx
  800420578a:	00 00 00 
  800420578d:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205794:	00 00 00 
  8004205797:	be 91 04 00 00       	mov    $0x491,%esi
  800420579c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042057a3:	00 00 00 
  80042057a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057ab:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042057b2:	00 00 00 
  80042057b5:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042057b8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042057bc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042057c0:	66 83 f8 02          	cmp    $0x2,%ax
  80042057c4:	74 35                	je     80042057fb <page_check+0x96e>
  80042057c6:	48 b9 60 71 21 04 80 	movabs $0x8004217160,%rcx
  80042057cd:	00 00 00 
  80042057d0:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042057d7:	00 00 00 
  80042057da:	be 92 04 00 00       	mov    $0x492,%esi
  80042057df:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042057e6:	00 00 00 
  80042057e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057ee:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042057f5:	00 00 00 
  80042057f8:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  80042057fb:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205800:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004205807:	00 00 00 
  800420580a:	ff d0                	callq  *%rax
  800420580c:	48 85 c0             	test   %rax,%rax
  800420580f:	74 35                	je     8004205846 <page_check+0x9b9>
  8004205811:	48 b9 7f 6c 21 04 80 	movabs $0x8004216c7f,%rcx
  8004205818:	00 00 00 
  800420581b:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205822:	00 00 00 
  8004205825:	be 95 04 00 00       	mov    $0x495,%esi
  800420582a:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205831:	00 00 00 
  8004205834:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205839:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205840:	00 00 00 
  8004205843:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205846:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420584d:	00 00 00 
  8004205850:	48 8b 00             	mov    (%rax),%rax
  8004205853:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205857:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420585c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205861:	48 89 c7             	mov    %rax,%rdi
  8004205864:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  800420586b:	00 00 00 
  800420586e:	ff d0                	callq  *%rax
  8004205870:	85 c0                	test   %eax,%eax
  8004205872:	74 35                	je     80042058a9 <page_check+0xa1c>
  8004205874:	48 b9 f8 70 21 04 80 	movabs $0x80042170f8,%rcx
  800420587b:	00 00 00 
  800420587e:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205885:	00 00 00 
  8004205888:	be 98 04 00 00       	mov    $0x498,%esi
  800420588d:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205894:	00 00 00 
  8004205897:	b8 00 00 00 00       	mov    $0x0,%eax
  800420589c:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042058a3:	00 00 00 
  80042058a6:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042058a9:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042058b0:	00 00 00 
  80042058b3:	48 8b 00             	mov    (%rax),%rax
  80042058b6:	be 00 10 00 00       	mov    $0x1000,%esi
  80042058bb:	48 89 c7             	mov    %rax,%rdi
  80042058be:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  80042058c5:	00 00 00 
  80042058c8:	ff d0                	callq  *%rax
  80042058ca:	48 89 c3             	mov    %rax,%rbx
  80042058cd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042058d1:	48 89 c7             	mov    %rax,%rdi
  80042058d4:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  80042058db:	00 00 00 
  80042058de:	ff d0                	callq  *%rax
  80042058e0:	48 39 c3             	cmp    %rax,%rbx
  80042058e3:	74 35                	je     800420591a <page_check+0xa8d>
  80042058e5:	48 b9 30 71 21 04 80 	movabs $0x8004217130,%rcx
  80042058ec:	00 00 00 
  80042058ef:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042058f6:	00 00 00 
  80042058f9:	be 99 04 00 00       	mov    $0x499,%esi
  80042058fe:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205905:	00 00 00 
  8004205908:	b8 00 00 00 00       	mov    $0x0,%eax
  800420590d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205914:	00 00 00 
  8004205917:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420591a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420591e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205922:	66 83 f8 02          	cmp    $0x2,%ax
  8004205926:	74 35                	je     800420595d <page_check+0xad0>
  8004205928:	48 b9 60 71 21 04 80 	movabs $0x8004217160,%rcx
  800420592f:	00 00 00 
  8004205932:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205939:	00 00 00 
  800420593c:	be 9a 04 00 00       	mov    $0x49a,%esi
  8004205941:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205948:	00 00 00 
  800420594b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205950:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205957:	00 00 00 
  800420595a:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  800420595d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205962:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  8004205969:	00 00 00 
  800420596c:	ff d0                	callq  *%rax
  800420596e:	48 85 c0             	test   %rax,%rax
  8004205971:	74 35                	je     80042059a8 <page_check+0xb1b>
  8004205973:	48 b9 7f 6c 21 04 80 	movabs $0x8004216c7f,%rcx
  800420597a:	00 00 00 
  800420597d:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205984:	00 00 00 
  8004205987:	be 9e 04 00 00       	mov    $0x49e,%esi
  800420598c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205993:	00 00 00 
  8004205996:	b8 00 00 00 00       	mov    $0x0,%eax
  800420599b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042059a2:	00 00 00 
  80042059a5:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  80042059a8:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042059af:	00 00 00 
  80042059b2:	48 8b 00             	mov    (%rax),%rax
  80042059b5:	48 8b 00             	mov    (%rax),%rax
  80042059b8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042059be:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042059c2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042059c6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042059ca:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  80042059cd:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80042059d0:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042059d7:	00 00 00 
  80042059da:	48 8b 00             	mov    (%rax),%rax
  80042059dd:	48 39 c2             	cmp    %rax,%rdx
  80042059e0:	72 32                	jb     8004205a14 <page_check+0xb87>
  80042059e2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042059e6:	48 89 c1             	mov    %rax,%rcx
  80042059e9:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042059f0:	00 00 00 
  80042059f3:	be a0 04 00 00       	mov    $0x4a0,%esi
  80042059f8:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042059ff:	00 00 00 
  8004205a02:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a07:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205a0e:	00 00 00 
  8004205a11:	41 ff d0             	callq  *%r8
  8004205a14:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205a1b:	00 00 00 
  8004205a1e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205a22:	48 01 d0             	add    %rdx,%rax
  8004205a25:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004205a29:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004205a2d:	48 8b 00             	mov    (%rax),%rax
  8004205a30:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a36:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004205a3a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205a3e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205a42:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004205a45:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004205a48:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004205a4f:	00 00 00 
  8004205a52:	48 8b 00             	mov    (%rax),%rax
  8004205a55:	48 39 c2             	cmp    %rax,%rdx
  8004205a58:	72 32                	jb     8004205a8c <page_check+0xbff>
  8004205a5a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205a5e:	48 89 c1             	mov    %rax,%rcx
  8004205a61:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004205a68:	00 00 00 
  8004205a6b:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004205a70:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205a77:	00 00 00 
  8004205a7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a7f:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205a86:	00 00 00 
  8004205a89:	41 ff d0             	callq  *%r8
  8004205a8c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205a93:	00 00 00 
  8004205a96:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205a9a:	48 01 d0             	add    %rdx,%rax
  8004205a9d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004205aa1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205aa5:	48 8b 00             	mov    (%rax),%rax
  8004205aa8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205aae:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004205ab5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205abc:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205ac0:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004205ac6:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004205acc:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004205ad3:	00 00 00 
  8004205ad6:	48 8b 00             	mov    (%rax),%rax
  8004205ad9:	48 39 c2             	cmp    %rax,%rdx
  8004205adc:	72 35                	jb     8004205b13 <page_check+0xc86>
  8004205ade:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205ae5:	48 89 c1             	mov    %rax,%rcx
  8004205ae8:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004205aef:	00 00 00 
  8004205af2:	be a2 04 00 00       	mov    $0x4a2,%esi
  8004205af7:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205afe:	00 00 00 
  8004205b01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b06:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205b0d:	00 00 00 
  8004205b10:	41 ff d0             	callq  *%r8
  8004205b13:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205b1a:	00 00 00 
  8004205b1d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205b24:	48 01 d0             	add    %rdx,%rax
  8004205b27:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004205b2e:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205b35:	00 00 00 
  8004205b38:	48 8b 00             	mov    (%rax),%rax
  8004205b3b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205b40:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205b45:	48 89 c7             	mov    %rax,%rdi
  8004205b48:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004205b4f:	00 00 00 
  8004205b52:	ff d0                	callq  *%rax
  8004205b54:	48 8b 95 e0 fe ff ff 	mov    -0x120(%rbp),%rdx
  8004205b5b:	48 83 c2 08          	add    $0x8,%rdx
  8004205b5f:	48 39 d0             	cmp    %rdx,%rax
  8004205b62:	74 35                	je     8004205b99 <page_check+0xd0c>
  8004205b64:	48 b9 78 71 21 04 80 	movabs $0x8004217178,%rcx
  8004205b6b:	00 00 00 
  8004205b6e:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205b75:	00 00 00 
  8004205b78:	be a3 04 00 00       	mov    $0x4a3,%esi
  8004205b7d:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205b84:	00 00 00 
  8004205b87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b8c:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205b93:	00 00 00 
  8004205b96:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  8004205b99:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205ba0:	00 00 00 
  8004205ba3:	48 8b 00             	mov    (%rax),%rax
  8004205ba6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205baa:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004205baf:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205bb4:	48 89 c7             	mov    %rax,%rdi
  8004205bb7:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  8004205bbe:	00 00 00 
  8004205bc1:	ff d0                	callq  *%rax
  8004205bc3:	85 c0                	test   %eax,%eax
  8004205bc5:	74 35                	je     8004205bfc <page_check+0xd6f>
  8004205bc7:	48 b9 b8 71 21 04 80 	movabs $0x80042171b8,%rcx
  8004205bce:	00 00 00 
  8004205bd1:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205bd8:	00 00 00 
  8004205bdb:	be a6 04 00 00       	mov    $0x4a6,%esi
  8004205be0:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205be7:	00 00 00 
  8004205bea:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205bef:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205bf6:	00 00 00 
  8004205bf9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205bfc:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205c03:	00 00 00 
  8004205c06:	48 8b 00             	mov    (%rax),%rax
  8004205c09:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205c0e:	48 89 c7             	mov    %rax,%rdi
  8004205c11:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004205c18:	00 00 00 
  8004205c1b:	ff d0                	callq  *%rax
  8004205c1d:	48 89 c3             	mov    %rax,%rbx
  8004205c20:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c24:	48 89 c7             	mov    %rax,%rdi
  8004205c27:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004205c2e:	00 00 00 
  8004205c31:	ff d0                	callq  *%rax
  8004205c33:	48 39 c3             	cmp    %rax,%rbx
  8004205c36:	74 35                	je     8004205c6d <page_check+0xde0>
  8004205c38:	48 b9 30 71 21 04 80 	movabs $0x8004217130,%rcx
  8004205c3f:	00 00 00 
  8004205c42:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205c49:	00 00 00 
  8004205c4c:	be a7 04 00 00       	mov    $0x4a7,%esi
  8004205c51:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205c58:	00 00 00 
  8004205c5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c60:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205c67:	00 00 00 
  8004205c6a:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205c6d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c71:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205c75:	66 83 f8 02          	cmp    $0x2,%ax
  8004205c79:	74 35                	je     8004205cb0 <page_check+0xe23>
  8004205c7b:	48 b9 60 71 21 04 80 	movabs $0x8004217160,%rcx
  8004205c82:	00 00 00 
  8004205c85:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205c8c:	00 00 00 
  8004205c8f:	be a8 04 00 00       	mov    $0x4a8,%esi
  8004205c94:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205c9b:	00 00 00 
  8004205c9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ca3:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205caa:	00 00 00 
  8004205cad:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004205cb0:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205cb7:	00 00 00 
  8004205cba:	48 8b 00             	mov    (%rax),%rax
  8004205cbd:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205cc2:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205cc7:	48 89 c7             	mov    %rax,%rdi
  8004205cca:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004205cd1:	00 00 00 
  8004205cd4:	ff d0                	callq  *%rax
  8004205cd6:	48 8b 00             	mov    (%rax),%rax
  8004205cd9:	83 e0 04             	and    $0x4,%eax
  8004205cdc:	48 85 c0             	test   %rax,%rax
  8004205cdf:	75 35                	jne    8004205d16 <page_check+0xe89>
  8004205ce1:	48 b9 f8 71 21 04 80 	movabs $0x80042171f8,%rcx
  8004205ce8:	00 00 00 
  8004205ceb:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205cf2:	00 00 00 
  8004205cf5:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004205cfa:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205d01:	00 00 00 
  8004205d04:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d09:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205d10:	00 00 00 
  8004205d13:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004205d16:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205d1d:	00 00 00 
  8004205d20:	48 8b 00             	mov    (%rax),%rax
  8004205d23:	48 8b 00             	mov    (%rax),%rax
  8004205d26:	83 e0 04             	and    $0x4,%eax
  8004205d29:	48 85 c0             	test   %rax,%rax
  8004205d2c:	75 35                	jne    8004205d63 <page_check+0xed6>
  8004205d2e:	48 b9 2b 72 21 04 80 	movabs $0x800421722b,%rcx
  8004205d35:	00 00 00 
  8004205d38:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205d3f:	00 00 00 
  8004205d42:	be aa 04 00 00       	mov    $0x4aa,%esi
  8004205d47:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205d4e:	00 00 00 
  8004205d51:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d56:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205d5d:	00 00 00 
  8004205d60:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004205d63:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205d6a:	00 00 00 
  8004205d6d:	48 8b 00             	mov    (%rax),%rax
  8004205d70:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004205d74:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205d79:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004205d7e:	48 89 c7             	mov    %rax,%rdi
  8004205d81:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  8004205d88:	00 00 00 
  8004205d8b:	ff d0                	callq  *%rax
  8004205d8d:	85 c0                	test   %eax,%eax
  8004205d8f:	78 35                	js     8004205dc6 <page_check+0xf39>
  8004205d91:	48 b9 48 72 21 04 80 	movabs $0x8004217248,%rcx
  8004205d98:	00 00 00 
  8004205d9b:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205da2:	00 00 00 
  8004205da5:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004205daa:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205db1:	00 00 00 
  8004205db4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205db9:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205dc0:	00 00 00 
  8004205dc3:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004205dc6:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205dcd:	00 00 00 
  8004205dd0:	48 8b 00             	mov    (%rax),%rax
  8004205dd3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205dd7:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205ddc:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205de1:	48 89 c7             	mov    %rax,%rdi
  8004205de4:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  8004205deb:	00 00 00 
  8004205dee:	ff d0                	callq  *%rax
  8004205df0:	85 c0                	test   %eax,%eax
  8004205df2:	74 35                	je     8004205e29 <page_check+0xf9c>
  8004205df4:	48 b9 80 72 21 04 80 	movabs $0x8004217280,%rcx
  8004205dfb:	00 00 00 
  8004205dfe:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205e05:	00 00 00 
  8004205e08:	be b1 04 00 00       	mov    $0x4b1,%esi
  8004205e0d:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205e14:	00 00 00 
  8004205e17:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e1c:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205e23:	00 00 00 
  8004205e26:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004205e29:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205e30:	00 00 00 
  8004205e33:	48 8b 00             	mov    (%rax),%rax
  8004205e36:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205e3b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205e40:	48 89 c7             	mov    %rax,%rdi
  8004205e43:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004205e4a:	00 00 00 
  8004205e4d:	ff d0                	callq  *%rax
  8004205e4f:	48 8b 00             	mov    (%rax),%rax
  8004205e52:	83 e0 04             	and    $0x4,%eax
  8004205e55:	48 85 c0             	test   %rax,%rax
  8004205e58:	74 35                	je     8004205e8f <page_check+0x1002>
  8004205e5a:	48 b9 b8 72 21 04 80 	movabs $0x80042172b8,%rcx
  8004205e61:	00 00 00 
  8004205e64:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205e6b:	00 00 00 
  8004205e6e:	be b2 04 00 00       	mov    $0x4b2,%esi
  8004205e73:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205e7a:	00 00 00 
  8004205e7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e82:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205e89:	00 00 00 
  8004205e8c:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004205e8f:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205e96:	00 00 00 
  8004205e99:	48 8b 00             	mov    (%rax),%rax
  8004205e9c:	be 00 00 00 00       	mov    $0x0,%esi
  8004205ea1:	48 89 c7             	mov    %rax,%rdi
  8004205ea4:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004205eab:	00 00 00 
  8004205eae:	ff d0                	callq  *%rax
  8004205eb0:	48 89 c3             	mov    %rax,%rbx
  8004205eb3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205eb7:	48 89 c7             	mov    %rax,%rdi
  8004205eba:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004205ec1:	00 00 00 
  8004205ec4:	ff d0                	callq  *%rax
  8004205ec6:	48 39 c3             	cmp    %rax,%rbx
  8004205ec9:	74 35                	je     8004205f00 <page_check+0x1073>
  8004205ecb:	48 b9 f0 72 21 04 80 	movabs $0x80042172f0,%rcx
  8004205ed2:	00 00 00 
  8004205ed5:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205edc:	00 00 00 
  8004205edf:	be b5 04 00 00       	mov    $0x4b5,%esi
  8004205ee4:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205eeb:	00 00 00 
  8004205eee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ef3:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205efa:	00 00 00 
  8004205efd:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004205f00:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205f07:	00 00 00 
  8004205f0a:	48 8b 00             	mov    (%rax),%rax
  8004205f0d:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205f12:	48 89 c7             	mov    %rax,%rdi
  8004205f15:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004205f1c:	00 00 00 
  8004205f1f:	ff d0                	callq  *%rax
  8004205f21:	48 89 c3             	mov    %rax,%rbx
  8004205f24:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205f28:	48 89 c7             	mov    %rax,%rdi
  8004205f2b:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  8004205f32:	00 00 00 
  8004205f35:	ff d0                	callq  *%rax
  8004205f37:	48 39 c3             	cmp    %rax,%rbx
  8004205f3a:	74 35                	je     8004205f71 <page_check+0x10e4>
  8004205f3c:	48 b9 20 73 21 04 80 	movabs $0x8004217320,%rcx
  8004205f43:	00 00 00 
  8004205f46:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205f4d:	00 00 00 
  8004205f50:	be b6 04 00 00       	mov    $0x4b6,%esi
  8004205f55:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205f5c:	00 00 00 
  8004205f5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f64:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205f6b:	00 00 00 
  8004205f6e:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004205f71:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205f75:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205f79:	66 83 f8 02          	cmp    $0x2,%ax
  8004205f7d:	74 35                	je     8004205fb4 <page_check+0x1127>
  8004205f7f:	48 b9 50 73 21 04 80 	movabs $0x8004217350,%rcx
  8004205f86:	00 00 00 
  8004205f89:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205f90:	00 00 00 
  8004205f93:	be b8 04 00 00       	mov    $0x4b8,%esi
  8004205f98:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205f9f:	00 00 00 
  8004205fa2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fa7:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205fae:	00 00 00 
  8004205fb1:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004205fb4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205fb8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205fbc:	66 83 f8 01          	cmp    $0x1,%ax
  8004205fc0:	74 35                	je     8004205ff7 <page_check+0x116a>
  8004205fc2:	48 b9 61 73 21 04 80 	movabs $0x8004217361,%rcx
  8004205fc9:	00 00 00 
  8004205fcc:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004205fd3:	00 00 00 
  8004205fd6:	be b9 04 00 00       	mov    $0x4b9,%esi
  8004205fdb:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004205fe2:	00 00 00 
  8004205fe5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fea:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004205ff1:	00 00 00 
  8004205ff4:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004205ff7:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004205ffe:	00 00 00 
  8004206001:	48 8b 00             	mov    (%rax),%rax
  8004206004:	be 00 00 00 00       	mov    $0x0,%esi
  8004206009:	48 89 c7             	mov    %rax,%rdi
  800420600c:	48 b8 8a 31 20 04 80 	movabs $0x800420318a,%rax
  8004206013:	00 00 00 
  8004206016:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206018:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420601f:	00 00 00 
  8004206022:	48 8b 00             	mov    (%rax),%rax
  8004206025:	be 00 00 00 00       	mov    $0x0,%esi
  800420602a:	48 89 c7             	mov    %rax,%rdi
  800420602d:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004206034:	00 00 00 
  8004206037:	ff d0                	callq  *%rax
  8004206039:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420603d:	74 35                	je     8004206074 <page_check+0x11e7>
  800420603f:	48 b9 78 73 21 04 80 	movabs $0x8004217378,%rcx
  8004206046:	00 00 00 
  8004206049:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206050:	00 00 00 
  8004206053:	be be 04 00 00       	mov    $0x4be,%esi
  8004206058:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420605f:	00 00 00 
  8004206062:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206067:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420606e:	00 00 00 
  8004206071:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206074:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420607b:	00 00 00 
  800420607e:	48 8b 00             	mov    (%rax),%rax
  8004206081:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206086:	48 89 c7             	mov    %rax,%rdi
  8004206089:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004206090:	00 00 00 
  8004206093:	ff d0                	callq  *%rax
  8004206095:	48 89 c3             	mov    %rax,%rbx
  8004206098:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420609c:	48 89 c7             	mov    %rax,%rdi
  800420609f:	48 b8 e9 16 20 04 80 	movabs $0x80042016e9,%rax
  80042060a6:	00 00 00 
  80042060a9:	ff d0                	callq  *%rax
  80042060ab:	48 39 c3             	cmp    %rax,%rbx
  80042060ae:	74 35                	je     80042060e5 <page_check+0x1258>
  80042060b0:	48 b9 20 73 21 04 80 	movabs $0x8004217320,%rcx
  80042060b7:	00 00 00 
  80042060ba:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042060c1:	00 00 00 
  80042060c4:	be bf 04 00 00       	mov    $0x4bf,%esi
  80042060c9:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042060d0:	00 00 00 
  80042060d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060d8:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042060df:	00 00 00 
  80042060e2:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  80042060e5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042060e9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042060ed:	66 83 f8 01          	cmp    $0x1,%ax
  80042060f1:	74 35                	je     8004206128 <page_check+0x129b>
  80042060f3:	48 b9 c5 70 21 04 80 	movabs $0x80042170c5,%rcx
  80042060fa:	00 00 00 
  80042060fd:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206104:	00 00 00 
  8004206107:	be c0 04 00 00       	mov    $0x4c0,%esi
  800420610c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206113:	00 00 00 
  8004206116:	b8 00 00 00 00       	mov    $0x0,%eax
  800420611b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206122:	00 00 00 
  8004206125:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206128:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420612c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206130:	66 83 f8 01          	cmp    $0x1,%ax
  8004206134:	74 35                	je     800420616b <page_check+0x12de>
  8004206136:	48 b9 61 73 21 04 80 	movabs $0x8004217361,%rcx
  800420613d:	00 00 00 
  8004206140:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206147:	00 00 00 
  800420614a:	be c1 04 00 00       	mov    $0x4c1,%esi
  800420614f:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206156:	00 00 00 
  8004206159:	b8 00 00 00 00       	mov    $0x0,%eax
  800420615e:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206165:	00 00 00 
  8004206168:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  800420616b:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206172:	00 00 00 
  8004206175:	48 8b 00             	mov    (%rax),%rax
  8004206178:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420617c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206181:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206186:	48 89 c7             	mov    %rax,%rdi
  8004206189:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  8004206190:	00 00 00 
  8004206193:	ff d0                	callq  *%rax
  8004206195:	85 c0                	test   %eax,%eax
  8004206197:	74 35                	je     80042061ce <page_check+0x1341>
  8004206199:	48 b9 80 72 21 04 80 	movabs $0x8004217280,%rcx
  80042061a0:	00 00 00 
  80042061a3:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042061aa:	00 00 00 
  80042061ad:	be c5 04 00 00       	mov    $0x4c5,%esi
  80042061b2:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042061b9:	00 00 00 
  80042061bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061c1:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042061c8:	00 00 00 
  80042061cb:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  80042061ce:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042061d2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042061d6:	66 85 c0             	test   %ax,%ax
  80042061d9:	75 35                	jne    8004206210 <page_check+0x1383>
  80042061db:	48 b9 9b 73 21 04 80 	movabs $0x800421739b,%rcx
  80042061e2:	00 00 00 
  80042061e5:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042061ec:	00 00 00 
  80042061ef:	be c6 04 00 00       	mov    $0x4c6,%esi
  80042061f4:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042061fb:	00 00 00 
  80042061fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206203:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420620a:	00 00 00 
  800420620d:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206210:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206214:	48 8b 00             	mov    (%rax),%rax
  8004206217:	48 85 c0             	test   %rax,%rax
  800420621a:	74 35                	je     8004206251 <page_check+0x13c4>
  800420621c:	48 b9 a7 73 21 04 80 	movabs $0x80042173a7,%rcx
  8004206223:	00 00 00 
  8004206226:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420622d:	00 00 00 
  8004206230:	be c7 04 00 00       	mov    $0x4c7,%esi
  8004206235:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420623c:	00 00 00 
  800420623f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206244:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420624b:	00 00 00 
  800420624e:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206251:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206258:	00 00 00 
  800420625b:	48 8b 00             	mov    (%rax),%rax
  800420625e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206263:	48 89 c7             	mov    %rax,%rdi
  8004206266:	48 b8 8a 31 20 04 80 	movabs $0x800420318a,%rax
  800420626d:	00 00 00 
  8004206270:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206272:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206279:	00 00 00 
  800420627c:	48 8b 00             	mov    (%rax),%rax
  800420627f:	be 00 00 00 00       	mov    $0x0,%esi
  8004206284:	48 89 c7             	mov    %rax,%rdi
  8004206287:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  800420628e:	00 00 00 
  8004206291:	ff d0                	callq  *%rax
  8004206293:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206297:	74 35                	je     80042062ce <page_check+0x1441>
  8004206299:	48 b9 78 73 21 04 80 	movabs $0x8004217378,%rcx
  80042062a0:	00 00 00 
  80042062a3:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  80042062aa:	00 00 00 
  80042062ad:	be cb 04 00 00       	mov    $0x4cb,%esi
  80042062b2:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042062b9:	00 00 00 
  80042062bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062c1:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042062c8:	00 00 00 
  80042062cb:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  80042062ce:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042062d5:	00 00 00 
  80042062d8:	48 8b 00             	mov    (%rax),%rax
  80042062db:	be 00 10 00 00       	mov    $0x1000,%esi
  80042062e0:	48 89 c7             	mov    %rax,%rdi
  80042062e3:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  80042062ea:	00 00 00 
  80042062ed:	ff d0                	callq  *%rax
  80042062ef:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042062f3:	74 35                	je     800420632a <page_check+0x149d>
  80042062f5:	48 b9 c0 73 21 04 80 	movabs $0x80042173c0,%rcx
  80042062fc:	00 00 00 
  80042062ff:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206306:	00 00 00 
  8004206309:	be cc 04 00 00       	mov    $0x4cc,%esi
  800420630e:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206315:	00 00 00 
  8004206318:	b8 00 00 00 00       	mov    $0x0,%eax
  800420631d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206324:	00 00 00 
  8004206327:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  800420632a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420632e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206332:	66 85 c0             	test   %ax,%ax
  8004206335:	74 35                	je     800420636c <page_check+0x14df>
  8004206337:	48 b9 e6 73 21 04 80 	movabs $0x80042173e6,%rcx
  800420633e:	00 00 00 
  8004206341:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206348:	00 00 00 
  800420634b:	be cd 04 00 00       	mov    $0x4cd,%esi
  8004206350:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206357:	00 00 00 
  800420635a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420635f:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206366:	00 00 00 
  8004206369:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  800420636c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206370:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206374:	66 83 f8 01          	cmp    $0x1,%ax
  8004206378:	74 35                	je     80042063af <page_check+0x1522>
  800420637a:	48 b9 61 73 21 04 80 	movabs $0x8004217361,%rcx
  8004206381:	00 00 00 
  8004206384:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420638b:	00 00 00 
  800420638e:	be ce 04 00 00       	mov    $0x4ce,%esi
  8004206393:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420639a:	00 00 00 
  800420639d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063a2:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042063a9:	00 00 00 
  80042063ac:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  80042063af:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042063b6:	00 00 00 
  80042063b9:	48 8b 00             	mov    (%rax),%rax
  80042063bc:	48 8b 00             	mov    (%rax),%rax
  80042063bf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042063c5:	48 89 c7             	mov    %rax,%rdi
  80042063c8:	48 b8 0e 17 20 04 80 	movabs $0x800420170e,%rax
  80042063cf:	00 00 00 
  80042063d2:	ff d0                	callq  *%rax
  80042063d4:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  80042063db:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042063e2:	00 00 00 
  80042063e5:	48 8b 00             	mov    (%rax),%rax
  80042063e8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  80042063ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042063f3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042063f7:	66 83 f8 01          	cmp    $0x1,%ax
  80042063fb:	74 35                	je     8004206432 <page_check+0x15a5>
  80042063fd:	48 b9 61 73 21 04 80 	movabs $0x8004217361,%rcx
  8004206404:	00 00 00 
  8004206407:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420640e:	00 00 00 
  8004206411:	be e4 04 00 00       	mov    $0x4e4,%esi
  8004206416:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420641d:	00 00 00 
  8004206420:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206425:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420642c:	00 00 00 
  800420642f:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  8004206432:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206439:	48 89 c7             	mov    %rax,%rdi
  800420643c:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004206443:	00 00 00 
  8004206446:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  8004206448:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420644f:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004206453:	74 13                	je     8004206468 <page_check+0x15db>
  8004206455:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206459:	48 89 c7             	mov    %rax,%rdi
  800420645c:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004206463:	00 00 00 
  8004206466:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  8004206468:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420646f:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004206473:	74 13                	je     8004206488 <page_check+0x15fb>
  8004206475:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206479:	48 89 c7             	mov    %rax,%rdi
  800420647c:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004206483:	00 00 00 
  8004206486:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  8004206488:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420648f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004206493:	74 13                	je     80042064a8 <page_check+0x161b>
  8004206495:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206499:	48 89 c7             	mov    %rax,%rdi
  800420649c:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  80042064a3:	00 00 00 
  80042064a6:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  80042064a8:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  80042064af:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  80042064b3:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042064ba:	00 00 00 
  80042064bd:	48 8b 00             	mov    (%rax),%rax
  80042064c0:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042064c7:	ba 01 00 00 00       	mov    $0x1,%edx
  80042064cc:	48 89 ce             	mov    %rcx,%rsi
  80042064cf:	48 89 c7             	mov    %rax,%rdi
  80042064d2:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042064d9:	00 00 00 
  80042064dc:	ff d0                	callq  *%rax
  80042064de:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  80042064e5:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042064ec:	00 00 00 
  80042064ef:	48 8b 00             	mov    (%rax),%rax
  80042064f2:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042064f9:	48 c1 ea 27          	shr    $0x27,%rdx
  80042064fd:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206503:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206507:	48 01 d0             	add    %rdx,%rax
  800420650a:	48 8b 00             	mov    (%rax),%rax
  800420650d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206513:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  800420651a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004206521:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206525:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  800420652b:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  8004206531:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004206538:	00 00 00 
  800420653b:	48 8b 00             	mov    (%rax),%rax
  800420653e:	48 39 c2             	cmp    %rax,%rdx
  8004206541:	72 35                	jb     8004206578 <page_check+0x16eb>
  8004206543:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420654a:	48 89 c1             	mov    %rax,%rcx
  800420654d:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004206554:	00 00 00 
  8004206557:	be ec 04 00 00       	mov    $0x4ec,%esi
  800420655c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206563:	00 00 00 
  8004206566:	b8 00 00 00 00       	mov    $0x0,%eax
  800420656b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206572:	00 00 00 
  8004206575:	41 ff d0             	callq  *%r8
  8004206578:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420657f:	00 00 00 
  8004206582:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004206589:	48 01 d0             	add    %rdx,%rax
  800420658c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206590:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206597:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420659b:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042065a0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042065a7:	00 
  80042065a8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042065ac:	48 01 d0             	add    %rdx,%rax
  80042065af:	48 8b 00             	mov    (%rax),%rax
  80042065b2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042065b8:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  80042065bf:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042065c6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042065ca:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  80042065d0:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  80042065d6:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042065dd:	00 00 00 
  80042065e0:	48 8b 00             	mov    (%rax),%rax
  80042065e3:	48 39 c2             	cmp    %rax,%rdx
  80042065e6:	72 35                	jb     800420661d <page_check+0x1790>
  80042065e8:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042065ef:	48 89 c1             	mov    %rax,%rcx
  80042065f2:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042065f9:	00 00 00 
  80042065fc:	be ed 04 00 00       	mov    $0x4ed,%esi
  8004206601:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206608:	00 00 00 
  800420660b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206610:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206617:	00 00 00 
  800420661a:	41 ff d0             	callq  *%r8
  800420661d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206624:	00 00 00 
  8004206627:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420662e:	48 01 d0             	add    %rdx,%rax
  8004206631:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206635:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420663c:	48 c1 e8 15          	shr    $0x15,%rax
  8004206640:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206645:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420664c:	00 
  800420664d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206651:	48 01 d0             	add    %rdx,%rax
  8004206654:	48 8b 00             	mov    (%rax),%rax
  8004206657:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420665d:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004206664:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800420666b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420666f:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  8004206675:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  800420667b:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004206682:	00 00 00 
  8004206685:	48 8b 00             	mov    (%rax),%rax
  8004206688:	48 39 c2             	cmp    %rax,%rdx
  800420668b:	72 35                	jb     80042066c2 <page_check+0x1835>
  800420668d:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004206694:	48 89 c1             	mov    %rax,%rcx
  8004206697:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  800420669e:	00 00 00 
  80042066a1:	be ee 04 00 00       	mov    $0x4ee,%esi
  80042066a6:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042066ad:	00 00 00 
  80042066b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066b5:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042066bc:	00 00 00 
  80042066bf:	41 ff d0             	callq  *%r8
  80042066c2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042066c9:	00 00 00 
  80042066cc:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042066d3:	48 01 d0             	add    %rdx,%rax
  80042066d6:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  80042066dd:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042066e4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042066e8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042066ed:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042066f4:	00 
  80042066f5:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042066fc:	48 01 c2             	add    %rax,%rdx
  80042066ff:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004206706:	48 39 c2             	cmp    %rax,%rdx
  8004206709:	74 35                	je     8004206740 <page_check+0x18b3>
  800420670b:	48 b9 f7 73 21 04 80 	movabs $0x80042173f7,%rcx
  8004206712:	00 00 00 
  8004206715:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  800420671c:	00 00 00 
  800420671f:	be ef 04 00 00       	mov    $0x4ef,%esi
  8004206724:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420672b:	00 00 00 
  800420672e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206733:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420673a:	00 00 00 
  800420673d:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206740:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206744:	48 89 c7             	mov    %rax,%rdi
  8004206747:	48 b8 7f 17 20 04 80 	movabs $0x800420177f,%rax
  800420674e:	00 00 00 
  8004206751:	ff d0                	callq  *%rax
  8004206753:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206758:	be ff 00 00 00       	mov    $0xff,%esi
  800420675d:	48 89 c7             	mov    %rax,%rdi
  8004206760:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004206767:	00 00 00 
  800420676a:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  800420676c:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206773:	00 00 00 
  8004206776:	48 8b 00             	mov    (%rax),%rax
  8004206779:	ba 01 00 00 00       	mov    $0x1,%edx
  800420677e:	be 00 00 00 00       	mov    $0x0,%esi
  8004206783:	48 89 c7             	mov    %rax,%rdi
  8004206786:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800420678d:	00 00 00 
  8004206790:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206792:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206799:	00 00 00 
  800420679c:	48 8b 00             	mov    (%rax),%rax
  800420679f:	48 8b 00             	mov    (%rax),%rax
  80042067a2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042067a8:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  80042067af:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042067b6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042067ba:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  80042067c0:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  80042067c6:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042067cd:	00 00 00 
  80042067d0:	48 8b 00             	mov    (%rax),%rax
  80042067d3:	48 39 c2             	cmp    %rax,%rdx
  80042067d6:	72 35                	jb     800420680d <page_check+0x1980>
  80042067d8:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042067df:	48 89 c1             	mov    %rax,%rcx
  80042067e2:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042067e9:	00 00 00 
  80042067ec:	be f4 04 00 00       	mov    $0x4f4,%esi
  80042067f1:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  80042067f8:	00 00 00 
  80042067fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206800:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206807:	00 00 00 
  800420680a:	41 ff d0             	callq  *%r8
  800420680d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206814:	00 00 00 
  8004206817:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420681e:	48 01 d0             	add    %rdx,%rax
  8004206821:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004206825:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206829:	48 8b 00             	mov    (%rax),%rax
  800420682c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206832:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004206839:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004206840:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206844:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  800420684a:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004206850:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004206857:	00 00 00 
  800420685a:	48 8b 00             	mov    (%rax),%rax
  800420685d:	48 39 c2             	cmp    %rax,%rdx
  8004206860:	72 35                	jb     8004206897 <page_check+0x1a0a>
  8004206862:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004206869:	48 89 c1             	mov    %rax,%rcx
  800420686c:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004206873:	00 00 00 
  8004206876:	be f5 04 00 00       	mov    $0x4f5,%esi
  800420687b:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206882:	00 00 00 
  8004206885:	b8 00 00 00 00       	mov    $0x0,%eax
  800420688a:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206891:	00 00 00 
  8004206894:	41 ff d0             	callq  *%r8
  8004206897:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420689e:	00 00 00 
  80042068a1:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042068a8:	48 01 d0             	add    %rdx,%rax
  80042068ab:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  80042068af:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042068b3:	48 8b 00             	mov    (%rax),%rax
  80042068b6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042068bc:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  80042068c3:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042068ca:	48 c1 e8 0c          	shr    $0xc,%rax
  80042068ce:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  80042068d4:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  80042068da:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042068e1:	00 00 00 
  80042068e4:	48 8b 00             	mov    (%rax),%rax
  80042068e7:	48 39 c2             	cmp    %rax,%rdx
  80042068ea:	72 35                	jb     8004206921 <page_check+0x1a94>
  80042068ec:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042068f3:	48 89 c1             	mov    %rax,%rcx
  80042068f6:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042068fd:	00 00 00 
  8004206900:	be f6 04 00 00       	mov    $0x4f6,%esi
  8004206905:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  800420690c:	00 00 00 
  800420690f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206914:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420691b:	00 00 00 
  800420691e:	41 ff d0             	callq  *%r8
  8004206921:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206928:	00 00 00 
  800420692b:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004206932:	48 01 d0             	add    %rdx,%rax
  8004206935:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  800420693c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004206943:	eb 58                	jmp    800420699d <page_check+0x1b10>
		assert((ptep[i] & PTE_P) == 0);
  8004206945:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  800420694c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420694f:	48 63 d2             	movslq %edx,%rdx
  8004206952:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206956:	48 01 d0             	add    %rdx,%rax
  8004206959:	48 8b 00             	mov    (%rax),%rax
  800420695c:	83 e0 01             	and    $0x1,%eax
  800420695f:	48 85 c0             	test   %rax,%rax
  8004206962:	74 35                	je     8004206999 <page_check+0x1b0c>
  8004206964:	48 b9 0f 74 21 04 80 	movabs $0x800421740f,%rcx
  800420696b:	00 00 00 
  800420696e:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206975:	00 00 00 
  8004206978:	be f8 04 00 00       	mov    $0x4f8,%esi
  800420697d:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206984:	00 00 00 
  8004206987:	b8 00 00 00 00       	mov    $0x0,%eax
  800420698c:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206993:	00 00 00 
  8004206996:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  8004206999:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420699d:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  80042069a4:	7e 9f                	jle    8004206945 <page_check+0x1ab8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  80042069a6:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  80042069ad:	00 00 00 
  80042069b0:	48 8b 00             	mov    (%rax),%rax
  80042069b3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  80042069ba:	48 b8 38 32 3d 04 80 	movabs $0x80043d3238,%rax
  80042069c1:	00 00 00 
  80042069c4:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042069c8:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  80042069cb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042069cf:	48 89 c7             	mov    %rax,%rdi
  80042069d2:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  80042069d9:	00 00 00 
  80042069dc:	ff d0                	callq  *%rax
	page_decref(pp2);
  80042069de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042069e2:	48 89 c7             	mov    %rax,%rdi
  80042069e5:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  80042069ec:	00 00 00 
  80042069ef:	ff d0                	callq  *%rax
	page_decref(pp3);
  80042069f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042069f5:	48 89 c7             	mov    %rax,%rdi
  80042069f8:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  80042069ff:	00 00 00 
  8004206a02:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  8004206a04:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206a08:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206a0c:	66 85 c0             	test   %ax,%ax
  8004206a0f:	74 35                	je     8004206a46 <page_check+0x1bb9>
  8004206a11:	48 b9 26 74 21 04 80 	movabs $0x8004217426,%rcx
  8004206a18:	00 00 00 
  8004206a1b:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206a22:	00 00 00 
  8004206a25:	be 04 05 00 00       	mov    $0x504,%esi
  8004206a2a:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206a31:	00 00 00 
  8004206a34:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a39:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206a40:	00 00 00 
  8004206a43:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206a46:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a4a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206a4e:	66 85 c0             	test   %ax,%ax
  8004206a51:	74 35                	je     8004206a88 <page_check+0x1bfb>
  8004206a53:	48 b9 e6 73 21 04 80 	movabs $0x80042173e6,%rcx
  8004206a5a:	00 00 00 
  8004206a5d:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206a64:	00 00 00 
  8004206a67:	be 05 05 00 00       	mov    $0x505,%esi
  8004206a6c:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206a73:	00 00 00 
  8004206a76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a7b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206a82:	00 00 00 
  8004206a85:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  8004206a88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206a8c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206a90:	66 85 c0             	test   %ax,%ax
  8004206a93:	74 35                	je     8004206aca <page_check+0x1c3d>
  8004206a95:	48 b9 37 74 21 04 80 	movabs $0x8004217437,%rcx
  8004206a9c:	00 00 00 
  8004206a9f:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206aa6:	00 00 00 
  8004206aa9:	be 06 05 00 00       	mov    $0x506,%esi
  8004206aae:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206ab5:	00 00 00 
  8004206ab8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206abd:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206ac4:	00 00 00 
  8004206ac7:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  8004206aca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206ace:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206ad2:	66 85 c0             	test   %ax,%ax
  8004206ad5:	74 35                	je     8004206b0c <page_check+0x1c7f>
  8004206ad7:	48 b9 48 74 21 04 80 	movabs $0x8004217448,%rcx
  8004206ade:	00 00 00 
  8004206ae1:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206ae8:	00 00 00 
  8004206aeb:	be 07 05 00 00       	mov    $0x507,%esi
  8004206af0:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206af7:	00 00 00 
  8004206afa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206aff:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206b06:	00 00 00 
  8004206b09:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  8004206b0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206b10:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b14:	66 85 c0             	test   %ax,%ax
  8004206b17:	74 35                	je     8004206b4e <page_check+0x1cc1>
  8004206b19:	48 b9 59 74 21 04 80 	movabs $0x8004217459,%rcx
  8004206b20:	00 00 00 
  8004206b23:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206b2a:	00 00 00 
  8004206b2d:	be 08 05 00 00       	mov    $0x508,%esi
  8004206b32:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206b39:	00 00 00 
  8004206b3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b41:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206b48:	00 00 00 
  8004206b4b:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  8004206b4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206b52:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b56:	66 85 c0             	test   %ax,%ax
  8004206b59:	74 35                	je     8004206b90 <page_check+0x1d03>
  8004206b5b:	48 b9 6a 74 21 04 80 	movabs $0x800421746a,%rcx
  8004206b62:	00 00 00 
  8004206b65:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206b6c:	00 00 00 
  8004206b6f:	be 09 05 00 00       	mov    $0x509,%esi
  8004206b74:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206b7b:	00 00 00 
  8004206b7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b83:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206b8a:	00 00 00 
  8004206b8d:	41 ff d0             	callq  *%r8

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004206b90:	be 01 10 00 00       	mov    $0x1001,%esi
  8004206b95:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206b9a:	48 b8 df 32 20 04 80 	movabs $0x80042032df,%rax
  8004206ba1:	00 00 00 
  8004206ba4:	ff d0                	callq  *%rax
  8004206ba6:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004206bad:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206bb2:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206bb7:	48 b8 df 32 20 04 80 	movabs $0x80042032df,%rax
  8004206bbe:	00 00 00 
  8004206bc1:	ff d0                	callq  *%rax
  8004206bc3:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004206bca:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206bd1:	00 00 00 
  8004206bd4:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004206bdb:	76 1d                	jbe    8004206bfa <page_check+0x1d6d>
  8004206bdd:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206be4:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206beb:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004206bf2:	00 00 00 
  8004206bf5:	48 39 c2             	cmp    %rax,%rdx
  8004206bf8:	76 35                	jbe    8004206c2f <page_check+0x1da2>
  8004206bfa:	48 b9 80 74 21 04 80 	movabs $0x8004217480,%rcx
  8004206c01:	00 00 00 
  8004206c04:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206c0b:	00 00 00 
  8004206c0e:	be 0f 05 00 00       	mov    $0x50f,%esi
  8004206c13:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206c1a:	00 00 00 
  8004206c1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c22:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206c29:	00 00 00 
  8004206c2c:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  8004206c2f:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206c36:	00 00 00 
  8004206c39:	48 39 85 e8 fe ff ff 	cmp    %rax,-0x118(%rbp)
  8004206c40:	76 1d                	jbe    8004206c5f <page_check+0x1dd2>
  8004206c42:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206c49:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206c50:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004206c57:	00 00 00 
  8004206c5a:	48 39 c2             	cmp    %rax,%rdx
  8004206c5d:	76 35                	jbe    8004206c94 <page_check+0x1e07>
  8004206c5f:	48 b9 a8 74 21 04 80 	movabs $0x80042174a8,%rcx
  8004206c66:	00 00 00 
  8004206c69:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206c70:	00 00 00 
  8004206c73:	be 10 05 00 00       	mov    $0x510,%esi
  8004206c78:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206c7f:	00 00 00 
  8004206c82:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c87:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206c8e:	00 00 00 
  8004206c91:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004206c94:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206c9b:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004206ca0:	48 85 c0             	test   %rax,%rax
  8004206ca3:	75 11                	jne    8004206cb6 <page_check+0x1e29>
  8004206ca5:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206cac:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004206cb1:	48 85 c0             	test   %rax,%rax
  8004206cb4:	74 35                	je     8004206ceb <page_check+0x1e5e>
  8004206cb6:	48 b9 d0 74 21 04 80 	movabs $0x80042174d0,%rcx
  8004206cbd:	00 00 00 
  8004206cc0:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206cc7:	00 00 00 
  8004206cca:	be 12 05 00 00       	mov    $0x512,%esi
  8004206ccf:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206cd6:	00 00 00 
  8004206cd9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206cde:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206ce5:	00 00 00 
  8004206ce8:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004206ceb:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206cf2:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004206cf8:	48 3b 85 e8 fe ff ff 	cmp    -0x118(%rbp),%rax
  8004206cff:	76 35                	jbe    8004206d36 <page_check+0x1ea9>
  8004206d01:	48 b9 f7 74 21 04 80 	movabs $0x80042174f7,%rcx
  8004206d08:	00 00 00 
  8004206d0b:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206d12:	00 00 00 
  8004206d15:	be 14 05 00 00       	mov    $0x514,%esi
  8004206d1a:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206d21:	00 00 00 
  8004206d24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d29:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206d30:	00 00 00 
  8004206d33:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004206d36:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206d3d:	00 00 00 
  8004206d40:	48 8b 00             	mov    (%rax),%rax
  8004206d43:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004206d4a:	48 89 d6             	mov    %rdx,%rsi
  8004206d4d:	48 89 c7             	mov    %rax,%rdi
  8004206d50:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004206d57:	00 00 00 
  8004206d5a:	ff d0                	callq  *%rax
  8004206d5c:	48 85 c0             	test   %rax,%rax
  8004206d5f:	74 35                	je     8004206d96 <page_check+0x1f09>
  8004206d61:	48 b9 10 75 21 04 80 	movabs $0x8004217510,%rcx
  8004206d68:	00 00 00 
  8004206d6b:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206d72:	00 00 00 
  8004206d75:	be 17 05 00 00       	mov    $0x517,%esi
  8004206d7a:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206d81:	00 00 00 
  8004206d84:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d89:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206d90:	00 00 00 
  8004206d93:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004206d96:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206d9d:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004206da4:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206dab:	00 00 00 
  8004206dae:	48 8b 00             	mov    (%rax),%rax
  8004206db1:	48 89 d6             	mov    %rdx,%rsi
  8004206db4:	48 89 c7             	mov    %rax,%rdi
  8004206db7:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004206dbe:	00 00 00 
  8004206dc1:	ff d0                	callq  *%rax
  8004206dc3:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004206dc9:	74 35                	je     8004206e00 <page_check+0x1f73>
  8004206dcb:	48 b9 38 75 21 04 80 	movabs $0x8004217538,%rcx
  8004206dd2:	00 00 00 
  8004206dd5:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206ddc:	00 00 00 
  8004206ddf:	be 18 05 00 00       	mov    $0x518,%esi
  8004206de4:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206deb:	00 00 00 
  8004206dee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206df3:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206dfa:	00 00 00 
  8004206dfd:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004206e00:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206e07:	00 00 00 
  8004206e0a:	48 8b 00             	mov    (%rax),%rax
  8004206e0d:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004206e14:	48 89 d6             	mov    %rdx,%rsi
  8004206e17:	48 89 c7             	mov    %rax,%rdi
  8004206e1a:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004206e21:	00 00 00 
  8004206e24:	ff d0                	callq  *%rax
  8004206e26:	48 85 c0             	test   %rax,%rax
  8004206e29:	74 35                	je     8004206e60 <page_check+0x1fd3>
  8004206e2b:	48 b9 68 75 21 04 80 	movabs $0x8004217568,%rcx
  8004206e32:	00 00 00 
  8004206e35:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206e3c:	00 00 00 
  8004206e3f:	be 19 05 00 00       	mov    $0x519,%esi
  8004206e44:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206e4b:	00 00 00 
  8004206e4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e53:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206e5a:	00 00 00 
  8004206e5d:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004206e60:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206e67:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004206e6e:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206e75:	00 00 00 
  8004206e78:	48 8b 00             	mov    (%rax),%rax
  8004206e7b:	48 89 d6             	mov    %rdx,%rsi
  8004206e7e:	48 89 c7             	mov    %rax,%rdi
  8004206e81:	48 b8 13 4c 20 04 80 	movabs $0x8004204c13,%rax
  8004206e88:	00 00 00 
  8004206e8b:	ff d0                	callq  *%rax
  8004206e8d:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206e91:	74 35                	je     8004206ec8 <page_check+0x203b>
  8004206e93:	48 b9 90 75 21 04 80 	movabs $0x8004217590,%rcx
  8004206e9a:	00 00 00 
  8004206e9d:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206ea4:	00 00 00 
  8004206ea7:	be 1a 05 00 00       	mov    $0x51a,%esi
  8004206eac:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206eb3:	00 00 00 
  8004206eb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ebb:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206ec2:	00 00 00 
  8004206ec5:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004206ec8:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004206ecf:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206ed6:	00 00 00 
  8004206ed9:	48 8b 00             	mov    (%rax),%rax
  8004206edc:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206ee1:	48 89 ce             	mov    %rcx,%rsi
  8004206ee4:	48 89 c7             	mov    %rax,%rdi
  8004206ee7:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004206eee:	00 00 00 
  8004206ef1:	ff d0                	callq  *%rax
  8004206ef3:	48 8b 00             	mov    (%rax),%rax
  8004206ef6:	83 e0 1a             	and    $0x1a,%eax
  8004206ef9:	48 85 c0             	test   %rax,%rax
  8004206efc:	75 35                	jne    8004206f33 <page_check+0x20a6>
  8004206efe:	48 b9 c0 75 21 04 80 	movabs $0x80042175c0,%rcx
  8004206f05:	00 00 00 
  8004206f08:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206f0f:	00 00 00 
  8004206f12:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004206f17:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206f1e:	00 00 00 
  8004206f21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f26:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206f2d:	00 00 00 
  8004206f30:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004206f33:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004206f3a:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206f41:	00 00 00 
  8004206f44:	48 8b 00             	mov    (%rax),%rax
  8004206f47:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206f4c:	48 89 ce             	mov    %rcx,%rsi
  8004206f4f:	48 89 c7             	mov    %rax,%rdi
  8004206f52:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004206f59:	00 00 00 
  8004206f5c:	ff d0                	callq  *%rax
  8004206f5e:	48 8b 00             	mov    (%rax),%rax
  8004206f61:	83 e0 04             	and    $0x4,%eax
  8004206f64:	48 85 c0             	test   %rax,%rax
  8004206f67:	74 35                	je     8004206f9e <page_check+0x2111>
  8004206f69:	48 b9 08 76 21 04 80 	movabs $0x8004217608,%rcx
  8004206f70:	00 00 00 
  8004206f73:	48 ba e1 67 21 04 80 	movabs $0x80042167e1,%rdx
  8004206f7a:	00 00 00 
  8004206f7d:	be 1d 05 00 00       	mov    $0x51d,%esi
  8004206f82:	48 bf f6 67 21 04 80 	movabs $0x80042167f6,%rdi
  8004206f89:	00 00 00 
  8004206f8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f91:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004206f98:	00 00 00 
  8004206f9b:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004206f9e:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004206fa5:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206fac:	00 00 00 
  8004206faf:	48 8b 00             	mov    (%rax),%rax
  8004206fb2:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206fb7:	48 89 ce             	mov    %rcx,%rsi
  8004206fba:	48 89 c7             	mov    %rax,%rdi
  8004206fbd:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004206fc4:	00 00 00 
  8004206fc7:	ff d0                	callq  *%rax
  8004206fc9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004206fd0:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206fd7:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004206fdd:	48 89 c1             	mov    %rax,%rcx
  8004206fe0:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004206fe7:	00 00 00 
  8004206fea:	48 8b 00             	mov    (%rax),%rax
  8004206fed:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206ff2:	48 89 ce             	mov    %rcx,%rsi
  8004206ff5:	48 89 c7             	mov    %rax,%rdi
  8004206ff8:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004206fff:	00 00 00 
  8004207002:	ff d0                	callq  *%rax
  8004207004:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  800420700b:	48 8b 8d e8 fe ff ff 	mov    -0x118(%rbp),%rcx
  8004207012:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  8004207019:	00 00 00 
  800420701c:	48 8b 00             	mov    (%rax),%rax
  800420701f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207024:	48 89 ce             	mov    %rcx,%rsi
  8004207027:	48 89 c7             	mov    %rax,%rdi
  800420702a:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004207031:	00 00 00 
  8004207034:	ff d0                	callq  *%rax
  8004207036:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  800420703d:	48 bf 3b 76 21 04 80 	movabs $0x800421763b,%rdi
  8004207044:	00 00 00 
  8004207047:	b8 00 00 00 00       	mov    $0x0,%eax
  800420704c:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004207053:	00 00 00 
  8004207056:	ff d2                	callq  *%rdx
}
  8004207058:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  800420705f:	5b                   	pop    %rbx
  8004207060:	5d                   	pop    %rbp
  8004207061:	c3                   	retq   

0000008004207062 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207062:	55                   	push   %rbp
  8004207063:	48 89 e5             	mov    %rsp,%rbp
  8004207066:	48 83 ec 08          	sub    $0x8,%rsp
  800420706a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420706e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207072:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  8004207079:	00 00 00 
  800420707c:	48 8b 00             	mov    (%rax),%rax
  800420707f:	48 29 c2             	sub    %rax,%rdx
  8004207082:	48 89 d0             	mov    %rdx,%rax
  8004207085:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207089:	c9                   	leaveq 
  800420708a:	c3                   	retq   

000000800420708b <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800420708b:	55                   	push   %rbp
  800420708c:	48 89 e5             	mov    %rsp,%rbp
  800420708f:	48 83 ec 08          	sub    $0x8,%rsp
  8004207093:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207097:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420709b:	48 89 c7             	mov    %rax,%rdi
  800420709e:	48 b8 62 70 20 04 80 	movabs $0x8004207062,%rax
  80042070a5:	00 00 00 
  80042070a8:	ff d0                	callq  *%rax
  80042070aa:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042070ae:	c9                   	leaveq 
  80042070af:	c3                   	retq   

00000080042070b0 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042070b0:	55                   	push   %rbp
  80042070b1:	48 89 e5             	mov    %rsp,%rbp
  80042070b4:	48 83 ec 10          	sub    $0x10,%rsp
  80042070b8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042070bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042070c0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042070c4:	48 89 c2             	mov    %rax,%rdx
  80042070c7:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042070ce:	00 00 00 
  80042070d1:	48 8b 00             	mov    (%rax),%rax
  80042070d4:	48 39 c2             	cmp    %rax,%rdx
  80042070d7:	72 2a                	jb     8004207103 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042070d9:	48 ba 58 76 21 04 80 	movabs $0x8004217658,%rdx
  80042070e0:	00 00 00 
  80042070e3:	be 54 00 00 00       	mov    $0x54,%esi
  80042070e8:	48 bf 77 76 21 04 80 	movabs $0x8004217677,%rdi
  80042070ef:	00 00 00 
  80042070f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070f7:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  80042070fe:	00 00 00 
  8004207101:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004207103:	48 b8 38 47 3d 04 80 	movabs $0x80043d4738,%rax
  800420710a:	00 00 00 
  800420710d:	48 8b 00             	mov    (%rax),%rax
  8004207110:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207114:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207118:	48 c1 e2 04          	shl    $0x4,%rdx
  800420711c:	48 01 d0             	add    %rdx,%rax
}
  800420711f:	c9                   	leaveq 
  8004207120:	c3                   	retq   

0000008004207121 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004207121:	55                   	push   %rbp
  8004207122:	48 89 e5             	mov    %rsp,%rbp
  8004207125:	48 83 ec 20          	sub    $0x20,%rsp
  8004207129:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420712d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207131:	48 89 c7             	mov    %rax,%rdi
  8004207134:	48 b8 8b 70 20 04 80 	movabs $0x800420708b,%rax
  800420713b:	00 00 00 
  800420713e:	ff d0                	callq  *%rax
  8004207140:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207144:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207148:	48 c1 e8 0c          	shr    $0xc,%rax
  800420714c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420714f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207152:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004207159:	00 00 00 
  800420715c:	48 8b 00             	mov    (%rax),%rax
  800420715f:	48 39 c2             	cmp    %rax,%rdx
  8004207162:	72 32                	jb     8004207196 <page2kva+0x75>
  8004207164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207168:	48 89 c1             	mov    %rax,%rcx
  800420716b:	48 ba 88 76 21 04 80 	movabs $0x8004217688,%rdx
  8004207172:	00 00 00 
  8004207175:	be 5b 00 00 00       	mov    $0x5b,%esi
  800420717a:	48 bf 77 76 21 04 80 	movabs $0x8004217677,%rdi
  8004207181:	00 00 00 
  8004207184:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207189:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004207190:	00 00 00 
  8004207193:	41 ff d0             	callq  *%r8
  8004207196:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420719d:	00 00 00 
  80042071a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042071a4:	48 01 d0             	add    %rdx,%rax
}
  80042071a7:	c9                   	leaveq 
  80042071a8:	c3                   	retq   

00000080042071a9 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  80042071a9:	55                   	push   %rbp
  80042071aa:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  80042071ad:	48 bf 60 b7 22 04 80 	movabs $0x800422b760,%rdi
  80042071b4:	00 00 00 
  80042071b7:	48 b8 db 61 21 04 80 	movabs $0x80042161db,%rax
  80042071be:	00 00 00 
  80042071c1:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  80042071c3:	f3 90                	pause  
}
  80042071c5:	5d                   	pop    %rbp
  80042071c6:	c3                   	retq   

00000080042071c7 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  80042071c7:	55                   	push   %rbp
  80042071c8:	48 89 e5             	mov    %rsp,%rbp
  80042071cb:	53                   	push   %rbx
  80042071cc:	48 83 ec 28          	sub    $0x28,%rsp
  80042071d0:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80042071d3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042071d7:	89 d0                	mov    %edx,%eax
  80042071d9:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  80042071dc:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042071e0:	75 42                	jne    8004207224 <envid2env+0x5d>
		*env_store = curenv;
  80042071e2:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042071e9:	00 00 00 
  80042071ec:	ff d0                	callq  *%rax
  80042071ee:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042071f5:	00 00 00 
  80042071f8:	48 98                	cltq   
  80042071fa:	48 c1 e0 03          	shl    $0x3,%rax
  80042071fe:	48 89 c2             	mov    %rax,%rdx
  8004207201:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207205:	48 29 c2             	sub    %rax,%rdx
  8004207208:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420720c:	48 83 c0 08          	add    $0x8,%rax
  8004207210:	48 8b 10             	mov    (%rax),%rdx
  8004207213:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207217:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  800420721a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420721f:	e9 09 01 00 00       	jmpq   800420732d <envid2env+0x166>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207224:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420722b:	00 00 00 
  800420722e:	48 8b 08             	mov    (%rax),%rcx
  8004207231:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207234:	48 98                	cltq   
  8004207236:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420723b:	48 89 c2             	mov    %rax,%rdx
  800420723e:	48 89 d0             	mov    %rdx,%rax
  8004207241:	48 c1 e0 03          	shl    $0x3,%rax
  8004207245:	48 01 d0             	add    %rdx,%rax
  8004207248:	48 c1 e0 05          	shl    $0x5,%rax
  800420724c:	48 01 c8             	add    %rcx,%rax
  800420724f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207253:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207257:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420725d:	85 c0                	test   %eax,%eax
  800420725f:	74 0f                	je     8004207270 <envid2env+0xa9>
  8004207261:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207265:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420726b:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  800420726e:	74 15                	je     8004207285 <envid2env+0xbe>
		*env_store = 0;
  8004207270:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207274:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  800420727b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207280:	e9 a8 00 00 00       	jmpq   800420732d <envid2env+0x166>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207285:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207289:	0f 84 8e 00 00 00    	je     800420731d <envid2env+0x156>
  800420728f:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004207296:	00 00 00 
  8004207299:	ff d0                	callq  *%rax
  800420729b:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042072a2:	00 00 00 
  80042072a5:	48 98                	cltq   
  80042072a7:	48 c1 e0 03          	shl    $0x3,%rax
  80042072ab:	48 89 c2             	mov    %rax,%rdx
  80042072ae:	48 c1 e2 04          	shl    $0x4,%rdx
  80042072b2:	48 29 c2             	sub    %rax,%rdx
  80042072b5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042072b9:	48 83 c0 08          	add    $0x8,%rax
  80042072bd:	48 8b 00             	mov    (%rax),%rax
  80042072c0:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042072c4:	74 57                	je     800420731d <envid2env+0x156>
  80042072c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042072ca:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  80042072d0:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042072d7:	00 00 00 
  80042072da:	ff d0                	callq  *%rax
  80042072dc:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042072e3:	00 00 00 
  80042072e6:	48 98                	cltq   
  80042072e8:	48 c1 e0 03          	shl    $0x3,%rax
  80042072ec:	48 89 c2             	mov    %rax,%rdx
  80042072ef:	48 c1 e2 04          	shl    $0x4,%rdx
  80042072f3:	48 29 c2             	sub    %rax,%rdx
  80042072f6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042072fa:	48 83 c0 08          	add    $0x8,%rax
  80042072fe:	48 8b 00             	mov    (%rax),%rax
  8004207301:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207307:	39 c3                	cmp    %eax,%ebx
  8004207309:	74 12                	je     800420731d <envid2env+0x156>
		*env_store = 0;
  800420730b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420730f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207316:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420731b:	eb 10                	jmp    800420732d <envid2env+0x166>
	}

	*env_store = e;
  800420731d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207321:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207325:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207328:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420732d:	48 83 c4 28          	add    $0x28,%rsp
  8004207331:	5b                   	pop    %rbx
  8004207332:	5d                   	pop    %rbp
  8004207333:	c3                   	retq   

0000008004207334 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  8004207334:	55                   	push   %rbp
  8004207335:	48 89 e5             	mov    %rsp,%rbp
  8004207338:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	


	env_free_list = &envs[0];
  800420733c:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  8004207343:	00 00 00 
  8004207346:	48 8b 10             	mov    (%rax),%rdx
  8004207349:	48 b8 58 32 3d 04 80 	movabs $0x80043d3258,%rax
  8004207350:	00 00 00 
  8004207353:	48 89 10             	mov    %rdx,(%rax)
	struct Env *last = NULL;
  8004207356:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420735d:	00 
	int i;
	for(i=0; i< NENV; i++){
  800420735e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004207365:	e9 ff 00 00 00       	jmpq   8004207469 <env_init+0x135>
		envs[i].env_id = 0;
  800420736a:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  8004207371:	00 00 00 
  8004207374:	48 8b 08             	mov    (%rax),%rcx
  8004207377:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420737a:	48 63 d0             	movslq %eax,%rdx
  800420737d:	48 89 d0             	mov    %rdx,%rax
  8004207380:	48 c1 e0 03          	shl    $0x3,%rax
  8004207384:	48 01 d0             	add    %rdx,%rax
  8004207387:	48 c1 e0 05          	shl    $0x5,%rax
  800420738b:	48 01 c8             	add    %rcx,%rax
  800420738e:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  8004207395:	00 00 00 
		envs[i].env_status = ENV_FREE;
  8004207398:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420739f:	00 00 00 
  80042073a2:	48 8b 08             	mov    (%rax),%rcx
  80042073a5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042073a8:	48 63 d0             	movslq %eax,%rdx
  80042073ab:	48 89 d0             	mov    %rdx,%rax
  80042073ae:	48 c1 e0 03          	shl    $0x3,%rax
  80042073b2:	48 01 d0             	add    %rdx,%rax
  80042073b5:	48 c1 e0 05          	shl    $0x5,%rax
  80042073b9:	48 01 c8             	add    %rcx,%rax
  80042073bc:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042073c3:	00 00 00 
		envs[i].env_link = NULL;
  80042073c6:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  80042073cd:	00 00 00 
  80042073d0:	48 8b 08             	mov    (%rax),%rcx
  80042073d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042073d6:	48 63 d0             	movslq %eax,%rdx
  80042073d9:	48 89 d0             	mov    %rdx,%rax
  80042073dc:	48 c1 e0 03          	shl    $0x3,%rax
  80042073e0:	48 01 d0             	add    %rdx,%rax
  80042073e3:	48 c1 e0 05          	shl    $0x5,%rax
  80042073e7:	48 01 c8             	add    %rcx,%rax
  80042073ea:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  80042073f1:	00 00 00 00 
		if(last == NULL){
  80042073f5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042073fa:	75 2a                	jne    8004207426 <env_init+0xf2>
			last = &envs[i];
  80042073fc:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  8004207403:	00 00 00 
  8004207406:	48 8b 08             	mov    (%rax),%rcx
  8004207409:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420740c:	48 63 d0             	movslq %eax,%rdx
  800420740f:	48 89 d0             	mov    %rdx,%rax
  8004207412:	48 c1 e0 03          	shl    $0x3,%rax
  8004207416:	48 01 d0             	add    %rdx,%rax
  8004207419:	48 c1 e0 05          	shl    $0x5,%rax
  800420741d:	48 01 c8             	add    %rcx,%rax
  8004207420:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207424:	eb 3f                	jmp    8004207465 <env_init+0x131>
		} else {
			last->env_link = &envs[i];
  8004207426:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420742d:	00 00 00 
  8004207430:	48 8b 08             	mov    (%rax),%rcx
  8004207433:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207436:	48 63 d0             	movslq %eax,%rdx
  8004207439:	48 89 d0             	mov    %rdx,%rax
  800420743c:	48 c1 e0 03          	shl    $0x3,%rax
  8004207440:	48 01 d0             	add    %rdx,%rax
  8004207443:	48 c1 e0 05          	shl    $0x5,%rax
  8004207447:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420744b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420744f:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
			last = last->env_link;
  8004207456:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420745a:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  8004207461:	48 89 45 f8          	mov    %rax,-0x8(%rbp)


	env_free_list = &envs[0];
	struct Env *last = NULL;
	int i;
	for(i=0; i< NENV; i++){
  8004207465:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004207469:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%rbp)
  8004207470:	0f 8e f4 fe ff ff    	jle    800420736a <env_init+0x36>




	// Per-CPU part of the initialization
	env_init_percpu();
  8004207476:	48 b8 84 74 20 04 80 	movabs $0x8004207484,%rax
  800420747d:	00 00 00 
  8004207480:	ff d0                	callq  *%rax
}
  8004207482:	c9                   	leaveq 
  8004207483:	c3                   	retq   

0000008004207484 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207484:	55                   	push   %rbp
  8004207485:	48 89 e5             	mov    %rsp,%rbp
  8004207488:	53                   	push   %rbx
  8004207489:	48 83 ec 10          	sub    $0x10,%rsp
  800420748d:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004207494:	00 00 00 
  8004207497:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  800420749b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420749f:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  80042074a2:	b8 23 00 00 00       	mov    $0x23,%eax
  80042074a7:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  80042074a9:	b8 23 00 00 00       	mov    $0x23,%eax
  80042074ae:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  80042074b0:	b8 10 00 00 00       	mov    $0x10,%eax
  80042074b5:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  80042074b7:	b8 10 00 00 00       	mov    $0x10,%eax
  80042074bc:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  80042074be:	b8 10 00 00 00       	mov    $0x10,%eax
  80042074c3:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  80042074c5:	b8 08 00 00 00       	mov    $0x8,%eax
  80042074ca:	89 c3                	mov    %eax,%ebx
  80042074cc:	53                   	push   %rbx
  80042074cd:	48 b8 da 74 20 04 80 	movabs $0x80042074da,%rax
  80042074d4:	00 00 00 
  80042074d7:	50                   	push   %rax
  80042074d8:	48 cb                	lretq  
  80042074da:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  80042074e0:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80042074e4:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  80042074e7:	48 83 c4 10          	add    $0x10,%rsp
  80042074eb:	5b                   	pop    %rbx
  80042074ec:	5d                   	pop    %rbp
  80042074ed:	c3                   	retq   

00000080042074ee <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  80042074ee:	55                   	push   %rbp
  80042074ef:	48 89 e5             	mov    %rsp,%rbp
  80042074f2:	48 83 ec 20          	sub    $0x20,%rsp
  80042074f6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042074fa:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207501:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207502:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207507:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  800420750e:	00 00 00 
  8004207511:	ff d0                	callq  *%rax
  8004207513:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207517:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420751c:	75 0a                	jne    8004207528 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  800420751e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207523:	e9 98 00 00 00       	jmpq   80042075c0 <env_setup_vm+0xd2>





	e->env_pml4e = page2kva(p);
  8004207528:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420752c:	48 89 c7             	mov    %rax,%rdi
  800420752f:	48 b8 21 71 20 04 80 	movabs $0x8004207121,%rax
  8004207536:	00 00 00 
  8004207539:	ff d0                	callq  *%rax
  800420753b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420753f:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3 = page2pa(p);
  8004207546:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420754a:	48 89 c7             	mov    %rax,%rdi
  800420754d:	48 b8 8b 70 20 04 80 	movabs $0x800420708b,%rax
  8004207554:	00 00 00 
  8004207557:	ff d0                	callq  *%rax
  8004207559:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420755d:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)
	p->pp_ref++;
  8004207564:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207568:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420756c:	8d 50 01             	lea    0x1(%rax),%edx
  800420756f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207573:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e[1] = boot_pml4e[1];
  8004207577:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420757b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207582:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004207586:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420758d:	00 00 00 
  8004207590:	48 8b 00             	mov    (%rax),%rax
  8004207593:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207597:	48 89 02             	mov    %rax,(%rdx)



	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  800420759a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420759e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042075a5:	48 8d 50 10          	lea    0x10(%rax),%rdx
  80042075a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042075ad:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042075b4:	48 83 c8 05          	or     $0x5,%rax
  80042075b8:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  80042075bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042075c0:	c9                   	leaveq 
  80042075c1:	c3                   	retq   

00000080042075c2 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042075c2:	55                   	push   %rbp
  80042075c3:	48 89 e5             	mov    %rsp,%rbp
  80042075c6:	53                   	push   %rbx
  80042075c7:	48 83 ec 38          	sub    $0x38,%rsp
  80042075cb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042075cf:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  80042075d2:	48 b8 58 32 3d 04 80 	movabs $0x80043d3258,%rax
  80042075d9:	00 00 00 
  80042075dc:	48 8b 00             	mov    (%rax),%rax
  80042075df:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042075e3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042075e8:	75 0a                	jne    80042075f4 <env_alloc+0x32>
		return -E_NO_FREE_ENV;
  80042075ea:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042075ef:	e9 13 02 00 00       	jmpq   8004207807 <env_alloc+0x245>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  80042075f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042075f8:	48 89 c7             	mov    %rax,%rdi
  80042075fb:	48 b8 ee 74 20 04 80 	movabs $0x80042074ee,%rax
  8004207602:	00 00 00 
  8004207605:	ff d0                	callq  *%rax
  8004207607:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420760a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420760e:	79 08                	jns    8004207618 <env_alloc+0x56>
		return r;
  8004207610:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207613:	e9 ef 01 00 00       	jmpq   8004207807 <env_alloc+0x245>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207618:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420761c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207622:	05 00 10 00 00       	add    $0x1000,%eax
  8004207627:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  800420762c:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  800420762f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004207633:	7f 07                	jg     800420763c <env_alloc+0x7a>
		generation = 1 << ENVGENSHIFT;
  8004207635:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%rbp)
	e->env_id = generation | (e - envs);
  800420763c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004207640:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  8004207647:	00 00 00 
  800420764a:	48 8b 00             	mov    (%rax),%rax
  800420764d:	48 29 c2             	sub    %rax,%rdx
  8004207650:	48 89 d0             	mov    %rdx,%rax
  8004207653:	48 c1 f8 05          	sar    $0x5,%rax
  8004207657:	48 89 c2             	mov    %rax,%rdx
  800420765a:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  8004207661:	e3 38 8e 
  8004207664:	48 0f af c2          	imul   %rdx,%rax
  8004207668:	0b 45 ec             	or     -0x14(%rbp),%eax
  800420766b:	89 c2                	mov    %eax,%edx
  800420766d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207671:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207677:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420767b:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420767e:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004207684:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207688:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  800420768f:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207692:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207696:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420769d:	00 00 00 
	e->env_runs = 0;
  80042076a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042076a4:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  80042076ab:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  80042076ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042076b2:	ba c0 00 00 00       	mov    $0xc0,%edx
  80042076b7:	be 00 00 00 00       	mov    $0x0,%esi
  80042076bc:	48 89 c7             	mov    %rax,%rdi
  80042076bf:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  80042076c6:	00 00 00 
  80042076c9:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  80042076cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042076cf:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  80042076d6:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  80042076d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042076dc:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  80042076e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042076e6:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  80042076ed:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  80042076ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042076f3:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  80042076f8:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  80042076ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207703:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  800420770a:	1b 00 
	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	


	e->env_tf.tf_eflags |= FL_IF;
  800420770c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207710:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207717:	80 cc 02             	or     $0x2,%ah
  800420771a:	48 89 c2             	mov    %rax,%rdx
  800420771d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207721:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)



	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207728:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420772c:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004207733:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207737:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420773b:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004207742:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207746:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  800420774d:	48 b8 58 32 3d 04 80 	movabs $0x80043d3258,%rax
  8004207754:	00 00 00 
  8004207757:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  800420775a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420775e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004207762:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004207765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207769:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  800420776f:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004207776:	00 00 00 
  8004207779:	ff d0                	callq  *%rax
  800420777b:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  8004207782:	00 00 00 
  8004207785:	48 98                	cltq   
  8004207787:	48 c1 e0 03          	shl    $0x3,%rax
  800420778b:	48 89 c2             	mov    %rax,%rdx
  800420778e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207792:	48 29 c2             	sub    %rax,%rdx
  8004207795:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207799:	48 83 c0 08          	add    $0x8,%rax
  800420779d:	48 8b 00             	mov    (%rax),%rax
  80042077a0:	48 85 c0             	test   %rax,%rax
  80042077a3:	74 39                	je     80042077de <env_alloc+0x21c>
  80042077a5:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042077ac:	00 00 00 
  80042077af:	ff d0                	callq  *%rax
  80042077b1:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042077b8:	00 00 00 
  80042077bb:	48 98                	cltq   
  80042077bd:	48 c1 e0 03          	shl    $0x3,%rax
  80042077c1:	48 89 c2             	mov    %rax,%rdx
  80042077c4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042077c8:	48 29 c2             	sub    %rax,%rdx
  80042077cb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042077cf:	48 83 c0 08          	add    $0x8,%rax
  80042077d3:	48 8b 00             	mov    (%rax),%rax
  80042077d6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042077dc:	eb 05                	jmp    80042077e3 <env_alloc+0x221>
  80042077de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077e3:	89 da                	mov    %ebx,%edx
  80042077e5:	89 c6                	mov    %eax,%esi
  80042077e7:	48 bf ab 76 21 04 80 	movabs $0x80042176ab,%rdi
  80042077ee:	00 00 00 
  80042077f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077f6:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  80042077fd:	00 00 00 
  8004207800:	ff d1                	callq  *%rcx
	return 0;
  8004207802:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207807:	48 83 c4 38          	add    $0x38,%rsp
  800420780b:	5b                   	pop    %rbx
  800420780c:	5d                   	pop    %rbp
  800420780d:	c3                   	retq   

000000800420780e <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  800420780e:	55                   	push   %rbp
  800420780f:	48 89 e5             	mov    %rsp,%rbp
  8004207812:	48 83 ec 60          	sub    $0x60,%rsp
  8004207816:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420781a:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420781e:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
	// LAB 3: Your code here.




	void *start = ROUNDDOWN(va, PGSIZE);
  8004207822:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004207826:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420782a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420782e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207834:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  		void *end = ROUNDUP(va + len, PGSIZE);
  8004207838:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  800420783f:	00 
  8004207840:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207844:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207848:	48 01 d0             	add    %rdx,%rax
  800420784b:	48 89 c2             	mov    %rax,%rdx
  800420784e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207852:	48 01 d0             	add    %rdx,%rax
  8004207855:	48 83 e8 01          	sub    $0x1,%rax
  8004207859:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420785d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207861:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207866:	48 f7 75 e8          	divq   -0x18(%rbp)
  800420786a:	48 89 d0             	mov    %rdx,%rax
  800420786d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004207871:	48 29 c2             	sub    %rax,%rdx
  8004207874:	48 89 d0             	mov    %rdx,%rax
  8004207877:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  		for(; start < end; start += PGSIZE) {
  800420787b:	e9 c3 00 00 00       	jmpq   8004207943 <region_alloc+0x135>
     		 struct PageInfo *pp = page_alloc(0);
  8004207880:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207885:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  800420788c:	00 00 00 
  800420788f:	ff d0                	callq  *%rax
  8004207891:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
      		if (pp) {
  8004207895:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420789a:	74 7d                	je     8004207919 <region_alloc+0x10b>
        	  pp->pp_ref++;
  800420789c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042078a0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042078a4:	8d 50 01             	lea    0x1(%rax),%edx
  80042078a7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042078ab:	66 89 50 08          	mov    %dx,0x8(%rax)
         	 int ret = page_insert(e->env_pml4e, pp, start, PTE_W | PTE_U);
  80042078af:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042078b3:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042078ba:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042078be:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042078c2:	b9 06 00 00 00       	mov    $0x6,%ecx
  80042078c7:	48 89 c7             	mov    %rax,%rdi
  80042078ca:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  80042078d1:	00 00 00 
  80042078d4:	ff d0                	callq  *%rax
  80042078d6:	89 45 cc             	mov    %eax,-0x34(%rbp)
         	 if (ret < 0) {
  80042078d9:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042078dd:	79 30                	jns    800420790f <region_alloc+0x101>
         	     panic("region_alloc: %e \n", ret);
  80042078df:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042078e2:	89 c1                	mov    %eax,%ecx
  80042078e4:	48 ba c0 76 21 04 80 	movabs $0x80042176c0,%rdx
  80042078eb:	00 00 00 
  80042078ee:	be 4d 01 00 00       	mov    $0x14d,%esi
  80042078f3:	48 bf d3 76 21 04 80 	movabs $0x80042176d3,%rdi
  80042078fa:	00 00 00 
  80042078fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207902:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004207909:	00 00 00 
  800420790c:	41 ff d0             	callq  *%r8



	void *start = ROUNDDOWN(va, PGSIZE);
  		void *end = ROUNDUP(va + len, PGSIZE);
  		for(; start < end; start += PGSIZE) {
  800420790f:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207916:	00 
  8004207917:	eb 2a                	jmp    8004207943 <region_alloc+0x135>
         	 int ret = page_insert(e->env_pml4e, pp, start, PTE_W | PTE_U);
         	 if (ret < 0) {
         	     panic("region_alloc: %e \n", ret);
       		   }
     		 } else {
       			   panic("region_alloc: page allocation failed!! \n");
  8004207919:	48 ba e0 76 21 04 80 	movabs $0x80042176e0,%rdx
  8004207920:	00 00 00 
  8004207923:	be 50 01 00 00       	mov    $0x150,%esi
  8004207928:	48 bf d3 76 21 04 80 	movabs $0x80042176d3,%rdi
  800420792f:	00 00 00 
  8004207932:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207937:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  800420793e:	00 00 00 
  8004207941:	ff d1                	callq  *%rcx



	void *start = ROUNDDOWN(va, PGSIZE);
  		void *end = ROUNDUP(va + len, PGSIZE);
  		for(; start < end; start += PGSIZE) {
  8004207943:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207947:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420794b:	0f 82 2f ff ff ff    	jb     8004207880 <region_alloc+0x72>
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
}
  8004207951:	c9                   	leaveq 
  8004207952:	c3                   	retq   

0000008004207953 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207953:	55                   	push   %rbp
  8004207954:	48 89 e5             	mov    %rsp,%rbp
  8004207957:	48 83 ec 40          	sub    $0x40,%rsp
  800420795b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420795f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	// LAB 3: Your code here
	// Now map one page for the program's initial stack
	// at virtual address USTACKTOP - PGSIZE.

	// LAB 3: Your code here.
	e->elf = binary;
  8004207963:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207967:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420796b:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)


  struct Proghdr *program_header, *end_program_header;
  struct Elf *elf = (struct Elf *) binary;
  8004207972:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207976:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  program_header = (struct Proghdr *) (binary + elf->e_phoff);
  800420797a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420797e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207982:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207986:	48 01 d0             	add    %rdx,%rax
  8004207989:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  end_program_header = program_header + elf->e_phnum;
  800420798d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207991:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004207995:	0f b7 c0             	movzwl %ax,%eax
  8004207998:	48 c1 e0 03          	shl    $0x3,%rax
  800420799c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042079a3:	00 
  80042079a4:	48 29 c2             	sub    %rax,%rdx
  80042079a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079ab:	48 01 d0             	add    %rdx,%rax
  80042079ae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  lcr3(e->env_cr3); // Important!
  80042079b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042079b6:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042079bd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  80042079c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042079c5:	0f 22 d8             	mov    %rax,%cr3

  for (; program_header < end_program_header; program_header++) {
  80042079c8:	e9 a8 00 00 00       	jmpq   8004207a75 <load_icode+0x122>
      if (program_header->p_type == ELF_PROG_LOAD) {
  80042079cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079d1:	8b 00                	mov    (%rax),%eax
  80042079d3:	83 f8 01             	cmp    $0x1,%eax
  80042079d6:	0f 85 94 00 00 00    	jne    8004207a70 <load_icode+0x11d>
          region_alloc(e, (void *) program_header->p_va, program_header->p_memsz);
  80042079dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079e0:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042079e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079e8:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042079ec:	48 89 c1             	mov    %rax,%rcx
  80042079ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042079f3:	48 89 ce             	mov    %rcx,%rsi
  80042079f6:	48 89 c7             	mov    %rax,%rdi
  80042079f9:	48 b8 0e 78 20 04 80 	movabs $0x800420780e,%rax
  8004207a00:	00 00 00 
  8004207a03:	ff d0                	callq  *%rax
          memmove((void *) program_header->p_va, (void *)binary + program_header->p_offset, program_header->p_filesz);
  8004207a05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a09:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207a0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a11:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004207a15:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207a19:	48 01 c1             	add    %rax,%rcx
  8004207a1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a20:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207a24:	48 89 ce             	mov    %rcx,%rsi
  8004207a27:	48 89 c7             	mov    %rax,%rdi
  8004207a2a:	48 b8 68 ee 20 04 80 	movabs $0x800420ee68,%rax
  8004207a31:	00 00 00 
  8004207a34:	ff d0                	callq  *%rax
          memset((void *)program_header->p_va + program_header->p_filesz, 0, program_header->p_memsz - program_header->p_filesz);
  8004207a36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a3a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207a3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a42:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004207a46:	48 29 c2             	sub    %rax,%rdx
  8004207a49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a4d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004207a51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a55:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207a59:	48 01 c8             	add    %rcx,%rax
  8004207a5c:	be 00 00 00 00       	mov    $0x0,%esi
  8004207a61:	48 89 c7             	mov    %rax,%rdi
  8004207a64:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004207a6b:	00 00 00 
  8004207a6e:	ff d0                	callq  *%rax
  program_header = (struct Proghdr *) (binary + elf->e_phoff);
  end_program_header = program_header + elf->e_phnum;

  lcr3(e->env_cr3); // Important!

  for (; program_header < end_program_header; program_header++) {
  8004207a70:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004207a75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a79:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207a7d:	0f 82 4a ff ff ff    	jb     80042079cd <load_icode+0x7a>
          memmove((void *) program_header->p_va, (void *)binary + program_header->p_offset, program_header->p_filesz);
          memset((void *)program_header->p_va + program_header->p_filesz, 0, program_header->p_memsz - program_header->p_filesz);
      }
  }

  lcr3(boot_cr3);
  8004207a83:	48 b8 20 47 3d 04 80 	movabs $0x80043d4720,%rax
  8004207a8a:	00 00 00 
  8004207a8d:	48 8b 00             	mov    (%rax),%rax
  8004207a90:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004207a94:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207a98:	0f 22 d8             	mov    %rax,%cr3

  region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE); // the stack for user space
  8004207a9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207a9f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004207aa4:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004207aa9:	48 89 c7             	mov    %rax,%rdi
  8004207aac:	48 b8 0e 78 20 04 80 	movabs $0x800420780e,%rax
  8004207ab3:	00 00 00 
  8004207ab6:	ff d0                	callq  *%rax
  e->env_tf.tf_rip = elf->e_entry;
  8004207ab8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207abc:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004207ac0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207ac4:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
}
  8004207acb:	c9                   	leaveq 
  8004207acc:	c3                   	retq   

0000008004207acd <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004207acd:	55                   	push   %rbp
  8004207ace:	48 89 e5             	mov    %rsp,%rbp
  8004207ad1:	48 83 ec 20          	sub    $0x20,%rsp
  8004207ad5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004207ad9:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.
	struct Env *env;
	int ret = env_alloc(&env, 0);
  8004207adc:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004207ae0:	be 00 00 00 00       	mov    $0x0,%esi
  8004207ae5:	48 89 c7             	mov    %rax,%rdi
  8004207ae8:	48 b8 c2 75 20 04 80 	movabs $0x80042075c2,%rax
  8004207aef:	00 00 00 
  8004207af2:	ff d0                	callq  *%rax
  8004207af4:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (ret < 0) {
  8004207af7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207afb:	79 30                	jns    8004207b2d <env_create+0x60>
			panic("env_alloc: %e", ret);
  8004207afd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207b00:	89 c1                	mov    %eax,%ecx
  8004207b02:	48 ba 09 77 21 04 80 	movabs $0x8004217709,%rdx
  8004207b09:	00 00 00 
  8004207b0c:	be bf 01 00 00       	mov    $0x1bf,%esi
  8004207b11:	48 bf d3 76 21 04 80 	movabs $0x80042176d3,%rdi
  8004207b18:	00 00 00 
  8004207b1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b20:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004207b27:	00 00 00 
  8004207b2a:	41 ff d0             	callq  *%r8
	}
	load_icode(env, binary);
  8004207b2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b31:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207b35:	48 89 d6             	mov    %rdx,%rsi
  8004207b38:	48 89 c7             	mov    %rax,%rdi
  8004207b3b:	48 b8 53 79 20 04 80 	movabs $0x8004207953,%rax
  8004207b42:	00 00 00 
  8004207b45:	ff d0                	callq  *%rax
	env->env_type = type;
  8004207b47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b4b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004207b4e:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
}
  8004207b54:	c9                   	leaveq 
  8004207b55:	c3                   	retq   

0000008004207b56 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004207b56:	55                   	push   %rbp
  8004207b57:	48 89 e5             	mov    %rsp,%rbp
  8004207b5a:	53                   	push   %rbx
  8004207b5b:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004207b62:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004207b69:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004207b70:	00 00 00 
  8004207b73:	ff d0                	callq  *%rax
  8004207b75:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  8004207b7c:	00 00 00 
  8004207b7f:	48 98                	cltq   
  8004207b81:	48 c1 e0 03          	shl    $0x3,%rax
  8004207b85:	48 89 c2             	mov    %rax,%rdx
  8004207b88:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207b8c:	48 29 c2             	sub    %rax,%rdx
  8004207b8f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207b93:	48 83 c0 08          	add    $0x8,%rax
  8004207b97:	48 8b 00             	mov    (%rax),%rax
  8004207b9a:	48 3b 85 68 ff ff ff 	cmp    -0x98(%rbp),%rax
  8004207ba1:	75 1e                	jne    8004207bc1 <env_free+0x6b>
		lcr3(boot_cr3);
  8004207ba3:	48 b8 20 47 3d 04 80 	movabs $0x80043d4720,%rax
  8004207baa:	00 00 00 
  8004207bad:	48 8b 00             	mov    (%rax),%rax
  8004207bb0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004207bb7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207bbe:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004207bc1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207bc8:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004207bce:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004207bd5:	00 00 00 
  8004207bd8:	ff d0                	callq  *%rax
  8004207bda:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  8004207be1:	00 00 00 
  8004207be4:	48 98                	cltq   
  8004207be6:	48 c1 e0 03          	shl    $0x3,%rax
  8004207bea:	48 89 c2             	mov    %rax,%rdx
  8004207bed:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207bf1:	48 29 c2             	sub    %rax,%rdx
  8004207bf4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207bf8:	48 83 c0 08          	add    $0x8,%rax
  8004207bfc:	48 8b 00             	mov    (%rax),%rax
  8004207bff:	48 85 c0             	test   %rax,%rax
  8004207c02:	74 39                	je     8004207c3d <env_free+0xe7>
  8004207c04:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004207c0b:	00 00 00 
  8004207c0e:	ff d0                	callq  *%rax
  8004207c10:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  8004207c17:	00 00 00 
  8004207c1a:	48 98                	cltq   
  8004207c1c:	48 c1 e0 03          	shl    $0x3,%rax
  8004207c20:	48 89 c2             	mov    %rax,%rdx
  8004207c23:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207c27:	48 29 c2             	sub    %rax,%rdx
  8004207c2a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207c2e:	48 83 c0 08          	add    $0x8,%rax
  8004207c32:	48 8b 00             	mov    (%rax),%rax
  8004207c35:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207c3b:	eb 05                	jmp    8004207c42 <env_free+0xec>
  8004207c3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c42:	89 da                	mov    %ebx,%edx
  8004207c44:	89 c6                	mov    %eax,%esi
  8004207c46:	48 bf 17 77 21 04 80 	movabs $0x8004217717,%rdi
  8004207c4d:	00 00 00 
  8004207c50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c55:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  8004207c5c:	00 00 00 
  8004207c5f:	ff d1                	callq  *%rcx

	// Flush all mapped pages in the user portion of the address space
	if (e->env_pml4e[0] & PTE_P) {
  8004207c61:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207c68:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207c6f:	48 8b 00             	mov    (%rax),%rax
  8004207c72:	83 e0 01             	and    $0x1,%eax
  8004207c75:	48 85 c0             	test   %rax,%rax
  8004207c78:	0f 84 7a 03 00 00    	je     8004207ff8 <env_free+0x4a2>
		pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004207c7e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207c85:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207c8c:	48 8b 00             	mov    (%rax),%rax
  8004207c8f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207c95:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004207c99:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207c9d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207ca1:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004207ca4:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004207ca7:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004207cae:	00 00 00 
  8004207cb1:	48 8b 00             	mov    (%rax),%rax
  8004207cb4:	48 39 c2             	cmp    %rax,%rdx
  8004207cb7:	72 32                	jb     8004207ceb <env_free+0x195>
  8004207cb9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207cbd:	48 89 c1             	mov    %rax,%rcx
  8004207cc0:	48 ba 88 76 21 04 80 	movabs $0x8004217688,%rdx
  8004207cc7:	00 00 00 
  8004207cca:	be da 01 00 00       	mov    $0x1da,%esi
  8004207ccf:	48 bf d3 76 21 04 80 	movabs $0x80042176d3,%rdi
  8004207cd6:	00 00 00 
  8004207cd9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207cde:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004207ce5:	00 00 00 
  8004207ce8:	41 ff d0             	callq  *%r8
  8004207ceb:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207cf2:	00 00 00 
  8004207cf5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207cf9:	48 01 d0             	add    %rdx,%rax
  8004207cfc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		int pdeno_limit;
		uint64_t pdpe_index;
		// using 3 instead of NPDPENTRIES as we have only first three indices
		// set for 4GB of address space.
		for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004207d00:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004207d07:	00 
  8004207d08:	e9 ab 02 00 00       	jmpq   8004207fb8 <env_free+0x462>
			if(!(env_pdpe[pdpe_index] & PTE_P))
  8004207d0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207d11:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207d18:	00 
  8004207d19:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207d1d:	48 01 d0             	add    %rdx,%rax
  8004207d20:	48 8b 00             	mov    (%rax),%rax
  8004207d23:	83 e0 01             	and    $0x1,%eax
  8004207d26:	48 85 c0             	test   %rax,%rax
  8004207d29:	75 05                	jne    8004207d30 <env_free+0x1da>
				continue;
  8004207d2b:	e9 83 02 00 00       	jmpq   8004207fb3 <env_free+0x45d>
			pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004207d30:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207d34:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207d3b:	00 
  8004207d3c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207d40:	48 01 d0             	add    %rdx,%rax
  8004207d43:	48 8b 00             	mov    (%rax),%rax
  8004207d46:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207d4c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004207d50:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207d54:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207d58:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004207d5b:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004207d5e:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004207d65:	00 00 00 
  8004207d68:	48 8b 00             	mov    (%rax),%rax
  8004207d6b:	48 39 c2             	cmp    %rax,%rdx
  8004207d6e:	72 32                	jb     8004207da2 <env_free+0x24c>
  8004207d70:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207d74:	48 89 c1             	mov    %rax,%rcx
  8004207d77:	48 ba 88 76 21 04 80 	movabs $0x8004217688,%rdx
  8004207d7e:	00 00 00 
  8004207d81:	be e2 01 00 00       	mov    $0x1e2,%esi
  8004207d86:	48 bf d3 76 21 04 80 	movabs $0x80042176d3,%rdi
  8004207d8d:	00 00 00 
  8004207d90:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d95:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004207d9c:	00 00 00 
  8004207d9f:	41 ff d0             	callq  *%r8
  8004207da2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207da9:	00 00 00 
  8004207dac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207db0:	48 01 d0             	add    %rdx,%rax
  8004207db3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004207db7:	48 83 7d d8 03       	cmpq   $0x3,-0x28(%rbp)
  8004207dbc:	75 07                	jne    8004207dc5 <env_free+0x26f>
  8004207dbe:	b8 04 00 00 00       	mov    $0x4,%eax
  8004207dc3:	eb 05                	jmp    8004207dca <env_free+0x274>
  8004207dc5:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004207dca:	89 45 a4             	mov    %eax,-0x5c(%rbp)
			static_assert(UTOP % PTSIZE == 0);
			for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004207dcd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004207dd4:	00 
  8004207dd5:	e9 6e 01 00 00       	jmpq   8004207f48 <env_free+0x3f2>

				// only look at mapped page tables
				if (!(env_pgdir[pdeno] & PTE_P))
  8004207dda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207dde:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207de5:	00 
  8004207de6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207dea:	48 01 d0             	add    %rdx,%rax
  8004207ded:	48 8b 00             	mov    (%rax),%rax
  8004207df0:	83 e0 01             	and    $0x1,%eax
  8004207df3:	48 85 c0             	test   %rax,%rax
  8004207df6:	75 05                	jne    8004207dfd <env_free+0x2a7>
					continue;
  8004207df8:	e9 46 01 00 00       	jmpq   8004207f43 <env_free+0x3ed>
				// find the pa and va of the page table
				pa = PTE_ADDR(env_pgdir[pdeno]);
  8004207dfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207e01:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207e08:	00 
  8004207e09:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207e0d:	48 01 d0             	add    %rdx,%rax
  8004207e10:	48 8b 00             	mov    (%rax),%rax
  8004207e13:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207e19:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				pt = (pte_t*) KADDR(pa);
  8004207e1d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207e21:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004207e25:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004207e29:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207e2d:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004207e30:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004207e33:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004207e3a:	00 00 00 
  8004207e3d:	48 8b 00             	mov    (%rax),%rax
  8004207e40:	48 39 c2             	cmp    %rax,%rdx
  8004207e43:	72 32                	jb     8004207e77 <env_free+0x321>
  8004207e45:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004207e49:	48 89 c1             	mov    %rax,%rcx
  8004207e4c:	48 ba 88 76 21 04 80 	movabs $0x8004217688,%rdx
  8004207e53:	00 00 00 
  8004207e56:	be ec 01 00 00       	mov    $0x1ec,%esi
  8004207e5b:	48 bf d3 76 21 04 80 	movabs $0x80042176d3,%rdi
  8004207e62:	00 00 00 
  8004207e65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e6a:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004207e71:	00 00 00 
  8004207e74:	41 ff d0             	callq  *%r8
  8004207e77:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207e7e:	00 00 00 
  8004207e81:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004207e85:	48 01 d0             	add    %rdx,%rax
  8004207e88:	48 89 45 80          	mov    %rax,-0x80(%rbp)

				// unmap all PTEs in this page table
				for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004207e8c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004207e93:	00 
  8004207e94:	eb 67                	jmp    8004207efd <env_free+0x3a7>
					if (pt[pteno] & PTE_P){
  8004207e96:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207e9a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207ea1:	00 
  8004207ea2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004207ea6:	48 01 d0             	add    %rdx,%rax
  8004207ea9:	48 8b 00             	mov    (%rax),%rax
  8004207eac:	83 e0 01             	and    $0x1,%eax
  8004207eaf:	48 85 c0             	test   %rax,%rax
  8004207eb2:	74 44                	je     8004207ef8 <env_free+0x3a2>
						page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004207eb4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207eb8:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004207ebc:	48 89 c2             	mov    %rax,%rdx
  8004207ebf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207ec3:	48 c1 e0 15          	shl    $0x15,%rax
  8004207ec7:	48 09 c2             	or     %rax,%rdx
  8004207eca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207ece:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207ed2:	48 09 d0             	or     %rdx,%rax
  8004207ed5:	48 89 c2             	mov    %rax,%rdx
  8004207ed8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207edf:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207ee6:	48 89 d6             	mov    %rdx,%rsi
  8004207ee9:	48 89 c7             	mov    %rax,%rdi
  8004207eec:	48 b8 8a 31 20 04 80 	movabs $0x800420318a,%rax
  8004207ef3:	00 00 00 
  8004207ef6:	ff d0                	callq  *%rax
				// find the pa and va of the page table
				pa = PTE_ADDR(env_pgdir[pdeno]);
				pt = (pte_t*) KADDR(pa);

				// unmap all PTEs in this page table
				for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004207ef8:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  8004207efd:	48 81 7d e0 fe 01 00 	cmpq   $0x1fe,-0x20(%rbp)
  8004207f04:	00 
  8004207f05:	76 8f                	jbe    8004207e96 <env_free+0x340>
						page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
					}
				}

				// free the page table itself
				env_pgdir[pdeno] = 0;
  8004207f07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f0b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207f12:	00 
  8004207f13:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207f17:	48 01 d0             	add    %rdx,%rax
  8004207f1a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
				page_decref(pa2page(pa));
  8004207f21:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207f25:	48 89 c7             	mov    %rax,%rdi
  8004207f28:	48 b8 b0 70 20 04 80 	movabs $0x80042070b0,%rax
  8004207f2f:	00 00 00 
  8004207f32:	ff d0                	callq  *%rax
  8004207f34:	48 89 c7             	mov    %rax,%rdi
  8004207f37:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004207f3e:	00 00 00 
  8004207f41:	ff d0                	callq  *%rax
			if(!(env_pdpe[pdpe_index] & PTE_P))
				continue;
			pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
			pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
			static_assert(UTOP % PTSIZE == 0);
			for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004207f43:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004207f48:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004207f4b:	48 98                	cltq   
  8004207f4d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207f51:	0f 87 83 fe ff ff    	ja     8004207dda <env_free+0x284>
				// free the page table itself
				env_pgdir[pdeno] = 0;
				page_decref(pa2page(pa));
			}
			// free the page directory
			pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004207f57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207f5b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207f62:	00 
  8004207f63:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207f67:	48 01 d0             	add    %rdx,%rax
  8004207f6a:	48 8b 00             	mov    (%rax),%rax
  8004207f6d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207f73:	48 89 45 98          	mov    %rax,-0x68(%rbp)
			env_pdpe[pdpe_index] = 0;
  8004207f77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207f7b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207f82:	00 
  8004207f83:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207f87:	48 01 d0             	add    %rdx,%rax
  8004207f8a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004207f91:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207f95:	48 89 c7             	mov    %rax,%rdi
  8004207f98:	48 b8 b0 70 20 04 80 	movabs $0x80042070b0,%rax
  8004207f9f:	00 00 00 
  8004207fa2:	ff d0                	callq  *%rax
  8004207fa4:	48 89 c7             	mov    %rax,%rdi
  8004207fa7:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004207fae:	00 00 00 
  8004207fb1:	ff d0                	callq  *%rax
		pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
		int pdeno_limit;
		uint64_t pdpe_index;
		// using 3 instead of NPDPENTRIES as we have only first three indices
		// set for 4GB of address space.
		for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004207fb3:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004207fb8:	48 83 7d d8 03       	cmpq   $0x3,-0x28(%rbp)
  8004207fbd:	0f 86 4a fd ff ff    	jbe    8004207d0d <env_free+0x1b7>
			pa = PTE_ADDR(env_pdpe[pdpe_index]);
			env_pdpe[pdpe_index] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory pointer
		page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004207fc3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207fca:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207fd1:	48 8b 00             	mov    (%rax),%rax
  8004207fd4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207fda:	48 89 c7             	mov    %rax,%rdi
  8004207fdd:	48 b8 b0 70 20 04 80 	movabs $0x80042070b0,%rax
  8004207fe4:	00 00 00 
  8004207fe7:	ff d0                	callq  *%rax
  8004207fe9:	48 89 c7             	mov    %rax,%rdi
  8004207fec:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004207ff3:	00 00 00 
  8004207ff6:	ff d0                	callq  *%rax
	}
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004207ff8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207fff:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208006:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  800420800d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208014:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420801b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	e->env_pml4e = 0;
  800420801f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208026:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  800420802d:	00 00 00 00 
	e->env_cr3 = 0;
  8004208031:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208038:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  800420803f:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208043:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208047:	48 89 c7             	mov    %rax,%rdi
  800420804a:	48 b8 b0 70 20 04 80 	movabs $0x80042070b0,%rax
  8004208051:	00 00 00 
  8004208054:	ff d0                	callq  *%rax
  8004208056:	48 89 c7             	mov    %rax,%rdi
  8004208059:	48 b8 2a 2b 20 04 80 	movabs $0x8004202b2a,%rax
  8004208060:	00 00 00 
  8004208063:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208065:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420806c:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208073:	00 00 00 
	e->env_link = env_free_list;
  8004208076:	48 b8 58 32 3d 04 80 	movabs $0x80043d3258,%rax
  800420807d:	00 00 00 
  8004208080:	48 8b 10             	mov    (%rax),%rdx
  8004208083:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420808a:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208091:	48 b8 58 32 3d 04 80 	movabs $0x80043d3258,%rax
  8004208098:	00 00 00 
  800420809b:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  80042080a2:	48 89 10             	mov    %rdx,(%rax)
}
  80042080a5:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  80042080ac:	5b                   	pop    %rbx
  80042080ad:	5d                   	pop    %rbp
  80042080ae:	c3                   	retq   

00000080042080af <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  80042080af:	55                   	push   %rbp
  80042080b0:	48 89 e5             	mov    %rsp,%rbp
  80042080b3:	48 83 ec 10          	sub    $0x10,%rsp
  80042080b7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  80042080bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080bf:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042080c5:	83 f8 03             	cmp    $0x3,%eax
  80042080c8:	75 4a                	jne    8004208114 <env_destroy+0x65>
  80042080ca:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042080d1:	00 00 00 
  80042080d4:	ff d0                	callq  *%rax
  80042080d6:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042080dd:	00 00 00 
  80042080e0:	48 98                	cltq   
  80042080e2:	48 c1 e0 03          	shl    $0x3,%rax
  80042080e6:	48 89 c2             	mov    %rax,%rdx
  80042080e9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042080ed:	48 29 c2             	sub    %rax,%rdx
  80042080f0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042080f4:	48 83 c0 08          	add    $0x8,%rax
  80042080f8:	48 8b 00             	mov    (%rax),%rax
  80042080fb:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042080ff:	74 13                	je     8004208114 <env_destroy+0x65>
		e->env_status = ENV_DYING;
  8004208101:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208105:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  800420810c:	00 00 00 
		return;
  800420810f:	e9 8b 00 00 00       	jmpq   800420819f <env_destroy+0xf0>
	}

	env_free(e);
  8004208114:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208118:	48 89 c7             	mov    %rax,%rdi
  800420811b:	48 b8 56 7b 20 04 80 	movabs $0x8004207b56,%rax
  8004208122:	00 00 00 
  8004208125:	ff d0                	callq  *%rax
	if (curenv == e) {
  8004208127:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420812e:	00 00 00 
  8004208131:	ff d0                	callq  *%rax
  8004208133:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420813a:	00 00 00 
  800420813d:	48 98                	cltq   
  800420813f:	48 c1 e0 03          	shl    $0x3,%rax
  8004208143:	48 89 c2             	mov    %rax,%rdx
  8004208146:	48 c1 e2 04          	shl    $0x4,%rdx
  800420814a:	48 29 c2             	sub    %rax,%rdx
  800420814d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208151:	48 83 c0 08          	add    $0x8,%rax
  8004208155:	48 8b 00             	mov    (%rax),%rax
  8004208158:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420815c:	75 41                	jne    800420819f <env_destroy+0xf0>
		curenv = NULL;
  800420815e:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004208165:	00 00 00 
  8004208168:	ff d0                	callq  *%rax
  800420816a:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  8004208171:	00 00 00 
  8004208174:	48 98                	cltq   
  8004208176:	48 c1 e0 03          	shl    $0x3,%rax
  800420817a:	48 89 c2             	mov    %rax,%rdx
  800420817d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208181:	48 29 c2             	sub    %rax,%rdx
  8004208184:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208188:	48 83 c0 08          	add    $0x8,%rax
  800420818c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004208193:	48 b8 5f c3 20 04 80 	movabs $0x800420c35f,%rax
  800420819a:	00 00 00 
  800420819d:	ff d0                	callq  *%rax
	}
}
  800420819f:	c9                   	leaveq 
  80042081a0:	c3                   	retq   

00000080042081a1 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  80042081a1:	55                   	push   %rbp
  80042081a2:	48 89 e5             	mov    %rsp,%rbp
  80042081a5:	53                   	push   %rbx
  80042081a6:	48 83 ec 18          	sub    $0x18,%rsp
  80042081aa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  80042081ae:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042081b5:	00 00 00 
  80042081b8:	ff d0                	callq  *%rax
  80042081ba:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042081c1:	00 00 00 
  80042081c4:	48 98                	cltq   
  80042081c6:	48 c1 e0 03          	shl    $0x3,%rax
  80042081ca:	48 89 c2             	mov    %rax,%rdx
  80042081cd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042081d1:	48 29 c2             	sub    %rax,%rdx
  80042081d4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042081d8:	48 83 c0 08          	add    $0x8,%rax
  80042081dc:	48 8b 18             	mov    (%rax),%rbx
  80042081df:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042081e6:	00 00 00 
  80042081e9:	ff d0                	callq  *%rax
  80042081eb:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)
	__asm __volatile("movq %0,%%rsp\n"
  80042081f1:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  80042081f5:	4c 8b 3c 24          	mov    (%rsp),%r15
  80042081f9:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  80042081fe:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208203:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208208:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420820d:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208212:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208217:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420821c:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208221:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208226:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420822b:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208230:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004208235:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420823a:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420823f:	48 83 c4 78          	add    $0x78,%rsp
  8004208243:	8e 04 24             	mov    (%rsp),%es
  8004208246:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  800420824a:	48 83 c4 10          	add    $0x10,%rsp
  800420824e:	48 83 c4 10          	add    $0x10,%rsp
  8004208252:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208254:	48 ba 2d 77 21 04 80 	movabs $0x800421772d,%rdx
  800420825b:	00 00 00 
  800420825e:	be 39 02 00 00       	mov    $0x239,%esi
  8004208263:	48 bf d3 76 21 04 80 	movabs $0x80042176d3,%rdi
  800420826a:	00 00 00 
  800420826d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208272:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  8004208279:	00 00 00 
  800420827c:	ff d1                	callq  *%rcx

000000800420827e <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  800420827e:	55                   	push   %rbp
  800420827f:	48 89 e5             	mov    %rsp,%rbp
  8004208282:	48 83 ec 20          	sub    $0x20,%rsp
  8004208286:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.

	if (curenv && curenv->env_status == ENV_RUNNING)
  800420828a:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004208291:	00 00 00 
  8004208294:	ff d0                	callq  *%rax
  8004208296:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420829d:	00 00 00 
  80042082a0:	48 98                	cltq   
  80042082a2:	48 c1 e0 03          	shl    $0x3,%rax
  80042082a6:	48 89 c2             	mov    %rax,%rdx
  80042082a9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042082ad:	48 29 c2             	sub    %rax,%rdx
  80042082b0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042082b4:	48 83 c0 08          	add    $0x8,%rax
  80042082b8:	48 8b 00             	mov    (%rax),%rax
  80042082bb:	48 85 c0             	test   %rax,%rax
  80042082be:	74 77                	je     8004208337 <env_run+0xb9>
  80042082c0:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042082c7:	00 00 00 
  80042082ca:	ff d0                	callq  *%rax
  80042082cc:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042082d3:	00 00 00 
  80042082d6:	48 98                	cltq   
  80042082d8:	48 c1 e0 03          	shl    $0x3,%rax
  80042082dc:	48 89 c2             	mov    %rax,%rdx
  80042082df:	48 c1 e2 04          	shl    $0x4,%rdx
  80042082e3:	48 29 c2             	sub    %rax,%rdx
  80042082e6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042082ea:	48 83 c0 08          	add    $0x8,%rax
  80042082ee:	48 8b 00             	mov    (%rax),%rax
  80042082f1:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042082f7:	83 f8 03             	cmp    $0x3,%eax
  80042082fa:	75 3b                	jne    8004208337 <env_run+0xb9>
      curenv->env_status = ENV_RUNNABLE;
  80042082fc:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004208303:	00 00 00 
  8004208306:	ff d0                	callq  *%rax
  8004208308:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420830f:	00 00 00 
  8004208312:	48 98                	cltq   
  8004208314:	48 c1 e0 03          	shl    $0x3,%rax
  8004208318:	48 89 c2             	mov    %rax,%rdx
  800420831b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420831f:	48 29 c2             	sub    %rax,%rdx
  8004208322:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208326:	48 83 c0 08          	add    $0x8,%rax
  800420832a:	48 8b 00             	mov    (%rax),%rax
  800420832d:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208334:	00 00 00 

  curenv = e;
  8004208337:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420833e:	00 00 00 
  8004208341:	ff d0                	callq  *%rax
  8004208343:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420834a:	00 00 00 
  800420834d:	48 98                	cltq   
  800420834f:	48 c1 e0 03          	shl    $0x3,%rax
  8004208353:	48 89 c2             	mov    %rax,%rdx
  8004208356:	48 c1 e2 04          	shl    $0x4,%rdx
  800420835a:	48 29 c2             	sub    %rax,%rdx
  800420835d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208361:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208365:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208369:	48 89 02             	mov    %rax,(%rdx)
  curenv->env_status = ENV_RUNNING;
  800420836c:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004208373:	00 00 00 
  8004208376:	ff d0                	callq  *%rax
  8004208378:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420837f:	00 00 00 
  8004208382:	48 98                	cltq   
  8004208384:	48 c1 e0 03          	shl    $0x3,%rax
  8004208388:	48 89 c2             	mov    %rax,%rdx
  800420838b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420838f:	48 29 c2             	sub    %rax,%rdx
  8004208392:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208396:	48 83 c0 08          	add    $0x8,%rax
  800420839a:	48 8b 00             	mov    (%rax),%rax
  800420839d:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  80042083a4:	00 00 00 
  curenv->env_runs++;
  80042083a7:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042083ae:	00 00 00 
  80042083b1:	ff d0                	callq  *%rax
  80042083b3:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  80042083ba:	00 00 00 
  80042083bd:	48 98                	cltq   
  80042083bf:	48 c1 e0 03          	shl    $0x3,%rax
  80042083c3:	48 89 c2             	mov    %rax,%rdx
  80042083c6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042083ca:	48 29 c2             	sub    %rax,%rdx
  80042083cd:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042083d1:	48 83 c0 08          	add    $0x8,%rax
  80042083d5:	48 8b 00             	mov    (%rax),%rax
  80042083d8:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  80042083de:	83 c2 01             	add    $0x1,%edx
  80042083e1:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)

	unlock_kernel();
  80042083e7:	48 b8 a9 71 20 04 80 	movabs $0x80042071a9,%rax
  80042083ee:	00 00 00 
  80042083f1:	ff d0                	callq  *%rax

  lcr3(curenv->env_cr3);
  80042083f3:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042083fa:	00 00 00 
  80042083fd:	ff d0                	callq  *%rax
  80042083ff:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  8004208406:	00 00 00 
  8004208409:	48 98                	cltq   
  800420840b:	48 c1 e0 03          	shl    $0x3,%rax
  800420840f:	48 89 c2             	mov    %rax,%rdx
  8004208412:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208416:	48 29 c2             	sub    %rax,%rdx
  8004208419:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420841d:	48 83 c0 08          	add    $0x8,%rax
  8004208421:	48 8b 00             	mov    (%rax),%rax
  8004208424:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420842b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420842f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208433:	0f 22 d8             	mov    %rax,%cr3
  env_pop_tf(&(curenv->env_tf));
  8004208436:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420843d:	00 00 00 
  8004208440:	ff d0                	callq  *%rax
  8004208442:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  8004208449:	00 00 00 
  800420844c:	48 98                	cltq   
  800420844e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208452:	48 89 c2             	mov    %rax,%rdx
  8004208455:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208459:	48 29 c2             	sub    %rax,%rdx
  800420845c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208460:	48 83 c0 08          	add    $0x8,%rax
  8004208464:	48 8b 00             	mov    (%rax),%rax
  8004208467:	48 89 c7             	mov    %rax,%rdi
  800420846a:	48 b8 a1 81 20 04 80 	movabs $0x80042081a1,%rax
  8004208471:	00 00 00 
  8004208474:	ff d0                	callq  *%rax

0000008004208476 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208476:	55                   	push   %rbp
  8004208477:	48 89 e5             	mov    %rsp,%rbp
  800420847a:	48 83 ec 14          	sub    $0x14,%rsp
  800420847e:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004208481:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208484:	0f b6 c0             	movzbl %al,%eax
  8004208487:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  800420848e:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208491:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208495:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208498:	ee                   	out    %al,(%dx)
  8004208499:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042084a0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042084a3:	89 c2                	mov    %eax,%edx
  80042084a5:	ec                   	in     (%dx),%al
  80042084a6:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042084a9:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  80042084ad:	0f b6 c0             	movzbl %al,%eax
}
  80042084b0:	c9                   	leaveq 
  80042084b1:	c3                   	retq   

00000080042084b2 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  80042084b2:	55                   	push   %rbp
  80042084b3:	48 89 e5             	mov    %rsp,%rbp
  80042084b6:	48 83 ec 18          	sub    $0x18,%rsp
  80042084ba:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042084bd:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  80042084c0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042084c3:	0f b6 c0             	movzbl %al,%eax
  80042084c6:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042084cd:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042084d0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042084d4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042084d7:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  80042084d8:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042084db:	0f b6 c0             	movzbl %al,%eax
  80042084de:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  80042084e5:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042084e8:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042084ec:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042084ef:	ee                   	out    %al,(%dx)
}
  80042084f0:	c9                   	leaveq 
  80042084f1:	c3                   	retq   

00000080042084f2 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  80042084f2:	55                   	push   %rbp
  80042084f3:	48 89 e5             	mov    %rsp,%rbp
  80042084f6:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  80042084fa:	48 b8 60 32 3d 04 80 	movabs $0x80043d3260,%rax
  8004208501:	00 00 00 
  8004208504:	c6 00 01             	movb   $0x1,(%rax)
  8004208507:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  800420850e:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  8004208512:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208516:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208519:	ee                   	out    %al,(%dx)
  800420851a:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208521:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  8004208525:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208529:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420852c:	ee                   	out    %al,(%dx)
  800420852d:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  8004208534:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208538:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420853c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420853f:	ee                   	out    %al,(%dx)
  8004208540:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004208547:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  800420854b:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800420854f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208552:	ee                   	out    %al,(%dx)
  8004208553:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  800420855a:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  800420855e:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004208562:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208565:	ee                   	out    %al,(%dx)
  8004208566:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  800420856d:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208571:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004208575:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208578:	ee                   	out    %al,(%dx)
  8004208579:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208580:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004208584:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208588:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420858b:	ee                   	out    %al,(%dx)
  800420858c:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004208593:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004208597:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  800420859b:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420859e:	ee                   	out    %al,(%dx)
  800420859f:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  80042085a6:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  80042085aa:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042085ae:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042085b1:	ee                   	out    %al,(%dx)
  80042085b2:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  80042085b9:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  80042085bd:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  80042085c1:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042085c4:	ee                   	out    %al,(%dx)
  80042085c5:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  80042085cc:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  80042085d0:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  80042085d4:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042085d7:	ee                   	out    %al,(%dx)
  80042085d8:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  80042085df:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  80042085e3:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  80042085e7:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80042085ea:	ee                   	out    %al,(%dx)
  80042085eb:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  80042085f2:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  80042085f6:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  80042085fa:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042085fd:	ee                   	out    %al,(%dx)
  80042085fe:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004208605:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004208609:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  800420860d:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004208610:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004208611:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  8004208618:	00 00 00 
  800420861b:	0f b7 00             	movzwl (%rax),%eax
  800420861e:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004208622:	74 1e                	je     8004208642 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004208624:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  800420862b:	00 00 00 
  800420862e:	0f b7 00             	movzwl (%rax),%eax
  8004208631:	0f b7 c0             	movzwl %ax,%eax
  8004208634:	89 c7                	mov    %eax,%edi
  8004208636:	48 b8 44 86 20 04 80 	movabs $0x8004208644,%rax
  800420863d:	00 00 00 
  8004208640:	ff d0                	callq  *%rax
}
  8004208642:	c9                   	leaveq 
  8004208643:	c3                   	retq   

0000008004208644 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004208644:	55                   	push   %rbp
  8004208645:	48 89 e5             	mov    %rsp,%rbp
  8004208648:	48 83 ec 30          	sub    $0x30,%rsp
  800420864c:	89 f8                	mov    %edi,%eax
  800420864e:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004208652:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  8004208659:	00 00 00 
  800420865c:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8004208660:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004208663:	48 b8 60 32 3d 04 80 	movabs $0x80043d3260,%rax
  800420866a:	00 00 00 
  800420866d:	0f b6 00             	movzbl (%rax),%eax
  8004208670:	83 f0 01             	xor    $0x1,%eax
  8004208673:	84 c0                	test   %al,%al
  8004208675:	74 05                	je     800420867c <irq_setmask_8259A+0x38>
		return;
  8004208677:	e9 b7 00 00 00       	jmpq   8004208733 <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  800420867c:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208680:	0f b6 c0             	movzbl %al,%eax
  8004208683:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  800420868a:	88 45 f7             	mov    %al,-0x9(%rbp)
  800420868d:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004208691:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004208694:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004208695:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208699:	66 c1 e8 08          	shr    $0x8,%ax
  800420869d:	0f b6 c0             	movzbl %al,%eax
  80042086a0:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  80042086a7:	88 45 ef             	mov    %al,-0x11(%rbp)
  80042086aa:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042086ae:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042086b1:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  80042086b2:	48 bf 39 77 21 04 80 	movabs $0x8004217739,%rdi
  80042086b9:	00 00 00 
  80042086bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042086c1:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042086c8:	00 00 00 
  80042086cb:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  80042086cd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042086d4:	eb 3c                	jmp    8004208712 <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  80042086d6:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042086da:	f7 d0                	not    %eax
  80042086dc:	89 c2                	mov    %eax,%edx
  80042086de:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042086e1:	89 c1                	mov    %eax,%ecx
  80042086e3:	d3 fa                	sar    %cl,%edx
  80042086e5:	89 d0                	mov    %edx,%eax
  80042086e7:	83 e0 01             	and    $0x1,%eax
  80042086ea:	85 c0                	test   %eax,%eax
  80042086ec:	74 20                	je     800420870e <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  80042086ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042086f1:	89 c6                	mov    %eax,%esi
  80042086f3:	48 bf 4d 77 21 04 80 	movabs $0x800421774d,%rdi
  80042086fa:	00 00 00 
  80042086fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208702:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004208709:	00 00 00 
  800420870c:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  800420870e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208712:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004208716:	7e be                	jle    80042086d6 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208718:	48 bf 51 77 21 04 80 	movabs $0x8004217751,%rdi
  800420871f:	00 00 00 
  8004208722:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208727:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420872e:	00 00 00 
  8004208731:	ff d2                	callq  *%rdx
}
  8004208733:	c9                   	leaveq 
  8004208734:	c3                   	retq   

0000008004208735 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004208735:	55                   	push   %rbp
  8004208736:	48 89 e5             	mov    %rsp,%rbp
  8004208739:	48 83 ec 10          	sub    $0x10,%rsp
  800420873d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208740:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004208744:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208747:	89 c7                	mov    %eax,%edi
  8004208749:	48 b8 7d 11 20 04 80 	movabs $0x800420117d,%rax
  8004208750:	00 00 00 
  8004208753:	ff d0                	callq  *%rax
	*cnt++;
  8004208755:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208759:	48 83 c0 04          	add    $0x4,%rax
  800420875d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004208761:	c9                   	leaveq 
  8004208762:	c3                   	retq   

0000008004208763 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004208763:	55                   	push   %rbp
  8004208764:	48 89 e5             	mov    %rsp,%rbp
  8004208767:	48 83 ec 30          	sub    $0x30,%rsp
  800420876b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420876f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004208773:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420877a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420877e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208782:	48 8b 0a             	mov    (%rdx),%rcx
  8004208785:	48 89 08             	mov    %rcx,(%rax)
  8004208788:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420878c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208790:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208794:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004208798:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420879c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042087a0:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80042087a4:	48 89 c6             	mov    %rax,%rsi
  80042087a7:	48 bf 35 87 20 04 80 	movabs $0x8004208735,%rdi
  80042087ae:	00 00 00 
  80042087b1:	48 b8 e0 e1 20 04 80 	movabs $0x800420e1e0,%rax
  80042087b8:	00 00 00 
  80042087bb:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  80042087bd:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  80042087c0:	c9                   	leaveq 
  80042087c1:	c3                   	retq   

00000080042087c2 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80042087c2:	55                   	push   %rbp
  80042087c3:	48 89 e5             	mov    %rsp,%rbp
  80042087c6:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  80042087cd:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  80042087d4:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  80042087db:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042087e2:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042087e9:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042087f0:	84 c0                	test   %al,%al
  80042087f2:	74 20                	je     8004208814 <cprintf+0x52>
  80042087f4:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042087f8:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042087fc:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208800:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004208804:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208808:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420880c:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208810:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004208814:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  800420881b:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004208822:	00 00 00 
  8004208825:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420882c:	00 00 00 
  800420882f:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004208833:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420883a:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208841:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208848:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420884f:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004208856:	48 8b 0a             	mov    (%rdx),%rcx
  8004208859:	48 89 08             	mov    %rcx,(%rax)
  800420885c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208860:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208864:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208868:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  800420886c:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004208873:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420887a:	48 89 d6             	mov    %rdx,%rsi
  800420887d:	48 89 c7             	mov    %rax,%rdi
  8004208880:	48 b8 63 87 20 04 80 	movabs $0x8004208763,%rax
  8004208887:	00 00 00 
  800420888a:	ff d0                	callq  *%rax
  800420888c:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004208892:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004208898:	c9                   	leaveq 
  8004208899:	c3                   	retq   

000000800420889a <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420889a:	55                   	push   %rbp
  800420889b:	48 89 e5             	mov    %rsp,%rbp
  800420889e:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042088a2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042088a6:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042088a9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042088ad:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042088b0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042088b4:	f0 87 02             	lock xchg %eax,(%rdx)
  80042088b7:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042088ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042088bd:	c9                   	leaveq 
  80042088be:	c3                   	retq   

00000080042088bf <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  80042088bf:	55                   	push   %rbp
  80042088c0:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  80042088c3:	48 bf 60 b7 22 04 80 	movabs $0x800422b760,%rdi
  80042088ca:	00 00 00 
  80042088cd:	48 b8 04 61 21 04 80 	movabs $0x8004216104,%rax
  80042088d4:	00 00 00 
  80042088d7:	ff d0                	callq  *%rax
}
  80042088d9:	5d                   	pop    %rbp
  80042088da:	c3                   	retq   

00000080042088db <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  80042088db:	55                   	push   %rbp
  80042088dc:	48 89 e5             	mov    %rsp,%rbp
  80042088df:	48 83 ec 04          	sub    $0x4,%rsp
  80042088e3:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  80042088e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042088e9:	83 f8 13             	cmp    $0x13,%eax
  80042088ec:	77 16                	ja     8004208904 <trapname+0x29>
		return excnames[trapno];
  80042088ee:	48 b8 80 7b 21 04 80 	movabs $0x8004217b80,%rax
  80042088f5:	00 00 00 
  80042088f8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042088fb:	48 63 d2             	movslq %edx,%rdx
  80042088fe:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004208902:	eb 34                	jmp    8004208938 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004208904:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004208908:	75 0c                	jne    8004208916 <trapname+0x3b>
		return "System call";
  800420890a:	48 b8 60 77 21 04 80 	movabs $0x8004217760,%rax
  8004208911:	00 00 00 
  8004208914:	eb 22                	jmp    8004208938 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004208916:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  800420891a:	7e 12                	jle    800420892e <trapname+0x53>
  800420891c:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004208920:	7f 0c                	jg     800420892e <trapname+0x53>
		return "Hardware Interrupt";
  8004208922:	48 b8 6c 77 21 04 80 	movabs $0x800421776c,%rax
  8004208929:	00 00 00 
  800420892c:	eb 0a                	jmp    8004208938 <trapname+0x5d>
	return "(unknown trap)";
  800420892e:	48 b8 7f 77 21 04 80 	movabs $0x800421777f,%rax
  8004208935:	00 00 00 
}
  8004208938:	c9                   	leaveq 
  8004208939:	c3                   	retq   

000000800420893a <trap_init>:


void
trap_init(void)
{
  800420893a:	55                   	push   %rbp
  800420893b:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
	idt_pd.pd_lim = sizeof(idt)-1;
  800420893e:	48 b8 80 42 3d 04 80 	movabs $0x80043d4280,%rax
  8004208945:	00 00 00 
  8004208948:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  800420894d:	48 ba 80 32 3d 04 80 	movabs $0x80043d3280,%rdx
  8004208954:	00 00 00 
  8004208957:	48 b8 80 42 3d 04 80 	movabs $0x80043d4280,%rax
  800420895e:	00 00 00 
  8004208961:	48 89 50 02          	mov    %rdx,0x2(%rax)

	SETGATE(idt[T_DIVIDE], 0, GD_KT, DIVIDE_F, 0);
  8004208965:	48 b8 9c c1 20 04 80 	movabs $0x800420c19c,%rax
  800420896c:	00 00 00 
  800420896f:	89 c2                	mov    %eax,%edx
  8004208971:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208978:	00 00 00 
  800420897b:	66 89 10             	mov    %dx,(%rax)
  800420897e:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208985:	00 00 00 
  8004208988:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  800420898e:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208995:	00 00 00 
  8004208998:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  800420899c:	83 e2 f8             	and    $0xfffffff8,%edx
  800420899f:	88 50 04             	mov    %dl,0x4(%rax)
  80042089a2:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042089a9:	00 00 00 
  80042089ac:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042089b0:	83 e2 07             	and    $0x7,%edx
  80042089b3:	88 50 04             	mov    %dl,0x4(%rax)
  80042089b6:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042089bd:	00 00 00 
  80042089c0:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042089c4:	83 e2 f0             	and    $0xfffffff0,%edx
  80042089c7:	83 ca 0e             	or     $0xe,%edx
  80042089ca:	88 50 05             	mov    %dl,0x5(%rax)
  80042089cd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042089d4:	00 00 00 
  80042089d7:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042089db:	83 e2 ef             	and    $0xffffffef,%edx
  80042089de:	88 50 05             	mov    %dl,0x5(%rax)
  80042089e1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042089e8:	00 00 00 
  80042089eb:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042089ef:	83 e2 9f             	and    $0xffffff9f,%edx
  80042089f2:	88 50 05             	mov    %dl,0x5(%rax)
  80042089f5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042089fc:	00 00 00 
  80042089ff:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208a03:	83 ca 80             	or     $0xffffff80,%edx
  8004208a06:	88 50 05             	mov    %dl,0x5(%rax)
  8004208a09:	48 b8 9c c1 20 04 80 	movabs $0x800420c19c,%rax
  8004208a10:	00 00 00 
  8004208a13:	48 c1 e8 10          	shr    $0x10,%rax
  8004208a17:	89 c2                	mov    %eax,%edx
  8004208a19:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208a20:	00 00 00 
  8004208a23:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004208a27:	48 b8 9c c1 20 04 80 	movabs $0x800420c19c,%rax
  8004208a2e:	00 00 00 
  8004208a31:	48 c1 e8 20          	shr    $0x20,%rax
  8004208a35:	89 c2                	mov    %eax,%edx
  8004208a37:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208a3e:	00 00 00 
  8004208a41:	89 50 08             	mov    %edx,0x8(%rax)
  8004208a44:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208a4b:	00 00 00 
  8004208a4e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_DEBUG], 0, GD_KT, DEBUG_F, 0);
  8004208a55:	48 b8 a6 c1 20 04 80 	movabs $0x800420c1a6,%rax
  8004208a5c:	00 00 00 
  8004208a5f:	89 c2                	mov    %eax,%edx
  8004208a61:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208a68:	00 00 00 
  8004208a6b:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004208a6f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208a76:	00 00 00 
  8004208a79:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  8004208a7f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208a86:	00 00 00 
  8004208a89:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004208a8d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208a90:	88 50 14             	mov    %dl,0x14(%rax)
  8004208a93:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208a9a:	00 00 00 
  8004208a9d:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004208aa1:	83 e2 07             	and    $0x7,%edx
  8004208aa4:	88 50 14             	mov    %dl,0x14(%rax)
  8004208aa7:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208aae:	00 00 00 
  8004208ab1:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208ab5:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208ab8:	83 ca 0e             	or     $0xe,%edx
  8004208abb:	88 50 15             	mov    %dl,0x15(%rax)
  8004208abe:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208ac5:	00 00 00 
  8004208ac8:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208acc:	83 e2 ef             	and    $0xffffffef,%edx
  8004208acf:	88 50 15             	mov    %dl,0x15(%rax)
  8004208ad2:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208ad9:	00 00 00 
  8004208adc:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208ae0:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208ae3:	88 50 15             	mov    %dl,0x15(%rax)
  8004208ae6:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208aed:	00 00 00 
  8004208af0:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208af4:	83 ca 80             	or     $0xffffff80,%edx
  8004208af7:	88 50 15             	mov    %dl,0x15(%rax)
  8004208afa:	48 b8 a6 c1 20 04 80 	movabs $0x800420c1a6,%rax
  8004208b01:	00 00 00 
  8004208b04:	48 c1 e8 10          	shr    $0x10,%rax
  8004208b08:	89 c2                	mov    %eax,%edx
  8004208b0a:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208b11:	00 00 00 
  8004208b14:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004208b18:	48 b8 a6 c1 20 04 80 	movabs $0x800420c1a6,%rax
  8004208b1f:	00 00 00 
  8004208b22:	48 c1 e8 20          	shr    $0x20,%rax
  8004208b26:	89 c2                	mov    %eax,%edx
  8004208b28:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208b2f:	00 00 00 
  8004208b32:	89 50 18             	mov    %edx,0x18(%rax)
  8004208b35:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208b3c:	00 00 00 
  8004208b3f:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[T_NMI], 0, GD_KT, NMI_F, 0);
  8004208b46:	48 b8 b0 c1 20 04 80 	movabs $0x800420c1b0,%rax
  8004208b4d:	00 00 00 
  8004208b50:	89 c2                	mov    %eax,%edx
  8004208b52:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208b59:	00 00 00 
  8004208b5c:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004208b60:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208b67:	00 00 00 
  8004208b6a:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004208b70:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208b77:	00 00 00 
  8004208b7a:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004208b7e:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208b81:	88 50 24             	mov    %dl,0x24(%rax)
  8004208b84:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208b8b:	00 00 00 
  8004208b8e:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004208b92:	83 e2 07             	and    $0x7,%edx
  8004208b95:	88 50 24             	mov    %dl,0x24(%rax)
  8004208b98:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208b9f:	00 00 00 
  8004208ba2:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208ba6:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208ba9:	83 ca 0e             	or     $0xe,%edx
  8004208bac:	88 50 25             	mov    %dl,0x25(%rax)
  8004208baf:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208bb6:	00 00 00 
  8004208bb9:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208bbd:	83 e2 ef             	and    $0xffffffef,%edx
  8004208bc0:	88 50 25             	mov    %dl,0x25(%rax)
  8004208bc3:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208bca:	00 00 00 
  8004208bcd:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208bd1:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208bd4:	88 50 25             	mov    %dl,0x25(%rax)
  8004208bd7:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208bde:	00 00 00 
  8004208be1:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208be5:	83 ca 80             	or     $0xffffff80,%edx
  8004208be8:	88 50 25             	mov    %dl,0x25(%rax)
  8004208beb:	48 b8 b0 c1 20 04 80 	movabs $0x800420c1b0,%rax
  8004208bf2:	00 00 00 
  8004208bf5:	48 c1 e8 10          	shr    $0x10,%rax
  8004208bf9:	89 c2                	mov    %eax,%edx
  8004208bfb:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208c02:	00 00 00 
  8004208c05:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004208c09:	48 b8 b0 c1 20 04 80 	movabs $0x800420c1b0,%rax
  8004208c10:	00 00 00 
  8004208c13:	48 c1 e8 20          	shr    $0x20,%rax
  8004208c17:	89 c2                	mov    %eax,%edx
  8004208c19:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208c20:	00 00 00 
  8004208c23:	89 50 28             	mov    %edx,0x28(%rax)
  8004208c26:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208c2d:	00 00 00 
  8004208c30:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_BRKPT], 0, GD_KT, BRKPT_F, 3);
  8004208c37:	48 b8 ba c1 20 04 80 	movabs $0x800420c1ba,%rax
  8004208c3e:	00 00 00 
  8004208c41:	89 c2                	mov    %eax,%edx
  8004208c43:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208c4a:	00 00 00 
  8004208c4d:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004208c51:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208c58:	00 00 00 
  8004208c5b:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004208c61:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208c68:	00 00 00 
  8004208c6b:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004208c6f:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208c72:	88 50 34             	mov    %dl,0x34(%rax)
  8004208c75:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208c7c:	00 00 00 
  8004208c7f:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004208c83:	83 e2 07             	and    $0x7,%edx
  8004208c86:	88 50 34             	mov    %dl,0x34(%rax)
  8004208c89:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208c90:	00 00 00 
  8004208c93:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208c97:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208c9a:	83 ca 0e             	or     $0xe,%edx
  8004208c9d:	88 50 35             	mov    %dl,0x35(%rax)
  8004208ca0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208ca7:	00 00 00 
  8004208caa:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208cae:	83 e2 ef             	and    $0xffffffef,%edx
  8004208cb1:	88 50 35             	mov    %dl,0x35(%rax)
  8004208cb4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208cbb:	00 00 00 
  8004208cbe:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208cc2:	83 ca 60             	or     $0x60,%edx
  8004208cc5:	88 50 35             	mov    %dl,0x35(%rax)
  8004208cc8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208ccf:	00 00 00 
  8004208cd2:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208cd6:	83 ca 80             	or     $0xffffff80,%edx
  8004208cd9:	88 50 35             	mov    %dl,0x35(%rax)
  8004208cdc:	48 b8 ba c1 20 04 80 	movabs $0x800420c1ba,%rax
  8004208ce3:	00 00 00 
  8004208ce6:	48 c1 e8 10          	shr    $0x10,%rax
  8004208cea:	89 c2                	mov    %eax,%edx
  8004208cec:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208cf3:	00 00 00 
  8004208cf6:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004208cfa:	48 b8 ba c1 20 04 80 	movabs $0x800420c1ba,%rax
  8004208d01:	00 00 00 
  8004208d04:	48 c1 e8 20          	shr    $0x20,%rax
  8004208d08:	89 c2                	mov    %eax,%edx
  8004208d0a:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208d11:	00 00 00 
  8004208d14:	89 50 38             	mov    %edx,0x38(%rax)
  8004208d17:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208d1e:	00 00 00 
  8004208d21:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[T_OFLOW], 0, GD_KT, OFLOW_F, 0);
  8004208d28:	48 b8 c4 c1 20 04 80 	movabs $0x800420c1c4,%rax
  8004208d2f:	00 00 00 
  8004208d32:	89 c2                	mov    %eax,%edx
  8004208d34:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208d3b:	00 00 00 
  8004208d3e:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004208d42:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208d49:	00 00 00 
  8004208d4c:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004208d52:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208d59:	00 00 00 
  8004208d5c:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208d60:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208d63:	88 50 44             	mov    %dl,0x44(%rax)
  8004208d66:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208d6d:	00 00 00 
  8004208d70:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208d74:	83 e2 07             	and    $0x7,%edx
  8004208d77:	88 50 44             	mov    %dl,0x44(%rax)
  8004208d7a:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208d81:	00 00 00 
  8004208d84:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208d88:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208d8b:	83 ca 0e             	or     $0xe,%edx
  8004208d8e:	88 50 45             	mov    %dl,0x45(%rax)
  8004208d91:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208d98:	00 00 00 
  8004208d9b:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208d9f:	83 e2 ef             	and    $0xffffffef,%edx
  8004208da2:	88 50 45             	mov    %dl,0x45(%rax)
  8004208da5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208dac:	00 00 00 
  8004208daf:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208db3:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208db6:	88 50 45             	mov    %dl,0x45(%rax)
  8004208db9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208dc0:	00 00 00 
  8004208dc3:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208dc7:	83 ca 80             	or     $0xffffff80,%edx
  8004208dca:	88 50 45             	mov    %dl,0x45(%rax)
  8004208dcd:	48 b8 c4 c1 20 04 80 	movabs $0x800420c1c4,%rax
  8004208dd4:	00 00 00 
  8004208dd7:	48 c1 e8 10          	shr    $0x10,%rax
  8004208ddb:	89 c2                	mov    %eax,%edx
  8004208ddd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208de4:	00 00 00 
  8004208de7:	66 89 50 46          	mov    %dx,0x46(%rax)
  8004208deb:	48 b8 c4 c1 20 04 80 	movabs $0x800420c1c4,%rax
  8004208df2:	00 00 00 
  8004208df5:	48 c1 e8 20          	shr    $0x20,%rax
  8004208df9:	89 c2                	mov    %eax,%edx
  8004208dfb:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e02:	00 00 00 
  8004208e05:	89 50 48             	mov    %edx,0x48(%rax)
  8004208e08:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e0f:	00 00 00 
  8004208e12:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[T_BOUND], 0, GD_KT, BOUND_F, 0);
  8004208e19:	48 b8 ce c1 20 04 80 	movabs $0x800420c1ce,%rax
  8004208e20:	00 00 00 
  8004208e23:	89 c2                	mov    %eax,%edx
  8004208e25:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e2c:	00 00 00 
  8004208e2f:	66 89 50 50          	mov    %dx,0x50(%rax)
  8004208e33:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e3a:	00 00 00 
  8004208e3d:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  8004208e43:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e4a:	00 00 00 
  8004208e4d:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004208e51:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208e54:	88 50 54             	mov    %dl,0x54(%rax)
  8004208e57:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e5e:	00 00 00 
  8004208e61:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004208e65:	83 e2 07             	and    $0x7,%edx
  8004208e68:	88 50 54             	mov    %dl,0x54(%rax)
  8004208e6b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e72:	00 00 00 
  8004208e75:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208e79:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208e7c:	83 ca 0e             	or     $0xe,%edx
  8004208e7f:	88 50 55             	mov    %dl,0x55(%rax)
  8004208e82:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e89:	00 00 00 
  8004208e8c:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208e90:	83 e2 ef             	and    $0xffffffef,%edx
  8004208e93:	88 50 55             	mov    %dl,0x55(%rax)
  8004208e96:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208e9d:	00 00 00 
  8004208ea0:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208ea4:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208ea7:	88 50 55             	mov    %dl,0x55(%rax)
  8004208eaa:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208eb1:	00 00 00 
  8004208eb4:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208eb8:	83 ca 80             	or     $0xffffff80,%edx
  8004208ebb:	88 50 55             	mov    %dl,0x55(%rax)
  8004208ebe:	48 b8 ce c1 20 04 80 	movabs $0x800420c1ce,%rax
  8004208ec5:	00 00 00 
  8004208ec8:	48 c1 e8 10          	shr    $0x10,%rax
  8004208ecc:	89 c2                	mov    %eax,%edx
  8004208ece:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208ed5:	00 00 00 
  8004208ed8:	66 89 50 56          	mov    %dx,0x56(%rax)
  8004208edc:	48 b8 ce c1 20 04 80 	movabs $0x800420c1ce,%rax
  8004208ee3:	00 00 00 
  8004208ee6:	48 c1 e8 20          	shr    $0x20,%rax
  8004208eea:	89 c2                	mov    %eax,%edx
  8004208eec:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208ef3:	00 00 00 
  8004208ef6:	89 50 58             	mov    %edx,0x58(%rax)
  8004208ef9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208f00:	00 00 00 
  8004208f03:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[T_ILLOP], 0, GD_KT, ILLOP_F, 0);
  8004208f0a:	48 b8 d8 c1 20 04 80 	movabs $0x800420c1d8,%rax
  8004208f11:	00 00 00 
  8004208f14:	89 c2                	mov    %eax,%edx
  8004208f16:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208f1d:	00 00 00 
  8004208f20:	66 89 50 60          	mov    %dx,0x60(%rax)
  8004208f24:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208f2b:	00 00 00 
  8004208f2e:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  8004208f34:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208f3b:	00 00 00 
  8004208f3e:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004208f42:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208f45:	88 50 64             	mov    %dl,0x64(%rax)
  8004208f48:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208f4f:	00 00 00 
  8004208f52:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004208f56:	83 e2 07             	and    $0x7,%edx
  8004208f59:	88 50 64             	mov    %dl,0x64(%rax)
  8004208f5c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208f63:	00 00 00 
  8004208f66:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208f6a:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208f6d:	83 ca 0e             	or     $0xe,%edx
  8004208f70:	88 50 65             	mov    %dl,0x65(%rax)
  8004208f73:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208f7a:	00 00 00 
  8004208f7d:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208f81:	83 e2 ef             	and    $0xffffffef,%edx
  8004208f84:	88 50 65             	mov    %dl,0x65(%rax)
  8004208f87:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208f8e:	00 00 00 
  8004208f91:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208f95:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208f98:	88 50 65             	mov    %dl,0x65(%rax)
  8004208f9b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208fa2:	00 00 00 
  8004208fa5:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208fa9:	83 ca 80             	or     $0xffffff80,%edx
  8004208fac:	88 50 65             	mov    %dl,0x65(%rax)
  8004208faf:	48 b8 d8 c1 20 04 80 	movabs $0x800420c1d8,%rax
  8004208fb6:	00 00 00 
  8004208fb9:	48 c1 e8 10          	shr    $0x10,%rax
  8004208fbd:	89 c2                	mov    %eax,%edx
  8004208fbf:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208fc6:	00 00 00 
  8004208fc9:	66 89 50 66          	mov    %dx,0x66(%rax)
  8004208fcd:	48 b8 d8 c1 20 04 80 	movabs $0x800420c1d8,%rax
  8004208fd4:	00 00 00 
  8004208fd7:	48 c1 e8 20          	shr    $0x20,%rax
  8004208fdb:	89 c2                	mov    %eax,%edx
  8004208fdd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208fe4:	00 00 00 
  8004208fe7:	89 50 68             	mov    %edx,0x68(%rax)
  8004208fea:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004208ff1:	00 00 00 
  8004208ff4:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[T_DEVICE], 0, GD_KT, DEVICE_F, 0);
  8004208ffb:	48 b8 e2 c1 20 04 80 	movabs $0x800420c1e2,%rax
  8004209002:	00 00 00 
  8004209005:	89 c2                	mov    %eax,%edx
  8004209007:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420900e:	00 00 00 
  8004209011:	66 89 50 70          	mov    %dx,0x70(%rax)
  8004209015:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420901c:	00 00 00 
  800420901f:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  8004209025:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420902c:	00 00 00 
  800420902f:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209033:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209036:	88 50 74             	mov    %dl,0x74(%rax)
  8004209039:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209040:	00 00 00 
  8004209043:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209047:	83 e2 07             	and    $0x7,%edx
  800420904a:	88 50 74             	mov    %dl,0x74(%rax)
  800420904d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209054:	00 00 00 
  8004209057:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420905b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420905e:	83 ca 0e             	or     $0xe,%edx
  8004209061:	88 50 75             	mov    %dl,0x75(%rax)
  8004209064:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420906b:	00 00 00 
  800420906e:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209072:	83 e2 ef             	and    $0xffffffef,%edx
  8004209075:	88 50 75             	mov    %dl,0x75(%rax)
  8004209078:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420907f:	00 00 00 
  8004209082:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209086:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209089:	88 50 75             	mov    %dl,0x75(%rax)
  800420908c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209093:	00 00 00 
  8004209096:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420909a:	83 ca 80             	or     $0xffffff80,%edx
  800420909d:	88 50 75             	mov    %dl,0x75(%rax)
  80042090a0:	48 b8 e2 c1 20 04 80 	movabs $0x800420c1e2,%rax
  80042090a7:	00 00 00 
  80042090aa:	48 c1 e8 10          	shr    $0x10,%rax
  80042090ae:	89 c2                	mov    %eax,%edx
  80042090b0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042090b7:	00 00 00 
  80042090ba:	66 89 50 76          	mov    %dx,0x76(%rax)
  80042090be:	48 b8 e2 c1 20 04 80 	movabs $0x800420c1e2,%rax
  80042090c5:	00 00 00 
  80042090c8:	48 c1 e8 20          	shr    $0x20,%rax
  80042090cc:	89 c2                	mov    %eax,%edx
  80042090ce:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042090d5:	00 00 00 
  80042090d8:	89 50 78             	mov    %edx,0x78(%rax)
  80042090db:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042090e2:	00 00 00 
  80042090e5:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[T_DBLFLT], 0, GD_KT, DBLFLT_F, 0);
  80042090ec:	48 b8 ec c1 20 04 80 	movabs $0x800420c1ec,%rax
  80042090f3:	00 00 00 
  80042090f6:	89 c2                	mov    %eax,%edx
  80042090f8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042090ff:	00 00 00 
  8004209102:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  8004209109:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209110:	00 00 00 
  8004209113:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  800420911a:	08 00 
  800420911c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209123:	00 00 00 
  8004209126:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420912d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209130:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209136:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420913d:	00 00 00 
  8004209140:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209147:	83 e2 07             	and    $0x7,%edx
  800420914a:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209150:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209157:	00 00 00 
  800420915a:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209161:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209164:	83 ca 0e             	or     $0xe,%edx
  8004209167:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420916d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209174:	00 00 00 
  8004209177:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420917e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209181:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209187:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420918e:	00 00 00 
  8004209191:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209198:	83 e2 9f             	and    $0xffffff9f,%edx
  800420919b:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042091a1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042091a8:	00 00 00 
  80042091ab:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042091b2:	83 ca 80             	or     $0xffffff80,%edx
  80042091b5:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042091bb:	48 b8 ec c1 20 04 80 	movabs $0x800420c1ec,%rax
  80042091c2:	00 00 00 
  80042091c5:	48 c1 e8 10          	shr    $0x10,%rax
  80042091c9:	89 c2                	mov    %eax,%edx
  80042091cb:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042091d2:	00 00 00 
  80042091d5:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  80042091dc:	48 b8 ec c1 20 04 80 	movabs $0x800420c1ec,%rax
  80042091e3:	00 00 00 
  80042091e6:	48 c1 e8 20          	shr    $0x20,%rax
  80042091ea:	89 c2                	mov    %eax,%edx
  80042091ec:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042091f3:	00 00 00 
  80042091f6:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  80042091fc:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209203:	00 00 00 
  8004209206:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  800420920d:	00 00 00 
	SETGATE(idt[T_TSS], 0, GD_KT, TSS_F, 0);
  8004209210:	48 b8 f4 c1 20 04 80 	movabs $0x800420c1f4,%rax
  8004209217:	00 00 00 
  800420921a:	89 c2                	mov    %eax,%edx
  800420921c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209223:	00 00 00 
  8004209226:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  800420922d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209234:	00 00 00 
  8004209237:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  800420923e:	08 00 
  8004209240:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209247:	00 00 00 
  800420924a:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209251:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209254:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420925a:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209261:	00 00 00 
  8004209264:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420926b:	83 e2 07             	and    $0x7,%edx
  800420926e:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209274:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420927b:	00 00 00 
  800420927e:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209285:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209288:	83 ca 0e             	or     $0xe,%edx
  800420928b:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209291:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209298:	00 00 00 
  800420929b:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042092a2:	83 e2 ef             	and    $0xffffffef,%edx
  80042092a5:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042092ab:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042092b2:	00 00 00 
  80042092b5:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042092bc:	83 e2 9f             	and    $0xffffff9f,%edx
  80042092bf:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042092c5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042092cc:	00 00 00 
  80042092cf:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042092d6:	83 ca 80             	or     $0xffffff80,%edx
  80042092d9:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042092df:	48 b8 f4 c1 20 04 80 	movabs $0x800420c1f4,%rax
  80042092e6:	00 00 00 
  80042092e9:	48 c1 e8 10          	shr    $0x10,%rax
  80042092ed:	89 c2                	mov    %eax,%edx
  80042092ef:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042092f6:	00 00 00 
  80042092f9:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  8004209300:	48 b8 f4 c1 20 04 80 	movabs $0x800420c1f4,%rax
  8004209307:	00 00 00 
  800420930a:	48 c1 e8 20          	shr    $0x20,%rax
  800420930e:	89 c2                	mov    %eax,%edx
  8004209310:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209317:	00 00 00 
  800420931a:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  8004209320:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209327:	00 00 00 
  800420932a:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  8004209331:	00 00 00 
	SETGATE(idt[T_SEGNP], 0, GD_KT, SEGNP_F, 0);
  8004209334:	48 b8 fc c1 20 04 80 	movabs $0x800420c1fc,%rax
  800420933b:	00 00 00 
  800420933e:	89 c2                	mov    %eax,%edx
  8004209340:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209347:	00 00 00 
  800420934a:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004209351:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209358:	00 00 00 
  800420935b:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  8004209362:	08 00 
  8004209364:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420936b:	00 00 00 
  800420936e:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209375:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209378:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420937e:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209385:	00 00 00 
  8004209388:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420938f:	83 e2 07             	and    $0x7,%edx
  8004209392:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209398:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420939f:	00 00 00 
  80042093a2:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042093a9:	83 e2 f0             	and    $0xfffffff0,%edx
  80042093ac:	83 ca 0e             	or     $0xe,%edx
  80042093af:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042093b5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042093bc:	00 00 00 
  80042093bf:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042093c6:	83 e2 ef             	and    $0xffffffef,%edx
  80042093c9:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042093cf:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042093d6:	00 00 00 
  80042093d9:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042093e0:	83 e2 9f             	and    $0xffffff9f,%edx
  80042093e3:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042093e9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042093f0:	00 00 00 
  80042093f3:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042093fa:	83 ca 80             	or     $0xffffff80,%edx
  80042093fd:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209403:	48 b8 fc c1 20 04 80 	movabs $0x800420c1fc,%rax
  800420940a:	00 00 00 
  800420940d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209411:	89 c2                	mov    %eax,%edx
  8004209413:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420941a:	00 00 00 
  800420941d:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  8004209424:	48 b8 fc c1 20 04 80 	movabs $0x800420c1fc,%rax
  800420942b:	00 00 00 
  800420942e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209432:	89 c2                	mov    %eax,%edx
  8004209434:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420943b:	00 00 00 
  800420943e:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  8004209444:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420944b:	00 00 00 
  800420944e:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  8004209455:	00 00 00 
	SETGATE(idt[T_STACK], 0, GD_KT, STACK_F, 0);
  8004209458:	48 b8 04 c2 20 04 80 	movabs $0x800420c204,%rax
  800420945f:	00 00 00 
  8004209462:	89 c2                	mov    %eax,%edx
  8004209464:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420946b:	00 00 00 
  800420946e:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004209475:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420947c:	00 00 00 
  800420947f:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  8004209486:	08 00 
  8004209488:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420948f:	00 00 00 
  8004209492:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209499:	83 e2 f8             	and    $0xfffffff8,%edx
  800420949c:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  80042094a2:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042094a9:	00 00 00 
  80042094ac:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  80042094b3:	83 e2 07             	and    $0x7,%edx
  80042094b6:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  80042094bc:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042094c3:	00 00 00 
  80042094c6:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  80042094cd:	83 e2 f0             	and    $0xfffffff0,%edx
  80042094d0:	83 ca 0e             	or     $0xe,%edx
  80042094d3:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  80042094d9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042094e0:	00 00 00 
  80042094e3:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  80042094ea:	83 e2 ef             	and    $0xffffffef,%edx
  80042094ed:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  80042094f3:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042094fa:	00 00 00 
  80042094fd:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209504:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209507:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420950d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209514:	00 00 00 
  8004209517:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420951e:	83 ca 80             	or     $0xffffff80,%edx
  8004209521:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209527:	48 b8 04 c2 20 04 80 	movabs $0x800420c204,%rax
  800420952e:	00 00 00 
  8004209531:	48 c1 e8 10          	shr    $0x10,%rax
  8004209535:	89 c2                	mov    %eax,%edx
  8004209537:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420953e:	00 00 00 
  8004209541:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  8004209548:	48 b8 04 c2 20 04 80 	movabs $0x800420c204,%rax
  800420954f:	00 00 00 
  8004209552:	48 c1 e8 20          	shr    $0x20,%rax
  8004209556:	89 c2                	mov    %eax,%edx
  8004209558:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420955f:	00 00 00 
  8004209562:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  8004209568:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420956f:	00 00 00 
  8004209572:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  8004209579:	00 00 00 
	SETGATE(idt[T_GPFLT], 0, GD_KT, GPFLT_F, 0);
  800420957c:	48 b8 0c c2 20 04 80 	movabs $0x800420c20c,%rax
  8004209583:	00 00 00 
  8004209586:	89 c2                	mov    %eax,%edx
  8004209588:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420958f:	00 00 00 
  8004209592:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  8004209599:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042095a0:	00 00 00 
  80042095a3:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  80042095aa:	08 00 
  80042095ac:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042095b3:	00 00 00 
  80042095b6:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  80042095bd:	83 e2 f8             	and    $0xfffffff8,%edx
  80042095c0:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  80042095c6:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042095cd:	00 00 00 
  80042095d0:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  80042095d7:	83 e2 07             	and    $0x7,%edx
  80042095da:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  80042095e0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042095e7:	00 00 00 
  80042095ea:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  80042095f1:	83 e2 f0             	and    $0xfffffff0,%edx
  80042095f4:	83 ca 0e             	or     $0xe,%edx
  80042095f7:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  80042095fd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209604:	00 00 00 
  8004209607:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420960e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209611:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209617:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420961e:	00 00 00 
  8004209621:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209628:	83 e2 9f             	and    $0xffffff9f,%edx
  800420962b:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209631:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209638:	00 00 00 
  800420963b:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209642:	83 ca 80             	or     $0xffffff80,%edx
  8004209645:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420964b:	48 b8 0c c2 20 04 80 	movabs $0x800420c20c,%rax
  8004209652:	00 00 00 
  8004209655:	48 c1 e8 10          	shr    $0x10,%rax
  8004209659:	89 c2                	mov    %eax,%edx
  800420965b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209662:	00 00 00 
  8004209665:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  800420966c:	48 b8 0c c2 20 04 80 	movabs $0x800420c20c,%rax
  8004209673:	00 00 00 
  8004209676:	48 c1 e8 20          	shr    $0x20,%rax
  800420967a:	89 c2                	mov    %eax,%edx
  800420967c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209683:	00 00 00 
  8004209686:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  800420968c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209693:	00 00 00 
  8004209696:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  800420969d:	00 00 00 
	SETGATE(idt[T_PGFLT], 0, GD_KT, PGFLT_F, 0);
  80042096a0:	48 b8 14 c2 20 04 80 	movabs $0x800420c214,%rax
  80042096a7:	00 00 00 
  80042096aa:	89 c2                	mov    %eax,%edx
  80042096ac:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042096b3:	00 00 00 
  80042096b6:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  80042096bd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042096c4:	00 00 00 
  80042096c7:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  80042096ce:	08 00 
  80042096d0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042096d7:	00 00 00 
  80042096da:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  80042096e1:	83 e2 f8             	and    $0xfffffff8,%edx
  80042096e4:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  80042096ea:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042096f1:	00 00 00 
  80042096f4:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  80042096fb:	83 e2 07             	and    $0x7,%edx
  80042096fe:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209704:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420970b:	00 00 00 
  800420970e:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209715:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209718:	83 ca 0e             	or     $0xe,%edx
  800420971b:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209721:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209728:	00 00 00 
  800420972b:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209732:	83 e2 ef             	and    $0xffffffef,%edx
  8004209735:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420973b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209742:	00 00 00 
  8004209745:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420974c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420974f:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209755:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420975c:	00 00 00 
  800420975f:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209766:	83 ca 80             	or     $0xffffff80,%edx
  8004209769:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420976f:	48 b8 14 c2 20 04 80 	movabs $0x800420c214,%rax
  8004209776:	00 00 00 
  8004209779:	48 c1 e8 10          	shr    $0x10,%rax
  800420977d:	89 c2                	mov    %eax,%edx
  800420977f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209786:	00 00 00 
  8004209789:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  8004209790:	48 b8 14 c2 20 04 80 	movabs $0x800420c214,%rax
  8004209797:	00 00 00 
  800420979a:	48 c1 e8 20          	shr    $0x20,%rax
  800420979e:	89 c2                	mov    %eax,%edx
  80042097a0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042097a7:	00 00 00 
  80042097aa:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  80042097b0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042097b7:	00 00 00 
  80042097ba:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  80042097c1:	00 00 00 
	SETGATE(idt[T_FPERR], 0, GD_KT, FPERR_F, 0);
  80042097c4:	48 b8 1c c2 20 04 80 	movabs $0x800420c21c,%rax
  80042097cb:	00 00 00 
  80042097ce:	89 c2                	mov    %eax,%edx
  80042097d0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042097d7:	00 00 00 
  80042097da:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  80042097e1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042097e8:	00 00 00 
  80042097eb:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  80042097f2:	08 00 
  80042097f4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042097fb:	00 00 00 
  80042097fe:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209805:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209808:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420980e:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209815:	00 00 00 
  8004209818:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420981f:	83 e2 07             	and    $0x7,%edx
  8004209822:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209828:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420982f:	00 00 00 
  8004209832:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209839:	83 e2 f0             	and    $0xfffffff0,%edx
  800420983c:	83 ca 0e             	or     $0xe,%edx
  800420983f:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209845:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420984c:	00 00 00 
  800420984f:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209856:	83 e2 ef             	and    $0xffffffef,%edx
  8004209859:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420985f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209866:	00 00 00 
  8004209869:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209870:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209873:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209879:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209880:	00 00 00 
  8004209883:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420988a:	83 ca 80             	or     $0xffffff80,%edx
  800420988d:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209893:	48 b8 1c c2 20 04 80 	movabs $0x800420c21c,%rax
  800420989a:	00 00 00 
  800420989d:	48 c1 e8 10          	shr    $0x10,%rax
  80042098a1:	89 c2                	mov    %eax,%edx
  80042098a3:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042098aa:	00 00 00 
  80042098ad:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  80042098b4:	48 b8 1c c2 20 04 80 	movabs $0x800420c21c,%rax
  80042098bb:	00 00 00 
  80042098be:	48 c1 e8 20          	shr    $0x20,%rax
  80042098c2:	89 c2                	mov    %eax,%edx
  80042098c4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042098cb:	00 00 00 
  80042098ce:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  80042098d4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042098db:	00 00 00 
  80042098de:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  80042098e5:	00 00 00 
	SETGATE(idt[T_ALIGN], 0, GD_KT, ALIGN_F, 0);
  80042098e8:	48 b8 26 c2 20 04 80 	movabs $0x800420c226,%rax
  80042098ef:	00 00 00 
  80042098f2:	89 c2                	mov    %eax,%edx
  80042098f4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042098fb:	00 00 00 
  80042098fe:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  8004209905:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420990c:	00 00 00 
  800420990f:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  8004209916:	08 00 
  8004209918:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420991f:	00 00 00 
  8004209922:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209929:	83 e2 f8             	and    $0xfffffff8,%edx
  800420992c:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209932:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209939:	00 00 00 
  800420993c:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209943:	83 e2 07             	and    $0x7,%edx
  8004209946:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420994c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209953:	00 00 00 
  8004209956:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420995d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209960:	83 ca 0e             	or     $0xe,%edx
  8004209963:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209969:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209970:	00 00 00 
  8004209973:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420997a:	83 e2 ef             	and    $0xffffffef,%edx
  800420997d:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209983:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420998a:	00 00 00 
  800420998d:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209994:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209997:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420999d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042099a4:	00 00 00 
  80042099a7:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  80042099ae:	83 ca 80             	or     $0xffffff80,%edx
  80042099b1:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  80042099b7:	48 b8 26 c2 20 04 80 	movabs $0x800420c226,%rax
  80042099be:	00 00 00 
  80042099c1:	48 c1 e8 10          	shr    $0x10,%rax
  80042099c5:	89 c2                	mov    %eax,%edx
  80042099c7:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042099ce:	00 00 00 
  80042099d1:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  80042099d8:	48 b8 26 c2 20 04 80 	movabs $0x800420c226,%rax
  80042099df:	00 00 00 
  80042099e2:	48 c1 e8 20          	shr    $0x20,%rax
  80042099e6:	89 c2                	mov    %eax,%edx
  80042099e8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042099ef:	00 00 00 
  80042099f2:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  80042099f8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  80042099ff:	00 00 00 
  8004209a02:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  8004209a09:	00 00 00 
	SETGATE(idt[T_MCHK], 0, GD_KT, MCHK_F, 0);
  8004209a0c:	48 b8 2e c2 20 04 80 	movabs $0x800420c22e,%rax
  8004209a13:	00 00 00 
  8004209a16:	89 c2                	mov    %eax,%edx
  8004209a18:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209a1f:	00 00 00 
  8004209a22:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  8004209a29:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209a30:	00 00 00 
  8004209a33:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  8004209a3a:	08 00 
  8004209a3c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209a43:	00 00 00 
  8004209a46:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004209a4d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a50:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004209a56:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209a5d:	00 00 00 
  8004209a60:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004209a67:	83 e2 07             	and    $0x7,%edx
  8004209a6a:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004209a70:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209a77:	00 00 00 
  8004209a7a:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209a81:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209a84:	83 ca 0e             	or     $0xe,%edx
  8004209a87:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209a8d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209a94:	00 00 00 
  8004209a97:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209a9e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209aa1:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209aa7:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209aae:	00 00 00 
  8004209ab1:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209ab8:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209abb:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209ac1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209ac8:	00 00 00 
  8004209acb:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209ad2:	83 ca 80             	or     $0xffffff80,%edx
  8004209ad5:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209adb:	48 b8 2e c2 20 04 80 	movabs $0x800420c22e,%rax
  8004209ae2:	00 00 00 
  8004209ae5:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ae9:	89 c2                	mov    %eax,%edx
  8004209aeb:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209af2:	00 00 00 
  8004209af5:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  8004209afc:	48 b8 2e c2 20 04 80 	movabs $0x800420c22e,%rax
  8004209b03:	00 00 00 
  8004209b06:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b0a:	89 c2                	mov    %eax,%edx
  8004209b0c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209b13:	00 00 00 
  8004209b16:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  8004209b1c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209b23:	00 00 00 
  8004209b26:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  8004209b2d:	00 00 00 
	SETGATE(idt[T_SIMDERR], 0, GD_KT, SIMDERR_F, 0);
  8004209b30:	48 b8 34 c2 20 04 80 	movabs $0x800420c234,%rax
  8004209b37:	00 00 00 
  8004209b3a:	89 c2                	mov    %eax,%edx
  8004209b3c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209b43:	00 00 00 
  8004209b46:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  8004209b4d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209b54:	00 00 00 
  8004209b57:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  8004209b5e:	08 00 
  8004209b60:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209b67:	00 00 00 
  8004209b6a:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004209b71:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b74:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004209b7a:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209b81:	00 00 00 
  8004209b84:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004209b8b:	83 e2 07             	and    $0x7,%edx
  8004209b8e:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004209b94:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209b9b:	00 00 00 
  8004209b9e:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209ba5:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ba8:	83 ca 0e             	or     $0xe,%edx
  8004209bab:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209bb1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209bb8:	00 00 00 
  8004209bbb:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209bc2:	83 e2 ef             	and    $0xffffffef,%edx
  8004209bc5:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209bcb:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209bd2:	00 00 00 
  8004209bd5:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209bdc:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209bdf:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209be5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209bec:	00 00 00 
  8004209bef:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209bf6:	83 ca 80             	or     $0xffffff80,%edx
  8004209bf9:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209bff:	48 b8 34 c2 20 04 80 	movabs $0x800420c234,%rax
  8004209c06:	00 00 00 
  8004209c09:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c0d:	89 c2                	mov    %eax,%edx
  8004209c0f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209c16:	00 00 00 
  8004209c19:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  8004209c20:	48 b8 34 c2 20 04 80 	movabs $0x800420c234,%rax
  8004209c27:	00 00 00 
  8004209c2a:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c2e:	89 c2                	mov    %eax,%edx
  8004209c30:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209c37:	00 00 00 
  8004209c3a:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  8004209c40:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209c47:	00 00 00 
  8004209c4a:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  8004209c51:	00 00 00 
	SETGATE(idt[T_SYSCALL], 0, GD_KT, SYSCALL_F, 3);
  8004209c54:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  8004209c5b:	00 00 00 
  8004209c5e:	89 c2                	mov    %eax,%edx
  8004209c60:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209c67:	00 00 00 
  8004209c6a:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  8004209c71:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209c78:	00 00 00 
  8004209c7b:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  8004209c82:	08 00 
  8004209c84:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209c8b:	00 00 00 
  8004209c8e:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209c95:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209c98:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209c9e:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209ca5:	00 00 00 
  8004209ca8:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209caf:	83 e2 07             	and    $0x7,%edx
  8004209cb2:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209cb8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209cbf:	00 00 00 
  8004209cc2:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209cc9:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ccc:	83 ca 0e             	or     $0xe,%edx
  8004209ccf:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209cd5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209cdc:	00 00 00 
  8004209cdf:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209ce6:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ce9:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209cef:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209cf6:	00 00 00 
  8004209cf9:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209d00:	83 ca 60             	or     $0x60,%edx
  8004209d03:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209d09:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209d10:	00 00 00 
  8004209d13:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209d1a:	83 ca 80             	or     $0xffffff80,%edx
  8004209d1d:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209d23:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  8004209d2a:	00 00 00 
  8004209d2d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d31:	89 c2                	mov    %eax,%edx
  8004209d33:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209d3a:	00 00 00 
  8004209d3d:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  8004209d44:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  8004209d4b:	00 00 00 
  8004209d4e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d52:	89 c2                	mov    %eax,%edx
  8004209d54:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209d5b:	00 00 00 
  8004209d5e:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  8004209d64:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209d6b:	00 00 00 
  8004209d6e:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  8004209d75:	00 00 00 

	// LAB 4
	SETGATE(idt[IRQ_OFFSET], 0, GD_KT, IRQ0_HANDLER, 0);
  8004209d78:	48 b8 48 c2 20 04 80 	movabs $0x800420c248,%rax
  8004209d7f:	00 00 00 
  8004209d82:	89 c2                	mov    %eax,%edx
  8004209d84:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209d8b:	00 00 00 
  8004209d8e:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  8004209d95:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209d9c:	00 00 00 
  8004209d9f:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  8004209da6:	08 00 
  8004209da8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209daf:	00 00 00 
  8004209db2:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  8004209db9:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209dbc:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  8004209dc2:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209dc9:	00 00 00 
  8004209dcc:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  8004209dd3:	83 e2 07             	and    $0x7,%edx
  8004209dd6:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  8004209ddc:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209de3:	00 00 00 
  8004209de6:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209ded:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209df0:	83 ca 0e             	or     $0xe,%edx
  8004209df3:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209df9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209e00:	00 00 00 
  8004209e03:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209e0a:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e0d:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209e13:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209e1a:	00 00 00 
  8004209e1d:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209e24:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209e27:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209e2d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209e34:	00 00 00 
  8004209e37:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209e3e:	83 ca 80             	or     $0xffffff80,%edx
  8004209e41:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209e47:	48 b8 48 c2 20 04 80 	movabs $0x800420c248,%rax
  8004209e4e:	00 00 00 
  8004209e51:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e55:	89 c2                	mov    %eax,%edx
  8004209e57:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209e5e:	00 00 00 
  8004209e61:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  8004209e68:	48 b8 48 c2 20 04 80 	movabs $0x800420c248,%rax
  8004209e6f:	00 00 00 
  8004209e72:	48 c1 e8 20          	shr    $0x20,%rax
  8004209e76:	89 c2                	mov    %eax,%edx
  8004209e78:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209e7f:	00 00 00 
  8004209e82:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  8004209e88:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209e8f:	00 00 00 
  8004209e92:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  8004209e99:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 1], 0, GD_KT, IRQ1_HANDLER, 0);
  8004209e9c:	48 b8 4e c2 20 04 80 	movabs $0x800420c24e,%rax
  8004209ea3:	00 00 00 
  8004209ea6:	89 c2                	mov    %eax,%edx
  8004209ea8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209eaf:	00 00 00 
  8004209eb2:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  8004209eb9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209ec0:	00 00 00 
  8004209ec3:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  8004209eca:	08 00 
  8004209ecc:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209ed3:	00 00 00 
  8004209ed6:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  8004209edd:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209ee0:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  8004209ee6:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209eed:	00 00 00 
  8004209ef0:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  8004209ef7:	83 e2 07             	and    $0x7,%edx
  8004209efa:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  8004209f00:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209f07:	00 00 00 
  8004209f0a:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209f11:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f14:	83 ca 0e             	or     $0xe,%edx
  8004209f17:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209f1d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209f24:	00 00 00 
  8004209f27:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209f2e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f31:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209f37:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209f3e:	00 00 00 
  8004209f41:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209f48:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f4b:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209f51:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209f58:	00 00 00 
  8004209f5b:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209f62:	83 ca 80             	or     $0xffffff80,%edx
  8004209f65:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209f6b:	48 b8 4e c2 20 04 80 	movabs $0x800420c24e,%rax
  8004209f72:	00 00 00 
  8004209f75:	48 c1 e8 10          	shr    $0x10,%rax
  8004209f79:	89 c2                	mov    %eax,%edx
  8004209f7b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209f82:	00 00 00 
  8004209f85:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  8004209f8c:	48 b8 4e c2 20 04 80 	movabs $0x800420c24e,%rax
  8004209f93:	00 00 00 
  8004209f96:	48 c1 e8 20          	shr    $0x20,%rax
  8004209f9a:	89 c2                	mov    %eax,%edx
  8004209f9c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209fa3:	00 00 00 
  8004209fa6:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  8004209fac:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209fb3:	00 00 00 
  8004209fb6:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  8004209fbd:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 2], 0, GD_KT, IRQ2_HANDLER, 0);
  8004209fc0:	48 b8 54 c2 20 04 80 	movabs $0x800420c254,%rax
  8004209fc7:	00 00 00 
  8004209fca:	89 c2                	mov    %eax,%edx
  8004209fcc:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209fd3:	00 00 00 
  8004209fd6:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  8004209fdd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209fe4:	00 00 00 
  8004209fe7:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  8004209fee:	08 00 
  8004209ff0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  8004209ff7:	00 00 00 
  8004209ffa:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a001:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a004:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a00a:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a011:	00 00 00 
  800420a014:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a01b:	83 e2 07             	and    $0x7,%edx
  800420a01e:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a024:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a02b:	00 00 00 
  800420a02e:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a035:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a038:	83 ca 0e             	or     $0xe,%edx
  800420a03b:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a041:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a048:	00 00 00 
  800420a04b:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a052:	83 e2 ef             	and    $0xffffffef,%edx
  800420a055:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a05b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a062:	00 00 00 
  800420a065:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a06c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a06f:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a075:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a07c:	00 00 00 
  800420a07f:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a086:	83 ca 80             	or     $0xffffff80,%edx
  800420a089:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a08f:	48 b8 54 c2 20 04 80 	movabs $0x800420c254,%rax
  800420a096:	00 00 00 
  800420a099:	48 c1 e8 10          	shr    $0x10,%rax
  800420a09d:	89 c2                	mov    %eax,%edx
  800420a09f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a0a6:	00 00 00 
  800420a0a9:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420a0b0:	48 b8 54 c2 20 04 80 	movabs $0x800420c254,%rax
  800420a0b7:	00 00 00 
  800420a0ba:	48 c1 e8 20          	shr    $0x20,%rax
  800420a0be:	89 c2                	mov    %eax,%edx
  800420a0c0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a0c7:	00 00 00 
  800420a0ca:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420a0d0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a0d7:	00 00 00 
  800420a0da:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420a0e1:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 3], 0, GD_KT, IRQ3_HANDLER, 0);
  800420a0e4:	48 b8 5a c2 20 04 80 	movabs $0x800420c25a,%rax
  800420a0eb:	00 00 00 
  800420a0ee:	89 c2                	mov    %eax,%edx
  800420a0f0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a0f7:	00 00 00 
  800420a0fa:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420a101:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a108:	00 00 00 
  800420a10b:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420a112:	08 00 
  800420a114:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a11b:	00 00 00 
  800420a11e:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a125:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a128:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a12e:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a135:	00 00 00 
  800420a138:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a13f:	83 e2 07             	and    $0x7,%edx
  800420a142:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a148:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a14f:	00 00 00 
  800420a152:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a159:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a15c:	83 ca 0e             	or     $0xe,%edx
  800420a15f:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a165:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a16c:	00 00 00 
  800420a16f:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a176:	83 e2 ef             	and    $0xffffffef,%edx
  800420a179:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a17f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a186:	00 00 00 
  800420a189:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a190:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a193:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a199:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a1a0:	00 00 00 
  800420a1a3:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a1aa:	83 ca 80             	or     $0xffffff80,%edx
  800420a1ad:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a1b3:	48 b8 5a c2 20 04 80 	movabs $0x800420c25a,%rax
  800420a1ba:	00 00 00 
  800420a1bd:	48 c1 e8 10          	shr    $0x10,%rax
  800420a1c1:	89 c2                	mov    %eax,%edx
  800420a1c3:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a1ca:	00 00 00 
  800420a1cd:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420a1d4:	48 b8 5a c2 20 04 80 	movabs $0x800420c25a,%rax
  800420a1db:	00 00 00 
  800420a1de:	48 c1 e8 20          	shr    $0x20,%rax
  800420a1e2:	89 c2                	mov    %eax,%edx
  800420a1e4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a1eb:	00 00 00 
  800420a1ee:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420a1f4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a1fb:	00 00 00 
  800420a1fe:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420a205:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 4], 0, GD_KT, IRQ4_HANDLER, 0);
  800420a208:	48 b8 60 c2 20 04 80 	movabs $0x800420c260,%rax
  800420a20f:	00 00 00 
  800420a212:	89 c2                	mov    %eax,%edx
  800420a214:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a21b:	00 00 00 
  800420a21e:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a225:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a22c:	00 00 00 
  800420a22f:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a236:	08 00 
  800420a238:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a23f:	00 00 00 
  800420a242:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a249:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a24c:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a252:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a259:	00 00 00 
  800420a25c:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a263:	83 e2 07             	and    $0x7,%edx
  800420a266:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a26c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a273:	00 00 00 
  800420a276:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a27d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a280:	83 ca 0e             	or     $0xe,%edx
  800420a283:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a289:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a290:	00 00 00 
  800420a293:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a29a:	83 e2 ef             	and    $0xffffffef,%edx
  800420a29d:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a2a3:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a2aa:	00 00 00 
  800420a2ad:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a2b4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a2b7:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a2bd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a2c4:	00 00 00 
  800420a2c7:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a2ce:	83 ca 80             	or     $0xffffff80,%edx
  800420a2d1:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a2d7:	48 b8 60 c2 20 04 80 	movabs $0x800420c260,%rax
  800420a2de:	00 00 00 
  800420a2e1:	48 c1 e8 10          	shr    $0x10,%rax
  800420a2e5:	89 c2                	mov    %eax,%edx
  800420a2e7:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a2ee:	00 00 00 
  800420a2f1:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420a2f8:	48 b8 60 c2 20 04 80 	movabs $0x800420c260,%rax
  800420a2ff:	00 00 00 
  800420a302:	48 c1 e8 20          	shr    $0x20,%rax
  800420a306:	89 c2                	mov    %eax,%edx
  800420a308:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a30f:	00 00 00 
  800420a312:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420a318:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a31f:	00 00 00 
  800420a322:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420a329:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 5], 0, GD_KT, IRQ5_HANDLER, 0);
  800420a32c:	48 b8 66 c2 20 04 80 	movabs $0x800420c266,%rax
  800420a333:	00 00 00 
  800420a336:	89 c2                	mov    %eax,%edx
  800420a338:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a33f:	00 00 00 
  800420a342:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420a349:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a350:	00 00 00 
  800420a353:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420a35a:	08 00 
  800420a35c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a363:	00 00 00 
  800420a366:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420a36d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a370:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420a376:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a37d:	00 00 00 
  800420a380:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420a387:	83 e2 07             	and    $0x7,%edx
  800420a38a:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420a390:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a397:	00 00 00 
  800420a39a:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a3a1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a3a4:	83 ca 0e             	or     $0xe,%edx
  800420a3a7:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a3ad:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a3b4:	00 00 00 
  800420a3b7:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a3be:	83 e2 ef             	and    $0xffffffef,%edx
  800420a3c1:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a3c7:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a3ce:	00 00 00 
  800420a3d1:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a3d8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a3db:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a3e1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a3e8:	00 00 00 
  800420a3eb:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a3f2:	83 ca 80             	or     $0xffffff80,%edx
  800420a3f5:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a3fb:	48 b8 66 c2 20 04 80 	movabs $0x800420c266,%rax
  800420a402:	00 00 00 
  800420a405:	48 c1 e8 10          	shr    $0x10,%rax
  800420a409:	89 c2                	mov    %eax,%edx
  800420a40b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a412:	00 00 00 
  800420a415:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420a41c:	48 b8 66 c2 20 04 80 	movabs $0x800420c266,%rax
  800420a423:	00 00 00 
  800420a426:	48 c1 e8 20          	shr    $0x20,%rax
  800420a42a:	89 c2                	mov    %eax,%edx
  800420a42c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a433:	00 00 00 
  800420a436:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420a43c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a443:	00 00 00 
  800420a446:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420a44d:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 6], 0, GD_KT, IRQ6_HANDLER, 0);
  800420a450:	48 b8 6c c2 20 04 80 	movabs $0x800420c26c,%rax
  800420a457:	00 00 00 
  800420a45a:	89 c2                	mov    %eax,%edx
  800420a45c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a463:	00 00 00 
  800420a466:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420a46d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a474:	00 00 00 
  800420a477:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420a47e:	08 00 
  800420a480:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a487:	00 00 00 
  800420a48a:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420a491:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a494:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420a49a:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a4a1:	00 00 00 
  800420a4a4:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420a4ab:	83 e2 07             	and    $0x7,%edx
  800420a4ae:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420a4b4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a4bb:	00 00 00 
  800420a4be:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a4c5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a4c8:	83 ca 0e             	or     $0xe,%edx
  800420a4cb:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a4d1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a4d8:	00 00 00 
  800420a4db:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a4e2:	83 e2 ef             	and    $0xffffffef,%edx
  800420a4e5:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a4eb:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a4f2:	00 00 00 
  800420a4f5:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a4fc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a4ff:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a505:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a50c:	00 00 00 
  800420a50f:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a516:	83 ca 80             	or     $0xffffff80,%edx
  800420a519:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a51f:	48 b8 6c c2 20 04 80 	movabs $0x800420c26c,%rax
  800420a526:	00 00 00 
  800420a529:	48 c1 e8 10          	shr    $0x10,%rax
  800420a52d:	89 c2                	mov    %eax,%edx
  800420a52f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a536:	00 00 00 
  800420a539:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420a540:	48 b8 6c c2 20 04 80 	movabs $0x800420c26c,%rax
  800420a547:	00 00 00 
  800420a54a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a54e:	89 c2                	mov    %eax,%edx
  800420a550:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a557:	00 00 00 
  800420a55a:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420a560:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a567:	00 00 00 
  800420a56a:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420a571:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 7], 0, GD_KT, IRQ7_HANDLER, 0);
  800420a574:	48 b8 72 c2 20 04 80 	movabs $0x800420c272,%rax
  800420a57b:	00 00 00 
  800420a57e:	89 c2                	mov    %eax,%edx
  800420a580:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a587:	00 00 00 
  800420a58a:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420a591:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a598:	00 00 00 
  800420a59b:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420a5a2:	08 00 
  800420a5a4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a5ab:	00 00 00 
  800420a5ae:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a5b5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a5b8:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a5be:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a5c5:	00 00 00 
  800420a5c8:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a5cf:	83 e2 07             	and    $0x7,%edx
  800420a5d2:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a5d8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a5df:	00 00 00 
  800420a5e2:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a5e9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a5ec:	83 ca 0e             	or     $0xe,%edx
  800420a5ef:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a5f5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a5fc:	00 00 00 
  800420a5ff:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a606:	83 e2 ef             	and    $0xffffffef,%edx
  800420a609:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a60f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a616:	00 00 00 
  800420a619:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a620:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a623:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a629:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a630:	00 00 00 
  800420a633:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a63a:	83 ca 80             	or     $0xffffff80,%edx
  800420a63d:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a643:	48 b8 72 c2 20 04 80 	movabs $0x800420c272,%rax
  800420a64a:	00 00 00 
  800420a64d:	48 c1 e8 10          	shr    $0x10,%rax
  800420a651:	89 c2                	mov    %eax,%edx
  800420a653:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a65a:	00 00 00 
  800420a65d:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420a664:	48 b8 72 c2 20 04 80 	movabs $0x800420c272,%rax
  800420a66b:	00 00 00 
  800420a66e:	48 c1 e8 20          	shr    $0x20,%rax
  800420a672:	89 c2                	mov    %eax,%edx
  800420a674:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a67b:	00 00 00 
  800420a67e:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420a684:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a68b:	00 00 00 
  800420a68e:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420a695:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 8], 0, GD_KT, IRQ8_HANDLER, 0);
  800420a698:	48 b8 78 c2 20 04 80 	movabs $0x800420c278,%rax
  800420a69f:	00 00 00 
  800420a6a2:	89 c2                	mov    %eax,%edx
  800420a6a4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a6ab:	00 00 00 
  800420a6ae:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420a6b5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a6bc:	00 00 00 
  800420a6bf:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420a6c6:	08 00 
  800420a6c8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a6cf:	00 00 00 
  800420a6d2:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420a6d9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a6dc:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420a6e2:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a6e9:	00 00 00 
  800420a6ec:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420a6f3:	83 e2 07             	and    $0x7,%edx
  800420a6f6:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420a6fc:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a703:	00 00 00 
  800420a706:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a70d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a710:	83 ca 0e             	or     $0xe,%edx
  800420a713:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a719:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a720:	00 00 00 
  800420a723:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a72a:	83 e2 ef             	and    $0xffffffef,%edx
  800420a72d:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a733:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a73a:	00 00 00 
  800420a73d:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a744:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a747:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a74d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a754:	00 00 00 
  800420a757:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a75e:	83 ca 80             	or     $0xffffff80,%edx
  800420a761:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a767:	48 b8 78 c2 20 04 80 	movabs $0x800420c278,%rax
  800420a76e:	00 00 00 
  800420a771:	48 c1 e8 10          	shr    $0x10,%rax
  800420a775:	89 c2                	mov    %eax,%edx
  800420a777:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a77e:	00 00 00 
  800420a781:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420a788:	48 b8 78 c2 20 04 80 	movabs $0x800420c278,%rax
  800420a78f:	00 00 00 
  800420a792:	48 c1 e8 20          	shr    $0x20,%rax
  800420a796:	89 c2                	mov    %eax,%edx
  800420a798:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a79f:	00 00 00 
  800420a7a2:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420a7a8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a7af:	00 00 00 
  800420a7b2:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420a7b9:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 9], 0, GD_KT, IRQ9_HANDLER, 0);
  800420a7bc:	48 b8 7e c2 20 04 80 	movabs $0x800420c27e,%rax
  800420a7c3:	00 00 00 
  800420a7c6:	89 c2                	mov    %eax,%edx
  800420a7c8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a7cf:	00 00 00 
  800420a7d2:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420a7d9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a7e0:	00 00 00 
  800420a7e3:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420a7ea:	08 00 
  800420a7ec:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a7f3:	00 00 00 
  800420a7f6:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420a7fd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a800:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420a806:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a80d:	00 00 00 
  800420a810:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420a817:	83 e2 07             	and    $0x7,%edx
  800420a81a:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420a820:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a827:	00 00 00 
  800420a82a:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a831:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a834:	83 ca 0e             	or     $0xe,%edx
  800420a837:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a83d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a844:	00 00 00 
  800420a847:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a84e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a851:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a857:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a85e:	00 00 00 
  800420a861:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a868:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a86b:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a871:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a878:	00 00 00 
  800420a87b:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a882:	83 ca 80             	or     $0xffffff80,%edx
  800420a885:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a88b:	48 b8 7e c2 20 04 80 	movabs $0x800420c27e,%rax
  800420a892:	00 00 00 
  800420a895:	48 c1 e8 10          	shr    $0x10,%rax
  800420a899:	89 c2                	mov    %eax,%edx
  800420a89b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a8a2:	00 00 00 
  800420a8a5:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420a8ac:	48 b8 7e c2 20 04 80 	movabs $0x800420c27e,%rax
  800420a8b3:	00 00 00 
  800420a8b6:	48 c1 e8 20          	shr    $0x20,%rax
  800420a8ba:	89 c2                	mov    %eax,%edx
  800420a8bc:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a8c3:	00 00 00 
  800420a8c6:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420a8cc:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a8d3:	00 00 00 
  800420a8d6:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420a8dd:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, IRQ10_HANDLER, 0);
  800420a8e0:	48 b8 84 c2 20 04 80 	movabs $0x800420c284,%rax
  800420a8e7:	00 00 00 
  800420a8ea:	89 c2                	mov    %eax,%edx
  800420a8ec:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a8f3:	00 00 00 
  800420a8f6:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420a8fd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a904:	00 00 00 
  800420a907:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420a90e:	08 00 
  800420a910:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a917:	00 00 00 
  800420a91a:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420a921:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a924:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420a92a:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a931:	00 00 00 
  800420a934:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420a93b:	83 e2 07             	and    $0x7,%edx
  800420a93e:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420a944:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a94b:	00 00 00 
  800420a94e:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a955:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a958:	83 ca 0e             	or     $0xe,%edx
  800420a95b:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a961:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a968:	00 00 00 
  800420a96b:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a972:	83 e2 ef             	and    $0xffffffef,%edx
  800420a975:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a97b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a982:	00 00 00 
  800420a985:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a98c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a98f:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a995:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a99c:	00 00 00 
  800420a99f:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a9a6:	83 ca 80             	or     $0xffffff80,%edx
  800420a9a9:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a9af:	48 b8 84 c2 20 04 80 	movabs $0x800420c284,%rax
  800420a9b6:	00 00 00 
  800420a9b9:	48 c1 e8 10          	shr    $0x10,%rax
  800420a9bd:	89 c2                	mov    %eax,%edx
  800420a9bf:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a9c6:	00 00 00 
  800420a9c9:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420a9d0:	48 b8 84 c2 20 04 80 	movabs $0x800420c284,%rax
  800420a9d7:	00 00 00 
  800420a9da:	48 c1 e8 20          	shr    $0x20,%rax
  800420a9de:	89 c2                	mov    %eax,%edx
  800420a9e0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a9e7:	00 00 00 
  800420a9ea:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420a9f0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420a9f7:	00 00 00 
  800420a9fa:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420aa01:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, IRQ11_HANDLER, 0);
  800420aa04:	48 b8 8a c2 20 04 80 	movabs $0x800420c28a,%rax
  800420aa0b:	00 00 00 
  800420aa0e:	89 c2                	mov    %eax,%edx
  800420aa10:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aa17:	00 00 00 
  800420aa1a:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420aa21:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aa28:	00 00 00 
  800420aa2b:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420aa32:	08 00 
  800420aa34:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aa3b:	00 00 00 
  800420aa3e:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420aa45:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aa48:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420aa4e:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aa55:	00 00 00 
  800420aa58:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420aa5f:	83 e2 07             	and    $0x7,%edx
  800420aa62:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420aa68:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aa6f:	00 00 00 
  800420aa72:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420aa79:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aa7c:	83 ca 0e             	or     $0xe,%edx
  800420aa7f:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420aa85:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aa8c:	00 00 00 
  800420aa8f:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420aa96:	83 e2 ef             	and    $0xffffffef,%edx
  800420aa99:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420aa9f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aaa6:	00 00 00 
  800420aaa9:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420aab0:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aab3:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420aab9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aac0:	00 00 00 
  800420aac3:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420aaca:	83 ca 80             	or     $0xffffff80,%edx
  800420aacd:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420aad3:	48 b8 8a c2 20 04 80 	movabs $0x800420c28a,%rax
  800420aada:	00 00 00 
  800420aadd:	48 c1 e8 10          	shr    $0x10,%rax
  800420aae1:	89 c2                	mov    %eax,%edx
  800420aae3:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aaea:	00 00 00 
  800420aaed:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420aaf4:	48 b8 8a c2 20 04 80 	movabs $0x800420c28a,%rax
  800420aafb:	00 00 00 
  800420aafe:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab02:	89 c2                	mov    %eax,%edx
  800420ab04:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ab0b:	00 00 00 
  800420ab0e:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420ab14:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ab1b:	00 00 00 
  800420ab1e:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420ab25:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, IRQ12_HANDLER, 0);
  800420ab28:	48 b8 90 c2 20 04 80 	movabs $0x800420c290,%rax
  800420ab2f:	00 00 00 
  800420ab32:	89 c2                	mov    %eax,%edx
  800420ab34:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ab3b:	00 00 00 
  800420ab3e:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420ab45:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ab4c:	00 00 00 
  800420ab4f:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420ab56:	08 00 
  800420ab58:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ab5f:	00 00 00 
  800420ab62:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420ab69:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ab6c:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420ab72:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ab79:	00 00 00 
  800420ab7c:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420ab83:	83 e2 07             	and    $0x7,%edx
  800420ab86:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420ab8c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ab93:	00 00 00 
  800420ab96:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420ab9d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aba0:	83 ca 0e             	or     $0xe,%edx
  800420aba3:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420aba9:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420abb0:	00 00 00 
  800420abb3:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420abba:	83 e2 ef             	and    $0xffffffef,%edx
  800420abbd:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420abc3:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420abca:	00 00 00 
  800420abcd:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420abd4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420abd7:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420abdd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420abe4:	00 00 00 
  800420abe7:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420abee:	83 ca 80             	or     $0xffffff80,%edx
  800420abf1:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420abf7:	48 b8 90 c2 20 04 80 	movabs $0x800420c290,%rax
  800420abfe:	00 00 00 
  800420ac01:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac05:	89 c2                	mov    %eax,%edx
  800420ac07:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ac0e:	00 00 00 
  800420ac11:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420ac18:	48 b8 90 c2 20 04 80 	movabs $0x800420c290,%rax
  800420ac1f:	00 00 00 
  800420ac22:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac26:	89 c2                	mov    %eax,%edx
  800420ac28:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ac2f:	00 00 00 
  800420ac32:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420ac38:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ac3f:	00 00 00 
  800420ac42:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420ac49:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, IRQ13_HANDLER, 0);
  800420ac4c:	48 b8 96 c2 20 04 80 	movabs $0x800420c296,%rax
  800420ac53:	00 00 00 
  800420ac56:	89 c2                	mov    %eax,%edx
  800420ac58:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ac5f:	00 00 00 
  800420ac62:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420ac69:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ac70:	00 00 00 
  800420ac73:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420ac7a:	08 00 
  800420ac7c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ac83:	00 00 00 
  800420ac86:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420ac8d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ac90:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420ac96:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ac9d:	00 00 00 
  800420aca0:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420aca7:	83 e2 07             	and    $0x7,%edx
  800420acaa:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420acb0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420acb7:	00 00 00 
  800420acba:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420acc1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420acc4:	83 ca 0e             	or     $0xe,%edx
  800420acc7:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420accd:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420acd4:	00 00 00 
  800420acd7:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420acde:	83 e2 ef             	and    $0xffffffef,%edx
  800420ace1:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ace7:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420acee:	00 00 00 
  800420acf1:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420acf8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420acfb:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ad01:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ad08:	00 00 00 
  800420ad0b:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ad12:	83 ca 80             	or     $0xffffff80,%edx
  800420ad15:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ad1b:	48 b8 96 c2 20 04 80 	movabs $0x800420c296,%rax
  800420ad22:	00 00 00 
  800420ad25:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad29:	89 c2                	mov    %eax,%edx
  800420ad2b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ad32:	00 00 00 
  800420ad35:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420ad3c:	48 b8 96 c2 20 04 80 	movabs $0x800420c296,%rax
  800420ad43:	00 00 00 
  800420ad46:	48 c1 e8 20          	shr    $0x20,%rax
  800420ad4a:	89 c2                	mov    %eax,%edx
  800420ad4c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ad53:	00 00 00 
  800420ad56:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420ad5c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ad63:	00 00 00 
  800420ad66:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420ad6d:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, IRQ14_HANDLER, 0);
  800420ad70:	48 b8 9c c2 20 04 80 	movabs $0x800420c29c,%rax
  800420ad77:	00 00 00 
  800420ad7a:	89 c2                	mov    %eax,%edx
  800420ad7c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ad83:	00 00 00 
  800420ad86:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420ad8d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ad94:	00 00 00 
  800420ad97:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420ad9e:	08 00 
  800420ada0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ada7:	00 00 00 
  800420adaa:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420adb1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420adb4:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420adba:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420adc1:	00 00 00 
  800420adc4:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420adcb:	83 e2 07             	and    $0x7,%edx
  800420adce:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420add4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420addb:	00 00 00 
  800420adde:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ade5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ade8:	83 ca 0e             	or     $0xe,%edx
  800420adeb:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420adf1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420adf8:	00 00 00 
  800420adfb:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ae02:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae05:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ae0b:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ae12:	00 00 00 
  800420ae15:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ae1c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae1f:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ae25:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ae2c:	00 00 00 
  800420ae2f:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ae36:	83 ca 80             	or     $0xffffff80,%edx
  800420ae39:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ae3f:	48 b8 9c c2 20 04 80 	movabs $0x800420c29c,%rax
  800420ae46:	00 00 00 
  800420ae49:	48 c1 e8 10          	shr    $0x10,%rax
  800420ae4d:	89 c2                	mov    %eax,%edx
  800420ae4f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ae56:	00 00 00 
  800420ae59:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420ae60:	48 b8 9c c2 20 04 80 	movabs $0x800420c29c,%rax
  800420ae67:	00 00 00 
  800420ae6a:	48 c1 e8 20          	shr    $0x20,%rax
  800420ae6e:	89 c2                	mov    %eax,%edx
  800420ae70:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ae77:	00 00 00 
  800420ae7a:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420ae80:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420ae87:	00 00 00 
  800420ae8a:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420ae91:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, IRQ15_HANDLER, 0);
  800420ae94:	48 b8 a2 c2 20 04 80 	movabs $0x800420c2a2,%rax
  800420ae9b:	00 00 00 
  800420ae9e:	89 c2                	mov    %eax,%edx
  800420aea0:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aea7:	00 00 00 
  800420aeaa:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420aeb1:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aeb8:	00 00 00 
  800420aebb:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420aec2:	08 00 
  800420aec4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aecb:	00 00 00 
  800420aece:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420aed5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aed8:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420aede:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aee5:	00 00 00 
  800420aee8:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420aeef:	83 e2 07             	and    $0x7,%edx
  800420aef2:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420aef8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420aeff:	00 00 00 
  800420af02:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420af09:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af0c:	83 ca 0e             	or     $0xe,%edx
  800420af0f:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420af15:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420af1c:	00 00 00 
  800420af1f:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420af26:	83 e2 ef             	and    $0xffffffef,%edx
  800420af29:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420af2f:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420af36:	00 00 00 
  800420af39:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420af40:	83 e2 9f             	and    $0xffffff9f,%edx
  800420af43:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420af49:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420af50:	00 00 00 
  800420af53:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420af5a:	83 ca 80             	or     $0xffffff80,%edx
  800420af5d:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420af63:	48 b8 a2 c2 20 04 80 	movabs $0x800420c2a2,%rax
  800420af6a:	00 00 00 
  800420af6d:	48 c1 e8 10          	shr    $0x10,%rax
  800420af71:	89 c2                	mov    %eax,%edx
  800420af73:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420af7a:	00 00 00 
  800420af7d:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420af84:	48 b8 a2 c2 20 04 80 	movabs $0x800420c2a2,%rax
  800420af8b:	00 00 00 
  800420af8e:	48 c1 e8 20          	shr    $0x20,%rax
  800420af92:	89 c2                	mov    %eax,%edx
  800420af94:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420af9b:	00 00 00 
  800420af9e:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420afa4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420afab:	00 00 00 
  800420afae:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420afb5:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], 0, GD_KT, IRQ_ERROR_HANDLER, 0);
  800420afb8:	48 b8 a8 c2 20 04 80 	movabs $0x800420c2a8,%rax
  800420afbf:	00 00 00 
  800420afc2:	89 c2                	mov    %eax,%edx
  800420afc4:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420afcb:	00 00 00 
  800420afce:	66 89 90 30 03 00 00 	mov    %dx,0x330(%rax)
  800420afd5:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420afdc:	00 00 00 
  800420afdf:	66 c7 80 32 03 00 00 	movw   $0x8,0x332(%rax)
  800420afe6:	08 00 
  800420afe8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420afef:	00 00 00 
  800420aff2:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420aff9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420affc:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420b002:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420b009:	00 00 00 
  800420b00c:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420b013:	83 e2 07             	and    $0x7,%edx
  800420b016:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420b01c:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420b023:	00 00 00 
  800420b026:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420b02d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b030:	83 ca 0e             	or     $0xe,%edx
  800420b033:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420b039:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420b040:	00 00 00 
  800420b043:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420b04a:	83 e2 ef             	and    $0xffffffef,%edx
  800420b04d:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420b053:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420b05a:	00 00 00 
  800420b05d:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420b064:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b067:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420b06d:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420b074:	00 00 00 
  800420b077:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420b07e:	83 ca 80             	or     $0xffffff80,%edx
  800420b081:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420b087:	48 b8 a8 c2 20 04 80 	movabs $0x800420c2a8,%rax
  800420b08e:	00 00 00 
  800420b091:	48 c1 e8 10          	shr    $0x10,%rax
  800420b095:	89 c2                	mov    %eax,%edx
  800420b097:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420b09e:	00 00 00 
  800420b0a1:	66 89 90 36 03 00 00 	mov    %dx,0x336(%rax)
  800420b0a8:	48 b8 a8 c2 20 04 80 	movabs $0x800420c2a8,%rax
  800420b0af:	00 00 00 
  800420b0b2:	48 c1 e8 20          	shr    $0x20,%rax
  800420b0b6:	89 c2                	mov    %eax,%edx
  800420b0b8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420b0bf:	00 00 00 
  800420b0c2:	89 90 38 03 00 00    	mov    %edx,0x338(%rax)
  800420b0c8:	48 b8 80 32 3d 04 80 	movabs $0x80043d3280,%rax
  800420b0cf:	00 00 00 
  800420b0d2:	c7 80 3c 03 00 00 00 	movl   $0x0,0x33c(%rax)
  800420b0d9:	00 00 00 
	// Per-CPU setup
	trap_init_percpu();
  800420b0dc:	48 b8 ea b0 20 04 80 	movabs $0x800420b0ea,%rax
  800420b0e3:	00 00 00 
  800420b0e6:	ff d0                	callq  *%rax
}
  800420b0e8:	5d                   	pop    %rbp
  800420b0e9:	c3                   	retq   

000000800420b0ea <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420b0ea:	55                   	push   %rbp
  800420b0eb:	48 89 e5             	mov    %rsp,%rbp
  800420b0ee:	48 83 ec 20          	sub    $0x20,%rsp
	// get a triple fault.  If you set up an individual CPU's TSS
	// wrong, you may not get a fault until you try to return from
	// user space on that CPU.
	//
	// LAB 4: Your code here:
	uint8_t id =  thiscpu->cpu_id;
  800420b0f2:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420b0f9:	00 00 00 
  800420b0fc:	ff d0                	callq  *%rax
  800420b0fe:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420b105:	00 00 00 
  800420b108:	48 98                	cltq   
  800420b10a:	48 c1 e0 03          	shl    $0x3,%rax
  800420b10e:	48 89 c2             	mov    %rax,%rdx
  800420b111:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b115:	48 29 c2             	sub    %rax,%rdx
  800420b118:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b11c:	0f b6 00             	movzbl (%rax),%eax
  800420b11f:	88 45 ff             	mov    %al,-0x1(%rbp)

	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - id * (KSTKSIZE + KSTKGAP);
  800420b122:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420b129:	00 00 00 
  800420b12c:	ff d0                	callq  *%rax
  800420b12e:	89 c6                	mov    %eax,%esi
  800420b130:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  800420b134:	89 d0                	mov    %edx,%eax
  800420b136:	01 c0                	add    %eax,%eax
  800420b138:	01 d0                	add    %edx,%eax
  800420b13a:	c1 e0 0f             	shl    $0xf,%eax
  800420b13d:	48 98                	cltq   
  800420b13f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420b146:	00 00 00 
  800420b149:	48 29 c2             	sub    %rax,%rdx
  800420b14c:	48 89 d0             	mov    %rdx,%rax
  800420b14f:	48 89 c1             	mov    %rax,%rcx
  800420b152:	48 bf 20 60 3d 04 80 	movabs $0x80043d6020,%rdi
  800420b159:	00 00 00 
  800420b15c:	48 63 c6             	movslq %esi,%rax
  800420b15f:	48 c1 e0 03          	shl    $0x3,%rax
  800420b163:	48 89 c2             	mov    %rax,%rdx
  800420b166:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b16a:	48 29 c2             	sub    %rax,%rdx
  800420b16d:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
  800420b171:	48 83 c0 10          	add    $0x10,%rax
  800420b175:	48 89 48 04          	mov    %rcx,0x4(%rax)
	struct Segdesc *seg = &gdt[(GD_TSS0 >> 3) + 2*id];
  800420b179:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  800420b17d:	01 c0                	add    %eax,%eax
  800420b17f:	83 c0 05             	add    $0x5,%eax
  800420b182:	48 98                	cltq   
  800420b184:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b18b:	00 
  800420b18c:	48 b8 c0 b5 22 04 80 	movabs $0x800422b5c0,%rax
  800420b193:	00 00 00 
  800420b196:	48 01 d0             	add    %rdx,%rax
  800420b199:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	SETTSS((struct SystemSegdesc64 *)seg, STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420b19d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b1a1:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420b1a6:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420b1ad:	00 00 00 
  800420b1b0:	ff d0                	callq  *%rax
  800420b1b2:	48 98                	cltq   
  800420b1b4:	48 c1 e0 03          	shl    $0x3,%rax
  800420b1b8:	48 89 c2             	mov    %rax,%rdx
  800420b1bb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b1bf:	48 29 c2             	sub    %rax,%rdx
  800420b1c2:	48 83 c2 10          	add    $0x10,%rdx
  800420b1c6:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  800420b1cd:	00 00 00 
  800420b1d0:	48 01 d0             	add    %rdx,%rax
  800420b1d3:	89 c2                	mov    %eax,%edx
  800420b1d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b1d9:	66 89 50 02          	mov    %dx,0x2(%rax)
  800420b1dd:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420b1e4:	00 00 00 
  800420b1e7:	ff d0                	callq  *%rax
  800420b1e9:	48 98                	cltq   
  800420b1eb:	48 c1 e0 03          	shl    $0x3,%rax
  800420b1ef:	48 89 c2             	mov    %rax,%rdx
  800420b1f2:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b1f6:	48 29 c2             	sub    %rax,%rdx
  800420b1f9:	48 83 c2 10          	add    $0x10,%rdx
  800420b1fd:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  800420b204:	00 00 00 
  800420b207:	48 01 d0             	add    %rdx,%rax
  800420b20a:	48 c1 e8 10          	shr    $0x10,%rax
  800420b20e:	89 c2                	mov    %eax,%edx
  800420b210:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b214:	88 50 04             	mov    %dl,0x4(%rax)
  800420b217:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b21b:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b21f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b222:	83 ca 09             	or     $0x9,%edx
  800420b225:	88 50 05             	mov    %dl,0x5(%rax)
  800420b228:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b22c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b230:	83 e2 ef             	and    $0xffffffef,%edx
  800420b233:	88 50 05             	mov    %dl,0x5(%rax)
  800420b236:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b23a:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b23e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b241:	88 50 05             	mov    %dl,0x5(%rax)
  800420b244:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b248:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b24c:	83 ca 80             	or     $0xffffff80,%edx
  800420b24f:	88 50 05             	mov    %dl,0x5(%rax)
  800420b252:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b256:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b25a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b25d:	88 50 06             	mov    %dl,0x6(%rax)
  800420b260:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b264:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b268:	83 e2 ef             	and    $0xffffffef,%edx
  800420b26b:	88 50 06             	mov    %dl,0x6(%rax)
  800420b26e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b272:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b276:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b279:	88 50 06             	mov    %dl,0x6(%rax)
  800420b27c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b280:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b284:	83 e2 7f             	and    $0x7f,%edx
  800420b287:	88 50 06             	mov    %dl,0x6(%rax)
  800420b28a:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420b291:	00 00 00 
  800420b294:	ff d0                	callq  *%rax
  800420b296:	48 98                	cltq   
  800420b298:	48 c1 e0 03          	shl    $0x3,%rax
  800420b29c:	48 89 c2             	mov    %rax,%rdx
  800420b29f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b2a3:	48 29 c2             	sub    %rax,%rdx
  800420b2a6:	48 83 c2 10          	add    $0x10,%rdx
  800420b2aa:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  800420b2b1:	00 00 00 
  800420b2b4:	48 01 d0             	add    %rdx,%rax
  800420b2b7:	48 c1 e8 18          	shr    $0x18,%rax
  800420b2bb:	89 c2                	mov    %eax,%edx
  800420b2bd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b2c1:	88 50 07             	mov    %dl,0x7(%rax)
  800420b2c4:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420b2cb:	00 00 00 
  800420b2ce:	ff d0                	callq  *%rax
  800420b2d0:	48 98                	cltq   
  800420b2d2:	48 c1 e0 03          	shl    $0x3,%rax
  800420b2d6:	48 89 c2             	mov    %rax,%rdx
  800420b2d9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b2dd:	48 29 c2             	sub    %rax,%rdx
  800420b2e0:	48 83 c2 10          	add    $0x10,%rdx
  800420b2e4:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  800420b2eb:	00 00 00 
  800420b2ee:	48 01 d0             	add    %rdx,%rax
  800420b2f1:	48 c1 e8 20          	shr    $0x20,%rax
  800420b2f5:	89 c2                	mov    %eax,%edx
  800420b2f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b2fb:	89 50 08             	mov    %edx,0x8(%rax)
  800420b2fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b302:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420b306:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b30a:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420b30e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b312:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
	ltr(GD_TSS0 + 2 * (id << 3));
  800420b318:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  800420b31c:	c1 e0 03             	shl    $0x3,%eax
  800420b31f:	83 c0 14             	add    $0x14,%eax
  800420b322:	01 c0                	add    %eax,%eax
  800420b324:	0f b7 c0             	movzwl %ax,%eax
  800420b327:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420b32b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420b32f:	0f 00 d8             	ltr    %ax
  800420b332:	48 b8 80 42 3d 04 80 	movabs $0x80043d4280,%rax
  800420b339:	00 00 00 
  800420b33c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420b340:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b344:	0f 01 18             	lidt   (%rax)
	// bottom three bits are special; we leave them 0)
	//ltr(GD_TSS0);

	// Load the IDT
	lidt(&idt_pd);
}
  800420b347:	c9                   	leaveq 
  800420b348:	c3                   	retq   

000000800420b349 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420b349:	55                   	push   %rbp
  800420b34a:	48 89 e5             	mov    %rsp,%rbp
  800420b34d:	48 83 ec 20          	sub    $0x20,%rsp
  800420b351:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420b355:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420b35c:	00 00 00 
  800420b35f:	ff d0                	callq  *%rax
  800420b361:	89 c2                	mov    %eax,%edx
  800420b363:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b367:	48 89 c6             	mov    %rax,%rsi
  800420b36a:	48 bf 8e 77 21 04 80 	movabs $0x800421778e,%rdi
  800420b371:	00 00 00 
  800420b374:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b379:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  800420b380:	00 00 00 
  800420b383:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420b385:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b389:	48 89 c7             	mov    %rax,%rdi
  800420b38c:	48 b8 5a b6 20 04 80 	movabs $0x800420b65a,%rax
  800420b393:	00 00 00 
  800420b396:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420b398:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b39c:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420b3a0:	0f b7 c0             	movzwl %ax,%eax
  800420b3a3:	89 c6                	mov    %eax,%esi
  800420b3a5:	48 bf ac 77 21 04 80 	movabs $0x80042177ac,%rdi
  800420b3ac:	00 00 00 
  800420b3af:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b3b4:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b3bb:	00 00 00 
  800420b3be:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420b3c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b3c4:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420b3cb:	0f b7 c0             	movzwl %ax,%eax
  800420b3ce:	89 c6                	mov    %eax,%esi
  800420b3d0:	48 bf bf 77 21 04 80 	movabs $0x80042177bf,%rdi
  800420b3d7:	00 00 00 
  800420b3da:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b3df:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b3e6:	00 00 00 
  800420b3e9:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420b3eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b3ef:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b3f6:	89 c7                	mov    %eax,%edi
  800420b3f8:	48 b8 db 88 20 04 80 	movabs $0x80042088db,%rax
  800420b3ff:	00 00 00 
  800420b402:	ff d0                	callq  *%rax
  800420b404:	48 89 c2             	mov    %rax,%rdx
  800420b407:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b40b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b412:	48 89 c6             	mov    %rax,%rsi
  800420b415:	48 bf d2 77 21 04 80 	movabs $0x80042177d2,%rdi
  800420b41c:	00 00 00 
  800420b41f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b424:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  800420b42b:	00 00 00 
  800420b42e:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420b430:	48 b8 90 42 3d 04 80 	movabs $0x80043d4290,%rax
  800420b437:	00 00 00 
  800420b43a:	48 8b 00             	mov    (%rax),%rax
  800420b43d:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420b441:	75 3a                	jne    800420b47d <print_trapframe+0x134>
  800420b443:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b447:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b44e:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b452:	75 29                	jne    800420b47d <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420b454:	0f 20 d0             	mov    %cr2,%rax
  800420b457:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420b45b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420b45f:	48 89 c6             	mov    %rax,%rsi
  800420b462:	48 bf e4 77 21 04 80 	movabs $0x80042177e4,%rdi
  800420b469:	00 00 00 
  800420b46c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b471:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b478:	00 00 00 
  800420b47b:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420b47d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b481:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b488:	48 89 c6             	mov    %rax,%rsi
  800420b48b:	48 bf f3 77 21 04 80 	movabs $0x80042177f3,%rdi
  800420b492:	00 00 00 
  800420b495:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b49a:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b4a1:	00 00 00 
  800420b4a4:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420b4a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b4aa:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b4b1:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b4b5:	0f 85 9c 00 00 00    	jne    800420b557 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420b4bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b4bf:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b4c6:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b4c9:	48 85 c0             	test   %rax,%rax
  800420b4cc:	74 0c                	je     800420b4da <print_trapframe+0x191>
  800420b4ce:	48 b9 01 78 21 04 80 	movabs $0x8004217801,%rcx
  800420b4d5:	00 00 00 
  800420b4d8:	eb 0a                	jmp    800420b4e4 <print_trapframe+0x19b>
  800420b4da:	48 b9 0c 78 21 04 80 	movabs $0x800421780c,%rcx
  800420b4e1:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420b4e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b4e8:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b4ef:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b4f2:	48 85 c0             	test   %rax,%rax
  800420b4f5:	74 0c                	je     800420b503 <print_trapframe+0x1ba>
  800420b4f7:	48 ba 18 78 21 04 80 	movabs $0x8004217818,%rdx
  800420b4fe:	00 00 00 
  800420b501:	eb 0a                	jmp    800420b50d <print_trapframe+0x1c4>
  800420b503:	48 ba 1e 78 21 04 80 	movabs $0x800421781e,%rdx
  800420b50a:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420b50d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b511:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b518:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b51b:	48 85 c0             	test   %rax,%rax
  800420b51e:	74 0c                	je     800420b52c <print_trapframe+0x1e3>
  800420b520:	48 b8 23 78 21 04 80 	movabs $0x8004217823,%rax
  800420b527:	00 00 00 
  800420b52a:	eb 0a                	jmp    800420b536 <print_trapframe+0x1ed>
  800420b52c:	48 b8 28 78 21 04 80 	movabs $0x8004217828,%rax
  800420b533:	00 00 00 
  800420b536:	48 89 c6             	mov    %rax,%rsi
  800420b539:	48 bf 2f 78 21 04 80 	movabs $0x800421782f,%rdi
  800420b540:	00 00 00 
  800420b543:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b548:	49 b8 c2 87 20 04 80 	movabs $0x80042087c2,%r8
  800420b54f:	00 00 00 
  800420b552:	41 ff d0             	callq  *%r8
  800420b555:	eb 1b                	jmp    800420b572 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420b557:	48 bf 3e 78 21 04 80 	movabs $0x800421783e,%rdi
  800420b55e:	00 00 00 
  800420b561:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b566:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b56d:	00 00 00 
  800420b570:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420b572:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b576:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420b57d:	48 89 c6             	mov    %rax,%rsi
  800420b580:	48 bf 40 78 21 04 80 	movabs $0x8004217840,%rdi
  800420b587:	00 00 00 
  800420b58a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b58f:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b596:	00 00 00 
  800420b599:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420b59b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b59f:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b5a6:	0f b7 c0             	movzwl %ax,%eax
  800420b5a9:	89 c6                	mov    %eax,%esi
  800420b5ab:	48 bf 4f 78 21 04 80 	movabs $0x800421784f,%rdi
  800420b5b2:	00 00 00 
  800420b5b5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b5ba:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b5c1:	00 00 00 
  800420b5c4:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420b5c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b5ca:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420b5d1:	48 89 c6             	mov    %rax,%rsi
  800420b5d4:	48 bf 62 78 21 04 80 	movabs $0x8004217862,%rdi
  800420b5db:	00 00 00 
  800420b5de:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b5e3:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b5ea:	00 00 00 
  800420b5ed:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420b5ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b5f3:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b5fa:	0f b7 c0             	movzwl %ax,%eax
  800420b5fd:	83 e0 03             	and    $0x3,%eax
  800420b600:	85 c0                	test   %eax,%eax
  800420b602:	74 54                	je     800420b658 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420b604:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b608:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420b60f:	48 89 c6             	mov    %rax,%rsi
  800420b612:	48 bf 71 78 21 04 80 	movabs $0x8004217871,%rdi
  800420b619:	00 00 00 
  800420b61c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b621:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b628:	00 00 00 
  800420b62b:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420b62d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b631:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420b638:	0f b7 c0             	movzwl %ax,%eax
  800420b63b:	89 c6                	mov    %eax,%esi
  800420b63d:	48 bf 80 78 21 04 80 	movabs $0x8004217880,%rdi
  800420b644:	00 00 00 
  800420b647:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b64c:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b653:	00 00 00 
  800420b656:	ff d2                	callq  *%rdx
	}
}
  800420b658:	c9                   	leaveq 
  800420b659:	c3                   	retq   

000000800420b65a <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420b65a:	55                   	push   %rbp
  800420b65b:	48 89 e5             	mov    %rsp,%rbp
  800420b65e:	48 83 ec 10          	sub    $0x10,%rsp
  800420b662:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420b666:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b66a:	48 8b 00             	mov    (%rax),%rax
  800420b66d:	48 89 c6             	mov    %rax,%rsi
  800420b670:	48 bf 93 78 21 04 80 	movabs $0x8004217893,%rdi
  800420b677:	00 00 00 
  800420b67a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b67f:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b686:	00 00 00 
  800420b689:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420b68b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b68f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b693:	48 89 c6             	mov    %rax,%rsi
  800420b696:	48 bf a2 78 21 04 80 	movabs $0x80042178a2,%rdi
  800420b69d:	00 00 00 
  800420b6a0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6a5:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b6ac:	00 00 00 
  800420b6af:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420b6b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b6b5:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420b6b9:	48 89 c6             	mov    %rax,%rsi
  800420b6bc:	48 bf b1 78 21 04 80 	movabs $0x80042178b1,%rdi
  800420b6c3:	00 00 00 
  800420b6c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6cb:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b6d2:	00 00 00 
  800420b6d5:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420b6d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b6db:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420b6df:	48 89 c6             	mov    %rax,%rsi
  800420b6e2:	48 bf c0 78 21 04 80 	movabs $0x80042178c0,%rdi
  800420b6e9:	00 00 00 
  800420b6ec:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6f1:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b6f8:	00 00 00 
  800420b6fb:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420b6fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b701:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420b705:	48 89 c6             	mov    %rax,%rsi
  800420b708:	48 bf cf 78 21 04 80 	movabs $0x80042178cf,%rdi
  800420b70f:	00 00 00 
  800420b712:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b717:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b71e:	00 00 00 
  800420b721:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420b723:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b727:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420b72b:	48 89 c6             	mov    %rax,%rsi
  800420b72e:	48 bf de 78 21 04 80 	movabs $0x80042178de,%rdi
  800420b735:	00 00 00 
  800420b738:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b73d:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b744:	00 00 00 
  800420b747:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420b749:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b74d:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420b751:	48 89 c6             	mov    %rax,%rsi
  800420b754:	48 bf ed 78 21 04 80 	movabs $0x80042178ed,%rdi
  800420b75b:	00 00 00 
  800420b75e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b763:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b76a:	00 00 00 
  800420b76d:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420b76f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b773:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420b777:	48 89 c6             	mov    %rax,%rsi
  800420b77a:	48 bf fb 78 21 04 80 	movabs $0x80042178fb,%rdi
  800420b781:	00 00 00 
  800420b784:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b789:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b790:	00 00 00 
  800420b793:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420b795:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b799:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420b79d:	48 89 c6             	mov    %rax,%rsi
  800420b7a0:	48 bf 09 79 21 04 80 	movabs $0x8004217909,%rdi
  800420b7a7:	00 00 00 
  800420b7aa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b7af:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b7b6:	00 00 00 
  800420b7b9:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420b7bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b7bf:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420b7c3:	48 89 c6             	mov    %rax,%rsi
  800420b7c6:	48 bf 18 79 21 04 80 	movabs $0x8004217918,%rdi
  800420b7cd:	00 00 00 
  800420b7d0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b7d5:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b7dc:	00 00 00 
  800420b7df:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420b7e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b7e5:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420b7e9:	48 89 c6             	mov    %rax,%rsi
  800420b7ec:	48 bf 27 79 21 04 80 	movabs $0x8004217927,%rdi
  800420b7f3:	00 00 00 
  800420b7f6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b7fb:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b802:	00 00 00 
  800420b805:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420b807:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b80b:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420b80f:	48 89 c6             	mov    %rax,%rsi
  800420b812:	48 bf 36 79 21 04 80 	movabs $0x8004217936,%rdi
  800420b819:	00 00 00 
  800420b81c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b821:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b828:	00 00 00 
  800420b82b:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420b82d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b831:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420b835:	48 89 c6             	mov    %rax,%rsi
  800420b838:	48 bf 45 79 21 04 80 	movabs $0x8004217945,%rdi
  800420b83f:	00 00 00 
  800420b842:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b847:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b84e:	00 00 00 
  800420b851:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420b853:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b857:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420b85b:	48 89 c6             	mov    %rax,%rsi
  800420b85e:	48 bf 54 79 21 04 80 	movabs $0x8004217954,%rdi
  800420b865:	00 00 00 
  800420b868:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b86d:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b874:	00 00 00 
  800420b877:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420b879:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b87d:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b881:	48 89 c6             	mov    %rax,%rsi
  800420b884:	48 bf 63 79 21 04 80 	movabs $0x8004217963,%rdi
  800420b88b:	00 00 00 
  800420b88e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b893:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b89a:	00 00 00 
  800420b89d:	ff d2                	callq  *%rdx
}
  800420b89f:	c9                   	leaveq 
  800420b8a0:	c3                   	retq   

000000800420b8a1 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420b8a1:	55                   	push   %rbp
  800420b8a2:	48 89 e5             	mov    %rsp,%rbp
  800420b8a5:	48 83 ec 10          	sub    $0x10,%rsp
  800420b8a9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.


	if (tf->tf_trapno == T_PGFLT) {
  800420b8ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8b1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b8b8:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b8bc:	75 18                	jne    800420b8d6 <trap_dispatch+0x35>
		page_fault_handler(tf);
  800420b8be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8c2:	48 89 c7             	mov    %rax,%rdi
  800420b8c5:	48 b8 cd bd 20 04 80 	movabs $0x800420bdcd,%rax
  800420b8cc:	00 00 00 
  800420b8cf:	ff d0                	callq  *%rax
		return;
  800420b8d1:	e9 8b 01 00 00       	jmpq   800420ba61 <trap_dispatch+0x1c0>
	}

	if (tf->tf_trapno == T_BRKPT) {
  800420b8d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8da:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b8e1:	48 83 f8 03          	cmp    $0x3,%rax
  800420b8e5:	75 18                	jne    800420b8ff <trap_dispatch+0x5e>
		monitor(tf);
  800420b8e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8eb:	48 89 c7             	mov    %rax,%rdi
  800420b8ee:	48 b8 1f 16 20 04 80 	movabs $0x800420161f,%rax
  800420b8f5:	00 00 00 
  800420b8f8:	ff d0                	callq  *%rax
		return;
  800420b8fa:	e9 62 01 00 00       	jmpq   800420ba61 <trap_dispatch+0x1c0>
	}

	if (tf->tf_trapno == T_SYSCALL) {
  800420b8ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b903:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b90a:	48 83 f8 30          	cmp    $0x30,%rax
  800420b90e:	75 55                	jne    800420b965 <trap_dispatch+0xc4>
		tf->tf_regs.reg_rax = syscall(
  800420b910:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b914:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420b918:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b91c:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420b920:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b924:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420b928:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b92c:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420b930:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b934:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420b938:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b93c:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b940:	4d 89 c1             	mov    %r8,%r9
  800420b943:	49 89 f8             	mov    %rdi,%r8
  800420b946:	48 89 c7             	mov    %rax,%rdi
  800420b949:	48 b8 09 d1 20 04 80 	movabs $0x800420d109,%rax
  800420b950:	00 00 00 
  800420b953:	ff d0                	callq  *%rax
  800420b955:	48 89 c2             	mov    %rax,%rdx
  800420b958:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b95c:	48 89 50 70          	mov    %rdx,0x70(%rax)
			tf->tf_regs.reg_rcx,
			tf->tf_regs.reg_rbx,
			tf->tf_regs.reg_rdi,
			tf->tf_regs.reg_rsi
			);
		return;
  800420b960:	e9 fc 00 00 00       	jmpq   800420ba61 <trap_dispatch+0x1c0>
	}
	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420b965:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b969:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b970:	48 83 f8 27          	cmp    $0x27,%rax
  800420b974:	75 33                	jne    800420b9a9 <trap_dispatch+0x108>
		cprintf("Spurious interrupt on irq 7\n");
  800420b976:	48 bf 72 79 21 04 80 	movabs $0x8004217972,%rdi
  800420b97d:	00 00 00 
  800420b980:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b985:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420b98c:	00 00 00 
  800420b98f:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420b991:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b995:	48 89 c7             	mov    %rax,%rdi
  800420b998:	48 b8 49 b3 20 04 80 	movabs $0x800420b349,%rax
  800420b99f:	00 00 00 
  800420b9a2:	ff d0                	callq  *%rax
		return;
  800420b9a4:	e9 b8 00 00 00       	jmpq   800420ba61 <trap_dispatch+0x1c0>
	}

	// Handle clock interrupts. Don't forget to acknowledge the
	// interrupt using lapic_eoi() before calling the scheduler!
	// LAB 4: Your code here.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
  800420b9a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b9ad:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b9b4:	48 83 f8 20          	cmp    $0x20,%rax
  800420b9b8:	75 18                	jne    800420b9d2 <trap_dispatch+0x131>
    lapic_eoi();
  800420b9ba:	48 b8 ae 5d 21 04 80 	movabs $0x8004215dae,%rax
  800420b9c1:	00 00 00 
  800420b9c4:	ff d0                	callq  *%rax
    sched_yield();
  800420b9c6:	48 b8 5f c3 20 04 80 	movabs $0x800420c35f,%rax
  800420b9cd:	00 00 00 
  800420b9d0:	ff d0                	callq  *%rax

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.

	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420b9d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b9d6:	48 89 c7             	mov    %rax,%rdi
  800420b9d9:	48 b8 49 b3 20 04 80 	movabs $0x800420b349,%rax
  800420b9e0:	00 00 00 
  800420b9e3:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420b9e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b9e9:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b9f0:	66 83 f8 08          	cmp    $0x8,%ax
  800420b9f4:	75 2a                	jne    800420ba20 <trap_dispatch+0x17f>
		panic("unhandled trap in kernel");
  800420b9f6:	48 ba 8f 79 21 04 80 	movabs $0x800421798f,%rdx
  800420b9fd:	00 00 00 
  800420ba00:	be 3d 01 00 00       	mov    $0x13d,%esi
  800420ba05:	48 bf a8 79 21 04 80 	movabs $0x80042179a8,%rdi
  800420ba0c:	00 00 00 
  800420ba0f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ba14:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  800420ba1b:	00 00 00 
  800420ba1e:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420ba20:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420ba27:	00 00 00 
  800420ba2a:	ff d0                	callq  *%rax
  800420ba2c:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420ba33:	00 00 00 
  800420ba36:	48 98                	cltq   
  800420ba38:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba3c:	48 89 c2             	mov    %rax,%rdx
  800420ba3f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba43:	48 29 c2             	sub    %rax,%rdx
  800420ba46:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ba4a:	48 83 c0 08          	add    $0x8,%rax
  800420ba4e:	48 8b 00             	mov    (%rax),%rax
  800420ba51:	48 89 c7             	mov    %rax,%rdi
  800420ba54:	48 b8 af 80 20 04 80 	movabs $0x80042080af,%rax
  800420ba5b:	00 00 00 
  800420ba5e:	ff d0                	callq  *%rax
		return;
  800420ba60:	90                   	nop
	}
}
  800420ba61:	c9                   	leaveq 
  800420ba62:	c3                   	retq   

000000800420ba63 <trap>:

void
trap(struct Trapframe *tf)
{
  800420ba63:	55                   	push   %rbp
  800420ba64:	48 89 e5             	mov    %rsp,%rbp
  800420ba67:	48 83 ec 20          	sub    $0x20,%rsp
  800420ba6b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420ba6f:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420ba70:	48 b8 10 47 3d 04 80 	movabs $0x80043d4710,%rax
  800420ba77:	00 00 00 
  800420ba7a:	48 8b 00             	mov    (%rax),%rax
  800420ba7d:	48 85 c0             	test   %rax,%rax
  800420ba80:	74 01                	je     800420ba83 <trap+0x20>
		asm volatile("hlt");
  800420ba82:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420ba83:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420ba8a:	00 00 00 
  800420ba8d:	ff d0                	callq  *%rax
  800420ba8f:	48 98                	cltq   
  800420ba91:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba95:	48 89 c2             	mov    %rax,%rdx
  800420ba98:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba9c:	48 29 c2             	sub    %rax,%rdx
  800420ba9f:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  800420baa6:	00 00 00 
  800420baa9:	48 01 d0             	add    %rdx,%rax
  800420baac:	48 83 c0 04          	add    $0x4,%rax
  800420bab0:	be 01 00 00 00       	mov    $0x1,%esi
  800420bab5:	48 89 c7             	mov    %rax,%rdi
  800420bab8:	48 b8 9a 88 20 04 80 	movabs $0x800420889a,%rax
  800420babf:	00 00 00 
  800420bac2:	ff d0                	callq  *%rax
  800420bac4:	83 f8 02             	cmp    $0x2,%eax
  800420bac7:	75 0c                	jne    800420bad5 <trap+0x72>
		lock_kernel();
  800420bac9:	48 b8 bf 88 20 04 80 	movabs $0x80042088bf,%rax
  800420bad0:	00 00 00 
  800420bad3:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420bad5:	9c                   	pushfq 
  800420bad6:	58                   	pop    %rax
  800420bad7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420badb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420badf:	25 00 02 00 00       	and    $0x200,%eax
  800420bae4:	48 85 c0             	test   %rax,%rax
  800420bae7:	74 35                	je     800420bb1e <trap+0xbb>
  800420bae9:	48 b9 b4 79 21 04 80 	movabs $0x80042179b4,%rcx
  800420baf0:	00 00 00 
  800420baf3:	48 ba cd 79 21 04 80 	movabs $0x80042179cd,%rdx
  800420bafa:	00 00 00 
  800420bafd:	be 58 01 00 00       	mov    $0x158,%esi
  800420bb02:	48 bf a8 79 21 04 80 	movabs $0x80042179a8,%rdi
  800420bb09:	00 00 00 
  800420bb0c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bb11:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420bb18:	00 00 00 
  800420bb1b:	41 ff d0             	callq  *%r8

	//cprintf("Incoming TRAP frame at %p\n", tf);
	if ((tf->tf_cs & 3) == 3) {
  800420bb1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bb22:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420bb29:	0f b7 c0             	movzwl %ax,%eax
  800420bb2c:	83 e0 03             	and    $0x3,%eax
  800420bb2f:	83 f8 03             	cmp    $0x3,%eax
  800420bb32:	0f 85 b3 01 00 00    	jne    800420bceb <trap+0x288>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420bb38:	48 b8 bf 88 20 04 80 	movabs $0x80042088bf,%rax
  800420bb3f:	00 00 00 
  800420bb42:	ff d0                	callq  *%rax
		assert(curenv);
  800420bb44:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bb4b:	00 00 00 
  800420bb4e:	ff d0                	callq  *%rax
  800420bb50:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bb57:	00 00 00 
  800420bb5a:	48 98                	cltq   
  800420bb5c:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb60:	48 89 c2             	mov    %rax,%rdx
  800420bb63:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb67:	48 29 c2             	sub    %rax,%rdx
  800420bb6a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb6e:	48 83 c0 08          	add    $0x8,%rax
  800420bb72:	48 8b 00             	mov    (%rax),%rax
  800420bb75:	48 85 c0             	test   %rax,%rax
  800420bb78:	75 35                	jne    800420bbaf <trap+0x14c>
  800420bb7a:	48 b9 e2 79 21 04 80 	movabs $0x80042179e2,%rcx
  800420bb81:	00 00 00 
  800420bb84:	48 ba cd 79 21 04 80 	movabs $0x80042179cd,%rdx
  800420bb8b:	00 00 00 
  800420bb8e:	be 61 01 00 00       	mov    $0x161,%esi
  800420bb93:	48 bf a8 79 21 04 80 	movabs $0x80042179a8,%rdi
  800420bb9a:	00 00 00 
  800420bb9d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bba2:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420bba9:	00 00 00 
  800420bbac:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420bbaf:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bbb6:	00 00 00 
  800420bbb9:	ff d0                	callq  *%rax
  800420bbbb:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bbc2:	00 00 00 
  800420bbc5:	48 98                	cltq   
  800420bbc7:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbcb:	48 89 c2             	mov    %rax,%rdx
  800420bbce:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bbd2:	48 29 c2             	sub    %rax,%rdx
  800420bbd5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bbd9:	48 83 c0 08          	add    $0x8,%rax
  800420bbdd:	48 8b 00             	mov    (%rax),%rax
  800420bbe0:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bbe6:	83 f8 01             	cmp    $0x1,%eax
  800420bbe9:	0f 85 81 00 00 00    	jne    800420bc70 <trap+0x20d>
			env_free(curenv);
  800420bbef:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bbf6:	00 00 00 
  800420bbf9:	ff d0                	callq  *%rax
  800420bbfb:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bc02:	00 00 00 
  800420bc05:	48 98                	cltq   
  800420bc07:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc0b:	48 89 c2             	mov    %rax,%rdx
  800420bc0e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc12:	48 29 c2             	sub    %rax,%rdx
  800420bc15:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc19:	48 83 c0 08          	add    $0x8,%rax
  800420bc1d:	48 8b 00             	mov    (%rax),%rax
  800420bc20:	48 89 c7             	mov    %rax,%rdi
  800420bc23:	48 b8 56 7b 20 04 80 	movabs $0x8004207b56,%rax
  800420bc2a:	00 00 00 
  800420bc2d:	ff d0                	callq  *%rax
			curenv = NULL;
  800420bc2f:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bc36:	00 00 00 
  800420bc39:	ff d0                	callq  *%rax
  800420bc3b:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bc42:	00 00 00 
  800420bc45:	48 98                	cltq   
  800420bc47:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc4b:	48 89 c2             	mov    %rax,%rdx
  800420bc4e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc52:	48 29 c2             	sub    %rax,%rdx
  800420bc55:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc59:	48 83 c0 08          	add    $0x8,%rax
  800420bc5d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420bc64:	48 b8 5f c3 20 04 80 	movabs $0x800420c35f,%rax
  800420bc6b:	00 00 00 
  800420bc6e:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420bc70:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bc77:	00 00 00 
  800420bc7a:	ff d0                	callq  *%rax
  800420bc7c:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bc83:	00 00 00 
  800420bc86:	48 98                	cltq   
  800420bc88:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc8c:	48 89 c2             	mov    %rax,%rdx
  800420bc8f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc93:	48 29 c2             	sub    %rax,%rdx
  800420bc96:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc9a:	48 83 c0 08          	add    $0x8,%rax
  800420bc9e:	48 8b 10             	mov    (%rax),%rdx
  800420bca1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bca5:	48 89 c6             	mov    %rax,%rsi
  800420bca8:	b8 18 00 00 00       	mov    $0x18,%eax
  800420bcad:	48 89 d7             	mov    %rdx,%rdi
  800420bcb0:	48 89 c1             	mov    %rax,%rcx
  800420bcb3:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420bcb6:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bcbd:	00 00 00 
  800420bcc0:	ff d0                	callq  *%rax
  800420bcc2:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bcc9:	00 00 00 
  800420bccc:	48 98                	cltq   
  800420bcce:	48 c1 e0 03          	shl    $0x3,%rax
  800420bcd2:	48 89 c2             	mov    %rax,%rdx
  800420bcd5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bcd9:	48 29 c2             	sub    %rax,%rdx
  800420bcdc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bce0:	48 83 c0 08          	add    $0x8,%rax
  800420bce4:	48 8b 00             	mov    (%rax),%rax
  800420bce7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420bceb:	48 b8 90 42 3d 04 80 	movabs $0x80043d4290,%rax
  800420bcf2:	00 00 00 
  800420bcf5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bcf9:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420bcfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bd00:	48 89 c7             	mov    %rax,%rdi
  800420bd03:	48 b8 a1 b8 20 04 80 	movabs $0x800420b8a1,%rax
  800420bd0a:	00 00 00 
  800420bd0d:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420bd0f:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bd16:	00 00 00 
  800420bd19:	ff d0                	callq  *%rax
  800420bd1b:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bd22:	00 00 00 
  800420bd25:	48 98                	cltq   
  800420bd27:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd2b:	48 89 c2             	mov    %rax,%rdx
  800420bd2e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd32:	48 29 c2             	sub    %rax,%rdx
  800420bd35:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd39:	48 83 c0 08          	add    $0x8,%rax
  800420bd3d:	48 8b 00             	mov    (%rax),%rax
  800420bd40:	48 85 c0             	test   %rax,%rax
  800420bd43:	74 7c                	je     800420bdc1 <trap+0x35e>
  800420bd45:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bd4c:	00 00 00 
  800420bd4f:	ff d0                	callq  *%rax
  800420bd51:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bd58:	00 00 00 
  800420bd5b:	48 98                	cltq   
  800420bd5d:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd61:	48 89 c2             	mov    %rax,%rdx
  800420bd64:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd68:	48 29 c2             	sub    %rax,%rdx
  800420bd6b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd6f:	48 83 c0 08          	add    $0x8,%rax
  800420bd73:	48 8b 00             	mov    (%rax),%rax
  800420bd76:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bd7c:	83 f8 03             	cmp    $0x3,%eax
  800420bd7f:	75 40                	jne    800420bdc1 <trap+0x35e>
		env_run(curenv);
  800420bd81:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bd88:	00 00 00 
  800420bd8b:	ff d0                	callq  *%rax
  800420bd8d:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420bd94:	00 00 00 
  800420bd97:	48 98                	cltq   
  800420bd99:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd9d:	48 89 c2             	mov    %rax,%rdx
  800420bda0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bda4:	48 29 c2             	sub    %rax,%rdx
  800420bda7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bdab:	48 83 c0 08          	add    $0x8,%rax
  800420bdaf:	48 8b 00             	mov    (%rax),%rax
  800420bdb2:	48 89 c7             	mov    %rax,%rdi
  800420bdb5:	48 b8 7e 82 20 04 80 	movabs $0x800420827e,%rax
  800420bdbc:	00 00 00 
  800420bdbf:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420bdc1:	48 b8 5f c3 20 04 80 	movabs $0x800420c35f,%rax
  800420bdc8:	00 00 00 
  800420bdcb:	ff d0                	callq  *%rax

000000800420bdcd <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420bdcd:	55                   	push   %rbp
  800420bdce:	48 89 e5             	mov    %rsp,%rbp
  800420bdd1:	53                   	push   %rbx
  800420bdd2:	48 83 ec 38          	sub    $0x38,%rsp
  800420bdd6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420bdda:	0f 20 d0             	mov    %cr2,%rax
  800420bddd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	return val;
  800420bde1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420bde5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.

	if((tf->tf_cs & 3) != 3)
  800420bde9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bded:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420bdf4:	0f b7 c0             	movzwl %ax,%eax
  800420bdf7:	83 e0 03             	and    $0x3,%eax
  800420bdfa:	83 f8 03             	cmp    $0x3,%eax
  800420bdfd:	74 2a                	je     800420be29 <page_fault_handler+0x5c>
		panic("invalid page fault in kernel mode");
  800420bdff:	48 ba f0 79 21 04 80 	movabs $0x80042179f0,%rdx
  800420be06:	00 00 00 
  800420be09:	be 90 01 00 00       	mov    $0x190,%esi
  800420be0e:	48 bf a8 79 21 04 80 	movabs $0x80042179a8,%rdi
  800420be15:	00 00 00 
  800420be18:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be1d:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  800420be24:	00 00 00 
  800420be27:	ff d1                	callq  *%rcx
	//   To change what the user environment runs, modify 'curenv->env_tf'
	//   (the 'tf' variable points at 'curenv->env_tf').

	// LAB 4: Your code here.

	if(curenv->env_pgfault_upcall)
  800420be29:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420be30:	00 00 00 
  800420be33:	ff d0                	callq  *%rax
  800420be35:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420be3c:	00 00 00 
  800420be3f:	48 98                	cltq   
  800420be41:	48 c1 e0 03          	shl    $0x3,%rax
  800420be45:	48 89 c2             	mov    %rax,%rdx
  800420be48:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be4c:	48 29 c2             	sub    %rax,%rdx
  800420be4f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420be53:	48 83 c0 08          	add    $0x8,%rax
  800420be57:	48 8b 00             	mov    (%rax),%rax
  800420be5a:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420be61:	48 85 c0             	test   %rax,%rax
  800420be64:	0f 84 71 02 00 00    	je     800420c0db <page_fault_handler+0x30e>
	{
		uintptr_t utf_addr;

		if(UXSTACKTOP-PGSIZE <= tf->tf_rsp && tf->tf_rsp <= UXSTACKTOP-1)
  800420be6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420be6e:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420be75:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420be7a:	48 39 c2             	cmp    %rax,%rdx
  800420be7d:	76 2c                	jbe    800420beab <page_fault_handler+0xde>
  800420be7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420be83:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420be8a:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420be8f:	48 39 c2             	cmp    %rax,%rdx
  800420be92:	77 17                	ja     800420beab <page_fault_handler+0xde>
			utf_addr = tf->tf_rsp - sizeof(struct UTrapframe) - 4;
  800420be94:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420be98:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420be9f:	48 2d a4 00 00 00    	sub    $0xa4,%rax
  800420bea5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420bea9:	eb 09                	jmp    800420beb4 <page_fault_handler+0xe7>
		else
			utf_addr = UXSTACKTOP - sizeof(struct UTrapframe);
  800420beab:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420beb0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)


		user_mem_assert(curenv, (void *)utf_addr, 1, PTE_W);
  800420beb4:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800420beb8:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bebf:	00 00 00 
  800420bec2:	ff d0                	callq  *%rax
  800420bec4:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420becb:	00 00 00 
  800420bece:	48 98                	cltq   
  800420bed0:	48 c1 e0 03          	shl    $0x3,%rax
  800420bed4:	48 89 c2             	mov    %rax,%rdx
  800420bed7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bedb:	48 29 c2             	sub    %rax,%rdx
  800420bede:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bee2:	48 83 c0 08          	add    $0x8,%rax
  800420bee6:	48 8b 00             	mov    (%rax),%rax
  800420bee9:	b9 02 00 00 00       	mov    $0x2,%ecx
  800420beee:	ba 01 00 00 00       	mov    $0x1,%edx
  800420bef3:	48 89 de             	mov    %rbx,%rsi
  800420bef6:	48 89 c7             	mov    %rax,%rdi
  800420bef9:	48 b8 25 35 20 04 80 	movabs $0x8004203525,%rax
  800420bf00:	00 00 00 
  800420bf03:	ff d0                	callq  *%rax

		struct UTrapframe *utf = (struct UTrapframe *)utf_addr;
  800420bf05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf09:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		utf->utf_fault_va = fault_va;
  800420bf0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bf11:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420bf15:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_err = tf->tf_err;
  800420bf18:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bf1c:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420bf23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bf27:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_regs = tf->tf_regs;
  800420bf2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bf2f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420bf33:	48 8b 0a             	mov    (%rdx),%rcx
  800420bf36:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420bf3a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420bf3e:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420bf42:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420bf46:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420bf4a:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420bf4e:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420bf52:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420bf56:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420bf5a:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420bf5e:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420bf62:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420bf66:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420bf6a:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420bf6e:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420bf72:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420bf76:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420bf7a:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420bf7e:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420bf82:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420bf86:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420bf8a:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420bf8e:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420bf92:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420bf96:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420bf9a:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420bf9e:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420bfa2:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420bfa6:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420bfad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bfb1:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420bfb8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bfbc:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_eflags = tf->tf_eflags;
  800420bfc3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bfc7:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420bfce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bfd2:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420bfd9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bfdd:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bfe4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bfe8:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

		curenv->env_tf.tf_rip = (uintptr_t)curenv->env_pgfault_upcall;
  800420bfef:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420bff6:	00 00 00 
  800420bff9:	ff d0                	callq  *%rax
  800420bffb:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c002:	00 00 00 
  800420c005:	48 98                	cltq   
  800420c007:	48 c1 e0 03          	shl    $0x3,%rax
  800420c00b:	48 89 c2             	mov    %rax,%rdx
  800420c00e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c012:	48 29 c2             	sub    %rax,%rdx
  800420c015:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c019:	48 83 c0 08          	add    $0x8,%rax
  800420c01d:	48 8b 18             	mov    (%rax),%rbx
  800420c020:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c027:	00 00 00 
  800420c02a:	ff d0                	callq  *%rax
  800420c02c:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c033:	00 00 00 
  800420c036:	48 98                	cltq   
  800420c038:	48 c1 e0 03          	shl    $0x3,%rax
  800420c03c:	48 89 c2             	mov    %rax,%rdx
  800420c03f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c043:	48 29 c2             	sub    %rax,%rdx
  800420c046:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c04a:	48 83 c0 08          	add    $0x8,%rax
  800420c04e:	48 8b 00             	mov    (%rax),%rax
  800420c051:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420c058:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
		curenv->env_tf.tf_rsp = utf_addr;
  800420c05f:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c066:	00 00 00 
  800420c069:	ff d0                	callq  *%rax
  800420c06b:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c072:	00 00 00 
  800420c075:	48 98                	cltq   
  800420c077:	48 c1 e0 03          	shl    $0x3,%rax
  800420c07b:	48 89 c2             	mov    %rax,%rdx
  800420c07e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c082:	48 29 c2             	sub    %rax,%rdx
  800420c085:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c089:	48 83 c0 08          	add    $0x8,%rax
  800420c08d:	48 8b 00             	mov    (%rax),%rax
  800420c090:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c094:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		env_run(curenv);
  800420c09b:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c0a2:	00 00 00 
  800420c0a5:	ff d0                	callq  *%rax
  800420c0a7:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c0ae:	00 00 00 
  800420c0b1:	48 98                	cltq   
  800420c0b3:	48 c1 e0 03          	shl    $0x3,%rax
  800420c0b7:	48 89 c2             	mov    %rax,%rdx
  800420c0ba:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c0be:	48 29 c2             	sub    %rax,%rdx
  800420c0c1:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c0c5:	48 83 c0 08          	add    $0x8,%rax
  800420c0c9:	48 8b 00             	mov    (%rax),%rax
  800420c0cc:	48 89 c7             	mov    %rax,%rdi
  800420c0cf:	48 b8 7e 82 20 04 80 	movabs $0x800420827e,%rax
  800420c0d6:	00 00 00 
  800420c0d9:	ff d0                	callq  *%rax
	}


	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420c0db:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c0df:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
		curenv->env_id, fault_va, tf->tf_rip);
  800420c0e6:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c0ed:	00 00 00 
  800420c0f0:	ff d0                	callq  *%rax
  800420c0f2:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c0f9:	00 00 00 
  800420c0fc:	48 98                	cltq   
  800420c0fe:	48 c1 e0 03          	shl    $0x3,%rax
  800420c102:	48 89 c2             	mov    %rax,%rdx
  800420c105:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c109:	48 29 c2             	sub    %rax,%rdx
  800420c10c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c110:	48 83 c0 08          	add    $0x8,%rax
  800420c114:	48 8b 00             	mov    (%rax),%rax
		env_run(curenv);
	}


	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420c117:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c11d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c121:	48 89 d9             	mov    %rbx,%rcx
  800420c124:	89 c6                	mov    %eax,%esi
  800420c126:	48 bf 18 7a 21 04 80 	movabs $0x8004217a18,%rdi
  800420c12d:	00 00 00 
  800420c130:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c135:	49 b8 c2 87 20 04 80 	movabs $0x80042087c2,%r8
  800420c13c:	00 00 00 
  800420c13f:	41 ff d0             	callq  *%r8
		curenv->env_id, fault_va, tf->tf_rip);
	print_trapframe(tf);
  800420c142:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c146:	48 89 c7             	mov    %rax,%rdi
  800420c149:	48 b8 49 b3 20 04 80 	movabs $0x800420b349,%rax
  800420c150:	00 00 00 
  800420c153:	ff d0                	callq  *%rax
	env_destroy(curenv);
  800420c155:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c15c:	00 00 00 
  800420c15f:	ff d0                	callq  *%rax
  800420c161:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c168:	00 00 00 
  800420c16b:	48 98                	cltq   
  800420c16d:	48 c1 e0 03          	shl    $0x3,%rax
  800420c171:	48 89 c2             	mov    %rax,%rdx
  800420c174:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c178:	48 29 c2             	sub    %rax,%rdx
  800420c17b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c17f:	48 83 c0 08          	add    $0x8,%rax
  800420c183:	48 8b 00             	mov    (%rax),%rax
  800420c186:	48 89 c7             	mov    %rax,%rdi
  800420c189:	48 b8 af 80 20 04 80 	movabs $0x80042080af,%rax
  800420c190:	00 00 00 
  800420c193:	ff d0                	callq  *%rax
}
  800420c195:	48 83 c4 38          	add    $0x38,%rsp
  800420c199:	5b                   	pop    %rbx
  800420c19a:	5d                   	pop    %rbp
  800420c19b:	c3                   	retq   

000000800420c19c <DIVIDE_F>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

  	TRAPHANDLER_NOEC(DIVIDE_F, T_DIVIDE)
  800420c19c:	6a 00                	pushq  $0x0
  800420c19e:	6a 00                	pushq  $0x0
  800420c1a0:	e9 09 01 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1a5:	90                   	nop

000000800420c1a6 <DEBUG_F>:
 	TRAPHANDLER_NOEC(DEBUG_F, T_DEBUG)
  800420c1a6:	6a 00                	pushq  $0x0
  800420c1a8:	6a 01                	pushq  $0x1
  800420c1aa:	e9 ff 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1af:	90                   	nop

000000800420c1b0 <NMI_F>:
 	TRAPHANDLER_NOEC(NMI_F, T_NMI)
  800420c1b0:	6a 00                	pushq  $0x0
  800420c1b2:	6a 02                	pushq  $0x2
  800420c1b4:	e9 f5 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1b9:	90                   	nop

000000800420c1ba <BRKPT_F>:
 	TRAPHANDLER_NOEC(BRKPT_F, T_BRKPT)
  800420c1ba:	6a 00                	pushq  $0x0
  800420c1bc:	6a 03                	pushq  $0x3
  800420c1be:	e9 eb 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1c3:	90                   	nop

000000800420c1c4 <OFLOW_F>:
 	TRAPHANDLER_NOEC(OFLOW_F, T_OFLOW)
  800420c1c4:	6a 00                	pushq  $0x0
  800420c1c6:	6a 04                	pushq  $0x4
  800420c1c8:	e9 e1 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1cd:	90                   	nop

000000800420c1ce <BOUND_F>:
 	TRAPHANDLER_NOEC(BOUND_F, T_BOUND)
  800420c1ce:	6a 00                	pushq  $0x0
  800420c1d0:	6a 05                	pushq  $0x5
  800420c1d2:	e9 d7 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1d7:	90                   	nop

000000800420c1d8 <ILLOP_F>:
 	TRAPHANDLER_NOEC(ILLOP_F, T_ILLOP)
  800420c1d8:	6a 00                	pushq  $0x0
  800420c1da:	6a 06                	pushq  $0x6
  800420c1dc:	e9 cd 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1e1:	90                   	nop

000000800420c1e2 <DEVICE_F>:
 	TRAPHANDLER_NOEC(DEVICE_F, T_DEVICE)
  800420c1e2:	6a 00                	pushq  $0x0
  800420c1e4:	6a 07                	pushq  $0x7
  800420c1e6:	e9 c3 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1eb:	90                   	nop

000000800420c1ec <DBLFLT_F>:
 	TRAPHANDLER(DBLFLT_F, T_DBLFLT)
  800420c1ec:	6a 08                	pushq  $0x8
  800420c1ee:	e9 bb 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1f3:	90                   	nop

000000800420c1f4 <TSS_F>:
 	TRAPHANDLER(TSS_F, T_TSS)
  800420c1f4:	6a 0a                	pushq  $0xa
  800420c1f6:	e9 b3 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c1fb:	90                   	nop

000000800420c1fc <SEGNP_F>:
 	TRAPHANDLER(SEGNP_F, T_SEGNP)
  800420c1fc:	6a 0b                	pushq  $0xb
  800420c1fe:	e9 ab 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c203:	90                   	nop

000000800420c204 <STACK_F>:
 	TRAPHANDLER(STACK_F, T_STACK)
  800420c204:	6a 0c                	pushq  $0xc
  800420c206:	e9 a3 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c20b:	90                   	nop

000000800420c20c <GPFLT_F>:
 	TRAPHANDLER(GPFLT_F, T_GPFLT)
  800420c20c:	6a 0d                	pushq  $0xd
  800420c20e:	e9 9b 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c213:	90                   	nop

000000800420c214 <PGFLT_F>:
 	TRAPHANDLER(PGFLT_F, T_PGFLT)
  800420c214:	6a 0e                	pushq  $0xe
  800420c216:	e9 93 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c21b:	90                   	nop

000000800420c21c <FPERR_F>:
 	TRAPHANDLER_NOEC(FPERR_F, T_FPERR)
  800420c21c:	6a 00                	pushq  $0x0
  800420c21e:	6a 10                	pushq  $0x10
  800420c220:	e9 89 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c225:	90                   	nop

000000800420c226 <ALIGN_F>:
 	TRAPHANDLER(ALIGN_F, T_ALIGN)
  800420c226:	6a 11                	pushq  $0x11
  800420c228:	e9 81 00 00 00       	jmpq   800420c2ae <_alltraps>
  800420c22d:	90                   	nop

000000800420c22e <MCHK_F>:
 	TRAPHANDLER_NOEC(MCHK_F, T_MCHK)
  800420c22e:	6a 00                	pushq  $0x0
  800420c230:	6a 12                	pushq  $0x12
  800420c232:	eb 7a                	jmp    800420c2ae <_alltraps>

000000800420c234 <SIMDERR_F>:
 	TRAPHANDLER_NOEC(SIMDERR_F, T_SIMDERR)
  800420c234:	6a 00                	pushq  $0x0
  800420c236:	6a 13                	pushq  $0x13
  800420c238:	eb 74                	jmp    800420c2ae <_alltraps>

000000800420c23a <SYSCALL_F>:

 	TRAPHANDLER_NOEC(SYSCALL_F, T_SYSCALL)
  800420c23a:	6a 00                	pushq  $0x0
  800420c23c:	6a 30                	pushq  $0x30
  800420c23e:	eb 6e                	jmp    800420c2ae <_alltraps>

000000800420c240 <DEFAULT_F>:
 	TRAPHANDLER(DEFAULT_F, T_DEFAULT)
  800420c240:	68 f4 01 00 00       	pushq  $0x1f4
  800420c245:	eb 67                	jmp    800420c2ae <_alltraps>
  800420c247:	90                   	nop

000000800420c248 <IRQ0_HANDLER>:

  /*  LAB 4 */
	  TRAPHANDLER_NOEC(IRQ0_HANDLER, IRQ_OFFSET)
  800420c248:	6a 00                	pushq  $0x0
  800420c24a:	6a 20                	pushq  $0x20
  800420c24c:	eb 60                	jmp    800420c2ae <_alltraps>

000000800420c24e <IRQ1_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ1_HANDLER, IRQ_OFFSET + 1)
  800420c24e:	6a 00                	pushq  $0x0
  800420c250:	6a 21                	pushq  $0x21
  800420c252:	eb 5a                	jmp    800420c2ae <_alltraps>

000000800420c254 <IRQ2_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ2_HANDLER, IRQ_OFFSET + 2)
  800420c254:	6a 00                	pushq  $0x0
  800420c256:	6a 22                	pushq  $0x22
  800420c258:	eb 54                	jmp    800420c2ae <_alltraps>

000000800420c25a <IRQ3_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ3_HANDLER, IRQ_OFFSET + 3)
  800420c25a:	6a 00                	pushq  $0x0
  800420c25c:	6a 23                	pushq  $0x23
  800420c25e:	eb 4e                	jmp    800420c2ae <_alltraps>

000000800420c260 <IRQ4_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ4_HANDLER, IRQ_OFFSET + 4)
  800420c260:	6a 00                	pushq  $0x0
  800420c262:	6a 24                	pushq  $0x24
  800420c264:	eb 48                	jmp    800420c2ae <_alltraps>

000000800420c266 <IRQ5_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ5_HANDLER, IRQ_OFFSET + 5)
  800420c266:	6a 00                	pushq  $0x0
  800420c268:	6a 25                	pushq  $0x25
  800420c26a:	eb 42                	jmp    800420c2ae <_alltraps>

000000800420c26c <IRQ6_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ6_HANDLER, IRQ_OFFSET + 6)
  800420c26c:	6a 00                	pushq  $0x0
  800420c26e:	6a 26                	pushq  $0x26
  800420c270:	eb 3c                	jmp    800420c2ae <_alltraps>

000000800420c272 <IRQ7_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ7_HANDLER, IRQ_OFFSET + 7)
  800420c272:	6a 00                	pushq  $0x0
  800420c274:	6a 27                	pushq  $0x27
  800420c276:	eb 36                	jmp    800420c2ae <_alltraps>

000000800420c278 <IRQ8_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ8_HANDLER, IRQ_OFFSET + 8)
  800420c278:	6a 00                	pushq  $0x0
  800420c27a:	6a 28                	pushq  $0x28
  800420c27c:	eb 30                	jmp    800420c2ae <_alltraps>

000000800420c27e <IRQ9_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ9_HANDLER, IRQ_OFFSET + 9)
  800420c27e:	6a 00                	pushq  $0x0
  800420c280:	6a 29                	pushq  $0x29
  800420c282:	eb 2a                	jmp    800420c2ae <_alltraps>

000000800420c284 <IRQ10_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ10_HANDLER, IRQ_OFFSET + 10)
  800420c284:	6a 00                	pushq  $0x0
  800420c286:	6a 2a                	pushq  $0x2a
  800420c288:	eb 24                	jmp    800420c2ae <_alltraps>

000000800420c28a <IRQ11_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ11_HANDLER, IRQ_OFFSET + 11)
  800420c28a:	6a 00                	pushq  $0x0
  800420c28c:	6a 2b                	pushq  $0x2b
  800420c28e:	eb 1e                	jmp    800420c2ae <_alltraps>

000000800420c290 <IRQ12_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ12_HANDLER, IRQ_OFFSET + 12)
  800420c290:	6a 00                	pushq  $0x0
  800420c292:	6a 2c                	pushq  $0x2c
  800420c294:	eb 18                	jmp    800420c2ae <_alltraps>

000000800420c296 <IRQ13_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ13_HANDLER, IRQ_OFFSET + 13)
  800420c296:	6a 00                	pushq  $0x0
  800420c298:	6a 2d                	pushq  $0x2d
  800420c29a:	eb 12                	jmp    800420c2ae <_alltraps>

000000800420c29c <IRQ14_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ14_HANDLER, IRQ_OFFSET + 14)
  800420c29c:	6a 00                	pushq  $0x0
  800420c29e:	6a 2e                	pushq  $0x2e
  800420c2a0:	eb 0c                	jmp    800420c2ae <_alltraps>

000000800420c2a2 <IRQ15_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ15_HANDLER, IRQ_OFFSET + 15)
  800420c2a2:	6a 00                	pushq  $0x0
  800420c2a4:	6a 2f                	pushq  $0x2f
  800420c2a6:	eb 06                	jmp    800420c2ae <_alltraps>

000000800420c2a8 <IRQ_ERROR_HANDLER>:
	  TRAPHANDLER_NOEC(IRQ_ERROR_HANDLER, IRQ_OFFSET + IRQ_ERROR)
  800420c2a8:	6a 00                	pushq  $0x0
  800420c2aa:	6a 33                	pushq  $0x33
  800420c2ac:	eb 00                	jmp    800420c2ae <_alltraps>

000000800420c2ae <_alltraps>:
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */

 _alltraps:
       	sub $16,%rsp
  800420c2ae:	48 83 ec 10          	sub    $0x10,%rsp
       	movw %ds,8(%rsp)
  800420c2b2:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
       	movw %es,0(%rsp)
  800420c2b6:	8c 04 24             	mov    %es,(%rsp)
       	PUSHA
  800420c2b9:	48 83 ec 78          	sub    $0x78,%rsp
  800420c2bd:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420c2c2:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420c2c7:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420c2cc:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420c2d1:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420c2d6:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420c2db:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420c2e0:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420c2e5:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420c2ea:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420c2ef:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420c2f4:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420c2f9:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420c2fe:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420c303:	4c 89 3c 24          	mov    %r15,(%rsp)
       	movq $GD_KD, %rax
  800420c307:	48 c7 c0 10 00 00 00 	mov    $0x10,%rax
       	movq %rax, %es
  800420c30e:	48 8e c0             	mov    %rax,%es
       	movq %rax, %ds
  800420c311:	48 8e d8             	mov    %rax,%ds
       	movq %rsp, %rdi
  800420c314:	48 89 e7             	mov    %rsp,%rdi
       	call trap
  800420c317:	e8 47 f7 ff ff       	callq  800420ba63 <trap>

000000800420c31c <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420c31c:	55                   	push   %rbp
  800420c31d:	48 89 e5             	mov    %rsp,%rbp
  800420c320:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420c324:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c328:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420c32b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c32f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c332:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420c336:	f0 87 02             	lock xchg %eax,(%rdx)
  800420c339:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420c33c:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420c33f:	c9                   	leaveq 
  800420c340:	c3                   	retq   

000000800420c341 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420c341:	55                   	push   %rbp
  800420c342:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420c345:	48 bf 60 b7 22 04 80 	movabs $0x800422b760,%rdi
  800420c34c:	00 00 00 
  800420c34f:	48 b8 db 61 21 04 80 	movabs $0x80042161db,%rax
  800420c356:	00 00 00 
  800420c359:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420c35b:	f3 90                	pause  
}
  800420c35d:	5d                   	pop    %rbp
  800420c35e:	c3                   	retq   

000000800420c35f <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420c35f:	55                   	push   %rbp
  800420c360:	48 89 e5             	mov    %rsp,%rbp
  800420c363:	48 83 ec 10          	sub    $0x10,%rsp
	// Never choose an environment that's currently running on
	// another CPU (env_status == ENV_RUNNING). If there are
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.

	int i, index = 0;
  800420c367:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	if (curenv)
  800420c36e:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c375:	00 00 00 
  800420c378:	ff d0                	callq  *%rax
  800420c37a:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c381:	00 00 00 
  800420c384:	48 98                	cltq   
  800420c386:	48 c1 e0 03          	shl    $0x3,%rax
  800420c38a:	48 89 c2             	mov    %rax,%rdx
  800420c38d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c391:	48 29 c2             	sub    %rax,%rdx
  800420c394:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c398:	48 83 c0 08          	add    $0x8,%rax
  800420c39c:	48 8b 00             	mov    (%rax),%rax
  800420c39f:	48 85 c0             	test   %rax,%rax
  800420c3a2:	74 41                	je     800420c3e5 <sched_yield+0x86>
		index = ENVX(curenv->env_id);
  800420c3a4:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c3ab:	00 00 00 
  800420c3ae:	ff d0                	callq  *%rax
  800420c3b0:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c3b7:	00 00 00 
  800420c3ba:	48 98                	cltq   
  800420c3bc:	48 c1 e0 03          	shl    $0x3,%rax
  800420c3c0:	48 89 c2             	mov    %rax,%rdx
  800420c3c3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c3c7:	48 29 c2             	sub    %rax,%rdx
  800420c3ca:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c3ce:	48 83 c0 08          	add    $0x8,%rax
  800420c3d2:	48 8b 00             	mov    (%rax),%rax
  800420c3d5:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c3db:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c3e0:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800420c3e3:	eb 07                	jmp    800420c3ec <sched_yield+0x8d>
	else
		index = 0;
  800420c3e5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)

	for(i = index; i != index + NENV ; i++) {
  800420c3ec:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420c3ef:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c3f2:	e9 80 00 00 00       	jmpq   800420c477 <sched_yield+0x118>
		if (envs[i%NENV].env_status == ENV_RUNNABLE)
  800420c3f7:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420c3fe:	00 00 00 
  800420c401:	48 8b 08             	mov    (%rax),%rcx
  800420c404:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c407:	99                   	cltd   
  800420c408:	c1 ea 16             	shr    $0x16,%edx
  800420c40b:	01 d0                	add    %edx,%eax
  800420c40d:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c412:	29 d0                	sub    %edx,%eax
  800420c414:	48 63 d0             	movslq %eax,%rdx
  800420c417:	48 89 d0             	mov    %rdx,%rax
  800420c41a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c41e:	48 01 d0             	add    %rdx,%rax
  800420c421:	48 c1 e0 05          	shl    $0x5,%rax
  800420c425:	48 01 c8             	add    %rcx,%rax
  800420c428:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c42e:	83 f8 02             	cmp    $0x2,%eax
  800420c431:	75 40                	jne    800420c473 <sched_yield+0x114>
			env_run(&envs[i%NENV]);
  800420c433:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420c43a:	00 00 00 
  800420c43d:	48 8b 08             	mov    (%rax),%rcx
  800420c440:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c443:	99                   	cltd   
  800420c444:	c1 ea 16             	shr    $0x16,%edx
  800420c447:	01 d0                	add    %edx,%eax
  800420c449:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c44e:	29 d0                	sub    %edx,%eax
  800420c450:	48 63 d0             	movslq %eax,%rdx
  800420c453:	48 89 d0             	mov    %rdx,%rax
  800420c456:	48 c1 e0 03          	shl    $0x3,%rax
  800420c45a:	48 01 d0             	add    %rdx,%rax
  800420c45d:	48 c1 e0 05          	shl    $0x5,%rax
  800420c461:	48 01 c8             	add    %rcx,%rax
  800420c464:	48 89 c7             	mov    %rax,%rdi
  800420c467:	48 b8 7e 82 20 04 80 	movabs $0x800420827e,%rax
  800420c46e:	00 00 00 
  800420c471:	ff d0                	callq  *%rax
	if (curenv)
		index = ENVX(curenv->env_id);
	else
		index = 0;

	for(i = index; i != index + NENV ; i++) {
  800420c473:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420c477:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420c47a:	05 00 04 00 00       	add    $0x400,%eax
  800420c47f:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420c482:	0f 85 6f ff ff ff    	jne    800420c3f7 <sched_yield+0x98>
		if (envs[i%NENV].env_status == ENV_RUNNABLE)
			env_run(&envs[i%NENV]);
	}
	if(curenv && curenv->env_status == ENV_RUNNING) {
  800420c488:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c48f:	00 00 00 
  800420c492:	ff d0                	callq  *%rax
  800420c494:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c49b:	00 00 00 
  800420c49e:	48 98                	cltq   
  800420c4a0:	48 c1 e0 03          	shl    $0x3,%rax
  800420c4a4:	48 89 c2             	mov    %rax,%rdx
  800420c4a7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c4ab:	48 29 c2             	sub    %rax,%rdx
  800420c4ae:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c4b2:	48 83 c0 08          	add    $0x8,%rax
  800420c4b6:	48 8b 00             	mov    (%rax),%rax
  800420c4b9:	48 85 c0             	test   %rax,%rax
  800420c4bc:	74 7c                	je     800420c53a <sched_yield+0x1db>
  800420c4be:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c4c5:	00 00 00 
  800420c4c8:	ff d0                	callq  *%rax
  800420c4ca:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c4d1:	00 00 00 
  800420c4d4:	48 98                	cltq   
  800420c4d6:	48 c1 e0 03          	shl    $0x3,%rax
  800420c4da:	48 89 c2             	mov    %rax,%rdx
  800420c4dd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c4e1:	48 29 c2             	sub    %rax,%rdx
  800420c4e4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c4e8:	48 83 c0 08          	add    $0x8,%rax
  800420c4ec:	48 8b 00             	mov    (%rax),%rax
  800420c4ef:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c4f5:	83 f8 03             	cmp    $0x3,%eax
  800420c4f8:	75 40                	jne    800420c53a <sched_yield+0x1db>
		env_run(curenv);
  800420c4fa:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c501:	00 00 00 
  800420c504:	ff d0                	callq  *%rax
  800420c506:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c50d:	00 00 00 
  800420c510:	48 98                	cltq   
  800420c512:	48 c1 e0 03          	shl    $0x3,%rax
  800420c516:	48 89 c2             	mov    %rax,%rdx
  800420c519:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c51d:	48 29 c2             	sub    %rax,%rdx
  800420c520:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c524:	48 83 c0 08          	add    $0x8,%rax
  800420c528:	48 8b 00             	mov    (%rax),%rax
  800420c52b:	48 89 c7             	mov    %rax,%rdi
  800420c52e:	48 b8 7e 82 20 04 80 	movabs $0x800420827e,%rax
  800420c535:	00 00 00 
  800420c538:	ff d0                	callq  *%rax
	}

	// sched_halt never returns
	sched_halt();
  800420c53a:	48 b8 48 c5 20 04 80 	movabs $0x800420c548,%rax
  800420c541:	00 00 00 
  800420c544:	ff d0                	callq  *%rax
}
  800420c546:	c9                   	leaveq 
  800420c547:	c3                   	retq   

000000800420c548 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420c548:	55                   	push   %rbp
  800420c549:	48 89 e5             	mov    %rsp,%rbp
  800420c54c:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420c550:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420c557:	e9 91 00 00 00       	jmpq   800420c5ed <sched_halt+0xa5>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420c55c:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420c563:	00 00 00 
  800420c566:	48 8b 08             	mov    (%rax),%rcx
  800420c569:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c56c:	48 63 d0             	movslq %eax,%rdx
  800420c56f:	48 89 d0             	mov    %rdx,%rax
  800420c572:	48 c1 e0 03          	shl    $0x3,%rax
  800420c576:	48 01 d0             	add    %rdx,%rax
  800420c579:	48 c1 e0 05          	shl    $0x5,%rax
  800420c57d:	48 01 c8             	add    %rcx,%rax
  800420c580:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c586:	83 f8 02             	cmp    $0x2,%eax
  800420c589:	74 6f                	je     800420c5fa <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
  800420c58b:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420c592:	00 00 00 
  800420c595:	48 8b 08             	mov    (%rax),%rcx
  800420c598:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c59b:	48 63 d0             	movslq %eax,%rdx
  800420c59e:	48 89 d0             	mov    %rdx,%rax
  800420c5a1:	48 c1 e0 03          	shl    $0x3,%rax
  800420c5a5:	48 01 d0             	add    %rdx,%rax
  800420c5a8:	48 c1 e0 05          	shl    $0x5,%rax
  800420c5ac:	48 01 c8             	add    %rcx,%rax
  800420c5af:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420c5b5:	83 f8 03             	cmp    $0x3,%eax
  800420c5b8:	74 40                	je     800420c5fa <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420c5ba:	48 b8 50 32 3d 04 80 	movabs $0x80043d3250,%rax
  800420c5c1:	00 00 00 
  800420c5c4:	48 8b 08             	mov    (%rax),%rcx
  800420c5c7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c5ca:	48 63 d0             	movslq %eax,%rdx
  800420c5cd:	48 89 d0             	mov    %rdx,%rax
  800420c5d0:	48 c1 e0 03          	shl    $0x3,%rax
  800420c5d4:	48 01 d0             	add    %rdx,%rax
  800420c5d7:	48 c1 e0 05          	shl    $0x5,%rax
  800420c5db:	48 01 c8             	add    %rcx,%rax
  800420c5de:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420c5e4:	83 f8 01             	cmp    $0x1,%eax
  800420c5e7:	74 11                	je     800420c5fa <sched_halt+0xb2>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420c5e9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420c5ed:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420c5f4:	0f 8e 62 ff ff ff    	jle    800420c55c <sched_halt+0x14>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420c5fa:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420c601:	75 2e                	jne    800420c631 <sched_halt+0xe9>
		cprintf("No runnable environments in the system!\n");
  800420c603:	48 bf 20 7c 21 04 80 	movabs $0x8004217c20,%rdi
  800420c60a:	00 00 00 
  800420c60d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c612:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420c619:	00 00 00 
  800420c61c:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420c61e:	bf 00 00 00 00       	mov    $0x0,%edi
  800420c623:	48 b8 1f 16 20 04 80 	movabs $0x800420161f,%rax
  800420c62a:	00 00 00 
  800420c62d:	ff d0                	callq  *%rax
  800420c62f:	eb ed                	jmp    800420c61e <sched_halt+0xd6>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420c631:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c638:	00 00 00 
  800420c63b:	ff d0                	callq  *%rax
  800420c63d:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c644:	00 00 00 
  800420c647:	48 98                	cltq   
  800420c649:	48 c1 e0 03          	shl    $0x3,%rax
  800420c64d:	48 89 c2             	mov    %rax,%rdx
  800420c650:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c654:	48 29 c2             	sub    %rax,%rdx
  800420c657:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c65b:	48 83 c0 08          	add    $0x8,%rax
  800420c65f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420c666:	48 b8 28 47 3d 04 80 	movabs $0x80043d4728,%rax
  800420c66d:	00 00 00 
  800420c670:	48 8b 00             	mov    (%rax),%rax
  800420c673:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420c677:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420c67e:	00 00 00 
  800420c681:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420c685:	77 32                	ja     800420c6b9 <sched_halt+0x171>
  800420c687:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c68b:	48 89 c1             	mov    %rax,%rcx
  800420c68e:	48 ba 50 7c 21 04 80 	movabs $0x8004217c50,%rdx
  800420c695:	00 00 00 
  800420c698:	be 4b 00 00 00       	mov    $0x4b,%esi
  800420c69d:	48 bf 74 7c 21 04 80 	movabs $0x8004217c74,%rdi
  800420c6a4:	00 00 00 
  800420c6a7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6ac:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420c6b3:	00 00 00 
  800420c6b6:	41 ff d0             	callq  *%r8
  800420c6b9:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420c6c0:	ff ff ff 
  800420c6c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c6c7:	48 01 d0             	add    %rdx,%rax
  800420c6ca:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420c6ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c6d2:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420c6d5:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c6dc:	00 00 00 
  800420c6df:	ff d0                	callq  *%rax
  800420c6e1:	48 98                	cltq   
  800420c6e3:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6e7:	48 89 c2             	mov    %rax,%rdx
  800420c6ea:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6ee:	48 29 c2             	sub    %rax,%rdx
  800420c6f1:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  800420c6f8:	00 00 00 
  800420c6fb:	48 01 d0             	add    %rdx,%rax
  800420c6fe:	48 83 c0 04          	add    $0x4,%rax
  800420c702:	be 02 00 00 00       	mov    $0x2,%esi
  800420c707:	48 89 c7             	mov    %rax,%rdi
  800420c70a:	48 b8 1c c3 20 04 80 	movabs $0x800420c31c,%rax
  800420c711:	00 00 00 
  800420c714:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420c716:	48 b8 41 c3 20 04 80 	movabs $0x800420c341,%rax
  800420c71d:	00 00 00 
  800420c720:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420c722:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c729:	00 00 00 
  800420c72c:	ff d0                	callq  *%rax
  800420c72e:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c735:	00 00 00 
  800420c738:	48 98                	cltq   
  800420c73a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c73e:	48 89 c2             	mov    %rax,%rdx
  800420c741:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c745:	48 29 c2             	sub    %rax,%rdx
  800420c748:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c74c:	48 83 c0 10          	add    $0x10,%rax
  800420c750:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420c754:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420c75b:	48 89 c4             	mov    %rax,%rsp
  800420c75e:	6a 00                	pushq  $0x0
  800420c760:	6a 00                	pushq  $0x0
  800420c762:	fb                   	sti    
  800420c763:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420c764:	c9                   	leaveq 
  800420c765:	c3                   	retq   

000000800420c766 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420c766:	55                   	push   %rbp
  800420c767:	48 89 e5             	mov    %rsp,%rbp
  800420c76a:	48 83 ec 10          	sub    $0x10,%rsp
  800420c76e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c772:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.

	user_mem_assert(curenv, s, len, PTE_U);
  800420c776:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c77d:	00 00 00 
  800420c780:	ff d0                	callq  *%rax
  800420c782:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c789:	00 00 00 
  800420c78c:	48 98                	cltq   
  800420c78e:	48 c1 e0 03          	shl    $0x3,%rax
  800420c792:	48 89 c2             	mov    %rax,%rdx
  800420c795:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c799:	48 29 c2             	sub    %rax,%rdx
  800420c79c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c7a0:	48 83 c0 08          	add    $0x8,%rax
  800420c7a4:	48 8b 00             	mov    (%rax),%rax
  800420c7a7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c7ab:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420c7af:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420c7b4:	48 89 c7             	mov    %rax,%rdi
  800420c7b7:	48 b8 25 35 20 04 80 	movabs $0x8004203525,%rax
  800420c7be:	00 00 00 
  800420c7c1:	ff d0                	callq  *%rax

	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420c7c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c7c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c7cb:	48 89 c6             	mov    %rax,%rsi
  800420c7ce:	48 bf 88 7c 21 04 80 	movabs $0x8004217c88,%rdi
  800420c7d5:	00 00 00 
  800420c7d8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c7dd:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  800420c7e4:	00 00 00 
  800420c7e7:	ff d1                	callq  *%rcx
}
  800420c7e9:	c9                   	leaveq 
  800420c7ea:	c3                   	retq   

000000800420c7eb <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420c7eb:	55                   	push   %rbp
  800420c7ec:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420c7ef:	48 b8 30 10 20 04 80 	movabs $0x8004201030,%rax
  800420c7f6:	00 00 00 
  800420c7f9:	ff d0                	callq  *%rax
}
  800420c7fb:	5d                   	pop    %rbp
  800420c7fc:	c3                   	retq   

000000800420c7fd <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420c7fd:	55                   	push   %rbp
  800420c7fe:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420c801:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c808:	00 00 00 
  800420c80b:	ff d0                	callq  *%rax
  800420c80d:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c814:	00 00 00 
  800420c817:	48 98                	cltq   
  800420c819:	48 c1 e0 03          	shl    $0x3,%rax
  800420c81d:	48 89 c2             	mov    %rax,%rdx
  800420c820:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c824:	48 29 c2             	sub    %rax,%rdx
  800420c827:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c82b:	48 83 c0 08          	add    $0x8,%rax
  800420c82f:	48 8b 00             	mov    (%rax),%rax
  800420c832:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420c838:	5d                   	pop    %rbp
  800420c839:	c3                   	retq   

000000800420c83a <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420c83a:	55                   	push   %rbp
  800420c83b:	48 89 e5             	mov    %rsp,%rbp
  800420c83e:	53                   	push   %rbx
  800420c83f:	48 83 ec 28          	sub    $0x28,%rsp
  800420c843:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420c846:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420c84a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c84d:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c852:	48 89 ce             	mov    %rcx,%rsi
  800420c855:	89 c7                	mov    %eax,%edi
  800420c857:	48 b8 c7 71 20 04 80 	movabs $0x80042071c7,%rax
  800420c85e:	00 00 00 
  800420c861:	ff d0                	callq  *%rax
  800420c863:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c866:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c86a:	79 08                	jns    800420c874 <sys_env_destroy+0x3a>
		return r;
  800420c86c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c86f:	e9 08 01 00 00       	jmpq   800420c97c <sys_env_destroy+0x142>
	if (e == curenv)
  800420c874:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c87b:	00 00 00 
  800420c87e:	ff d0                	callq  *%rax
  800420c880:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c887:	00 00 00 
  800420c88a:	48 98                	cltq   
  800420c88c:	48 c1 e0 03          	shl    $0x3,%rax
  800420c890:	48 89 c2             	mov    %rax,%rdx
  800420c893:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c897:	48 29 c2             	sub    %rax,%rdx
  800420c89a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c89e:	48 83 c0 08          	add    $0x8,%rax
  800420c8a2:	48 8b 10             	mov    (%rax),%rdx
  800420c8a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c8a9:	48 39 c2             	cmp    %rax,%rdx
  800420c8ac:	75 56                	jne    800420c904 <sys_env_destroy+0xca>
		cprintf("[%08x] exiting gracefully\n", curenv->env_id);
  800420c8ae:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c8b5:	00 00 00 
  800420c8b8:	ff d0                	callq  *%rax
  800420c8ba:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c8c1:	00 00 00 
  800420c8c4:	48 98                	cltq   
  800420c8c6:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8ca:	48 89 c2             	mov    %rax,%rdx
  800420c8cd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c8d1:	48 29 c2             	sub    %rax,%rdx
  800420c8d4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c8d8:	48 83 c0 08          	add    $0x8,%rax
  800420c8dc:	48 8b 00             	mov    (%rax),%rax
  800420c8df:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c8e5:	89 c6                	mov    %eax,%esi
  800420c8e7:	48 bf 8d 7c 21 04 80 	movabs $0x8004217c8d,%rdi
  800420c8ee:	00 00 00 
  800420c8f1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8f6:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420c8fd:	00 00 00 
  800420c900:	ff d2                	callq  *%rdx
  800420c902:	eb 60                	jmp    800420c964 <sys_env_destroy+0x12a>
	else
		cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
  800420c904:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c908:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  800420c90e:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c915:	00 00 00 
  800420c918:	ff d0                	callq  *%rax
  800420c91a:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c921:	00 00 00 
  800420c924:	48 98                	cltq   
  800420c926:	48 c1 e0 03          	shl    $0x3,%rax
  800420c92a:	48 89 c2             	mov    %rax,%rdx
  800420c92d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c931:	48 29 c2             	sub    %rax,%rdx
  800420c934:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c938:	48 83 c0 08          	add    $0x8,%rax
  800420c93c:	48 8b 00             	mov    (%rax),%rax
  800420c93f:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c945:	89 da                	mov    %ebx,%edx
  800420c947:	89 c6                	mov    %eax,%esi
  800420c949:	48 bf a8 7c 21 04 80 	movabs $0x8004217ca8,%rdi
  800420c950:	00 00 00 
  800420c953:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c958:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  800420c95f:	00 00 00 
  800420c962:	ff d1                	callq  *%rcx
	env_destroy(e);
  800420c964:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c968:	48 89 c7             	mov    %rax,%rdi
  800420c96b:	48 b8 af 80 20 04 80 	movabs $0x80042080af,%rax
  800420c972:	00 00 00 
  800420c975:	ff d0                	callq  *%rax
	return 0;
  800420c977:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c97c:	48 83 c4 28          	add    $0x28,%rsp
  800420c980:	5b                   	pop    %rbx
  800420c981:	5d                   	pop    %rbp
  800420c982:	c3                   	retq   

000000800420c983 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420c983:	55                   	push   %rbp
  800420c984:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420c987:	48 b8 5f c3 20 04 80 	movabs $0x800420c35f,%rax
  800420c98e:	00 00 00 
  800420c991:	ff d0                	callq  *%rax

000000800420c993 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420c993:	55                   	push   %rbp
  800420c994:	48 89 e5             	mov    %rsp,%rbp
  800420c997:	53                   	push   %rbx
  800420c998:	48 83 ec 18          	sub    $0x18,%rsp



	int result;
	struct Env *new_env;
	result = env_alloc(&new_env, curenv->env_id);
  800420c99c:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420c9a3:	00 00 00 
  800420c9a6:	ff d0                	callq  *%rax
  800420c9a8:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420c9af:	00 00 00 
  800420c9b2:	48 98                	cltq   
  800420c9b4:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9b8:	48 89 c2             	mov    %rax,%rdx
  800420c9bb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c9bf:	48 29 c2             	sub    %rax,%rdx
  800420c9c2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c9c6:	48 83 c0 08          	add    $0x8,%rax
  800420c9ca:	48 8b 00             	mov    (%rax),%rax
  800420c9cd:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420c9d3:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420c9d7:	89 d6                	mov    %edx,%esi
  800420c9d9:	48 89 c7             	mov    %rax,%rdi
  800420c9dc:	48 b8 c2 75 20 04 80 	movabs $0x80042075c2,%rax
  800420c9e3:	00 00 00 
  800420c9e6:	ff d0                	callq  *%rax
  800420c9e8:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (result < 0)
  800420c9eb:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c9ef:	79 05                	jns    800420c9f6 <sys_exofork+0x63>
		return result;
  800420c9f1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c9f4:	eb 6d                	jmp    800420ca63 <sys_exofork+0xd0>

	new_env->env_status = ENV_NOT_RUNNABLE;
  800420c9f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c9fa:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420ca01:	00 00 00 
	new_env->env_tf = curenv->env_tf;
  800420ca04:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420ca08:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420ca0f:	00 00 00 
  800420ca12:	ff d0                	callq  *%rax
  800420ca14:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420ca1b:	00 00 00 
  800420ca1e:	48 98                	cltq   
  800420ca20:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca24:	48 89 c2             	mov    %rax,%rdx
  800420ca27:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca2b:	48 29 c2             	sub    %rax,%rdx
  800420ca2e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ca32:	48 83 c0 08          	add    $0x8,%rax
  800420ca36:	48 8b 00             	mov    (%rax),%rax
  800420ca39:	48 89 da             	mov    %rbx,%rdx
  800420ca3c:	48 89 c6             	mov    %rax,%rsi
  800420ca3f:	b8 18 00 00 00       	mov    $0x18,%eax
  800420ca44:	48 89 d7             	mov    %rdx,%rdi
  800420ca47:	48 89 c1             	mov    %rax,%rcx
  800420ca4a:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	new_env->env_tf.tf_regs.reg_rax = 0;
  800420ca4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ca51:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420ca58:	00 

	return new_env->env_id;
  800420ca59:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ca5d:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

	//panic("sys_exofork not implemented");
}
  800420ca63:	48 83 c4 18          	add    $0x18,%rsp
  800420ca67:	5b                   	pop    %rbx
  800420ca68:	5d                   	pop    %rbp
  800420ca69:	c3                   	retq   

000000800420ca6a <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420ca6a:	55                   	push   %rbp
  800420ca6b:	48 89 e5             	mov    %rsp,%rbp
  800420ca6e:	48 83 ec 20          	sub    $0x20,%rsp
  800420ca72:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420ca75:	89 75 e8             	mov    %esi,-0x18(%rbp)



	int x;
	struct Env *e;
	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE)
  800420ca78:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420ca7c:	74 0d                	je     800420ca8b <sys_env_set_status+0x21>
  800420ca7e:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420ca82:	74 07                	je     800420ca8b <sys_env_set_status+0x21>
		return -E_INVAL;
  800420ca84:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ca89:	eb 3d                	jmp    800420cac8 <sys_env_set_status+0x5e>

	if ((x = envid2env(envid, &e, 1)) < 0)
  800420ca8b:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420ca8f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ca92:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ca97:	48 89 ce             	mov    %rcx,%rsi
  800420ca9a:	89 c7                	mov    %eax,%edi
  800420ca9c:	48 b8 c7 71 20 04 80 	movabs $0x80042071c7,%rax
  800420caa3:	00 00 00 
  800420caa6:	ff d0                	callq  *%rax
  800420caa8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420caab:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420caaf:	79 05                	jns    800420cab6 <sys_env_set_status+0x4c>
		return x;
  800420cab1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cab4:	eb 12                	jmp    800420cac8 <sys_env_set_status+0x5e>

	e->env_status = status;
  800420cab6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420caba:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420cabd:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420cac3:	b8 00 00 00 00       	mov    $0x0,%eax


}
  800420cac8:	c9                   	leaveq 
  800420cac9:	c3                   	retq   

000000800420caca <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420caca:	55                   	push   %rbp
  800420cacb:	48 89 e5             	mov    %rsp,%rbp
  800420cace:	48 83 ec 20          	sub    $0x20,%rsp
  800420cad2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420cad5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)


	int x;
	struct Env *e;

	if ((x = envid2env(envid, &e, 1)) < 0)
  800420cad9:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420cadd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420cae0:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cae5:	48 89 ce             	mov    %rcx,%rsi
  800420cae8:	89 c7                	mov    %eax,%edi
  800420caea:	48 b8 c7 71 20 04 80 	movabs $0x80042071c7,%rax
  800420caf1:	00 00 00 
  800420caf4:	ff d0                	callq  *%rax
  800420caf6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420caf9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cafd:	79 05                	jns    800420cb04 <sys_env_set_pgfault_upcall+0x3a>
		return x;
  800420caff:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cb02:	eb 14                	jmp    800420cb18 <sys_env_set_pgfault_upcall+0x4e>

	e->env_pgfault_upcall = func;
  800420cb04:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb08:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cb0c:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420cb13:	b8 00 00 00 00       	mov    $0x0,%eax


}
  800420cb18:	c9                   	leaveq 
  800420cb19:	c3                   	retq   

000000800420cb1a <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420cb1a:	55                   	push   %rbp
  800420cb1b:	48 89 e5             	mov    %rsp,%rbp
  800420cb1e:	48 83 ec 30          	sub    $0x30,%rsp
  800420cb22:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420cb25:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420cb29:	89 55 d8             	mov    %edx,-0x28(%rbp)

	int x;
	struct Env *e;
	struct PageInfo *pp;

	if ((uint64_t)va >= UTOP || (((uint64_t)va & 0xFFF) != 0))
  800420cb2c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420cb30:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cb37:	00 00 00 
  800420cb3a:	48 39 c2             	cmp    %rax,%rdx
  800420cb3d:	77 0e                	ja     800420cb4d <sys_page_alloc+0x33>
  800420cb3f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cb43:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cb48:	48 85 c0             	test   %rax,%rax
  800420cb4b:	74 0a                	je     800420cb57 <sys_page_alloc+0x3d>
		return -E_INVAL;
  800420cb4d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb52:	e9 b2 00 00 00       	jmpq   800420cc09 <sys_page_alloc+0xef>
	if ((perm | PTE_SYSCALL) != PTE_SYSCALL)
  800420cb57:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420cb5a:	0d 07 0e 00 00       	or     $0xe07,%eax
  800420cb5f:	3d 07 0e 00 00       	cmp    $0xe07,%eax
  800420cb64:	74 0a                	je     800420cb70 <sys_page_alloc+0x56>
		return -E_INVAL;
  800420cb66:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb6b:	e9 99 00 00 00       	jmpq   800420cc09 <sys_page_alloc+0xef>

	if ((x = envid2env(envid, &e, 1)) < 0)
  800420cb70:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420cb74:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420cb77:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cb7c:	48 89 ce             	mov    %rcx,%rsi
  800420cb7f:	89 c7                	mov    %eax,%edi
  800420cb81:	48 b8 c7 71 20 04 80 	movabs $0x80042071c7,%rax
  800420cb88:	00 00 00 
  800420cb8b:	ff d0                	callq  *%rax
  800420cb8d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cb90:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cb94:	79 05                	jns    800420cb9b <sys_page_alloc+0x81>
		return x;
  800420cb96:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cb99:	eb 6e                	jmp    800420cc09 <sys_page_alloc+0xef>

	pp = page_alloc(ALLOC_ZERO);
  800420cb9b:	bf 01 00 00 00       	mov    $0x1,%edi
  800420cba0:	48 b8 f9 29 20 04 80 	movabs $0x80042029f9,%rax
  800420cba7:	00 00 00 
  800420cbaa:	ff d0                	callq  *%rax
  800420cbac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pp == NULL)
  800420cbb0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420cbb5:	75 07                	jne    800420cbbe <sys_page_alloc+0xa4>
		return -E_NO_MEM;
  800420cbb7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420cbbc:	eb 4b                	jmp    800420cc09 <sys_page_alloc+0xef>

	if((x = page_insert(e->env_pml4e, pp, va, perm)) < 0)
  800420cbbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cbc2:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cbc9:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420cbcc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420cbd0:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420cbd4:	48 89 c7             	mov    %rax,%rdi
  800420cbd7:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  800420cbde:	00 00 00 
  800420cbe1:	ff d0                	callq  *%rax
  800420cbe3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cbe6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cbea:	79 18                	jns    800420cc04 <sys_page_alloc+0xea>
	{
		page_free(pp);
  800420cbec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cbf0:	48 89 c7             	mov    %rax,%rdi
  800420cbf3:	48 b8 b4 2a 20 04 80 	movabs $0x8004202ab4,%rax
  800420cbfa:	00 00 00 
  800420cbfd:	ff d0                	callq  *%rax
		return x;
  800420cbff:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cc02:	eb 05                	jmp    800420cc09 <sys_page_alloc+0xef>
	}
	return 0;
  800420cc04:	b8 00 00 00 00       	mov    $0x0,%eax

	//panic("sys_page_alloc not implemented");
}
  800420cc09:	c9                   	leaveq 
  800420cc0a:	c3                   	retq   

000000800420cc0b <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420cc0b:	55                   	push   %rbp
  800420cc0c:	48 89 e5             	mov    %rsp,%rbp
  800420cc0f:	48 83 ec 50          	sub    $0x50,%rsp
  800420cc13:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420cc16:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420cc1a:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420cc1d:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420cc21:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)

	int x;
	struct Env *src_env, *dst_env;
	struct PageInfo *pp;
	pte_t *ptep;
	if ((x = envid2env(srcenvid, &src_env, 1)) < 0)
  800420cc25:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420cc29:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420cc2c:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cc31:	48 89 ce             	mov    %rcx,%rsi
  800420cc34:	89 c7                	mov    %eax,%edi
  800420cc36:	48 b8 c7 71 20 04 80 	movabs $0x80042071c7,%rax
  800420cc3d:	00 00 00 
  800420cc40:	ff d0                	callq  *%rax
  800420cc42:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cc45:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cc49:	79 08                	jns    800420cc53 <sys_page_map+0x48>
		return x;
  800420cc4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cc4e:	e9 2c 01 00 00       	jmpq   800420cd7f <sys_page_map+0x174>
	if ((x = envid2env(dstenvid, &dst_env, 1)) < 0)
  800420cc53:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420cc57:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420cc5a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cc5f:	48 89 ce             	mov    %rcx,%rsi
  800420cc62:	89 c7                	mov    %eax,%edi
  800420cc64:	48 b8 c7 71 20 04 80 	movabs $0x80042071c7,%rax
  800420cc6b:	00 00 00 
  800420cc6e:	ff d0                	callq  *%rax
  800420cc70:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cc73:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cc77:	79 08                	jns    800420cc81 <sys_page_map+0x76>
		return x;
  800420cc79:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cc7c:	e9 fe 00 00 00       	jmpq   800420cd7f <sys_page_map+0x174>
	if ((uint64_t)srcva >= UTOP || (((uint64_t)srcva & 0xFFF) != 0))
  800420cc81:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420cc85:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cc8c:	00 00 00 
  800420cc8f:	48 39 c2             	cmp    %rax,%rdx
  800420cc92:	77 0e                	ja     800420cca2 <sys_page_map+0x97>
  800420cc94:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420cc98:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cc9d:	48 85 c0             	test   %rax,%rax
  800420cca0:	74 0a                	je     800420ccac <sys_page_map+0xa1>
		return -E_INVAL;
  800420cca2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cca7:	e9 d3 00 00 00       	jmpq   800420cd7f <sys_page_map+0x174>
	if ((uint64_t)dstva >= UTOP || (((uint64_t)dstva & 0xFFF) != 0))
  800420ccac:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420ccb0:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ccb7:	00 00 00 
  800420ccba:	48 39 c2             	cmp    %rax,%rdx
  800420ccbd:	77 0e                	ja     800420cccd <sys_page_map+0xc2>
  800420ccbf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420ccc3:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ccc8:	48 85 c0             	test   %rax,%rax
  800420cccb:	74 0a                	je     800420ccd7 <sys_page_map+0xcc>
		return -E_INVAL;
  800420cccd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ccd2:	e9 a8 00 00 00       	jmpq   800420cd7f <sys_page_map+0x174>
	if ((perm | PTE_SYSCALL) != PTE_SYSCALL)
  800420ccd7:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420ccda:	0d 07 0e 00 00       	or     $0xe07,%eax
  800420ccdf:	3d 07 0e 00 00       	cmp    $0xe07,%eax
  800420cce4:	74 0a                	je     800420ccf0 <sys_page_map+0xe5>
		return -E_INVAL;
  800420cce6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cceb:	e9 8f 00 00 00       	jmpq   800420cd7f <sys_page_map+0x174>

	pp = page_lookup(src_env->env_pml4e, srcva, &ptep);
  800420ccf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccf4:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ccfb:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420ccff:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420cd03:	48 89 ce             	mov    %rcx,%rsi
  800420cd06:	48 89 c7             	mov    %rax,%rdi
  800420cd09:	48 b8 13 31 20 04 80 	movabs $0x8004203113,%rax
  800420cd10:	00 00 00 
  800420cd13:	ff d0                	callq  *%rax
  800420cd15:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (pp == NULL)
  800420cd19:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420cd1e:	75 07                	jne    800420cd27 <sys_page_map+0x11c>
		return -E_INVAL;
  800420cd20:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd25:	eb 58                	jmp    800420cd7f <sys_page_map+0x174>
	if (!((*ptep) & PTE_W) && (perm & PTE_W))
  800420cd27:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cd2b:	48 8b 00             	mov    (%rax),%rax
  800420cd2e:	83 e0 02             	and    $0x2,%eax
  800420cd31:	48 85 c0             	test   %rax,%rax
  800420cd34:	75 11                	jne    800420cd47 <sys_page_map+0x13c>
  800420cd36:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420cd39:	83 e0 02             	and    $0x2,%eax
  800420cd3c:	85 c0                	test   %eax,%eax
  800420cd3e:	74 07                	je     800420cd47 <sys_page_map+0x13c>
		return -E_INVAL;
  800420cd40:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd45:	eb 38                	jmp    800420cd7f <sys_page_map+0x174>
	if ((x = page_insert(dst_env->env_pml4e, pp, dstva, perm)) < 0)
  800420cd47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cd4b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cd52:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420cd55:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420cd59:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420cd5d:	48 89 c7             	mov    %rax,%rdi
  800420cd60:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  800420cd67:	00 00 00 
  800420cd6a:	ff d0                	callq  *%rax
  800420cd6c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cd6f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cd73:	79 05                	jns    800420cd7a <sys_page_map+0x16f>
		return x;
  800420cd75:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cd78:	eb 05                	jmp    800420cd7f <sys_page_map+0x174>
	return 0;
  800420cd7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420cd7f:	c9                   	leaveq 
  800420cd80:	c3                   	retq   

000000800420cd81 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420cd81:	55                   	push   %rbp
  800420cd82:	48 89 e5             	mov    %rsp,%rbp
  800420cd85:	48 83 ec 20          	sub    $0x20,%rsp
  800420cd89:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420cd8c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)


	int x;
	struct Env *e;

	if ((x = envid2env(envid, &e, 1)) < 0)
  800420cd90:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420cd94:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420cd97:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cd9c:	48 89 ce             	mov    %rcx,%rsi
  800420cd9f:	89 c7                	mov    %eax,%edi
  800420cda1:	48 b8 c7 71 20 04 80 	movabs $0x80042071c7,%rax
  800420cda8:	00 00 00 
  800420cdab:	ff d0                	callq  *%rax
  800420cdad:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cdb0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cdb4:	79 05                	jns    800420cdbb <sys_page_unmap+0x3a>
		return x;
  800420cdb6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cdb9:	eb 4e                	jmp    800420ce09 <sys_page_unmap+0x88>
	if ((uint64_t)va >= UTOP || (((uint64_t)va & 0xFFF) != 0))
  800420cdbb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cdbf:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cdc6:	00 00 00 
  800420cdc9:	48 39 c2             	cmp    %rax,%rdx
  800420cdcc:	77 0e                	ja     800420cddc <sys_page_unmap+0x5b>
  800420cdce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cdd2:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cdd7:	48 85 c0             	test   %rax,%rax
  800420cdda:	74 07                	je     800420cde3 <sys_page_unmap+0x62>
		return -E_INVAL;
  800420cddc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cde1:	eb 26                	jmp    800420ce09 <sys_page_unmap+0x88>
	page_remove(e->env_pml4e, va);
  800420cde3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cde7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cdee:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cdf2:	48 89 d6             	mov    %rdx,%rsi
  800420cdf5:	48 89 c7             	mov    %rax,%rdi
  800420cdf8:	48 b8 8a 31 20 04 80 	movabs $0x800420318a,%rax
  800420cdff:	00 00 00 
  800420ce02:	ff d0                	callq  *%rax
	return 0;
  800420ce04:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ce09:	c9                   	leaveq 
  800420ce0a:	c3                   	retq   

000000800420ce0b <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420ce0b:	55                   	push   %rbp
  800420ce0c:	48 89 e5             	mov    %rsp,%rbp
  800420ce0f:	53                   	push   %rbx
  800420ce10:	48 83 ec 48          	sub    $0x48,%rsp
  800420ce14:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420ce17:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800420ce1a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420ce1e:	89 4d bc             	mov    %ecx,-0x44(%rbp)
		struct Env *e;
		struct PageInfo *pp;
		pte_t *pte;
		int r;

	    if ((r = envid2env(envid, &e, 0)) != 0) {
  800420ce21:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420ce25:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420ce28:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ce2d:	48 89 ce             	mov    %rcx,%rsi
  800420ce30:	89 c7                	mov    %eax,%edi
  800420ce32:	48 b8 c7 71 20 04 80 	movabs $0x80042071c7,%rax
  800420ce39:	00 00 00 
  800420ce3c:	ff d0                	callq  *%rax
  800420ce3e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420ce41:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420ce45:	74 08                	je     800420ce4f <sys_ipc_try_send+0x44>
		return r;
  800420ce47:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ce4a:	e9 c6 01 00 00       	jmpq   800420d015 <sys_ipc_try_send+0x20a>
	    }
	    if (e->env_ipc_recving == 0) {
  800420ce4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce53:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420ce5a:	83 f0 01             	xor    $0x1,%eax
  800420ce5d:	84 c0                	test   %al,%al
  800420ce5f:	74 0a                	je     800420ce6b <sys_ipc_try_send+0x60>
		return -E_IPC_NOT_RECV;
  800420ce61:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420ce66:	e9 aa 01 00 00       	jmpq   800420d015 <sys_ipc_try_send+0x20a>
	    }
	    if ((uint64_t)srcva < UTOP) {
  800420ce6b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ce6f:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ce76:	00 00 00 
  800420ce79:	48 39 c2             	cmp    %rax,%rdx
  800420ce7c:	0f 87 19 01 00 00    	ja     800420cf9b <sys_ipc_try_send+0x190>
		if (PGOFF(srcva) != 0) {
  800420ce82:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ce86:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ce8b:	48 85 c0             	test   %rax,%rax
  800420ce8e:	74 0a                	je     800420ce9a <sys_ipc_try_send+0x8f>
		    return -E_INVAL;
  800420ce90:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ce95:	e9 7b 01 00 00       	jmpq   800420d015 <sys_ipc_try_send+0x20a>
		}
		if ((perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P)) {
  800420ce9a:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420ce9d:	83 e0 05             	and    $0x5,%eax
  800420cea0:	83 f8 05             	cmp    $0x5,%eax
  800420cea3:	74 0a                	je     800420ceaf <sys_ipc_try_send+0xa4>
		    return -E_INVAL;
  800420cea5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ceaa:	e9 66 01 00 00       	jmpq   800420d015 <sys_ipc_try_send+0x20a>
		}
		if ((perm & ~(PTE_SYSCALL)) != 0) {
  800420ceaf:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420ceb2:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420ceb7:	85 c0                	test   %eax,%eax
  800420ceb9:	74 0a                	je     800420cec5 <sys_ipc_try_send+0xba>
		    return -E_INVAL;
  800420cebb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cec0:	e9 50 01 00 00       	jmpq   800420d015 <sys_ipc_try_send+0x20a>
		}
		if ((pp = page_lookup(curenv->env_pml4e, srcva, &pte)) == NULL) {
  800420cec5:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420cecc:	00 00 00 
  800420cecf:	ff d0                	callq  *%rax
  800420ced1:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420ced8:	00 00 00 
  800420cedb:	48 98                	cltq   
  800420cedd:	48 c1 e0 03          	shl    $0x3,%rax
  800420cee1:	48 89 c2             	mov    %rax,%rdx
  800420cee4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cee8:	48 29 c2             	sub    %rax,%rdx
  800420ceeb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ceef:	48 83 c0 08          	add    $0x8,%rax
  800420cef3:	48 8b 00             	mov    (%rax),%rax
  800420cef6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cefd:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420cf01:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420cf05:	48 89 ce             	mov    %rcx,%rsi
  800420cf08:	48 89 c7             	mov    %rax,%rdi
  800420cf0b:	48 b8 13 31 20 04 80 	movabs $0x8004203113,%rax
  800420cf12:	00 00 00 
  800420cf15:	ff d0                	callq  *%rax
  800420cf17:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420cf1b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420cf20:	75 0a                	jne    800420cf2c <sys_ipc_try_send+0x121>
		    return -E_INVAL;
  800420cf22:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cf27:	e9 e9 00 00 00       	jmpq   800420d015 <sys_ipc_try_send+0x20a>
		}
		if ((*pte & PTE_W) == 0 && (perm & PTE_W) == PTE_W) {
  800420cf2c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cf30:	48 8b 00             	mov    (%rax),%rax
  800420cf33:	83 e0 02             	and    $0x2,%eax
  800420cf36:	48 85 c0             	test   %rax,%rax
  800420cf39:	75 14                	jne    800420cf4f <sys_ipc_try_send+0x144>
  800420cf3b:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420cf3e:	83 e0 02             	and    $0x2,%eax
  800420cf41:	85 c0                	test   %eax,%eax
  800420cf43:	74 0a                	je     800420cf4f <sys_ipc_try_send+0x144>
		    return -E_INVAL;
  800420cf45:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cf4a:	e9 c6 00 00 00       	jmpq   800420d015 <sys_ipc_try_send+0x20a>
		}
		if ((r = page_insert(e->env_pml4e, pp, e->env_ipc_dstva, perm)) != 0) {
  800420cf4f:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420cf52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cf56:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420cf5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cf61:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cf68:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420cf6c:	48 89 c7             	mov    %rax,%rdi
  800420cf6f:	48 b8 5e 30 20 04 80 	movabs $0x800420305e,%rax
  800420cf76:	00 00 00 
  800420cf79:	ff d0                	callq  *%rax
  800420cf7b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420cf7e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420cf82:	74 08                	je     800420cf8c <sys_ipc_try_send+0x181>
		    return r;
  800420cf84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420cf87:	e9 89 00 00 00       	jmpq   800420d015 <sys_ipc_try_send+0x20a>
		}
		e->env_ipc_perm = perm;
  800420cf8c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cf90:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420cf93:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420cf99:	eb 0e                	jmp    800420cfa9 <sys_ipc_try_send+0x19e>
	    } else {
		e->env_ipc_perm = 0;
  800420cf9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cf9f:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420cfa6:	00 00 00 
	    }
	    e->env_ipc_recving = 0;
  800420cfa9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cfad:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	    e->env_ipc_from = curenv->env_id;
  800420cfb4:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
  800420cfb8:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420cfbf:	00 00 00 
  800420cfc2:	ff d0                	callq  *%rax
  800420cfc4:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420cfcb:	00 00 00 
  800420cfce:	48 98                	cltq   
  800420cfd0:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfd4:	48 89 c2             	mov    %rax,%rdx
  800420cfd7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cfdb:	48 29 c2             	sub    %rax,%rdx
  800420cfde:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cfe2:	48 83 c0 08          	add    $0x8,%rax
  800420cfe6:	48 8b 00             	mov    (%rax),%rax
  800420cfe9:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420cfef:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
	    e->env_ipc_value = value;
  800420cff5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cff9:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420cffc:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	    e->env_status = ENV_RUNNABLE;
  800420d002:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d006:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420d00d:	00 00 00 
	    return 0;
  800420d010:	b8 00 00 00 00       	mov    $0x0,%eax
		}
  800420d015:	48 83 c4 48          	add    $0x48,%rsp
  800420d019:	5b                   	pop    %rbx
  800420d01a:	5d                   	pop    %rbp
  800420d01b:	c3                   	retq   

000000800420d01c <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420d01c:	55                   	push   %rbp
  800420d01d:	48 89 e5             	mov    %rsp,%rbp
  800420d020:	48 83 ec 10          	sub    $0x10,%rsp
  800420d024:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 4: Your code here.
	if ((uint64_t)dstva < UTOP && PGOFF(dstva) != 0) {
  800420d028:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d02c:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d033:	00 00 00 
  800420d036:	48 39 c2             	cmp    %rax,%rdx
  800420d039:	77 18                	ja     800420d053 <sys_ipc_recv+0x37>
  800420d03b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d03f:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d044:	48 85 c0             	test   %rax,%rax
  800420d047:	74 0a                	je     800420d053 <sys_ipc_recv+0x37>
			return -E_INVAL;
  800420d049:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d04e:	e9 b4 00 00 00       	jmpq   800420d107 <sys_ipc_recv+0xeb>
	}
	curenv->env_ipc_recving = 1;
  800420d053:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420d05a:	00 00 00 
  800420d05d:	ff d0                	callq  *%rax
  800420d05f:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420d066:	00 00 00 
  800420d069:	48 98                	cltq   
  800420d06b:	48 c1 e0 03          	shl    $0x3,%rax
  800420d06f:	48 89 c2             	mov    %rax,%rdx
  800420d072:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d076:	48 29 c2             	sub    %rax,%rdx
  800420d079:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d07d:	48 83 c0 08          	add    $0x8,%rax
  800420d081:	48 8b 00             	mov    (%rax),%rax
  800420d084:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	curenv->env_ipc_dstva = dstva;
  800420d08b:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420d092:	00 00 00 
  800420d095:	ff d0                	callq  *%rax
  800420d097:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420d09e:	00 00 00 
  800420d0a1:	48 98                	cltq   
  800420d0a3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0a7:	48 89 c2             	mov    %rax,%rdx
  800420d0aa:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d0ae:	48 29 c2             	sub    %rax,%rdx
  800420d0b1:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d0b5:	48 83 c0 08          	add    $0x8,%rax
  800420d0b9:	48 8b 00             	mov    (%rax),%rax
  800420d0bc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d0c0:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420d0c7:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420d0ce:	00 00 00 
  800420d0d1:	ff d0                	callq  *%rax
  800420d0d3:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420d0da:	00 00 00 
  800420d0dd:	48 98                	cltq   
  800420d0df:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0e3:	48 89 c2             	mov    %rax,%rdx
  800420d0e6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d0ea:	48 29 c2             	sub    %rax,%rdx
  800420d0ed:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d0f1:	48 83 c0 08          	add    $0x8,%rax
  800420d0f5:	48 8b 00             	mov    (%rax),%rax
  800420d0f8:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420d0ff:	00 00 00 

	//panic("sys_ipc_recv not implemented");
	return 0;
  800420d102:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d107:	c9                   	leaveq 
  800420d108:	c3                   	retq   

000000800420d109 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420d109:	55                   	push   %rbp
  800420d10a:	48 89 e5             	mov    %rsp,%rbp
  800420d10d:	48 83 ec 30          	sub    $0x30,%rsp
  800420d111:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d115:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420d119:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d11d:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420d121:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420d125:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	// Return any appropriate return value.
	// LAB 3: Your code here.

	////////////////panic("syscall not implemented");

	switch (syscallno) {
  800420d129:	48 83 7d f8 0c       	cmpq   $0xc,-0x8(%rbp)
  800420d12e:	0f 87 95 01 00 00    	ja     800420d2c9 <syscall+0x1c0>
  800420d134:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d138:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420d13f:	00 
  800420d140:	48 b8 c0 7c 21 04 80 	movabs $0x8004217cc0,%rax
  800420d147:	00 00 00 
  800420d14a:	48 01 d0             	add    %rdx,%rax
  800420d14d:	48 8b 00             	mov    (%rax),%rax
  800420d150:	ff e0                	jmpq   *%rax
		case SYS_cputs:
			sys_cputs((const char *)a1, (size_t)a2);
  800420d152:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d156:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d15a:	48 89 d6             	mov    %rdx,%rsi
  800420d15d:	48 89 c7             	mov    %rax,%rdi
  800420d160:	48 b8 66 c7 20 04 80 	movabs $0x800420c766,%rax
  800420d167:	00 00 00 
  800420d16a:	ff d0                	callq  *%rax
			return 0;
  800420d16c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d171:	e9 5a 01 00 00       	jmpq   800420d2d0 <syscall+0x1c7>
		case SYS_yield:
			sys_yield();
  800420d176:	48 b8 83 c9 20 04 80 	movabs $0x800420c983,%rax
  800420d17d:	00 00 00 
  800420d180:	ff d0                	callq  *%rax
			return 0;
  800420d182:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d187:	e9 44 01 00 00       	jmpq   800420d2d0 <syscall+0x1c7>
		case SYS_cgetc:
			return sys_cgetc();
  800420d18c:	48 b8 eb c7 20 04 80 	movabs $0x800420c7eb,%rax
  800420d193:	00 00 00 
  800420d196:	ff d0                	callq  *%rax
  800420d198:	48 98                	cltq   
  800420d19a:	e9 31 01 00 00       	jmpq   800420d2d0 <syscall+0x1c7>
		case SYS_getenvid:
			return sys_getenvid();
  800420d19f:	48 b8 fd c7 20 04 80 	movabs $0x800420c7fd,%rax
  800420d1a6:	00 00 00 
  800420d1a9:	ff d0                	callq  *%rax
  800420d1ab:	48 98                	cltq   
  800420d1ad:	e9 1e 01 00 00       	jmpq   800420d2d0 <syscall+0x1c7>
		case SYS_env_destroy:
			return sys_env_destroy(a1);
  800420d1b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1b6:	89 c7                	mov    %eax,%edi
  800420d1b8:	48 b8 3a c8 20 04 80 	movabs $0x800420c83a,%rax
  800420d1bf:	00 00 00 
  800420d1c2:	ff d0                	callq  *%rax
  800420d1c4:	48 98                	cltq   
  800420d1c6:	e9 05 01 00 00       	jmpq   800420d2d0 <syscall+0x1c7>
		case SYS_exofork:
			return sys_exofork();
  800420d1cb:	48 b8 93 c9 20 04 80 	movabs $0x800420c993,%rax
  800420d1d2:	00 00 00 
  800420d1d5:	ff d0                	callq  *%rax
  800420d1d7:	48 98                	cltq   
  800420d1d9:	e9 f2 00 00 00       	jmpq   800420d2d0 <syscall+0x1c7>
		case SYS_env_set_status:
			return sys_env_set_status(a1, a2);
  800420d1de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1e2:	89 c2                	mov    %eax,%edx
  800420d1e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1e8:	89 d6                	mov    %edx,%esi
  800420d1ea:	89 c7                	mov    %eax,%edi
  800420d1ec:	48 b8 6a ca 20 04 80 	movabs $0x800420ca6a,%rax
  800420d1f3:	00 00 00 
  800420d1f6:	ff d0                	callq  *%rax
  800420d1f8:	48 98                	cltq   
  800420d1fa:	e9 d1 00 00 00       	jmpq   800420d2d0 <syscall+0x1c7>
		case SYS_page_alloc:
			return sys_page_alloc((envid_t)a1, (void *)a2, (int)a3);
  800420d1ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d203:	89 c2                	mov    %eax,%edx
  800420d205:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d209:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d20d:	48 89 ce             	mov    %rcx,%rsi
  800420d210:	89 c7                	mov    %eax,%edi
  800420d212:	48 b8 1a cb 20 04 80 	movabs $0x800420cb1a,%rax
  800420d219:	00 00 00 
  800420d21c:	ff d0                	callq  *%rax
  800420d21e:	48 98                	cltq   
  800420d220:	e9 ab 00 00 00       	jmpq   800420d2d0 <syscall+0x1c7>
		case SYS_page_map:
			return sys_page_map((envid_t)a1, (void *)a2, (envid_t)a3, (void *)a4, (int)a5);
  800420d225:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d229:	89 c7                	mov    %eax,%edi
  800420d22b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420d22f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d233:	89 c2                	mov    %eax,%edx
  800420d235:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420d239:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d23d:	41 89 f8             	mov    %edi,%r8d
  800420d240:	89 c7                	mov    %eax,%edi
  800420d242:	48 b8 0b cc 20 04 80 	movabs $0x800420cc0b,%rax
  800420d249:	00 00 00 
  800420d24c:	ff d0                	callq  *%rax
  800420d24e:	48 98                	cltq   
  800420d250:	eb 7e                	jmp    800420d2d0 <syscall+0x1c7>
		case SYS_page_unmap:
			return sys_page_unmap((envid_t)a1, (void *)a2);
  800420d252:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d256:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d25a:	48 89 d6             	mov    %rdx,%rsi
  800420d25d:	89 c7                	mov    %eax,%edi
  800420d25f:	48 b8 81 cd 20 04 80 	movabs $0x800420cd81,%rax
  800420d266:	00 00 00 
  800420d269:	ff d0                	callq  *%rax
  800420d26b:	48 98                	cltq   
  800420d26d:	eb 61                	jmp    800420d2d0 <syscall+0x1c7>
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall((envid_t)a1, (void *)a2);
  800420d26f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d273:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d277:	48 89 d6             	mov    %rdx,%rsi
  800420d27a:	89 c7                	mov    %eax,%edi
  800420d27c:	48 b8 ca ca 20 04 80 	movabs $0x800420caca,%rax
  800420d283:	00 00 00 
  800420d286:	ff d0                	callq  *%rax
  800420d288:	48 98                	cltq   
  800420d28a:	eb 44                	jmp    800420d2d0 <syscall+0x1c7>
		case SYS_ipc_recv:
	    return sys_ipc_recv((void *)a1);
  800420d28c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d290:	48 89 c7             	mov    %rax,%rdi
  800420d293:	48 b8 1c d0 20 04 80 	movabs $0x800420d01c,%rax
  800420d29a:	00 00 00 
  800420d29d:	ff d0                	callq  *%rax
  800420d29f:	48 98                	cltq   
  800420d2a1:	eb 2d                	jmp    800420d2d0 <syscall+0x1c7>
		case SYS_ipc_try_send:
	    return sys_ipc_try_send(a1, a2, (void *)a3, a4);
  800420d2a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d2a7:	89 c1                	mov    %eax,%ecx
  800420d2a9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d2ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d2b1:	89 c6                	mov    %eax,%esi
  800420d2b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2b7:	89 c7                	mov    %eax,%edi
  800420d2b9:	48 b8 0b ce 20 04 80 	movabs $0x800420ce0b,%rax
  800420d2c0:	00 00 00 
  800420d2c3:	ff d0                	callq  *%rax
  800420d2c5:	48 98                	cltq   
  800420d2c7:	eb 07                	jmp    800420d2d0 <syscall+0x1c7>
		default:
			return -E_INVAL;
  800420d2c9:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
	}
}
  800420d2d0:	c9                   	leaveq 
  800420d2d1:	c3                   	retq   

000000800420d2d2 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420d2d2:	55                   	push   %rbp
  800420d2d3:	48 89 e5             	mov    %rsp,%rbp
  800420d2d6:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420d2dd:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420d2e4:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420d2eb:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420d2f2:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d2f9:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420d300:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420d304:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d30b:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d312:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420d316:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420d31d:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d324:	48 89 d1             	mov    %rdx,%rcx
  800420d327:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d32c:	48 89 ce             	mov    %rcx,%rsi
  800420d32f:	48 89 c7             	mov    %rax,%rdi
  800420d332:	48 b8 7f ef 20 04 80 	movabs $0x800420ef7f,%rax
  800420d339:	00 00 00 
  800420d33c:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420d33e:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420d345:	00 
	uint64_t ret_offset=0;
  800420d346:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d34d:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420d34e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d355:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d359:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420d35d:	74 0a                	je     800420d369 <list_func_die+0x97>
		return 0;
  800420d35f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d364:	e9 cd 06 00 00       	jmpq   800420da36 <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420d369:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420d370:	ba 38 00 00 00       	mov    $0x38,%edx
  800420d375:	be 00 00 00 00       	mov    $0x0,%esi
  800420d37a:	48 89 c7             	mov    %rax,%rdi
  800420d37d:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  800420d384:	00 00 00 
  800420d387:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420d389:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d390:	be 11 00 00 00       	mov    $0x11,%esi
  800420d395:	48 89 c7             	mov    %rax,%rdi
  800420d398:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d39f:	00 00 00 
  800420d3a2:	ff d0                	callq  *%rax
  800420d3a4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420d3a8:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d3af:	be 12 00 00 00       	mov    $0x12,%esi
  800420d3b4:	48 89 c7             	mov    %rax,%rdi
  800420d3b7:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d3be:	00 00 00 
  800420d3c1:	ff d0                	callq  *%rax
  800420d3c3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420d3c7:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420d3cc:	0f 84 5f 06 00 00    	je     800420da31 <list_func_die+0x75f>
  800420d3d2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d3d6:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d3da:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420d3e1:	0f 83 4a 06 00 00    	jae    800420da31 <list_func_die+0x75f>
  800420d3e7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420d3ec:	0f 84 3f 06 00 00    	je     800420da31 <list_func_die+0x75f>
  800420d3f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d3f6:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d3fa:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420d401:	0f 86 2a 06 00 00    	jbe    800420da31 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420d407:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d40e:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d415:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420d41c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d423:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420d426:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d42d:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420d434:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d43b:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420d43f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d446:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420d44d:	48 89 c7             	mov    %rax,%rdi
  800420d450:	48 b8 d8 ea 20 04 80 	movabs $0x800420ead8,%rax
  800420d457:	00 00 00 
  800420d45a:	ff d0                	callq  *%rax
  800420d45c:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420d463:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420d466:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d46a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420d46e:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d475:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420d479:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d480:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d487:	48 85 c0             	test   %rax,%rax
  800420d48a:	75 35                	jne    800420d4c1 <list_func_die+0x1ef>
  800420d48c:	48 b9 60 80 21 04 80 	movabs $0x8004218060,%rcx
  800420d493:	00 00 00 
  800420d496:	48 ba 6c 80 21 04 80 	movabs $0x800421806c,%rdx
  800420d49d:	00 00 00 
  800420d4a0:	be 91 00 00 00       	mov    $0x91,%esi
  800420d4a5:	48 bf 81 80 21 04 80 	movabs $0x8004218081,%rdi
  800420d4ac:	00 00 00 
  800420d4af:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d4b4:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420d4bb:	00 00 00 
  800420d4be:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420d4c1:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d4c8:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d4cf:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420d4d6:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420d4dd:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420d4e2:	48 89 c7             	mov    %rax,%rdi
  800420d4e5:	48 b8 39 43 21 04 80 	movabs $0x8004214339,%rax
  800420d4ec:	00 00 00 
  800420d4ef:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420d4f1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d4f8:	89 c2                	mov    %eax,%edx
  800420d4fa:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d501:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420d504:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d50b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420d512:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420d519:	00 00 00 
  800420d51c:	48 8b 00             	mov    (%rax),%rax
  800420d51f:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d526:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d52d:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420d531:	48 89 c7             	mov    %rax,%rdi
  800420d534:	48 b8 e9 0f 21 04 80 	movabs $0x8004210fe9,%rax
  800420d53b:	00 00 00 
  800420d53e:	ff d0                	callq  *%rax
  800420d540:	83 f8 04             	cmp    $0x4,%eax
  800420d543:	0f 84 e1 04 00 00    	je     800420da2a <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420d549:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d550:	48 83 f8 05          	cmp    $0x5,%rax
  800420d554:	74 05                	je     800420d55b <list_func_die+0x289>
				goto last;
  800420d556:	e9 cf 04 00 00       	jmpq   800420da2a <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d55b:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d562:	be 49 00 00 00       	mov    $0x49,%esi
  800420d567:	48 89 c7             	mov    %rax,%rdi
  800420d56a:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d571:	00 00 00 
  800420d574:	ff d0                	callq  *%rax
  800420d576:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420d57a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d57f:	0f 84 d7 00 00 00    	je     800420d65c <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d585:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d589:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d58d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d591:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d595:	48 01 d0             	add    %rdx,%rax
  800420d598:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420d59c:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420d5a3:	00 00 00 
  800420d5a6:	48 8b 08             	mov    (%rax),%rcx
  800420d5a9:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d5b0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d5b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d5b8:	48 8b 38             	mov    (%rax),%rdi
  800420d5bb:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d5bf:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d5c3:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d5c8:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d5cc:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d5d1:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d5d5:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d5da:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d5de:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d5e3:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d5e7:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d5ec:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d5f0:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d5f5:	48 89 cf             	mov    %rcx,%rdi
  800420d5f8:	48 b8 0f 0c 21 04 80 	movabs $0x8004210c0f,%rax
  800420d5ff:	00 00 00 
  800420d602:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d604:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d60b:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d610:	48 89 c7             	mov    %rax,%rdi
  800420d613:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d61a:	00 00 00 
  800420d61d:	ff d0                	callq  *%rax
  800420d61f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420d623:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d628:	74 0e                	je     800420d638 <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420d62a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d62e:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d632:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d636:	eb 24                	jmp    800420d65c <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420d638:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d63f:	be 49 00 00 00       	mov    $0x49,%esi
  800420d644:	48 89 c7             	mov    %rax,%rdi
  800420d647:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d64e:	00 00 00 
  800420d651:	ff d0                	callq  *%rax
  800420d653:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420d657:	e9 1e ff ff ff       	jmpq   800420d57a <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420d65c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d663:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d664:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d66b:	be 02 00 00 00       	mov    $0x2,%esi
  800420d670:	48 89 c7             	mov    %rax,%rdi
  800420d673:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d67a:	00 00 00 
  800420d67d:	ff d0                	callq  *%rax
  800420d67f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420d683:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d688:	0f 84 a2 00 00 00    	je     800420d730 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d68e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d692:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d696:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d69a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d69e:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d6a2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420d6a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6aa:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d6ae:	48 83 f8 03          	cmp    $0x3,%rax
  800420d6b2:	72 7c                	jb     800420d730 <list_func_die+0x45e>
  800420d6b4:	48 83 f8 04          	cmp    $0x4,%rax
  800420d6b8:	76 06                	jbe    800420d6c0 <list_func_die+0x3ee>
  800420d6ba:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d6be:	75 70                	jne    800420d730 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420d6c0:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d6c7:	00 
						atom = *(loc_ptr++);
  800420d6c8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d6cc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d6d0:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420d6d4:	0f b6 00             	movzbl (%rax),%eax
  800420d6d7:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420d6da:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420d6df:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420d6e3:	75 4a                	jne    800420d72f <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420d6e5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d6e9:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420d6f0:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420d6f7:	48 89 c7             	mov    %rax,%rdi
  800420d6fa:	48 b8 6e f9 20 04 80 	movabs $0x800420f96e,%rax
  800420d701:	00 00 00 
  800420d704:	ff d0                	callq  *%rax
  800420d706:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420d70a:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d711:	48 89 c2             	mov    %rax,%rdx
  800420d714:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d718:	48 29 c2             	sub    %rax,%rdx
  800420d71b:	48 89 d0             	mov    %rdx,%rax
  800420d71e:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420d722:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d729:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420d72d:	eb 00                	jmp    800420d72f <list_func_die+0x45d>
  800420d72f:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420d730:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d737:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d73a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d73e:	89 c2                	mov    %eax,%edx
  800420d740:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d747:	48 63 c9             	movslq %ecx,%rcx
  800420d74a:	48 83 c1 08          	add    $0x8,%rcx
  800420d74e:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420d752:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d759:	8b 50 28             	mov    0x28(%rax),%edx
  800420d75c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d763:	48 63 d2             	movslq %edx,%rdx
  800420d766:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d76a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d76e:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420d773:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d77a:	8b 40 28             	mov    0x28(%rax),%eax
  800420d77d:	8d 50 01             	lea    0x1(%rax),%edx
  800420d780:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d787:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420d78a:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d791:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d798:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d79d:	48 89 ce             	mov    %rcx,%rsi
  800420d7a0:	48 89 c7             	mov    %rax,%rdi
  800420d7a3:	48 b8 7f ef 20 04 80 	movabs $0x800420ef7f,%rax
  800420d7aa:	00 00 00 
  800420d7ad:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d7af:	e9 40 02 00 00       	jmpq   800420d9f4 <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420d7b4:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d7bb:	48 83 f8 05          	cmp    $0x5,%rax
  800420d7bf:	74 05                	je     800420d7c6 <list_func_die+0x4f4>
					break;
  800420d7c1:	e9 64 02 00 00       	jmpq   800420da2a <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d7c6:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d7cd:	be 49 00 00 00       	mov    $0x49,%esi
  800420d7d2:	48 89 c7             	mov    %rax,%rdi
  800420d7d5:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d7dc:	00 00 00 
  800420d7df:	ff d0                	callq  *%rax
  800420d7e1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420d7e5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d7ea:	0f 84 b1 00 00 00    	je     800420d8a1 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d7f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d7f4:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d7f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7fc:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d800:	48 01 d0             	add    %rdx,%rax
  800420d803:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420d807:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420d80e:	00 00 00 
  800420d811:	48 8b 08             	mov    (%rax),%rcx
  800420d814:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d81b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d81f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d823:	48 8b 38             	mov    (%rax),%rdi
  800420d826:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d82a:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d82e:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d833:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d837:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d83c:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d840:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d845:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d849:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d84e:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d852:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d857:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d85b:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d860:	48 89 cf             	mov    %rcx,%rdi
  800420d863:	48 b8 0f 0c 21 04 80 	movabs $0x8004210c0f,%rax
  800420d86a:	00 00 00 
  800420d86d:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d86f:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d876:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d87b:	48 89 c7             	mov    %rax,%rdi
  800420d87e:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d885:	00 00 00 
  800420d888:	ff d0                	callq  *%rax
  800420d88a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420d88e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d893:	74 0c                	je     800420d8a1 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420d895:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d899:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d89d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420d8a1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d8a8:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d8a9:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d8b0:	be 02 00 00 00       	mov    $0x2,%esi
  800420d8b5:	48 89 c7             	mov    %rax,%rdi
  800420d8b8:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  800420d8bf:	00 00 00 
  800420d8c2:	ff d0                	callq  *%rax
  800420d8c4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420d8c8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d8cd:	0f 84 a2 00 00 00    	je     800420d975 <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d8d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8d7:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d8db:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d8df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8e3:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d8e7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420d8eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8ef:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d8f3:	48 83 f8 03          	cmp    $0x3,%rax
  800420d8f7:	72 7c                	jb     800420d975 <list_func_die+0x6a3>
  800420d8f9:	48 83 f8 04          	cmp    $0x4,%rax
  800420d8fd:	76 06                	jbe    800420d905 <list_func_die+0x633>
  800420d8ff:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d903:	75 70                	jne    800420d975 <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420d905:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d90c:	00 
							atom = *(loc_ptr++);
  800420d90d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d911:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d915:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420d919:	0f b6 00             	movzbl (%rax),%eax
  800420d91c:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420d91f:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420d924:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420d928:	75 4a                	jne    800420d974 <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420d92a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d92e:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420d935:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420d93c:	48 89 c7             	mov    %rax,%rdi
  800420d93f:	48 b8 6e f9 20 04 80 	movabs $0x800420f96e,%rax
  800420d946:	00 00 00 
  800420d949:	ff d0                	callq  *%rax
  800420d94b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420d94f:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d956:	48 89 c2             	mov    %rax,%rdx
  800420d959:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d95d:	48 29 c2             	sub    %rax,%rdx
  800420d960:	48 89 d0             	mov    %rdx,%rax
  800420d963:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420d967:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d96e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420d972:	eb 00                	jmp    800420d974 <list_func_die+0x6a2>
  800420d974:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420d975:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d97c:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d97f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d983:	89 c2                	mov    %eax,%edx
  800420d985:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d98c:	48 63 c9             	movslq %ecx,%rcx
  800420d98f:	48 83 c1 08          	add    $0x8,%rcx
  800420d993:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420d997:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d99e:	8b 50 28             	mov    0x28(%rax),%edx
  800420d9a1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d9a8:	48 63 d2             	movslq %edx,%rdx
  800420d9ab:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d9af:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d9b3:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420d9b8:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d9bf:	8b 40 28             	mov    0x28(%rax),%eax
  800420d9c2:	8d 50 01             	lea    0x1(%rax),%edx
  800420d9c5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d9cc:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420d9cf:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d9d6:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d9dd:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d9e2:	48 89 ce             	mov    %rcx,%rsi
  800420d9e5:	48 89 c7             	mov    %rax,%rdi
  800420d9e8:	48 b8 7f ef 20 04 80 	movabs $0x800420ef7f,%rax
  800420d9ef:	00 00 00 
  800420d9f2:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d9f4:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420d9fb:	00 00 00 
  800420d9fe:	48 8b 00             	mov    (%rax),%rax
  800420da01:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420da05:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420da0c:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420da13:	48 89 c7             	mov    %rax,%rdi
  800420da16:	48 b8 a5 0d 21 04 80 	movabs $0x8004210da5,%rax
  800420da1d:	00 00 00 
  800420da20:	ff d0                	callq  *%rax
  800420da22:	85 c0                	test   %eax,%eax
  800420da24:	0f 84 8a fd ff ff    	je     800420d7b4 <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420da2a:	b8 01 00 00 00       	mov    $0x1,%eax
  800420da2f:	eb 05                	jmp    800420da36 <list_func_die+0x764>
	}

	return 0;
  800420da31:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420da36:	c9                   	leaveq 
  800420da37:	c3                   	retq   

000000800420da38 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420da38:	55                   	push   %rbp
  800420da39:	48 89 e5             	mov    %rsp,%rbp
  800420da3c:	53                   	push   %rbx
  800420da3d:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420da44:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420da4b:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420da52:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420da59:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420da5a:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420da61:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420da65:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420da6c:	48 bb 8f 80 21 04 80 	movabs $0x800421808f,%rbx
  800420da73:	00 00 00 
  800420da76:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420da79:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420da80:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420da87:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420da8e:	48 bb 8f 80 21 04 80 	movabs $0x800421808f,%rbx
  800420da95:	00 00 00 
  800420da98:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420da9c:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420daa3:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420daaa:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dab1:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420dab8:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420dabc:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dac3:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420daca:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420dad1:	00 00 00 
  800420dad4:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420dadb:	76 13                	jbe    800420daf0 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420dadd:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420dae4:	00 00 00 
  800420dae7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420daeb:	e9 08 01 00 00       	jmpq   800420dbf8 <debuginfo_rip+0x1c0>
	} else {
		if(curenv != lastenv) {
  800420daf0:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420daf7:	00 00 00 
  800420dafa:	ff d0                	callq  *%rax
  800420dafc:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420db03:	00 00 00 
  800420db06:	48 98                	cltq   
  800420db08:	48 c1 e0 03          	shl    $0x3,%rax
  800420db0c:	48 89 c2             	mov    %rax,%rdx
  800420db0f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420db13:	48 29 c2             	sub    %rax,%rdx
  800420db16:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420db1a:	48 83 c0 08          	add    $0x8,%rax
  800420db1e:	48 8b 10             	mov    (%rax),%rdx
  800420db21:	48 b8 98 42 3d 04 80 	movabs $0x80043d4298,%rax
  800420db28:	00 00 00 
  800420db2b:	48 8b 00             	mov    (%rax),%rax
  800420db2e:	48 39 c2             	cmp    %rax,%rdx
  800420db31:	0f 84 85 00 00 00    	je     800420dbbc <debuginfo_rip+0x184>
			find_debug_sections((uintptr_t)curenv->elf);
  800420db37:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420db3e:	00 00 00 
  800420db41:	ff d0                	callq  *%rax
  800420db43:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420db4a:	00 00 00 
  800420db4d:	48 98                	cltq   
  800420db4f:	48 c1 e0 03          	shl    $0x3,%rax
  800420db53:	48 89 c2             	mov    %rax,%rdx
  800420db56:	48 c1 e2 04          	shl    $0x4,%rdx
  800420db5a:	48 29 c2             	sub    %rax,%rdx
  800420db5d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420db61:	48 83 c0 08          	add    $0x8,%rax
  800420db65:	48 8b 00             	mov    (%rax),%rax
  800420db68:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420db6f:	48 89 c7             	mov    %rax,%rdi
  800420db72:	48 b8 34 45 21 04 80 	movabs $0x8004214534,%rax
  800420db79:	00 00 00 
  800420db7c:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420db7e:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420db85:	00 00 00 
  800420db88:	ff d0                	callq  *%rax
  800420db8a:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420db91:	00 00 00 
  800420db94:	48 98                	cltq   
  800420db96:	48 c1 e0 03          	shl    $0x3,%rax
  800420db9a:	48 89 c2             	mov    %rax,%rdx
  800420db9d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dba1:	48 29 c2             	sub    %rax,%rdx
  800420dba4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420dba8:	48 83 c0 08          	add    $0x8,%rax
  800420dbac:	48 8b 10             	mov    (%rax),%rdx
  800420dbaf:	48 b8 98 42 3d 04 80 	movabs $0x80043d4298,%rax
  800420dbb6:	00 00 00 
  800420dbb9:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420dbbc:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  800420dbc3:	00 00 00 
  800420dbc6:	ff d0                	callq  *%rax
  800420dbc8:	48 b9 20 60 3d 04 80 	movabs $0x80043d6020,%rcx
  800420dbcf:	00 00 00 
  800420dbd2:	48 98                	cltq   
  800420dbd4:	48 c1 e0 03          	shl    $0x3,%rax
  800420dbd8:	48 89 c2             	mov    %rax,%rdx
  800420dbdb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dbdf:	48 29 c2             	sub    %rax,%rdx
  800420dbe2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420dbe6:	48 83 c0 08          	add    $0x8,%rax
  800420dbea:	48 8b 00             	mov    (%rax),%rax
  800420dbed:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420dbf4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420dbf8:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dbff:	00 00 00 
  800420dc02:	48 8b 00             	mov    (%rax),%rax
  800420dc05:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dc09:	48 89 d6             	mov    %rdx,%rsi
  800420dc0c:	48 89 c7             	mov    %rax,%rdi
  800420dc0f:	48 b8 1d fc 20 04 80 	movabs $0x800420fc1d,%rax
  800420dc16:	00 00 00 
  800420dc19:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420dc1b:	48 bf 99 80 21 04 80 	movabs $0x8004218099,%rdi
  800420dc22:	00 00 00 
  800420dc25:	48 b8 b4 44 21 04 80 	movabs $0x80042144b4,%rax
  800420dc2c:	00 00 00 
  800420dc2f:	ff d0                	callq  *%rax
  800420dc31:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420dc35:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dc3c:	00 00 00 
  800420dc3f:	48 8b 00             	mov    (%rax),%rax
  800420dc42:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dc46:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420dc4a:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420dc4e:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dc55:	00 00 00 
  800420dc58:	48 8b 00             	mov    (%rax),%rax
  800420dc5b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dc5f:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420dc63:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420dc67:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dc6e:	00 00 00 
  800420dc71:	48 8b 00             	mov    (%rax),%rax
  800420dc74:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420dc78:	48 85 c0             	test   %rax,%rax
  800420dc7b:	75 35                	jne    800420dcb2 <debuginfo_rip+0x27a>
  800420dc7d:	48 b9 a5 80 21 04 80 	movabs $0x80042180a5,%rcx
  800420dc84:	00 00 00 
  800420dc87:	48 ba 6c 80 21 04 80 	movabs $0x800421806c,%rdx
  800420dc8e:	00 00 00 
  800420dc91:	be 37 01 00 00       	mov    $0x137,%esi
  800420dc96:	48 bf 81 80 21 04 80 	movabs $0x8004218081,%rdi
  800420dc9d:	00 00 00 
  800420dca0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dca5:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420dcac:	00 00 00 
  800420dcaf:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420dcb2:	e9 6f 01 00 00       	jmpq   800420de26 <debuginfo_rip+0x3ee>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420dcb7:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dcbe:	00 00 00 
  800420dcc1:	48 8b 00             	mov    (%rax),%rax
  800420dcc4:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420dcc8:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420dccf:	be 00 00 00 00       	mov    $0x0,%esi
  800420dcd4:	48 89 c7             	mov    %rax,%rdi
  800420dcd7:	48 b8 a5 0d 21 04 80 	movabs $0x8004210da5,%rax
  800420dcde:	00 00 00 
  800420dce1:	ff d0                	callq  *%rax
  800420dce3:	83 f8 04             	cmp    $0x4,%eax
  800420dce6:	75 05                	jne    800420dced <debuginfo_rip+0x2b5>
			continue;
  800420dce8:	e9 39 01 00 00       	jmpq   800420de26 <debuginfo_rip+0x3ee>

		cudie.cu_header = &cu;
  800420dced:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420dcf1:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420dcf8:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420dcff:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420dd03:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dd0a:	00 00 00 
  800420dd0d:	48 8b 00             	mov    (%rax),%rax
  800420dd10:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420dd17:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420dd1e:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420dd22:	48 89 c7             	mov    %rax,%rdi
  800420dd25:	48 b8 e9 0f 21 04 80 	movabs $0x8004210fe9,%rax
  800420dd2c:	00 00 00 
  800420dd2f:	ff d0                	callq  *%rax
  800420dd31:	83 f8 04             	cmp    $0x4,%eax
  800420dd34:	75 05                	jne    800420dd3b <debuginfo_rip+0x303>
			continue;
  800420dd36:	e9 eb 00 00 00       	jmpq   800420de26 <debuginfo_rip+0x3ee>

		die.cu_header = &cu;
  800420dd3b:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420dd3f:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420dd46:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420dd4d:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420dd54:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420dd5b:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420dd62:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dd69:	48 89 ce             	mov    %rcx,%rsi
  800420dd6c:	48 89 c7             	mov    %rax,%rdi
  800420dd6f:	48 b8 d2 d2 20 04 80 	movabs $0x800420d2d2,%rax
  800420dd76:	00 00 00 
  800420dd79:	ff d0                	callq  *%rax
  800420dd7b:	85 c0                	test   %eax,%eax
  800420dd7d:	74 30                	je     800420ddaf <debuginfo_rip+0x377>
				goto find_done;
  800420dd7f:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420dd80:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dd87:	00 00 00 
  800420dd8a:	48 8b 00             	mov    (%rax),%rax
  800420dd8d:	be 00 00 00 00       	mov    $0x0,%esi
  800420dd92:	48 89 c7             	mov    %rax,%rdi
  800420dd95:	48 b8 c1 36 21 04 80 	movabs $0x80042136c1,%rax
  800420dd9c:	00 00 00 
  800420dd9f:	ff d0                	callq  *%rax
  800420dda1:	83 f8 01             	cmp    $0x1,%eax
  800420dda4:	0f 85 bb 00 00 00    	jne    800420de65 <debuginfo_rip+0x42d>
  800420ddaa:	e9 ac 00 00 00       	jmpq   800420de5b <debuginfo_rip+0x423>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420ddaf:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420ddb6:	00 00 00 
  800420ddb9:	48 8b 00             	mov    (%rax),%rax
  800420ddbc:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420ddc0:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420ddc7:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420ddce:	48 89 c7             	mov    %rax,%rdi
  800420ddd1:	48 b8 a5 0d 21 04 80 	movabs $0x8004210da5,%rax
  800420ddd8:	00 00 00 
  800420dddb:	ff d0                	callq  *%rax
  800420dddd:	85 c0                	test   %eax,%eax
  800420dddf:	79 02                	jns    800420dde3 <debuginfo_rip+0x3ab>
				break; 
  800420dde1:	eb 43                	jmp    800420de26 <debuginfo_rip+0x3ee>
			die = die2;
  800420dde3:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420ddea:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420ddf1:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420ddf6:	48 89 ce             	mov    %rcx,%rsi
  800420ddf9:	48 89 c7             	mov    %rax,%rdi
  800420ddfc:	48 b8 7f ef 20 04 80 	movabs $0x800420ef7f,%rax
  800420de03:	00 00 00 
  800420de06:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420de08:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420de0c:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420de13:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420de1a:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420de21:	e9 2e ff ff ff       	jmpq   800420dd54 <debuginfo_rip+0x31c>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420de26:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420de2d:	00 00 00 
  800420de30:	48 8b 00             	mov    (%rax),%rax
  800420de33:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420de37:	48 89 d6             	mov    %rdx,%rsi
  800420de3a:	48 89 c7             	mov    %rax,%rdi
  800420de3d:	48 b8 ff fc 20 04 80 	movabs $0x800420fcff,%rax
  800420de44:	00 00 00 
  800420de47:	ff d0                	callq  *%rax
  800420de49:	85 c0                	test   %eax,%eax
  800420de4b:	0f 84 66 fe ff ff    	je     800420dcb7 <debuginfo_rip+0x27f>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800420de51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420de56:	e9 a0 00 00 00       	jmpq   800420defb <debuginfo_rip+0x4c3>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420de5b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420de60:	e9 96 00 00 00       	jmpq   800420defb <debuginfo_rip+0x4c3>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420de65:	48 b8 80 b6 22 04 80 	movabs $0x800422b680,%rax
  800420de6c:	00 00 00 
  800420de6f:	48 8b 08             	mov    (%rax),%rcx
  800420de72:	48 b8 78 b6 22 04 80 	movabs $0x800422b678,%rax
  800420de79:	00 00 00 
  800420de7c:	48 8b 10             	mov    (%rax),%rdx
  800420de7f:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420de86:	00 00 00 
  800420de89:	48 8b 00             	mov    (%rax),%rax
  800420de8c:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420de93:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420de99:	48 89 c7             	mov    %rax,%rdi
  800420de9c:	48 b8 2a 12 21 04 80 	movabs $0x800421122a,%rax
  800420dea3:	00 00 00 
  800420dea6:	ff d0                	callq  *%rax
  800420dea8:	85 c0                	test   %eax,%eax
  800420deaa:	75 4a                	jne    800420def6 <debuginfo_rip+0x4be>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420deac:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420deb3:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420deba:	48 b8 78 b6 22 04 80 	movabs $0x800422b678,%rax
  800420dec1:	00 00 00 
  800420dec4:	48 8b 30             	mov    (%rax),%rsi
  800420dec7:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dece:	00 00 00 
  800420ded1:	48 8b 00             	mov    (%rax),%rax
  800420ded4:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420dedb:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420dee1:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420dee7:	48 89 c7             	mov    %rax,%rdi
  800420deea:	48 b8 36 25 21 04 80 	movabs $0x8004212536,%rax
  800420def1:	00 00 00 
  800420def4:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420def6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420defb:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420df02:	5b                   	pop    %rbx
  800420df03:	5d                   	pop    %rbp
  800420df04:	c3                   	retq   

000000800420df05 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420df05:	55                   	push   %rbp
  800420df06:	48 89 e5             	mov    %rsp,%rbp
  800420df09:	53                   	push   %rbx
  800420df0a:	48 83 ec 38          	sub    $0x38,%rsp
  800420df0e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420df12:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420df16:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420df1a:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420df1d:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420df21:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420df25:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420df28:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420df2c:	77 3b                	ja     800420df69 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420df2e:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420df31:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420df35:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420df38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420df3c:	ba 00 00 00 00       	mov    $0x0,%edx
  800420df41:	48 f7 f3             	div    %rbx
  800420df44:	48 89 c2             	mov    %rax,%rdx
  800420df47:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420df4a:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420df4d:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420df51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df55:	41 89 f9             	mov    %edi,%r9d
  800420df58:	48 89 c7             	mov    %rax,%rdi
  800420df5b:	48 b8 05 df 20 04 80 	movabs $0x800420df05,%rax
  800420df62:	00 00 00 
  800420df65:	ff d0                	callq  *%rax
  800420df67:	eb 1e                	jmp    800420df87 <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420df69:	eb 12                	jmp    800420df7d <printnum+0x78>
			putch(padc, putdat);
  800420df6b:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420df6f:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420df72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df76:	48 89 ce             	mov    %rcx,%rsi
  800420df79:	89 d7                	mov    %edx,%edi
  800420df7b:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420df7d:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420df81:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420df85:	7f e4                	jg     800420df6b <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420df87:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420df8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420df8e:	ba 00 00 00 00       	mov    $0x0,%edx
  800420df93:	48 f7 f1             	div    %rcx
  800420df96:	48 89 d0             	mov    %rdx,%rax
  800420df99:	48 ba 10 82 21 04 80 	movabs $0x8004218210,%rdx
  800420dfa0:	00 00 00 
  800420dfa3:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420dfa7:	0f be d0             	movsbl %al,%edx
  800420dfaa:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420dfae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfb2:	48 89 ce             	mov    %rcx,%rsi
  800420dfb5:	89 d7                	mov    %edx,%edi
  800420dfb7:	ff d0                	callq  *%rax
}
  800420dfb9:	48 83 c4 38          	add    $0x38,%rsp
  800420dfbd:	5b                   	pop    %rbx
  800420dfbe:	5d                   	pop    %rbp
  800420dfbf:	c3                   	retq   

000000800420dfc0 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420dfc0:	55                   	push   %rbp
  800420dfc1:	48 89 e5             	mov    %rsp,%rbp
  800420dfc4:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420dfc8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dfcc:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420dfcf:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420dfd3:	7e 52                	jle    800420e027 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420dfd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfd9:	8b 00                	mov    (%rax),%eax
  800420dfdb:	83 f8 30             	cmp    $0x30,%eax
  800420dfde:	73 24                	jae    800420e004 <getuint+0x44>
  800420dfe0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfe4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420dfe8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfec:	8b 00                	mov    (%rax),%eax
  800420dfee:	89 c0                	mov    %eax,%eax
  800420dff0:	48 01 d0             	add    %rdx,%rax
  800420dff3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dff7:	8b 12                	mov    (%rdx),%edx
  800420dff9:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420dffc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e000:	89 0a                	mov    %ecx,(%rdx)
  800420e002:	eb 17                	jmp    800420e01b <getuint+0x5b>
  800420e004:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e008:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e00c:	48 89 d0             	mov    %rdx,%rax
  800420e00f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e013:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e017:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e01b:	48 8b 00             	mov    (%rax),%rax
  800420e01e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e022:	e9 a3 00 00 00       	jmpq   800420e0ca <getuint+0x10a>
	else if (lflag)
  800420e027:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420e02b:	74 4f                	je     800420e07c <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420e02d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e031:	8b 00                	mov    (%rax),%eax
  800420e033:	83 f8 30             	cmp    $0x30,%eax
  800420e036:	73 24                	jae    800420e05c <getuint+0x9c>
  800420e038:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e03c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e040:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e044:	8b 00                	mov    (%rax),%eax
  800420e046:	89 c0                	mov    %eax,%eax
  800420e048:	48 01 d0             	add    %rdx,%rax
  800420e04b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e04f:	8b 12                	mov    (%rdx),%edx
  800420e051:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e054:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e058:	89 0a                	mov    %ecx,(%rdx)
  800420e05a:	eb 17                	jmp    800420e073 <getuint+0xb3>
  800420e05c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e060:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e064:	48 89 d0             	mov    %rdx,%rax
  800420e067:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e06b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e06f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e073:	48 8b 00             	mov    (%rax),%rax
  800420e076:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e07a:	eb 4e                	jmp    800420e0ca <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420e07c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e080:	8b 00                	mov    (%rax),%eax
  800420e082:	83 f8 30             	cmp    $0x30,%eax
  800420e085:	73 24                	jae    800420e0ab <getuint+0xeb>
  800420e087:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e08b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e08f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e093:	8b 00                	mov    (%rax),%eax
  800420e095:	89 c0                	mov    %eax,%eax
  800420e097:	48 01 d0             	add    %rdx,%rax
  800420e09a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e09e:	8b 12                	mov    (%rdx),%edx
  800420e0a0:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e0a3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e0a7:	89 0a                	mov    %ecx,(%rdx)
  800420e0a9:	eb 17                	jmp    800420e0c2 <getuint+0x102>
  800420e0ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0af:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e0b3:	48 89 d0             	mov    %rdx,%rax
  800420e0b6:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e0ba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e0be:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e0c2:	8b 00                	mov    (%rax),%eax
  800420e0c4:	89 c0                	mov    %eax,%eax
  800420e0c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420e0ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e0ce:	c9                   	leaveq 
  800420e0cf:	c3                   	retq   

000000800420e0d0 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420e0d0:	55                   	push   %rbp
  800420e0d1:	48 89 e5             	mov    %rsp,%rbp
  800420e0d4:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420e0d8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e0dc:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420e0df:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420e0e3:	7e 52                	jle    800420e137 <getint+0x67>
		x=va_arg(*ap, long long);
  800420e0e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0e9:	8b 00                	mov    (%rax),%eax
  800420e0eb:	83 f8 30             	cmp    $0x30,%eax
  800420e0ee:	73 24                	jae    800420e114 <getint+0x44>
  800420e0f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0f4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e0f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0fc:	8b 00                	mov    (%rax),%eax
  800420e0fe:	89 c0                	mov    %eax,%eax
  800420e100:	48 01 d0             	add    %rdx,%rax
  800420e103:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e107:	8b 12                	mov    (%rdx),%edx
  800420e109:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e10c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e110:	89 0a                	mov    %ecx,(%rdx)
  800420e112:	eb 17                	jmp    800420e12b <getint+0x5b>
  800420e114:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e118:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e11c:	48 89 d0             	mov    %rdx,%rax
  800420e11f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e123:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e127:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e12b:	48 8b 00             	mov    (%rax),%rax
  800420e12e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e132:	e9 a3 00 00 00       	jmpq   800420e1da <getint+0x10a>
	else if (lflag)
  800420e137:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420e13b:	74 4f                	je     800420e18c <getint+0xbc>
		x=va_arg(*ap, long);
  800420e13d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e141:	8b 00                	mov    (%rax),%eax
  800420e143:	83 f8 30             	cmp    $0x30,%eax
  800420e146:	73 24                	jae    800420e16c <getint+0x9c>
  800420e148:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e14c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e150:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e154:	8b 00                	mov    (%rax),%eax
  800420e156:	89 c0                	mov    %eax,%eax
  800420e158:	48 01 d0             	add    %rdx,%rax
  800420e15b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e15f:	8b 12                	mov    (%rdx),%edx
  800420e161:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e164:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e168:	89 0a                	mov    %ecx,(%rdx)
  800420e16a:	eb 17                	jmp    800420e183 <getint+0xb3>
  800420e16c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e170:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e174:	48 89 d0             	mov    %rdx,%rax
  800420e177:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e17b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e17f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e183:	48 8b 00             	mov    (%rax),%rax
  800420e186:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e18a:	eb 4e                	jmp    800420e1da <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420e18c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e190:	8b 00                	mov    (%rax),%eax
  800420e192:	83 f8 30             	cmp    $0x30,%eax
  800420e195:	73 24                	jae    800420e1bb <getint+0xeb>
  800420e197:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e19b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e19f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1a3:	8b 00                	mov    (%rax),%eax
  800420e1a5:	89 c0                	mov    %eax,%eax
  800420e1a7:	48 01 d0             	add    %rdx,%rax
  800420e1aa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e1ae:	8b 12                	mov    (%rdx),%edx
  800420e1b0:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e1b3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e1b7:	89 0a                	mov    %ecx,(%rdx)
  800420e1b9:	eb 17                	jmp    800420e1d2 <getint+0x102>
  800420e1bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1bf:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e1c3:	48 89 d0             	mov    %rdx,%rax
  800420e1c6:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e1ca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e1ce:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e1d2:	8b 00                	mov    (%rax),%eax
  800420e1d4:	48 98                	cltq   
  800420e1d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420e1da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e1de:	c9                   	leaveq 
  800420e1df:	c3                   	retq   

000000800420e1e0 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420e1e0:	55                   	push   %rbp
  800420e1e1:	48 89 e5             	mov    %rsp,%rbp
  800420e1e4:	41 54                	push   %r12
  800420e1e6:	53                   	push   %rbx
  800420e1e7:	48 83 ec 60          	sub    $0x60,%rsp
  800420e1eb:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420e1ef:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420e1f3:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e1f7:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420e1fb:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e1ff:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420e203:	48 8b 0a             	mov    (%rdx),%rcx
  800420e206:	48 89 08             	mov    %rcx,(%rax)
  800420e209:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e20d:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e211:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e215:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e219:	eb 17                	jmp    800420e232 <vprintfmt+0x52>
			if (ch == '\0')
  800420e21b:	85 db                	test   %ebx,%ebx
  800420e21d:	0f 84 df 04 00 00    	je     800420e702 <vprintfmt+0x522>
				return;
			putch(ch, putdat);
  800420e223:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e227:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e22b:	48 89 d6             	mov    %rdx,%rsi
  800420e22e:	89 df                	mov    %ebx,%edi
  800420e230:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e232:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e236:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e23a:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e23e:	0f b6 00             	movzbl (%rax),%eax
  800420e241:	0f b6 d8             	movzbl %al,%ebx
  800420e244:	83 fb 25             	cmp    $0x25,%ebx
  800420e247:	75 d2                	jne    800420e21b <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420e249:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420e24d:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420e254:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420e25b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420e262:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420e269:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e26d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e271:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e275:	0f b6 00             	movzbl (%rax),%eax
  800420e278:	0f b6 d8             	movzbl %al,%ebx
  800420e27b:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420e27e:	83 f8 55             	cmp    $0x55,%eax
  800420e281:	0f 87 47 04 00 00    	ja     800420e6ce <vprintfmt+0x4ee>
  800420e287:	89 c0                	mov    %eax,%eax
  800420e289:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420e290:	00 
  800420e291:	48 b8 38 82 21 04 80 	movabs $0x8004218238,%rax
  800420e298:	00 00 00 
  800420e29b:	48 01 d0             	add    %rdx,%rax
  800420e29e:	48 8b 00             	mov    (%rax),%rax
  800420e2a1:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420e2a3:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420e2a7:	eb c0                	jmp    800420e269 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420e2a9:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420e2ad:	eb ba                	jmp    800420e269 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420e2af:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420e2b6:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420e2b9:	89 d0                	mov    %edx,%eax
  800420e2bb:	c1 e0 02             	shl    $0x2,%eax
  800420e2be:	01 d0                	add    %edx,%eax
  800420e2c0:	01 c0                	add    %eax,%eax
  800420e2c2:	01 d8                	add    %ebx,%eax
  800420e2c4:	83 e8 30             	sub    $0x30,%eax
  800420e2c7:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420e2ca:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e2ce:	0f b6 00             	movzbl (%rax),%eax
  800420e2d1:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420e2d4:	83 fb 2f             	cmp    $0x2f,%ebx
  800420e2d7:	7e 0c                	jle    800420e2e5 <vprintfmt+0x105>
  800420e2d9:	83 fb 39             	cmp    $0x39,%ebx
  800420e2dc:	7f 07                	jg     800420e2e5 <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420e2de:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420e2e3:	eb d1                	jmp    800420e2b6 <vprintfmt+0xd6>
			goto process_precision;
  800420e2e5:	eb 58                	jmp    800420e33f <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420e2e7:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e2ea:	83 f8 30             	cmp    $0x30,%eax
  800420e2ed:	73 17                	jae    800420e306 <vprintfmt+0x126>
  800420e2ef:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e2f3:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e2f6:	89 c0                	mov    %eax,%eax
  800420e2f8:	48 01 d0             	add    %rdx,%rax
  800420e2fb:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e2fe:	83 c2 08             	add    $0x8,%edx
  800420e301:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e304:	eb 0f                	jmp    800420e315 <vprintfmt+0x135>
  800420e306:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e30a:	48 89 d0             	mov    %rdx,%rax
  800420e30d:	48 83 c2 08          	add    $0x8,%rdx
  800420e311:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e315:	8b 00                	mov    (%rax),%eax
  800420e317:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420e31a:	eb 23                	jmp    800420e33f <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420e31c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e320:	79 0c                	jns    800420e32e <vprintfmt+0x14e>
				width = 0;
  800420e322:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420e329:	e9 3b ff ff ff       	jmpq   800420e269 <vprintfmt+0x89>
  800420e32e:	e9 36 ff ff ff       	jmpq   800420e269 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420e333:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420e33a:	e9 2a ff ff ff       	jmpq   800420e269 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420e33f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e343:	79 12                	jns    800420e357 <vprintfmt+0x177>
				width = precision, precision = -1;
  800420e345:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e348:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420e34b:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420e352:	e9 12 ff ff ff       	jmpq   800420e269 <vprintfmt+0x89>
  800420e357:	e9 0d ff ff ff       	jmpq   800420e269 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420e35c:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420e360:	e9 04 ff ff ff       	jmpq   800420e269 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420e365:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e368:	83 f8 30             	cmp    $0x30,%eax
  800420e36b:	73 17                	jae    800420e384 <vprintfmt+0x1a4>
  800420e36d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e371:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e374:	89 c0                	mov    %eax,%eax
  800420e376:	48 01 d0             	add    %rdx,%rax
  800420e379:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e37c:	83 c2 08             	add    $0x8,%edx
  800420e37f:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e382:	eb 0f                	jmp    800420e393 <vprintfmt+0x1b3>
  800420e384:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e388:	48 89 d0             	mov    %rdx,%rax
  800420e38b:	48 83 c2 08          	add    $0x8,%rdx
  800420e38f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e393:	8b 10                	mov    (%rax),%edx
  800420e395:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420e399:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e39d:	48 89 ce             	mov    %rcx,%rsi
  800420e3a0:	89 d7                	mov    %edx,%edi
  800420e3a2:	ff d0                	callq  *%rax
			break;
  800420e3a4:	e9 53 03 00 00       	jmpq   800420e6fc <vprintfmt+0x51c>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420e3a9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e3ac:	83 f8 30             	cmp    $0x30,%eax
  800420e3af:	73 17                	jae    800420e3c8 <vprintfmt+0x1e8>
  800420e3b1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e3b5:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e3b8:	89 c0                	mov    %eax,%eax
  800420e3ba:	48 01 d0             	add    %rdx,%rax
  800420e3bd:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e3c0:	83 c2 08             	add    $0x8,%edx
  800420e3c3:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e3c6:	eb 0f                	jmp    800420e3d7 <vprintfmt+0x1f7>
  800420e3c8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e3cc:	48 89 d0             	mov    %rdx,%rax
  800420e3cf:	48 83 c2 08          	add    $0x8,%rdx
  800420e3d3:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e3d7:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420e3d9:	85 db                	test   %ebx,%ebx
  800420e3db:	79 02                	jns    800420e3df <vprintfmt+0x1ff>
				err = -err;
  800420e3dd:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420e3df:	83 fb 15             	cmp    $0x15,%ebx
  800420e3e2:	7f 16                	jg     800420e3fa <vprintfmt+0x21a>
  800420e3e4:	48 b8 60 81 21 04 80 	movabs $0x8004218160,%rax
  800420e3eb:	00 00 00 
  800420e3ee:	48 63 d3             	movslq %ebx,%rdx
  800420e3f1:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420e3f5:	4d 85 e4             	test   %r12,%r12
  800420e3f8:	75 2e                	jne    800420e428 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420e3fa:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e3fe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e402:	89 d9                	mov    %ebx,%ecx
  800420e404:	48 ba 21 82 21 04 80 	movabs $0x8004218221,%rdx
  800420e40b:	00 00 00 
  800420e40e:	48 89 c7             	mov    %rax,%rdi
  800420e411:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e416:	49 b8 0b e7 20 04 80 	movabs $0x800420e70b,%r8
  800420e41d:	00 00 00 
  800420e420:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420e423:	e9 d4 02 00 00       	jmpq   800420e6fc <vprintfmt+0x51c>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420e428:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e42c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e430:	4c 89 e1             	mov    %r12,%rcx
  800420e433:	48 ba 2a 82 21 04 80 	movabs $0x800421822a,%rdx
  800420e43a:	00 00 00 
  800420e43d:	48 89 c7             	mov    %rax,%rdi
  800420e440:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e445:	49 b8 0b e7 20 04 80 	movabs $0x800420e70b,%r8
  800420e44c:	00 00 00 
  800420e44f:	41 ff d0             	callq  *%r8
			break;
  800420e452:	e9 a5 02 00 00       	jmpq   800420e6fc <vprintfmt+0x51c>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420e457:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e45a:	83 f8 30             	cmp    $0x30,%eax
  800420e45d:	73 17                	jae    800420e476 <vprintfmt+0x296>
  800420e45f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e463:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e466:	89 c0                	mov    %eax,%eax
  800420e468:	48 01 d0             	add    %rdx,%rax
  800420e46b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e46e:	83 c2 08             	add    $0x8,%edx
  800420e471:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e474:	eb 0f                	jmp    800420e485 <vprintfmt+0x2a5>
  800420e476:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e47a:	48 89 d0             	mov    %rdx,%rax
  800420e47d:	48 83 c2 08          	add    $0x8,%rdx
  800420e481:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e485:	4c 8b 20             	mov    (%rax),%r12
  800420e488:	4d 85 e4             	test   %r12,%r12
  800420e48b:	75 0a                	jne    800420e497 <vprintfmt+0x2b7>
				p = "(null)";
  800420e48d:	49 bc 2d 82 21 04 80 	movabs $0x800421822d,%r12
  800420e494:	00 00 00 
			if (width > 0 && padc != '-')
  800420e497:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e49b:	7e 3f                	jle    800420e4dc <vprintfmt+0x2fc>
  800420e49d:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420e4a1:	74 39                	je     800420e4dc <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420e4a3:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e4a6:	48 98                	cltq   
  800420e4a8:	48 89 c6             	mov    %rax,%rsi
  800420e4ab:	4c 89 e7             	mov    %r12,%rdi
  800420e4ae:	48 b8 06 eb 20 04 80 	movabs $0x800420eb06,%rax
  800420e4b5:	00 00 00 
  800420e4b8:	ff d0                	callq  *%rax
  800420e4ba:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420e4bd:	eb 17                	jmp    800420e4d6 <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420e4bf:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420e4c3:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420e4c7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e4cb:	48 89 ce             	mov    %rcx,%rsi
  800420e4ce:	89 d7                	mov    %edx,%edi
  800420e4d0:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420e4d2:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e4d6:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e4da:	7f e3                	jg     800420e4bf <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420e4dc:	eb 37                	jmp    800420e515 <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420e4de:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420e4e2:	74 1e                	je     800420e502 <vprintfmt+0x322>
  800420e4e4:	83 fb 1f             	cmp    $0x1f,%ebx
  800420e4e7:	7e 05                	jle    800420e4ee <vprintfmt+0x30e>
  800420e4e9:	83 fb 7e             	cmp    $0x7e,%ebx
  800420e4ec:	7e 14                	jle    800420e502 <vprintfmt+0x322>
					putch('?', putdat);
  800420e4ee:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e4f2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e4f6:	48 89 d6             	mov    %rdx,%rsi
  800420e4f9:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420e4fe:	ff d0                	callq  *%rax
  800420e500:	eb 0f                	jmp    800420e511 <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420e502:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e506:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e50a:	48 89 d6             	mov    %rdx,%rsi
  800420e50d:	89 df                	mov    %ebx,%edi
  800420e50f:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420e511:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e515:	4c 89 e0             	mov    %r12,%rax
  800420e518:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420e51c:	0f b6 00             	movzbl (%rax),%eax
  800420e51f:	0f be d8             	movsbl %al,%ebx
  800420e522:	85 db                	test   %ebx,%ebx
  800420e524:	74 10                	je     800420e536 <vprintfmt+0x356>
  800420e526:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e52a:	78 b2                	js     800420e4de <vprintfmt+0x2fe>
  800420e52c:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420e530:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e534:	79 a8                	jns    800420e4de <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e536:	eb 16                	jmp    800420e54e <vprintfmt+0x36e>
				putch(' ', putdat);
  800420e538:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e53c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e540:	48 89 d6             	mov    %rdx,%rsi
  800420e543:	bf 20 00 00 00       	mov    $0x20,%edi
  800420e548:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e54a:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e54e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e552:	7f e4                	jg     800420e538 <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420e554:	e9 a3 01 00 00       	jmpq   800420e6fc <vprintfmt+0x51c>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420e559:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e55d:	be 03 00 00 00       	mov    $0x3,%esi
  800420e562:	48 89 c7             	mov    %rax,%rdi
  800420e565:	48 b8 d0 e0 20 04 80 	movabs $0x800420e0d0,%rax
  800420e56c:	00 00 00 
  800420e56f:	ff d0                	callq  *%rax
  800420e571:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420e575:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e579:	48 85 c0             	test   %rax,%rax
  800420e57c:	79 1d                	jns    800420e59b <vprintfmt+0x3bb>
				putch('-', putdat);
  800420e57e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e582:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e586:	48 89 d6             	mov    %rdx,%rsi
  800420e589:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420e58e:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420e590:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e594:	48 f7 d8             	neg    %rax
  800420e597:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420e59b:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e5a2:	e9 e8 00 00 00       	jmpq   800420e68f <vprintfmt+0x4af>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420e5a7:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e5ab:	be 03 00 00 00       	mov    $0x3,%esi
  800420e5b0:	48 89 c7             	mov    %rax,%rdi
  800420e5b3:	48 b8 c0 df 20 04 80 	movabs $0x800420dfc0,%rax
  800420e5ba:	00 00 00 
  800420e5bd:	ff d0                	callq  *%rax
  800420e5bf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420e5c3:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e5ca:	e9 c0 00 00 00       	jmpq   800420e68f <vprintfmt+0x4af>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
  800420e5cf:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e5d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e5d7:	48 89 d6             	mov    %rdx,%rsi
  800420e5da:	bf 58 00 00 00       	mov    $0x58,%edi
  800420e5df:	ff d0                	callq  *%rax
			putch('X', putdat);
  800420e5e1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e5e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e5e9:	48 89 d6             	mov    %rdx,%rsi
  800420e5ec:	bf 58 00 00 00       	mov    $0x58,%edi
  800420e5f1:	ff d0                	callq  *%rax
			putch('X', putdat);
  800420e5f3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e5f7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e5fb:	48 89 d6             	mov    %rdx,%rsi
  800420e5fe:	bf 58 00 00 00       	mov    $0x58,%edi
  800420e603:	ff d0                	callq  *%rax
			break;
  800420e605:	e9 f2 00 00 00       	jmpq   800420e6fc <vprintfmt+0x51c>

			// pointer
		case 'p':
			putch('0', putdat);
  800420e60a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e60e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e612:	48 89 d6             	mov    %rdx,%rsi
  800420e615:	bf 30 00 00 00       	mov    $0x30,%edi
  800420e61a:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420e61c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e620:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e624:	48 89 d6             	mov    %rdx,%rsi
  800420e627:	bf 78 00 00 00       	mov    $0x78,%edi
  800420e62c:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420e62e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e631:	83 f8 30             	cmp    $0x30,%eax
  800420e634:	73 17                	jae    800420e64d <vprintfmt+0x46d>
  800420e636:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e63a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e63d:	89 c0                	mov    %eax,%eax
  800420e63f:	48 01 d0             	add    %rdx,%rax
  800420e642:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e645:	83 c2 08             	add    $0x8,%edx
  800420e648:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e64b:	eb 0f                	jmp    800420e65c <vprintfmt+0x47c>
				(uintptr_t) va_arg(aq, void *);
  800420e64d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e651:	48 89 d0             	mov    %rdx,%rax
  800420e654:	48 83 c2 08          	add    $0x8,%rdx
  800420e658:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e65c:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e65f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420e663:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420e66a:	eb 23                	jmp    800420e68f <vprintfmt+0x4af>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420e66c:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e670:	be 03 00 00 00       	mov    $0x3,%esi
  800420e675:	48 89 c7             	mov    %rax,%rdi
  800420e678:	48 b8 c0 df 20 04 80 	movabs $0x800420dfc0,%rax
  800420e67f:	00 00 00 
  800420e682:	ff d0                	callq  *%rax
  800420e684:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420e688:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420e68f:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420e694:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420e697:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420e69a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e69e:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e6a2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e6a6:	45 89 c1             	mov    %r8d,%r9d
  800420e6a9:	41 89 f8             	mov    %edi,%r8d
  800420e6ac:	48 89 c7             	mov    %rax,%rdi
  800420e6af:	48 b8 05 df 20 04 80 	movabs $0x800420df05,%rax
  800420e6b6:	00 00 00 
  800420e6b9:	ff d0                	callq  *%rax
			break;
  800420e6bb:	eb 3f                	jmp    800420e6fc <vprintfmt+0x51c>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420e6bd:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e6c1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e6c5:	48 89 d6             	mov    %rdx,%rsi
  800420e6c8:	89 df                	mov    %ebx,%edi
  800420e6ca:	ff d0                	callq  *%rax
			break;
  800420e6cc:	eb 2e                	jmp    800420e6fc <vprintfmt+0x51c>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420e6ce:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e6d2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e6d6:	48 89 d6             	mov    %rdx,%rsi
  800420e6d9:	bf 25 00 00 00       	mov    $0x25,%edi
  800420e6de:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420e6e0:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e6e5:	eb 05                	jmp    800420e6ec <vprintfmt+0x50c>
  800420e6e7:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e6ec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e6f0:	48 83 e8 01          	sub    $0x1,%rax
  800420e6f4:	0f b6 00             	movzbl (%rax),%eax
  800420e6f7:	3c 25                	cmp    $0x25,%al
  800420e6f9:	75 ec                	jne    800420e6e7 <vprintfmt+0x507>
				/* do nothing */;
			break;
  800420e6fb:	90                   	nop
		}
	}
  800420e6fc:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e6fd:	e9 30 fb ff ff       	jmpq   800420e232 <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420e702:	48 83 c4 60          	add    $0x60,%rsp
  800420e706:	5b                   	pop    %rbx
  800420e707:	41 5c                	pop    %r12
  800420e709:	5d                   	pop    %rbp
  800420e70a:	c3                   	retq   

000000800420e70b <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420e70b:	55                   	push   %rbp
  800420e70c:	48 89 e5             	mov    %rsp,%rbp
  800420e70f:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420e716:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420e71d:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420e724:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e72b:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e732:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e739:	84 c0                	test   %al,%al
  800420e73b:	74 20                	je     800420e75d <printfmt+0x52>
  800420e73d:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e741:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e745:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e749:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e74d:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e751:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e755:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e759:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e75d:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420e764:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420e76b:	00 00 00 
  800420e76e:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420e775:	00 00 00 
  800420e778:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e77c:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420e783:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e78a:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420e791:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420e798:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420e79f:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420e7a6:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420e7ad:	48 89 c7             	mov    %rax,%rdi
  800420e7b0:	48 b8 e0 e1 20 04 80 	movabs $0x800420e1e0,%rax
  800420e7b7:	00 00 00 
  800420e7ba:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420e7bc:	c9                   	leaveq 
  800420e7bd:	c3                   	retq   

000000800420e7be <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420e7be:	55                   	push   %rbp
  800420e7bf:	48 89 e5             	mov    %rsp,%rbp
  800420e7c2:	48 83 ec 10          	sub    $0x10,%rsp
  800420e7c6:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420e7c9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420e7cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7d1:	8b 40 10             	mov    0x10(%rax),%eax
  800420e7d4:	8d 50 01             	lea    0x1(%rax),%edx
  800420e7d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7db:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420e7de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7e2:	48 8b 10             	mov    (%rax),%rdx
  800420e7e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e7ed:	48 39 c2             	cmp    %rax,%rdx
  800420e7f0:	73 17                	jae    800420e809 <sprintputch+0x4b>
		*b->buf++ = ch;
  800420e7f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7f6:	48 8b 00             	mov    (%rax),%rax
  800420e7f9:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420e7fd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e801:	48 89 0a             	mov    %rcx,(%rdx)
  800420e804:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420e807:	88 10                	mov    %dl,(%rax)
}
  800420e809:	c9                   	leaveq 
  800420e80a:	c3                   	retq   

000000800420e80b <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420e80b:	55                   	push   %rbp
  800420e80c:	48 89 e5             	mov    %rsp,%rbp
  800420e80f:	48 83 ec 50          	sub    $0x50,%rsp
  800420e813:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420e817:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420e81a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420e81e:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420e822:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420e826:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e82a:	48 8b 0a             	mov    (%rdx),%rcx
  800420e82d:	48 89 08             	mov    %rcx,(%rax)
  800420e830:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e834:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e838:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e83c:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420e840:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e844:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420e848:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420e84b:	48 98                	cltq   
  800420e84d:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420e851:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e855:	48 01 d0             	add    %rdx,%rax
  800420e858:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420e85c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420e863:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e868:	74 06                	je     800420e870 <vsnprintf+0x65>
  800420e86a:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420e86e:	7f 07                	jg     800420e877 <vsnprintf+0x6c>
		return -E_INVAL;
  800420e870:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e875:	eb 2f                	jmp    800420e8a6 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420e877:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e87b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e87f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420e883:	48 89 c6             	mov    %rax,%rsi
  800420e886:	48 bf be e7 20 04 80 	movabs $0x800420e7be,%rdi
  800420e88d:	00 00 00 
  800420e890:	48 b8 e0 e1 20 04 80 	movabs $0x800420e1e0,%rax
  800420e897:	00 00 00 
  800420e89a:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420e89c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e8a0:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420e8a3:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420e8a6:	c9                   	leaveq 
  800420e8a7:	c3                   	retq   

000000800420e8a8 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420e8a8:	55                   	push   %rbp
  800420e8a9:	48 89 e5             	mov    %rsp,%rbp
  800420e8ac:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420e8b3:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420e8ba:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420e8c0:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e8c7:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e8ce:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e8d5:	84 c0                	test   %al,%al
  800420e8d7:	74 20                	je     800420e8f9 <snprintf+0x51>
  800420e8d9:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e8dd:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e8e1:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e8e5:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e8e9:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e8ed:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e8f1:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e8f5:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e8f9:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420e900:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420e907:	00 00 00 
  800420e90a:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420e911:	00 00 00 
  800420e914:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e918:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420e91f:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e926:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420e92d:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420e934:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420e93b:	48 8b 0a             	mov    (%rdx),%rcx
  800420e93e:	48 89 08             	mov    %rcx,(%rax)
  800420e941:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e945:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e949:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e94d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420e951:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420e958:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420e95f:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420e965:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420e96c:	48 89 c7             	mov    %rax,%rdi
  800420e96f:	48 b8 0b e8 20 04 80 	movabs $0x800420e80b,%rax
  800420e976:	00 00 00 
  800420e979:	ff d0                	callq  *%rax
  800420e97b:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420e981:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420e987:	c9                   	leaveq 
  800420e988:	c3                   	retq   

000000800420e989 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420e989:	55                   	push   %rbp
  800420e98a:	48 89 e5             	mov    %rsp,%rbp
  800420e98d:	48 83 ec 20          	sub    $0x20,%rsp
  800420e991:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

	if (prompt != NULL)
  800420e995:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e99a:	74 22                	je     800420e9be <readline+0x35>
		cprintf("%s", prompt);
  800420e99c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9a0:	48 89 c6             	mov    %rax,%rsi
  800420e9a3:	48 bf e8 84 21 04 80 	movabs $0x80042184e8,%rdi
  800420e9aa:	00 00 00 
  800420e9ad:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e9b2:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420e9b9:	00 00 00 
  800420e9bc:	ff d2                	callq  *%rdx

	i = 0;
  800420e9be:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420e9c5:	bf 00 00 00 00       	mov    $0x0,%edi
  800420e9ca:	48 b8 bd 11 20 04 80 	movabs $0x80042011bd,%rax
  800420e9d1:	00 00 00 
  800420e9d4:	ff d0                	callq  *%rax
  800420e9d6:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420e9d9:	48 b8 9b 11 20 04 80 	movabs $0x800420119b,%rax
  800420e9e0:	00 00 00 
  800420e9e3:	ff d0                	callq  *%rax
  800420e9e5:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420e9e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420e9ec:	79 2a                	jns    800420ea18 <readline+0x8f>
			cprintf("read error: %e\n", c);
  800420e9ee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e9f1:	89 c6                	mov    %eax,%esi
  800420e9f3:	48 bf eb 84 21 04 80 	movabs $0x80042184eb,%rdi
  800420e9fa:	00 00 00 
  800420e9fd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea02:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800420ea09:	00 00 00 
  800420ea0c:	ff d2                	callq  *%rdx
			return NULL;
  800420ea0e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea13:	e9 be 00 00 00       	jmpq   800420ead6 <readline+0x14d>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420ea18:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420ea1c:	74 06                	je     800420ea24 <readline+0x9b>
  800420ea1e:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420ea22:	75 26                	jne    800420ea4a <readline+0xc1>
  800420ea24:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ea28:	7e 20                	jle    800420ea4a <readline+0xc1>
			if (echoing)
  800420ea2a:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420ea2e:	74 11                	je     800420ea41 <readline+0xb8>
				cputchar('\b');
  800420ea30:	bf 08 00 00 00       	mov    $0x8,%edi
  800420ea35:	48 b8 7d 11 20 04 80 	movabs $0x800420117d,%rax
  800420ea3c:	00 00 00 
  800420ea3f:	ff d0                	callq  *%rax
			i--;
  800420ea41:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420ea45:	e9 87 00 00 00       	jmpq   800420ead1 <readline+0x148>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420ea4a:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420ea4e:	7e 3f                	jle    800420ea8f <readline+0x106>
  800420ea50:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420ea57:	7f 36                	jg     800420ea8f <readline+0x106>
			if (echoing)
  800420ea59:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420ea5d:	74 11                	je     800420ea70 <readline+0xe7>
				cputchar(c);
  800420ea5f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ea62:	89 c7                	mov    %eax,%edi
  800420ea64:	48 b8 7d 11 20 04 80 	movabs $0x800420117d,%rax
  800420ea6b:	00 00 00 
  800420ea6e:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420ea70:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ea73:	8d 50 01             	lea    0x1(%rax),%edx
  800420ea76:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420ea79:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420ea7c:	89 d1                	mov    %edx,%ecx
  800420ea7e:	48 ba a0 42 3d 04 80 	movabs $0x80043d42a0,%rdx
  800420ea85:	00 00 00 
  800420ea88:	48 98                	cltq   
  800420ea8a:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420ea8d:	eb 42                	jmp    800420ead1 <readline+0x148>
		} else if (c == '\n' || c == '\r') {
  800420ea8f:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420ea93:	74 06                	je     800420ea9b <readline+0x112>
  800420ea95:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420ea99:	75 36                	jne    800420ead1 <readline+0x148>
			if (echoing)
  800420ea9b:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420ea9f:	74 11                	je     800420eab2 <readline+0x129>
				cputchar('\n');
  800420eaa1:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420eaa6:	48 b8 7d 11 20 04 80 	movabs $0x800420117d,%rax
  800420eaad:	00 00 00 
  800420eab0:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420eab2:	48 ba a0 42 3d 04 80 	movabs $0x80043d42a0,%rdx
  800420eab9:	00 00 00 
  800420eabc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420eabf:	48 98                	cltq   
  800420eac1:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420eac5:	48 b8 a0 42 3d 04 80 	movabs $0x80043d42a0,%rax
  800420eacc:	00 00 00 
  800420eacf:	eb 05                	jmp    800420ead6 <readline+0x14d>
		}
	}
  800420ead1:	e9 03 ff ff ff       	jmpq   800420e9d9 <readline+0x50>
}
  800420ead6:	c9                   	leaveq 
  800420ead7:	c3                   	retq   

000000800420ead8 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420ead8:	55                   	push   %rbp
  800420ead9:	48 89 e5             	mov    %rsp,%rbp
  800420eadc:	48 83 ec 18          	sub    $0x18,%rsp
  800420eae0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420eae4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420eaeb:	eb 09                	jmp    800420eaf6 <strlen+0x1e>
		n++;
  800420eaed:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420eaf1:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420eaf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eafa:	0f b6 00             	movzbl (%rax),%eax
  800420eafd:	84 c0                	test   %al,%al
  800420eaff:	75 ec                	jne    800420eaed <strlen+0x15>
		n++;
	return n;
  800420eb01:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420eb04:	c9                   	leaveq 
  800420eb05:	c3                   	retq   

000000800420eb06 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420eb06:	55                   	push   %rbp
  800420eb07:	48 89 e5             	mov    %rsp,%rbp
  800420eb0a:	48 83 ec 20          	sub    $0x20,%rsp
  800420eb0e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eb12:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420eb16:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420eb1d:	eb 0e                	jmp    800420eb2d <strnlen+0x27>
		n++;
  800420eb1f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420eb23:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420eb28:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420eb2d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420eb32:	74 0b                	je     800420eb3f <strnlen+0x39>
  800420eb34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb38:	0f b6 00             	movzbl (%rax),%eax
  800420eb3b:	84 c0                	test   %al,%al
  800420eb3d:	75 e0                	jne    800420eb1f <strnlen+0x19>
		n++;
	return n;
  800420eb3f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420eb42:	c9                   	leaveq 
  800420eb43:	c3                   	retq   

000000800420eb44 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420eb44:	55                   	push   %rbp
  800420eb45:	48 89 e5             	mov    %rsp,%rbp
  800420eb48:	48 83 ec 20          	sub    $0x20,%rsp
  800420eb4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eb50:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420eb54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb58:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420eb5c:	90                   	nop
  800420eb5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb61:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420eb65:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420eb69:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420eb6d:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420eb71:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420eb75:	0f b6 12             	movzbl (%rdx),%edx
  800420eb78:	88 10                	mov    %dl,(%rax)
  800420eb7a:	0f b6 00             	movzbl (%rax),%eax
  800420eb7d:	84 c0                	test   %al,%al
  800420eb7f:	75 dc                	jne    800420eb5d <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420eb81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420eb85:	c9                   	leaveq 
  800420eb86:	c3                   	retq   

000000800420eb87 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420eb87:	55                   	push   %rbp
  800420eb88:	48 89 e5             	mov    %rsp,%rbp
  800420eb8b:	48 83 ec 20          	sub    $0x20,%rsp
  800420eb8f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eb93:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420eb97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb9b:	48 89 c7             	mov    %rax,%rdi
  800420eb9e:	48 b8 d8 ea 20 04 80 	movabs $0x800420ead8,%rax
  800420eba5:	00 00 00 
  800420eba8:	ff d0                	callq  *%rax
  800420ebaa:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420ebad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ebb0:	48 63 d0             	movslq %eax,%rdx
  800420ebb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebb7:	48 01 c2             	add    %rax,%rdx
  800420ebba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ebbe:	48 89 c6             	mov    %rax,%rsi
  800420ebc1:	48 89 d7             	mov    %rdx,%rdi
  800420ebc4:	48 b8 44 eb 20 04 80 	movabs $0x800420eb44,%rax
  800420ebcb:	00 00 00 
  800420ebce:	ff d0                	callq  *%rax
	return dst;
  800420ebd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420ebd4:	c9                   	leaveq 
  800420ebd5:	c3                   	retq   

000000800420ebd6 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420ebd6:	55                   	push   %rbp
  800420ebd7:	48 89 e5             	mov    %rsp,%rbp
  800420ebda:	48 83 ec 28          	sub    $0x28,%rsp
  800420ebde:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ebe2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ebe6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420ebea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebee:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420ebf2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ebf9:	00 
  800420ebfa:	eb 2a                	jmp    800420ec26 <strncpy+0x50>
		*dst++ = *src;
  800420ebfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec00:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ec04:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ec08:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ec0c:	0f b6 12             	movzbl (%rdx),%edx
  800420ec0f:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420ec11:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ec15:	0f b6 00             	movzbl (%rax),%eax
  800420ec18:	84 c0                	test   %al,%al
  800420ec1a:	74 05                	je     800420ec21 <strncpy+0x4b>
			src++;
  800420ec1c:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420ec21:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ec26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec2a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420ec2e:	72 cc                	jb     800420ebfc <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420ec30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420ec34:	c9                   	leaveq 
  800420ec35:	c3                   	retq   

000000800420ec36 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420ec36:	55                   	push   %rbp
  800420ec37:	48 89 e5             	mov    %rsp,%rbp
  800420ec3a:	48 83 ec 28          	sub    $0x28,%rsp
  800420ec3e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ec42:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ec46:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420ec4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec4e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420ec52:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420ec57:	74 3d                	je     800420ec96 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420ec59:	eb 1d                	jmp    800420ec78 <strlcpy+0x42>
			*dst++ = *src++;
  800420ec5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec5f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ec63:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ec67:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ec6b:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420ec6f:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420ec73:	0f b6 12             	movzbl (%rdx),%edx
  800420ec76:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420ec78:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420ec7d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420ec82:	74 0b                	je     800420ec8f <strlcpy+0x59>
  800420ec84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ec88:	0f b6 00             	movzbl (%rax),%eax
  800420ec8b:	84 c0                	test   %al,%al
  800420ec8d:	75 cc                	jne    800420ec5b <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420ec8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec93:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420ec96:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec9e:	48 29 c2             	sub    %rax,%rdx
  800420eca1:	48 89 d0             	mov    %rdx,%rax
}
  800420eca4:	c9                   	leaveq 
  800420eca5:	c3                   	retq   

000000800420eca6 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420eca6:	55                   	push   %rbp
  800420eca7:	48 89 e5             	mov    %rsp,%rbp
  800420ecaa:	48 83 ec 10          	sub    $0x10,%rsp
  800420ecae:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ecb2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420ecb6:	eb 0a                	jmp    800420ecc2 <strcmp+0x1c>
		p++, q++;
  800420ecb8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ecbd:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420ecc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ecc6:	0f b6 00             	movzbl (%rax),%eax
  800420ecc9:	84 c0                	test   %al,%al
  800420eccb:	74 12                	je     800420ecdf <strcmp+0x39>
  800420eccd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ecd1:	0f b6 10             	movzbl (%rax),%edx
  800420ecd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ecd8:	0f b6 00             	movzbl (%rax),%eax
  800420ecdb:	38 c2                	cmp    %al,%dl
  800420ecdd:	74 d9                	je     800420ecb8 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420ecdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ece3:	0f b6 00             	movzbl (%rax),%eax
  800420ece6:	0f b6 d0             	movzbl %al,%edx
  800420ece9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eced:	0f b6 00             	movzbl (%rax),%eax
  800420ecf0:	0f b6 c0             	movzbl %al,%eax
  800420ecf3:	29 c2                	sub    %eax,%edx
  800420ecf5:	89 d0                	mov    %edx,%eax
}
  800420ecf7:	c9                   	leaveq 
  800420ecf8:	c3                   	retq   

000000800420ecf9 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420ecf9:	55                   	push   %rbp
  800420ecfa:	48 89 e5             	mov    %rsp,%rbp
  800420ecfd:	48 83 ec 18          	sub    $0x18,%rsp
  800420ed01:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ed05:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420ed09:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420ed0d:	eb 0f                	jmp    800420ed1e <strncmp+0x25>
		n--, p++, q++;
  800420ed0f:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420ed14:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ed19:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420ed1e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ed23:	74 1d                	je     800420ed42 <strncmp+0x49>
  800420ed25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed29:	0f b6 00             	movzbl (%rax),%eax
  800420ed2c:	84 c0                	test   %al,%al
  800420ed2e:	74 12                	je     800420ed42 <strncmp+0x49>
  800420ed30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed34:	0f b6 10             	movzbl (%rax),%edx
  800420ed37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed3b:	0f b6 00             	movzbl (%rax),%eax
  800420ed3e:	38 c2                	cmp    %al,%dl
  800420ed40:	74 cd                	je     800420ed0f <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420ed42:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ed47:	75 07                	jne    800420ed50 <strncmp+0x57>
		return 0;
  800420ed49:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ed4e:	eb 18                	jmp    800420ed68 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420ed50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed54:	0f b6 00             	movzbl (%rax),%eax
  800420ed57:	0f b6 d0             	movzbl %al,%edx
  800420ed5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed5e:	0f b6 00             	movzbl (%rax),%eax
  800420ed61:	0f b6 c0             	movzbl %al,%eax
  800420ed64:	29 c2                	sub    %eax,%edx
  800420ed66:	89 d0                	mov    %edx,%eax
}
  800420ed68:	c9                   	leaveq 
  800420ed69:	c3                   	retq   

000000800420ed6a <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420ed6a:	55                   	push   %rbp
  800420ed6b:	48 89 e5             	mov    %rsp,%rbp
  800420ed6e:	48 83 ec 0c          	sub    $0xc,%rsp
  800420ed72:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ed76:	89 f0                	mov    %esi,%eax
  800420ed78:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420ed7b:	eb 17                	jmp    800420ed94 <strchr+0x2a>
		if (*s == c)
  800420ed7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed81:	0f b6 00             	movzbl (%rax),%eax
  800420ed84:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420ed87:	75 06                	jne    800420ed8f <strchr+0x25>
			return (char *) s;
  800420ed89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed8d:	eb 15                	jmp    800420eda4 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420ed8f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ed94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed98:	0f b6 00             	movzbl (%rax),%eax
  800420ed9b:	84 c0                	test   %al,%al
  800420ed9d:	75 de                	jne    800420ed7d <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420ed9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420eda4:	c9                   	leaveq 
  800420eda5:	c3                   	retq   

000000800420eda6 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420eda6:	55                   	push   %rbp
  800420eda7:	48 89 e5             	mov    %rsp,%rbp
  800420edaa:	48 83 ec 0c          	sub    $0xc,%rsp
  800420edae:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420edb2:	89 f0                	mov    %esi,%eax
  800420edb4:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420edb7:	eb 13                	jmp    800420edcc <strfind+0x26>
		if (*s == c)
  800420edb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420edbd:	0f b6 00             	movzbl (%rax),%eax
  800420edc0:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420edc3:	75 02                	jne    800420edc7 <strfind+0x21>
			break;
  800420edc5:	eb 10                	jmp    800420edd7 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420edc7:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420edcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420edd0:	0f b6 00             	movzbl (%rax),%eax
  800420edd3:	84 c0                	test   %al,%al
  800420edd5:	75 e2                	jne    800420edb9 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420edd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420eddb:	c9                   	leaveq 
  800420eddc:	c3                   	retq   

000000800420eddd <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420eddd:	55                   	push   %rbp
  800420edde:	48 89 e5             	mov    %rsp,%rbp
  800420ede1:	48 83 ec 18          	sub    $0x18,%rsp
  800420ede5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ede9:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420edec:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420edf0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420edf5:	75 06                	jne    800420edfd <memset+0x20>
		return v;
  800420edf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420edfb:	eb 69                	jmp    800420ee66 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420edfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee01:	83 e0 03             	and    $0x3,%eax
  800420ee04:	48 85 c0             	test   %rax,%rax
  800420ee07:	75 48                	jne    800420ee51 <memset+0x74>
  800420ee09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee0d:	83 e0 03             	and    $0x3,%eax
  800420ee10:	48 85 c0             	test   %rax,%rax
  800420ee13:	75 3c                	jne    800420ee51 <memset+0x74>
		c &= 0xFF;
  800420ee15:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420ee1c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ee1f:	c1 e0 18             	shl    $0x18,%eax
  800420ee22:	89 c2                	mov    %eax,%edx
  800420ee24:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ee27:	c1 e0 10             	shl    $0x10,%eax
  800420ee2a:	09 c2                	or     %eax,%edx
  800420ee2c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ee2f:	c1 e0 08             	shl    $0x8,%eax
  800420ee32:	09 d0                	or     %edx,%eax
  800420ee34:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420ee37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee3b:	48 c1 e8 02          	shr    $0x2,%rax
  800420ee3f:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420ee42:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ee46:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ee49:	48 89 d7             	mov    %rdx,%rdi
  800420ee4c:	fc                   	cld    
  800420ee4d:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420ee4f:	eb 11                	jmp    800420ee62 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420ee51:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ee55:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ee58:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ee5c:	48 89 d7             	mov    %rdx,%rdi
  800420ee5f:	fc                   	cld    
  800420ee60:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420ee62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ee66:	c9                   	leaveq 
  800420ee67:	c3                   	retq   

000000800420ee68 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420ee68:	55                   	push   %rbp
  800420ee69:	48 89 e5             	mov    %rsp,%rbp
  800420ee6c:	48 83 ec 28          	sub    $0x28,%rsp
  800420ee70:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ee74:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ee78:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420ee7c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ee80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420ee84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee88:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420ee8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee90:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420ee94:	0f 83 88 00 00 00    	jae    800420ef22 <memmove+0xba>
  800420ee9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ee9e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420eea2:	48 01 d0             	add    %rdx,%rax
  800420eea5:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420eea9:	76 77                	jbe    800420ef22 <memmove+0xba>
		s += n;
  800420eeab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eeaf:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420eeb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eeb7:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420eebb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eebf:	83 e0 03             	and    $0x3,%eax
  800420eec2:	48 85 c0             	test   %rax,%rax
  800420eec5:	75 3b                	jne    800420ef02 <memmove+0x9a>
  800420eec7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eecb:	83 e0 03             	and    $0x3,%eax
  800420eece:	48 85 c0             	test   %rax,%rax
  800420eed1:	75 2f                	jne    800420ef02 <memmove+0x9a>
  800420eed3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eed7:	83 e0 03             	and    $0x3,%eax
  800420eeda:	48 85 c0             	test   %rax,%rax
  800420eedd:	75 23                	jne    800420ef02 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420eedf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eee3:	48 83 e8 04          	sub    $0x4,%rax
  800420eee7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420eeeb:	48 83 ea 04          	sub    $0x4,%rdx
  800420eeef:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420eef3:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420eef7:	48 89 c7             	mov    %rax,%rdi
  800420eefa:	48 89 d6             	mov    %rdx,%rsi
  800420eefd:	fd                   	std    
  800420eefe:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420ef00:	eb 1d                	jmp    800420ef1f <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420ef02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef06:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420ef0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef0e:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420ef12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef16:	48 89 d7             	mov    %rdx,%rdi
  800420ef19:	48 89 c1             	mov    %rax,%rcx
  800420ef1c:	fd                   	std    
  800420ef1d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420ef1f:	fc                   	cld    
  800420ef20:	eb 57                	jmp    800420ef79 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420ef22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef26:	83 e0 03             	and    $0x3,%eax
  800420ef29:	48 85 c0             	test   %rax,%rax
  800420ef2c:	75 36                	jne    800420ef64 <memmove+0xfc>
  800420ef2e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef32:	83 e0 03             	and    $0x3,%eax
  800420ef35:	48 85 c0             	test   %rax,%rax
  800420ef38:	75 2a                	jne    800420ef64 <memmove+0xfc>
  800420ef3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef3e:	83 e0 03             	and    $0x3,%eax
  800420ef41:	48 85 c0             	test   %rax,%rax
  800420ef44:	75 1e                	jne    800420ef64 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420ef46:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef4a:	48 c1 e8 02          	shr    $0x2,%rax
  800420ef4e:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420ef51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef55:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ef59:	48 89 c7             	mov    %rax,%rdi
  800420ef5c:	48 89 d6             	mov    %rdx,%rsi
  800420ef5f:	fc                   	cld    
  800420ef60:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420ef62:	eb 15                	jmp    800420ef79 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420ef64:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef68:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ef6c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ef70:	48 89 c7             	mov    %rax,%rdi
  800420ef73:	48 89 d6             	mov    %rdx,%rsi
  800420ef76:	fc                   	cld    
  800420ef77:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420ef79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420ef7d:	c9                   	leaveq 
  800420ef7e:	c3                   	retq   

000000800420ef7f <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420ef7f:	55                   	push   %rbp
  800420ef80:	48 89 e5             	mov    %rsp,%rbp
  800420ef83:	48 83 ec 18          	sub    $0x18,%rsp
  800420ef87:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ef8b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420ef8f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420ef93:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ef97:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420ef9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef9f:	48 89 ce             	mov    %rcx,%rsi
  800420efa2:	48 89 c7             	mov    %rax,%rdi
  800420efa5:	48 b8 68 ee 20 04 80 	movabs $0x800420ee68,%rax
  800420efac:	00 00 00 
  800420efaf:	ff d0                	callq  *%rax
}
  800420efb1:	c9                   	leaveq 
  800420efb2:	c3                   	retq   

000000800420efb3 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420efb3:	55                   	push   %rbp
  800420efb4:	48 89 e5             	mov    %rsp,%rbp
  800420efb7:	48 83 ec 28          	sub    $0x28,%rsp
  800420efbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420efbf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420efc3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420efc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420efcb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420efcf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420efd3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420efd7:	eb 36                	jmp    800420f00f <memcmp+0x5c>
		if (*s1 != *s2)
  800420efd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420efdd:	0f b6 10             	movzbl (%rax),%edx
  800420efe0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efe4:	0f b6 00             	movzbl (%rax),%eax
  800420efe7:	38 c2                	cmp    %al,%dl
  800420efe9:	74 1a                	je     800420f005 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420efeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420efef:	0f b6 00             	movzbl (%rax),%eax
  800420eff2:	0f b6 d0             	movzbl %al,%edx
  800420eff5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eff9:	0f b6 00             	movzbl (%rax),%eax
  800420effc:	0f b6 c0             	movzbl %al,%eax
  800420efff:	29 c2                	sub    %eax,%edx
  800420f001:	89 d0                	mov    %edx,%eax
  800420f003:	eb 20                	jmp    800420f025 <memcmp+0x72>
		s1++, s2++;
  800420f005:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f00a:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420f00f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f013:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420f017:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420f01b:	48 85 c0             	test   %rax,%rax
  800420f01e:	75 b9                	jne    800420efd9 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420f020:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f025:	c9                   	leaveq 
  800420f026:	c3                   	retq   

000000800420f027 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420f027:	55                   	push   %rbp
  800420f028:	48 89 e5             	mov    %rsp,%rbp
  800420f02b:	48 83 ec 28          	sub    $0x28,%rsp
  800420f02f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f033:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420f036:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420f03a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f03e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f042:	48 01 d0             	add    %rdx,%rax
  800420f045:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420f049:	eb 15                	jmp    800420f060 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420f04b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f04f:	0f b6 10             	movzbl (%rax),%edx
  800420f052:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f055:	38 c2                	cmp    %al,%dl
  800420f057:	75 02                	jne    800420f05b <memfind+0x34>
			break;
  800420f059:	eb 0f                	jmp    800420f06a <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420f05b:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f060:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f064:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420f068:	72 e1                	jb     800420f04b <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420f06a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420f06e:	c9                   	leaveq 
  800420f06f:	c3                   	retq   

000000800420f070 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420f070:	55                   	push   %rbp
  800420f071:	48 89 e5             	mov    %rsp,%rbp
  800420f074:	48 83 ec 34          	sub    $0x34,%rsp
  800420f078:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f07c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420f080:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420f083:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420f08a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f091:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420f092:	eb 05                	jmp    800420f099 <strtol+0x29>
		s++;
  800420f094:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420f099:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f09d:	0f b6 00             	movzbl (%rax),%eax
  800420f0a0:	3c 20                	cmp    $0x20,%al
  800420f0a2:	74 f0                	je     800420f094 <strtol+0x24>
  800420f0a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0a8:	0f b6 00             	movzbl (%rax),%eax
  800420f0ab:	3c 09                	cmp    $0x9,%al
  800420f0ad:	74 e5                	je     800420f094 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420f0af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0b3:	0f b6 00             	movzbl (%rax),%eax
  800420f0b6:	3c 2b                	cmp    $0x2b,%al
  800420f0b8:	75 07                	jne    800420f0c1 <strtol+0x51>
		s++;
  800420f0ba:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f0bf:	eb 17                	jmp    800420f0d8 <strtol+0x68>
	else if (*s == '-')
  800420f0c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0c5:	0f b6 00             	movzbl (%rax),%eax
  800420f0c8:	3c 2d                	cmp    $0x2d,%al
  800420f0ca:	75 0c                	jne    800420f0d8 <strtol+0x68>
		s++, neg = 1;
  800420f0cc:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f0d1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420f0d8:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420f0dc:	74 06                	je     800420f0e4 <strtol+0x74>
  800420f0de:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420f0e2:	75 28                	jne    800420f10c <strtol+0x9c>
  800420f0e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0e8:	0f b6 00             	movzbl (%rax),%eax
  800420f0eb:	3c 30                	cmp    $0x30,%al
  800420f0ed:	75 1d                	jne    800420f10c <strtol+0x9c>
  800420f0ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0f3:	48 83 c0 01          	add    $0x1,%rax
  800420f0f7:	0f b6 00             	movzbl (%rax),%eax
  800420f0fa:	3c 78                	cmp    $0x78,%al
  800420f0fc:	75 0e                	jne    800420f10c <strtol+0x9c>
		s += 2, base = 16;
  800420f0fe:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420f103:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420f10a:	eb 2c                	jmp    800420f138 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420f10c:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420f110:	75 19                	jne    800420f12b <strtol+0xbb>
  800420f112:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f116:	0f b6 00             	movzbl (%rax),%eax
  800420f119:	3c 30                	cmp    $0x30,%al
  800420f11b:	75 0e                	jne    800420f12b <strtol+0xbb>
		s++, base = 8;
  800420f11d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f122:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420f129:	eb 0d                	jmp    800420f138 <strtol+0xc8>
	else if (base == 0)
  800420f12b:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420f12f:	75 07                	jne    800420f138 <strtol+0xc8>
		base = 10;
  800420f131:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420f138:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f13c:	0f b6 00             	movzbl (%rax),%eax
  800420f13f:	3c 2f                	cmp    $0x2f,%al
  800420f141:	7e 1d                	jle    800420f160 <strtol+0xf0>
  800420f143:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f147:	0f b6 00             	movzbl (%rax),%eax
  800420f14a:	3c 39                	cmp    $0x39,%al
  800420f14c:	7f 12                	jg     800420f160 <strtol+0xf0>
			dig = *s - '0';
  800420f14e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f152:	0f b6 00             	movzbl (%rax),%eax
  800420f155:	0f be c0             	movsbl %al,%eax
  800420f158:	83 e8 30             	sub    $0x30,%eax
  800420f15b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420f15e:	eb 4e                	jmp    800420f1ae <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420f160:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f164:	0f b6 00             	movzbl (%rax),%eax
  800420f167:	3c 60                	cmp    $0x60,%al
  800420f169:	7e 1d                	jle    800420f188 <strtol+0x118>
  800420f16b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f16f:	0f b6 00             	movzbl (%rax),%eax
  800420f172:	3c 7a                	cmp    $0x7a,%al
  800420f174:	7f 12                	jg     800420f188 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420f176:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f17a:	0f b6 00             	movzbl (%rax),%eax
  800420f17d:	0f be c0             	movsbl %al,%eax
  800420f180:	83 e8 57             	sub    $0x57,%eax
  800420f183:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420f186:	eb 26                	jmp    800420f1ae <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420f188:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f18c:	0f b6 00             	movzbl (%rax),%eax
  800420f18f:	3c 40                	cmp    $0x40,%al
  800420f191:	7e 48                	jle    800420f1db <strtol+0x16b>
  800420f193:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f197:	0f b6 00             	movzbl (%rax),%eax
  800420f19a:	3c 5a                	cmp    $0x5a,%al
  800420f19c:	7f 3d                	jg     800420f1db <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420f19e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f1a2:	0f b6 00             	movzbl (%rax),%eax
  800420f1a5:	0f be c0             	movsbl %al,%eax
  800420f1a8:	83 e8 37             	sub    $0x37,%eax
  800420f1ab:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420f1ae:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f1b1:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420f1b4:	7c 02                	jl     800420f1b8 <strtol+0x148>
			break;
  800420f1b6:	eb 23                	jmp    800420f1db <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420f1b8:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f1bd:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420f1c0:	48 98                	cltq   
  800420f1c2:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420f1c7:	48 89 c2             	mov    %rax,%rdx
  800420f1ca:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f1cd:	48 98                	cltq   
  800420f1cf:	48 01 d0             	add    %rdx,%rax
  800420f1d2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420f1d6:	e9 5d ff ff ff       	jmpq   800420f138 <strtol+0xc8>

	if (endptr)
  800420f1db:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f1e0:	74 0b                	je     800420f1ed <strtol+0x17d>
		*endptr = (char *) s;
  800420f1e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f1e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f1ea:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420f1ed:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f1f1:	74 09                	je     800420f1fc <strtol+0x18c>
  800420f1f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1f7:	48 f7 d8             	neg    %rax
  800420f1fa:	eb 04                	jmp    800420f200 <strtol+0x190>
  800420f1fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f200:	c9                   	leaveq 
  800420f201:	c3                   	retq   

000000800420f202 <strstr>:

char * strstr(const char *in, const char *str)
{
  800420f202:	55                   	push   %rbp
  800420f203:	48 89 e5             	mov    %rsp,%rbp
  800420f206:	48 83 ec 30          	sub    $0x30,%rsp
  800420f20a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f20e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420f212:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f216:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f21a:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420f21e:	0f b6 00             	movzbl (%rax),%eax
  800420f221:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420f224:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420f228:	75 06                	jne    800420f230 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420f22a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f22e:	eb 6b                	jmp    800420f29b <strstr+0x99>

	len = strlen(str);
  800420f230:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f234:	48 89 c7             	mov    %rax,%rdi
  800420f237:	48 b8 d8 ea 20 04 80 	movabs $0x800420ead8,%rax
  800420f23e:	00 00 00 
  800420f241:	ff d0                	callq  *%rax
  800420f243:	48 98                	cltq   
  800420f245:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420f249:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f24d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f251:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420f255:	0f b6 00             	movzbl (%rax),%eax
  800420f258:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420f25b:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420f25f:	75 07                	jne    800420f268 <strstr+0x66>
				return (char *) 0;
  800420f261:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f266:	eb 33                	jmp    800420f29b <strstr+0x99>
		} while (sc != c);
  800420f268:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420f26c:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420f26f:	75 d8                	jne    800420f249 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420f271:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f275:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420f279:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f27d:	48 89 ce             	mov    %rcx,%rsi
  800420f280:	48 89 c7             	mov    %rax,%rdi
  800420f283:	48 b8 f9 ec 20 04 80 	movabs $0x800420ecf9,%rax
  800420f28a:	00 00 00 
  800420f28d:	ff d0                	callq  *%rax
  800420f28f:	85 c0                	test   %eax,%eax
  800420f291:	75 b6                	jne    800420f249 <strstr+0x47>

	return (char *) (in - 1);
  800420f293:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f297:	48 83 e8 01          	sub    $0x1,%rax
}
  800420f29b:	c9                   	leaveq 
  800420f29c:	c3                   	retq   

000000800420f29d <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420f29d:	55                   	push   %rbp
  800420f29e:	48 89 e5             	mov    %rsp,%rbp
  800420f2a1:	48 83 ec 24          	sub    $0x24,%rsp
  800420f2a5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f2a9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f2ad:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420f2b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f2b4:	48 8b 10             	mov    (%rax),%rdx
  800420f2b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f2bb:	48 01 d0             	add    %rdx,%rax
  800420f2be:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f2c2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f2c9:	00 
	switch (bytes_to_read) {
  800420f2ca:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f2cd:	83 f8 02             	cmp    $0x2,%eax
  800420f2d0:	0f 84 ab 00 00 00    	je     800420f381 <_dwarf_read_lsb+0xe4>
  800420f2d6:	83 f8 02             	cmp    $0x2,%eax
  800420f2d9:	7f 0e                	jg     800420f2e9 <_dwarf_read_lsb+0x4c>
  800420f2db:	83 f8 01             	cmp    $0x1,%eax
  800420f2de:	0f 84 b3 00 00 00    	je     800420f397 <_dwarf_read_lsb+0xfa>
  800420f2e4:	e9 d9 00 00 00       	jmpq   800420f3c2 <_dwarf_read_lsb+0x125>
  800420f2e9:	83 f8 04             	cmp    $0x4,%eax
  800420f2ec:	74 65                	je     800420f353 <_dwarf_read_lsb+0xb6>
  800420f2ee:	83 f8 08             	cmp    $0x8,%eax
  800420f2f1:	0f 85 cb 00 00 00    	jne    800420f3c2 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420f2f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2fb:	48 83 c0 04          	add    $0x4,%rax
  800420f2ff:	0f b6 00             	movzbl (%rax),%eax
  800420f302:	0f b6 c0             	movzbl %al,%eax
  800420f305:	48 c1 e0 20          	shl    $0x20,%rax
  800420f309:	48 89 c2             	mov    %rax,%rdx
  800420f30c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f310:	48 83 c0 05          	add    $0x5,%rax
  800420f314:	0f b6 00             	movzbl (%rax),%eax
  800420f317:	0f b6 c0             	movzbl %al,%eax
  800420f31a:	48 c1 e0 28          	shl    $0x28,%rax
  800420f31e:	48 09 d0             	or     %rdx,%rax
  800420f321:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420f325:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f329:	48 83 c0 06          	add    $0x6,%rax
  800420f32d:	0f b6 00             	movzbl (%rax),%eax
  800420f330:	0f b6 c0             	movzbl %al,%eax
  800420f333:	48 c1 e0 30          	shl    $0x30,%rax
  800420f337:	48 89 c2             	mov    %rax,%rdx
  800420f33a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f33e:	48 83 c0 07          	add    $0x7,%rax
  800420f342:	0f b6 00             	movzbl (%rax),%eax
  800420f345:	0f b6 c0             	movzbl %al,%eax
  800420f348:	48 c1 e0 38          	shl    $0x38,%rax
  800420f34c:	48 09 d0             	or     %rdx,%rax
  800420f34f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420f353:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f357:	48 83 c0 02          	add    $0x2,%rax
  800420f35b:	0f b6 00             	movzbl (%rax),%eax
  800420f35e:	0f b6 c0             	movzbl %al,%eax
  800420f361:	48 c1 e0 10          	shl    $0x10,%rax
  800420f365:	48 89 c2             	mov    %rax,%rdx
  800420f368:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f36c:	48 83 c0 03          	add    $0x3,%rax
  800420f370:	0f b6 00             	movzbl (%rax),%eax
  800420f373:	0f b6 c0             	movzbl %al,%eax
  800420f376:	48 c1 e0 18          	shl    $0x18,%rax
  800420f37a:	48 09 d0             	or     %rdx,%rax
  800420f37d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420f381:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f385:	48 83 c0 01          	add    $0x1,%rax
  800420f389:	0f b6 00             	movzbl (%rax),%eax
  800420f38c:	0f b6 c0             	movzbl %al,%eax
  800420f38f:	48 c1 e0 08          	shl    $0x8,%rax
  800420f393:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420f397:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f39b:	0f b6 00             	movzbl (%rax),%eax
  800420f39e:	0f b6 c0             	movzbl %al,%eax
  800420f3a1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f3a5:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420f3a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f3aa:	48 8b 10             	mov    (%rax),%rdx
  800420f3ad:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f3b0:	48 98                	cltq   
  800420f3b2:	48 01 c2             	add    %rax,%rdx
  800420f3b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f3b9:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f3bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f3c0:	eb 05                	jmp    800420f3c7 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420f3c2:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420f3c7:	c9                   	leaveq 
  800420f3c8:	c3                   	retq   

000000800420f3c9 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420f3c9:	55                   	push   %rbp
  800420f3ca:	48 89 e5             	mov    %rsp,%rbp
  800420f3cd:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f3d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f3d5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f3d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3dc:	48 8b 00             	mov    (%rax),%rax
  800420f3df:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f3e3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f3ea:	00 
	switch (bytes_to_read) {
  800420f3eb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f3ee:	83 f8 02             	cmp    $0x2,%eax
  800420f3f1:	0f 84 ab 00 00 00    	je     800420f4a2 <_dwarf_decode_lsb+0xd9>
  800420f3f7:	83 f8 02             	cmp    $0x2,%eax
  800420f3fa:	7f 0e                	jg     800420f40a <_dwarf_decode_lsb+0x41>
  800420f3fc:	83 f8 01             	cmp    $0x1,%eax
  800420f3ff:	0f 84 b3 00 00 00    	je     800420f4b8 <_dwarf_decode_lsb+0xef>
  800420f405:	e9 d9 00 00 00       	jmpq   800420f4e3 <_dwarf_decode_lsb+0x11a>
  800420f40a:	83 f8 04             	cmp    $0x4,%eax
  800420f40d:	74 65                	je     800420f474 <_dwarf_decode_lsb+0xab>
  800420f40f:	83 f8 08             	cmp    $0x8,%eax
  800420f412:	0f 85 cb 00 00 00    	jne    800420f4e3 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420f418:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f41c:	48 83 c0 04          	add    $0x4,%rax
  800420f420:	0f b6 00             	movzbl (%rax),%eax
  800420f423:	0f b6 c0             	movzbl %al,%eax
  800420f426:	48 c1 e0 20          	shl    $0x20,%rax
  800420f42a:	48 89 c2             	mov    %rax,%rdx
  800420f42d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f431:	48 83 c0 05          	add    $0x5,%rax
  800420f435:	0f b6 00             	movzbl (%rax),%eax
  800420f438:	0f b6 c0             	movzbl %al,%eax
  800420f43b:	48 c1 e0 28          	shl    $0x28,%rax
  800420f43f:	48 09 d0             	or     %rdx,%rax
  800420f442:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420f446:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f44a:	48 83 c0 06          	add    $0x6,%rax
  800420f44e:	0f b6 00             	movzbl (%rax),%eax
  800420f451:	0f b6 c0             	movzbl %al,%eax
  800420f454:	48 c1 e0 30          	shl    $0x30,%rax
  800420f458:	48 89 c2             	mov    %rax,%rdx
  800420f45b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f45f:	48 83 c0 07          	add    $0x7,%rax
  800420f463:	0f b6 00             	movzbl (%rax),%eax
  800420f466:	0f b6 c0             	movzbl %al,%eax
  800420f469:	48 c1 e0 38          	shl    $0x38,%rax
  800420f46d:	48 09 d0             	or     %rdx,%rax
  800420f470:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420f474:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f478:	48 83 c0 02          	add    $0x2,%rax
  800420f47c:	0f b6 00             	movzbl (%rax),%eax
  800420f47f:	0f b6 c0             	movzbl %al,%eax
  800420f482:	48 c1 e0 10          	shl    $0x10,%rax
  800420f486:	48 89 c2             	mov    %rax,%rdx
  800420f489:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f48d:	48 83 c0 03          	add    $0x3,%rax
  800420f491:	0f b6 00             	movzbl (%rax),%eax
  800420f494:	0f b6 c0             	movzbl %al,%eax
  800420f497:	48 c1 e0 18          	shl    $0x18,%rax
  800420f49b:	48 09 d0             	or     %rdx,%rax
  800420f49e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420f4a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4a6:	48 83 c0 01          	add    $0x1,%rax
  800420f4aa:	0f b6 00             	movzbl (%rax),%eax
  800420f4ad:	0f b6 c0             	movzbl %al,%eax
  800420f4b0:	48 c1 e0 08          	shl    $0x8,%rax
  800420f4b4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420f4b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4bc:	0f b6 00             	movzbl (%rax),%eax
  800420f4bf:	0f b6 c0             	movzbl %al,%eax
  800420f4c2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f4c6:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420f4c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f4cb:	48 8b 10             	mov    (%rax),%rdx
  800420f4ce:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f4d1:	48 98                	cltq   
  800420f4d3:	48 01 c2             	add    %rax,%rdx
  800420f4d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f4da:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f4dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f4e1:	eb 05                	jmp    800420f4e8 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420f4e3:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420f4e8:	c9                   	leaveq 
  800420f4e9:	c3                   	retq   

000000800420f4ea <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420f4ea:	55                   	push   %rbp
  800420f4eb:	48 89 e5             	mov    %rsp,%rbp
  800420f4ee:	48 83 ec 24          	sub    $0x24,%rsp
  800420f4f2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f4f6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f4fa:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420f4fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f501:	48 8b 10             	mov    (%rax),%rdx
  800420f504:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f508:	48 01 d0             	add    %rdx,%rax
  800420f50b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420f50f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f512:	83 f8 02             	cmp    $0x2,%eax
  800420f515:	74 35                	je     800420f54c <_dwarf_read_msb+0x62>
  800420f517:	83 f8 02             	cmp    $0x2,%eax
  800420f51a:	7f 0a                	jg     800420f526 <_dwarf_read_msb+0x3c>
  800420f51c:	83 f8 01             	cmp    $0x1,%eax
  800420f51f:	74 18                	je     800420f539 <_dwarf_read_msb+0x4f>
  800420f521:	e9 53 01 00 00       	jmpq   800420f679 <_dwarf_read_msb+0x18f>
  800420f526:	83 f8 04             	cmp    $0x4,%eax
  800420f529:	74 49                	je     800420f574 <_dwarf_read_msb+0x8a>
  800420f52b:	83 f8 08             	cmp    $0x8,%eax
  800420f52e:	0f 84 96 00 00 00    	je     800420f5ca <_dwarf_read_msb+0xe0>
  800420f534:	e9 40 01 00 00       	jmpq   800420f679 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800420f539:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f53d:	0f b6 00             	movzbl (%rax),%eax
  800420f540:	0f b6 c0             	movzbl %al,%eax
  800420f543:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f547:	e9 34 01 00 00       	jmpq   800420f680 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f54c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f550:	48 83 c0 01          	add    $0x1,%rax
  800420f554:	0f b6 00             	movzbl (%rax),%eax
  800420f557:	0f b6 d0             	movzbl %al,%edx
  800420f55a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f55e:	0f b6 00             	movzbl (%rax),%eax
  800420f561:	0f b6 c0             	movzbl %al,%eax
  800420f564:	48 c1 e0 08          	shl    $0x8,%rax
  800420f568:	48 09 d0             	or     %rdx,%rax
  800420f56b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f56f:	e9 0c 01 00 00       	jmpq   800420f680 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f574:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f578:	48 83 c0 03          	add    $0x3,%rax
  800420f57c:	0f b6 00             	movzbl (%rax),%eax
  800420f57f:	0f b6 c0             	movzbl %al,%eax
  800420f582:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f586:	48 83 c2 02          	add    $0x2,%rdx
  800420f58a:	0f b6 12             	movzbl (%rdx),%edx
  800420f58d:	0f b6 d2             	movzbl %dl,%edx
  800420f590:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f594:	48 09 d0             	or     %rdx,%rax
  800420f597:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f59b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f59f:	48 83 c0 01          	add    $0x1,%rax
  800420f5a3:	0f b6 00             	movzbl (%rax),%eax
  800420f5a6:	0f b6 c0             	movzbl %al,%eax
  800420f5a9:	48 c1 e0 10          	shl    $0x10,%rax
  800420f5ad:	48 89 c2             	mov    %rax,%rdx
  800420f5b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5b4:	0f b6 00             	movzbl (%rax),%eax
  800420f5b7:	0f b6 c0             	movzbl %al,%eax
  800420f5ba:	48 c1 e0 18          	shl    $0x18,%rax
  800420f5be:	48 09 d0             	or     %rdx,%rax
  800420f5c1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f5c5:	e9 b6 00 00 00       	jmpq   800420f680 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f5ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5ce:	48 83 c0 07          	add    $0x7,%rax
  800420f5d2:	0f b6 00             	movzbl (%rax),%eax
  800420f5d5:	0f b6 c0             	movzbl %al,%eax
  800420f5d8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5dc:	48 83 c2 06          	add    $0x6,%rdx
  800420f5e0:	0f b6 12             	movzbl (%rdx),%edx
  800420f5e3:	0f b6 d2             	movzbl %dl,%edx
  800420f5e6:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f5ea:	48 09 d0             	or     %rdx,%rax
  800420f5ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f5f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5f5:	48 83 c0 05          	add    $0x5,%rax
  800420f5f9:	0f b6 00             	movzbl (%rax),%eax
  800420f5fc:	0f b6 c0             	movzbl %al,%eax
  800420f5ff:	48 c1 e0 10          	shl    $0x10,%rax
  800420f603:	48 89 c2             	mov    %rax,%rdx
  800420f606:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f60a:	48 83 c0 04          	add    $0x4,%rax
  800420f60e:	0f b6 00             	movzbl (%rax),%eax
  800420f611:	0f b6 c0             	movzbl %al,%eax
  800420f614:	48 c1 e0 18          	shl    $0x18,%rax
  800420f618:	48 09 d0             	or     %rdx,%rax
  800420f61b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f61f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f623:	48 83 c0 03          	add    $0x3,%rax
  800420f627:	0f b6 00             	movzbl (%rax),%eax
  800420f62a:	0f b6 c0             	movzbl %al,%eax
  800420f62d:	48 c1 e0 20          	shl    $0x20,%rax
  800420f631:	48 89 c2             	mov    %rax,%rdx
  800420f634:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f638:	48 83 c0 02          	add    $0x2,%rax
  800420f63c:	0f b6 00             	movzbl (%rax),%eax
  800420f63f:	0f b6 c0             	movzbl %al,%eax
  800420f642:	48 c1 e0 28          	shl    $0x28,%rax
  800420f646:	48 09 d0             	or     %rdx,%rax
  800420f649:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f64d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f651:	48 83 c0 01          	add    $0x1,%rax
  800420f655:	0f b6 00             	movzbl (%rax),%eax
  800420f658:	0f b6 c0             	movzbl %al,%eax
  800420f65b:	48 c1 e0 30          	shl    $0x30,%rax
  800420f65f:	48 89 c2             	mov    %rax,%rdx
  800420f662:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f666:	0f b6 00             	movzbl (%rax),%eax
  800420f669:	0f b6 c0             	movzbl %al,%eax
  800420f66c:	48 c1 e0 38          	shl    $0x38,%rax
  800420f670:	48 09 d0             	or     %rdx,%rax
  800420f673:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f677:	eb 07                	jmp    800420f680 <_dwarf_read_msb+0x196>
	default:
		return (0);
  800420f679:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f67e:	eb 1a                	jmp    800420f69a <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800420f680:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f684:	48 8b 10             	mov    (%rax),%rdx
  800420f687:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f68a:	48 98                	cltq   
  800420f68c:	48 01 c2             	add    %rax,%rdx
  800420f68f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f693:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f696:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f69a:	c9                   	leaveq 
  800420f69b:	c3                   	retq   

000000800420f69c <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420f69c:	55                   	push   %rbp
  800420f69d:	48 89 e5             	mov    %rsp,%rbp
  800420f6a0:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f6a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f6a8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f6ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6af:	48 8b 00             	mov    (%rax),%rax
  800420f6b2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f6b6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f6bd:	00 
	switch (bytes_to_read) {
  800420f6be:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f6c1:	83 f8 02             	cmp    $0x2,%eax
  800420f6c4:	74 35                	je     800420f6fb <_dwarf_decode_msb+0x5f>
  800420f6c6:	83 f8 02             	cmp    $0x2,%eax
  800420f6c9:	7f 0a                	jg     800420f6d5 <_dwarf_decode_msb+0x39>
  800420f6cb:	83 f8 01             	cmp    $0x1,%eax
  800420f6ce:	74 18                	je     800420f6e8 <_dwarf_decode_msb+0x4c>
  800420f6d0:	e9 53 01 00 00       	jmpq   800420f828 <_dwarf_decode_msb+0x18c>
  800420f6d5:	83 f8 04             	cmp    $0x4,%eax
  800420f6d8:	74 49                	je     800420f723 <_dwarf_decode_msb+0x87>
  800420f6da:	83 f8 08             	cmp    $0x8,%eax
  800420f6dd:	0f 84 96 00 00 00    	je     800420f779 <_dwarf_decode_msb+0xdd>
  800420f6e3:	e9 40 01 00 00       	jmpq   800420f828 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420f6e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6ec:	0f b6 00             	movzbl (%rax),%eax
  800420f6ef:	0f b6 c0             	movzbl %al,%eax
  800420f6f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f6f6:	e9 34 01 00 00       	jmpq   800420f82f <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f6fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6ff:	48 83 c0 01          	add    $0x1,%rax
  800420f703:	0f b6 00             	movzbl (%rax),%eax
  800420f706:	0f b6 d0             	movzbl %al,%edx
  800420f709:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f70d:	0f b6 00             	movzbl (%rax),%eax
  800420f710:	0f b6 c0             	movzbl %al,%eax
  800420f713:	48 c1 e0 08          	shl    $0x8,%rax
  800420f717:	48 09 d0             	or     %rdx,%rax
  800420f71a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f71e:	e9 0c 01 00 00       	jmpq   800420f82f <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f723:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f727:	48 83 c0 03          	add    $0x3,%rax
  800420f72b:	0f b6 00             	movzbl (%rax),%eax
  800420f72e:	0f b6 c0             	movzbl %al,%eax
  800420f731:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f735:	48 83 c2 02          	add    $0x2,%rdx
  800420f739:	0f b6 12             	movzbl (%rdx),%edx
  800420f73c:	0f b6 d2             	movzbl %dl,%edx
  800420f73f:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f743:	48 09 d0             	or     %rdx,%rax
  800420f746:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f74a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f74e:	48 83 c0 01          	add    $0x1,%rax
  800420f752:	0f b6 00             	movzbl (%rax),%eax
  800420f755:	0f b6 c0             	movzbl %al,%eax
  800420f758:	48 c1 e0 10          	shl    $0x10,%rax
  800420f75c:	48 89 c2             	mov    %rax,%rdx
  800420f75f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f763:	0f b6 00             	movzbl (%rax),%eax
  800420f766:	0f b6 c0             	movzbl %al,%eax
  800420f769:	48 c1 e0 18          	shl    $0x18,%rax
  800420f76d:	48 09 d0             	or     %rdx,%rax
  800420f770:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f774:	e9 b6 00 00 00       	jmpq   800420f82f <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f779:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f77d:	48 83 c0 07          	add    $0x7,%rax
  800420f781:	0f b6 00             	movzbl (%rax),%eax
  800420f784:	0f b6 c0             	movzbl %al,%eax
  800420f787:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f78b:	48 83 c2 06          	add    $0x6,%rdx
  800420f78f:	0f b6 12             	movzbl (%rdx),%edx
  800420f792:	0f b6 d2             	movzbl %dl,%edx
  800420f795:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f799:	48 09 d0             	or     %rdx,%rax
  800420f79c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f7a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7a4:	48 83 c0 05          	add    $0x5,%rax
  800420f7a8:	0f b6 00             	movzbl (%rax),%eax
  800420f7ab:	0f b6 c0             	movzbl %al,%eax
  800420f7ae:	48 c1 e0 10          	shl    $0x10,%rax
  800420f7b2:	48 89 c2             	mov    %rax,%rdx
  800420f7b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7b9:	48 83 c0 04          	add    $0x4,%rax
  800420f7bd:	0f b6 00             	movzbl (%rax),%eax
  800420f7c0:	0f b6 c0             	movzbl %al,%eax
  800420f7c3:	48 c1 e0 18          	shl    $0x18,%rax
  800420f7c7:	48 09 d0             	or     %rdx,%rax
  800420f7ca:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f7ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7d2:	48 83 c0 03          	add    $0x3,%rax
  800420f7d6:	0f b6 00             	movzbl (%rax),%eax
  800420f7d9:	0f b6 c0             	movzbl %al,%eax
  800420f7dc:	48 c1 e0 20          	shl    $0x20,%rax
  800420f7e0:	48 89 c2             	mov    %rax,%rdx
  800420f7e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7e7:	48 83 c0 02          	add    $0x2,%rax
  800420f7eb:	0f b6 00             	movzbl (%rax),%eax
  800420f7ee:	0f b6 c0             	movzbl %al,%eax
  800420f7f1:	48 c1 e0 28          	shl    $0x28,%rax
  800420f7f5:	48 09 d0             	or     %rdx,%rax
  800420f7f8:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f7fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f800:	48 83 c0 01          	add    $0x1,%rax
  800420f804:	0f b6 00             	movzbl (%rax),%eax
  800420f807:	0f b6 c0             	movzbl %al,%eax
  800420f80a:	48 c1 e0 30          	shl    $0x30,%rax
  800420f80e:	48 89 c2             	mov    %rax,%rdx
  800420f811:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f815:	0f b6 00             	movzbl (%rax),%eax
  800420f818:	0f b6 c0             	movzbl %al,%eax
  800420f81b:	48 c1 e0 38          	shl    $0x38,%rax
  800420f81f:	48 09 d0             	or     %rdx,%rax
  800420f822:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f826:	eb 07                	jmp    800420f82f <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420f828:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f82d:	eb 1a                	jmp    800420f849 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420f82f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f833:	48 8b 10             	mov    (%rax),%rdx
  800420f836:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f839:	48 98                	cltq   
  800420f83b:	48 01 c2             	add    %rax,%rdx
  800420f83e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f842:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f849:	c9                   	leaveq 
  800420f84a:	c3                   	retq   

000000800420f84b <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f84b:	55                   	push   %rbp
  800420f84c:	48 89 e5             	mov    %rsp,%rbp
  800420f84f:	48 83 ec 30          	sub    $0x30,%rsp
  800420f853:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f857:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800420f85b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f862:	00 
	uint8_t b;
	int shift = 0;
  800420f863:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f86a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f86e:	48 8b 10             	mov    (%rax),%rdx
  800420f871:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f875:	48 01 d0             	add    %rdx,%rax
  800420f878:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f87c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f880:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f884:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f888:	0f b6 00             	movzbl (%rax),%eax
  800420f88b:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f88e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f892:	83 e0 7f             	and    $0x7f,%eax
  800420f895:	89 c2                	mov    %eax,%edx
  800420f897:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f89a:	89 c1                	mov    %eax,%ecx
  800420f89c:	d3 e2                	shl    %cl,%edx
  800420f89e:	89 d0                	mov    %edx,%eax
  800420f8a0:	48 98                	cltq   
  800420f8a2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f8a6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f8aa:	48 8b 00             	mov    (%rax),%rax
  800420f8ad:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f8b1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f8b5:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f8b8:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f8bc:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f8c0:	84 c0                	test   %al,%al
  800420f8c2:	78 b8                	js     800420f87c <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800420f8c4:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f8c8:	7f 1f                	jg     800420f8e9 <_dwarf_read_sleb128+0x9e>
  800420f8ca:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f8ce:	83 e0 40             	and    $0x40,%eax
  800420f8d1:	85 c0                	test   %eax,%eax
  800420f8d3:	74 14                	je     800420f8e9 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800420f8d5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f8d8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f8dd:	89 c1                	mov    %eax,%ecx
  800420f8df:	d3 e2                	shl    %cl,%edx
  800420f8e1:	89 d0                	mov    %edx,%eax
  800420f8e3:	48 98                	cltq   
  800420f8e5:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  800420f8e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f8ed:	c9                   	leaveq 
  800420f8ee:	c3                   	retq   

000000800420f8ef <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f8ef:	55                   	push   %rbp
  800420f8f0:	48 89 e5             	mov    %rsp,%rbp
  800420f8f3:	48 83 ec 30          	sub    $0x30,%rsp
  800420f8f7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f8fb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800420f8ff:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f906:	00 
	uint8_t b;
	int shift = 0;
  800420f907:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f90e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f912:	48 8b 10             	mov    (%rax),%rdx
  800420f915:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f919:	48 01 d0             	add    %rdx,%rax
  800420f91c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f920:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f924:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f928:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f92c:	0f b6 00             	movzbl (%rax),%eax
  800420f92f:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f932:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f936:	83 e0 7f             	and    $0x7f,%eax
  800420f939:	89 c2                	mov    %eax,%edx
  800420f93b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f93e:	89 c1                	mov    %eax,%ecx
  800420f940:	d3 e2                	shl    %cl,%edx
  800420f942:	89 d0                	mov    %edx,%eax
  800420f944:	48 98                	cltq   
  800420f946:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f94a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f94e:	48 8b 00             	mov    (%rax),%rax
  800420f951:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f955:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f959:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f95c:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f960:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f964:	84 c0                	test   %al,%al
  800420f966:	78 b8                	js     800420f920 <_dwarf_read_uleb128+0x31>

	return (ret);
  800420f968:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f96c:	c9                   	leaveq 
  800420f96d:	c3                   	retq   

000000800420f96e <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420f96e:	55                   	push   %rbp
  800420f96f:	48 89 e5             	mov    %rsp,%rbp
  800420f972:	48 83 ec 28          	sub    $0x28,%rsp
  800420f976:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800420f97a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f981:	00 
	uint8_t b;
	int shift = 0;
  800420f982:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420f989:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f98d:	48 8b 00             	mov    (%rax),%rax
  800420f990:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f994:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f998:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f99c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f9a0:	0f b6 00             	movzbl (%rax),%eax
  800420f9a3:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f9a6:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f9aa:	83 e0 7f             	and    $0x7f,%eax
  800420f9ad:	89 c2                	mov    %eax,%edx
  800420f9af:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f9b2:	89 c1                	mov    %eax,%ecx
  800420f9b4:	d3 e2                	shl    %cl,%edx
  800420f9b6:	89 d0                	mov    %edx,%eax
  800420f9b8:	48 98                	cltq   
  800420f9ba:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420f9be:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f9c2:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f9c6:	84 c0                	test   %al,%al
  800420f9c8:	78 ca                	js     800420f994 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800420f9ca:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f9ce:	7f 1f                	jg     800420f9ef <_dwarf_decode_sleb128+0x81>
  800420f9d0:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f9d4:	83 e0 40             	and    $0x40,%eax
  800420f9d7:	85 c0                	test   %eax,%eax
  800420f9d9:	74 14                	je     800420f9ef <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800420f9db:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f9de:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f9e3:	89 c1                	mov    %eax,%ecx
  800420f9e5:	d3 e2                	shl    %cl,%edx
  800420f9e7:	89 d0                	mov    %edx,%eax
  800420f9e9:	48 98                	cltq   
  800420f9eb:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800420f9ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f9f3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f9f7:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f9fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f9fe:	c9                   	leaveq 
  800420f9ff:	c3                   	retq   

000000800420fa00 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420fa00:	55                   	push   %rbp
  800420fa01:	48 89 e5             	mov    %rsp,%rbp
  800420fa04:	48 83 ec 28          	sub    $0x28,%rsp
  800420fa08:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  800420fa0c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420fa13:	00 
	uint8_t b;
	int shift = 0;
  800420fa14:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420fa1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa1f:	48 8b 00             	mov    (%rax),%rax
  800420fa22:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420fa26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa2a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fa2e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420fa32:	0f b6 00             	movzbl (%rax),%eax
  800420fa35:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420fa38:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420fa3c:	83 e0 7f             	and    $0x7f,%eax
  800420fa3f:	89 c2                	mov    %eax,%edx
  800420fa41:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fa44:	89 c1                	mov    %eax,%ecx
  800420fa46:	d3 e2                	shl    %cl,%edx
  800420fa48:	89 d0                	mov    %edx,%eax
  800420fa4a:	48 98                	cltq   
  800420fa4c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420fa50:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420fa54:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420fa58:	84 c0                	test   %al,%al
  800420fa5a:	78 ca                	js     800420fa26 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800420fa5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa60:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fa64:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420fa67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fa6b:	c9                   	leaveq 
  800420fa6c:	c3                   	retq   

000000800420fa6d <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420fa6d:	55                   	push   %rbp
  800420fa6e:	48 89 e5             	mov    %rsp,%rbp
  800420fa71:	48 83 ec 28          	sub    $0x28,%rsp
  800420fa75:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fa79:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fa7d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420fa81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa85:	48 8b 10             	mov    (%rax),%rdx
  800420fa88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa8c:	48 01 d0             	add    %rdx,%rax
  800420fa8f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fa93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa97:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420fa9b:	eb 17                	jmp    800420fab4 <_dwarf_read_string+0x47>
		src++;
  800420fa9d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420faa2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420faa6:	48 8b 00             	mov    (%rax),%rax
  800420faa9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420faad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fab1:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800420fab4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fab8:	0f b6 00             	movzbl (%rax),%eax
  800420fabb:	84 c0                	test   %al,%al
  800420fabd:	74 0d                	je     800420facc <_dwarf_read_string+0x5f>
  800420fabf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fac3:	48 8b 00             	mov    (%rax),%rax
  800420fac6:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420faca:	72 d1                	jb     800420fa9d <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800420facc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fad0:	0f b6 00             	movzbl (%rax),%eax
  800420fad3:	84 c0                	test   %al,%al
  800420fad5:	75 1f                	jne    800420faf6 <_dwarf_read_string+0x89>
  800420fad7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fadb:	48 8b 00             	mov    (%rax),%rax
  800420fade:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420fae2:	73 12                	jae    800420faf6 <_dwarf_read_string+0x89>
		(*offsetp)++;
  800420fae4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fae8:	48 8b 00             	mov    (%rax),%rax
  800420faeb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420faef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420faf3:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420faf6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fafa:	c9                   	leaveq 
  800420fafb:	c3                   	retq   

000000800420fafc <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420fafc:	55                   	push   %rbp
  800420fafd:	48 89 e5             	mov    %rsp,%rbp
  800420fb00:	48 83 ec 28          	sub    $0x28,%rsp
  800420fb04:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fb08:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fb0c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420fb10:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fb14:	48 8b 10             	mov    (%rax),%rdx
  800420fb17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb1b:	48 01 d0             	add    %rdx,%rax
  800420fb1e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fb22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb26:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420fb2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fb2e:	48 8b 10             	mov    (%rax),%rdx
  800420fb31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb35:	48 01 c2             	add    %rax,%rdx
  800420fb38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fb3c:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420fb3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fb43:	c9                   	leaveq 
  800420fb44:	c3                   	retq   

000000800420fb45 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420fb45:	55                   	push   %rbp
  800420fb46:	48 89 e5             	mov    %rsp,%rbp
  800420fb49:	48 83 ec 20          	sub    $0x20,%rsp
  800420fb4d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  800420fb51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb55:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420fb59:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420fb5e:	75 35                	jne    800420fb95 <_dwarf_elf_get_byte_order+0x50>
  800420fb60:	48 b9 00 85 21 04 80 	movabs $0x8004218500,%rcx
  800420fb67:	00 00 00 
  800420fb6a:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  800420fb71:	00 00 00 
  800420fb74:	be 29 01 00 00       	mov    $0x129,%esi
  800420fb79:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  800420fb80:	00 00 00 
  800420fb83:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fb88:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420fb8f:	00 00 00 
  800420fb92:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800420fb95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb99:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420fb9d:	0f b6 c0             	movzbl %al,%eax
  800420fba0:	83 f8 02             	cmp    $0x2,%eax
  800420fba3:	75 07                	jne    800420fbac <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800420fba5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fbaa:	eb 05                	jmp    800420fbb1 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800420fbac:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800420fbb1:	c9                   	leaveq 
  800420fbb2:	c3                   	retq   

000000800420fbb3 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420fbb3:	55                   	push   %rbp
  800420fbb4:	48 89 e5             	mov    %rsp,%rbp
  800420fbb7:	48 83 ec 20          	sub    $0x20,%rsp
  800420fbbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800420fbbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbc3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420fbc7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420fbcc:	75 35                	jne    800420fc03 <_dwarf_elf_get_pointer_size+0x50>
  800420fbce:	48 b9 00 85 21 04 80 	movabs $0x8004218500,%rcx
  800420fbd5:	00 00 00 
  800420fbd8:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  800420fbdf:	00 00 00 
  800420fbe2:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420fbe7:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  800420fbee:	00 00 00 
  800420fbf1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fbf6:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420fbfd:	00 00 00 
  800420fc00:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  800420fc03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc07:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420fc0b:	3c 01                	cmp    $0x1,%al
  800420fc0d:	75 07                	jne    800420fc16 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  800420fc0f:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fc14:	eb 05                	jmp    800420fc1b <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800420fc16:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420fc1b:	c9                   	leaveq 
  800420fc1c:	c3                   	retq   

000000800420fc1d <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420fc1d:	55                   	push   %rbp
  800420fc1e:	48 89 e5             	mov    %rsp,%rbp
  800420fc21:	53                   	push   %rbx
  800420fc22:	48 83 ec 18          	sub    $0x18,%rsp
  800420fc26:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fc2a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420fc2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc32:	ba 60 00 00 00       	mov    $0x60,%edx
  800420fc37:	be 00 00 00 00       	mov    $0x0,%esi
  800420fc3c:	48 89 c7             	mov    %rax,%rdi
  800420fc3f:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  800420fc46:	00 00 00 
  800420fc49:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  800420fc4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc4f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  800420fc56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc5a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420fc61:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420fc62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc66:	48 89 c7             	mov    %rax,%rdi
  800420fc69:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  800420fc70:	00 00 00 
  800420fc73:	ff d0                	callq  *%rax
  800420fc75:	0f b6 d0             	movzbl %al,%edx
  800420fc78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc7c:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420fc7f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc83:	48 89 c7             	mov    %rax,%rdi
  800420fc86:	48 b8 45 fb 20 04 80 	movabs $0x800420fb45,%rax
  800420fc8d:	00 00 00 
  800420fc90:	ff d0                	callq  *%rax
  800420fc92:	85 c0                	test   %eax,%eax
  800420fc94:	75 26                	jne    800420fcbc <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  800420fc96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc9a:	48 b9 ea f4 20 04 80 	movabs $0x800420f4ea,%rcx
  800420fca1:	00 00 00 
  800420fca4:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  800420fca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcac:	48 bb 9c f6 20 04 80 	movabs $0x800420f69c,%rbx
  800420fcb3:	00 00 00 
  800420fcb6:	48 89 58 20          	mov    %rbx,0x20(%rax)
  800420fcba:	eb 24                	jmp    800420fce0 <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  800420fcbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcc0:	48 b9 9d f2 20 04 80 	movabs $0x800420f29d,%rcx
  800420fcc7:	00 00 00 
  800420fcca:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800420fcce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcd2:	48 be c9 f3 20 04 80 	movabs $0x800420f3c9,%rsi
  800420fcd9:	00 00 00 
  800420fcdc:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800420fce0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fce4:	48 89 c7             	mov    %rax,%rdi
  800420fce7:	48 b8 ea 11 21 04 80 	movabs $0x80042111ea,%rax
  800420fcee:	00 00 00 
  800420fcf1:	ff d0                	callq  *%rax
	return 0;
  800420fcf3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fcf8:	48 83 c4 18          	add    $0x18,%rsp
  800420fcfc:	5b                   	pop    %rbx
  800420fcfd:	5d                   	pop    %rbp
  800420fcfe:	c3                   	retq   

000000800420fcff <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420fcff:	55                   	push   %rbp
  800420fd00:	48 89 e5             	mov    %rsp,%rbp
  800420fd03:	48 83 ec 20          	sub    $0x20,%rsp
  800420fd07:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fd0b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420fd0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd13:	48 8b 10             	mov    (%rax),%rdx
  800420fd16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd1a:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420fd1e:	48 39 c2             	cmp    %rax,%rdx
  800420fd21:	76 0a                	jbe    800420fd2d <_get_next_cu+0x2e>
		return -1;
  800420fd23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fd28:	e9 6b 01 00 00       	jmpq   800420fe98 <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  800420fd2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd31:	48 8b 00             	mov    (%rax),%rax
  800420fd34:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420fd38:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fd3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fd40:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420fd44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd48:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fd4c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fd50:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fd54:	48 89 d1             	mov    %rdx,%rcx
  800420fd57:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fd5b:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fd60:	48 89 cf             	mov    %rcx,%rdi
  800420fd63:	ff d0                	callq  *%rax
  800420fd65:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  800420fd68:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420fd6c:	75 2a                	jne    800420fd98 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420fd6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd72:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fd76:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fd7a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fd7e:	48 89 d1             	mov    %rdx,%rcx
  800420fd81:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fd85:	ba 08 00 00 00       	mov    $0x8,%edx
  800420fd8a:	48 89 cf             	mov    %rcx,%rdi
  800420fd8d:	ff d0                	callq  *%rax
  800420fd8f:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800420fd92:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420fd96:	eb 04                	jmp    800420fd9c <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  800420fd98:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  800420fd9c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fda0:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420fda4:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420fda7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fdaa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdae:	48 01 c2             	add    %rax,%rdx
  800420fdb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdb5:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420fdb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdbc:	48 8b 10             	mov    (%rax),%rdx
  800420fdbf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fdc3:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420fdc7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fdca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fdce:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420fdd1:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420fdd5:	75 07                	jne    800420fdde <_get_next_cu+0xdf>
  800420fdd7:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fddc:	eb 05                	jmp    800420fde3 <_get_next_cu+0xe4>
  800420fdde:	b8 0c 00 00 00       	mov    $0xc,%eax
  800420fde3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fde7:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420fdea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdee:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fdf2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fdf6:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fdfa:	48 89 d1             	mov    %rdx,%rcx
  800420fdfd:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fe01:	ba 02 00 00 00       	mov    $0x2,%edx
  800420fe06:	48 89 cf             	mov    %rcx,%rdi
  800420fe09:	ff d0                	callq  *%rax
  800420fe0b:	89 c2                	mov    %eax,%edx
  800420fe0d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe11:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420fe15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe19:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe1d:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420fe21:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fe25:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800420fe29:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fe2d:	48 89 cf             	mov    %rcx,%rdi
  800420fe30:	ff d0                	callq  *%rax
  800420fe32:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fe36:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420fe3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe3e:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe42:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe46:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fe4a:	48 89 d1             	mov    %rdx,%rcx
  800420fe4d:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fe51:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fe56:	48 89 cf             	mov    %rcx,%rdi
  800420fe59:	ff d0                	callq  *%rax
  800420fe5b:	89 c2                	mov    %eax,%edx
  800420fe5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe61:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420fe64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe68:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fe6c:	66 83 f8 01          	cmp    $0x1,%ax
  800420fe70:	76 0e                	jbe    800420fe80 <_get_next_cu+0x181>
  800420fe72:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe76:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fe7a:	66 83 f8 04          	cmp    $0x4,%ax
  800420fe7e:	76 07                	jbe    800420fe87 <_get_next_cu+0x188>
		return -1;
  800420fe80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fe85:	eb 11                	jmp    800420fe98 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  800420fe87:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fe8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe8f:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420fe93:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fe98:	c9                   	leaveq 
  800420fe99:	c3                   	retq   

000000800420fe9a <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420fe9a:	55                   	push   %rbp
  800420fe9b:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420fe9e:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420fea2:	0f b6 c8             	movzbl %al,%ecx
  800420fea5:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420fea9:	0f b7 d0             	movzwl %ax,%edx
  800420feac:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420feb0:	48 89 c6             	mov    %rax,%rsi
  800420feb3:	48 bf 32 85 21 04 80 	movabs $0x8004218532,%rdi
  800420feba:	00 00 00 
  800420febd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fec2:	49 b8 c2 87 20 04 80 	movabs $0x80042087c2,%r8
  800420fec9:	00 00 00 
  800420fecc:	41 ff d0             	callq  *%r8
}
  800420fecf:	5d                   	pop    %rbp
  800420fed0:	c3                   	retq   

000000800420fed1 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420fed1:	55                   	push   %rbp
  800420fed2:	48 89 e5             	mov    %rsp,%rbp
  800420fed5:	48 83 ec 60          	sub    $0x60,%rsp
  800420fed9:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420fedd:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420fee1:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420fee5:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  800420fee9:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420feee:	75 35                	jne    800420ff25 <_dwarf_abbrev_parse+0x54>
  800420fef0:	48 b9 41 85 21 04 80 	movabs $0x8004218541,%rcx
  800420fef7:	00 00 00 
  800420fefa:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  800420ff01:	00 00 00 
  800420ff04:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420ff09:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  800420ff10:	00 00 00 
  800420ff13:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ff18:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420ff1f:	00 00 00 
  800420ff22:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  800420ff25:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420ff2a:	75 35                	jne    800420ff61 <_dwarf_abbrev_parse+0x90>
  800420ff2c:	48 b9 4d 85 21 04 80 	movabs $0x800421854d,%rcx
  800420ff33:	00 00 00 
  800420ff36:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  800420ff3d:	00 00 00 
  800420ff40:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420ff45:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  800420ff4c:	00 00 00 
  800420ff4f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ff54:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800420ff5b:	00 00 00 
  800420ff5e:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  800420ff61:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ff65:	48 8b 10             	mov    (%rax),%rdx
  800420ff68:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ff6c:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff70:	48 39 c2             	cmp    %rax,%rdx
  800420ff73:	72 0a                	jb     800420ff7f <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420ff75:	b8 04 00 00 00       	mov    $0x4,%eax
  800420ff7a:	e9 d3 01 00 00       	jmpq   8004210152 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  800420ff7f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ff83:	48 8b 00             	mov    (%rax),%rax
  800420ff86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420ff8a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ff8e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ff92:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420ff96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff9a:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ff9e:	48 89 d6             	mov    %rdx,%rsi
  800420ffa1:	48 89 c7             	mov    %rax,%rdi
  800420ffa4:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  800420ffab:	00 00 00 
  800420ffae:	ff d0                	callq  *%rax
  800420ffb0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  800420ffb4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ffb9:	75 15                	jne    800420ffd0 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800420ffbb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ffbf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  800420ffc6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ffcb:	e9 82 01 00 00       	jmpq   8004210152 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420ffd0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffd4:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ffd8:	48 89 d6             	mov    %rdx,%rsi
  800420ffdb:	48 89 c7             	mov    %rax,%rdi
  800420ffde:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  800420ffe5:	00 00 00 
  800420ffe8:	ff d0                	callq  *%rax
  800420ffea:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800420ffee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fff2:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fff6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420fffa:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420fffe:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210003:	48 89 cf             	mov    %rcx,%rdi
  8004210006:	ff d0                	callq  *%rax
  8004210008:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  800421000b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421000f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210013:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  8004210016:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421001a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421001e:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004210022:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210026:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800421002a:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  800421002d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210031:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210035:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  8004210039:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421003d:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  8004210044:	00 
	abp->ab_atnum    = 0;
  8004210045:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210049:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004210050:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  8004210051:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210055:	48 8b 00             	mov    (%rax),%rax
  8004210058:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800421005c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210060:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210064:	48 89 d6             	mov    %rdx,%rsi
  8004210067:	48 89 c7             	mov    %rax,%rdi
  800421006a:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  8004210071:	00 00 00 
  8004210074:	ff d0                	callq  *%rax
  8004210076:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800421007a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421007e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210082:	48 89 d6             	mov    %rdx,%rsi
  8004210085:	48 89 c7             	mov    %rax,%rdi
  8004210088:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  800421008f:	00 00 00 
  8004210092:	ff d0                	callq  *%rax
  8004210094:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  8004210098:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421009d:	0f 84 89 00 00 00    	je     800421012c <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  80042100a3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042100a7:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042100ab:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042100af:	48 89 d0             	mov    %rdx,%rax
  80042100b2:	48 01 c0             	add    %rax,%rax
  80042100b5:	48 01 d0             	add    %rdx,%rax
  80042100b8:	48 c1 e0 03          	shl    $0x3,%rax
  80042100bc:	48 01 c8             	add    %rcx,%rax
  80042100bf:	48 8d 50 30          	lea    0x30(%rax),%rdx
  80042100c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042100c7:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  80042100ca:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042100ce:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042100d2:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042100d6:	48 89 d0             	mov    %rdx,%rax
  80042100d9:	48 01 c0             	add    %rax,%rax
  80042100dc:	48 01 d0             	add    %rdx,%rax
  80042100df:	48 c1 e0 03          	shl    $0x3,%rax
  80042100e3:	48 01 c8             	add    %rcx,%rax
  80042100e6:	48 8d 50 38          	lea    0x38(%rax),%rdx
  80042100ea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042100ee:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  80042100f1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042100f5:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042100f9:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042100fd:	48 89 d0             	mov    %rdx,%rax
  8004210100:	48 01 c0             	add    %rax,%rax
  8004210103:	48 01 d0             	add    %rdx,%rax
  8004210106:	48 c1 e0 03          	shl    $0x3,%rax
  800421010a:	48 01 c8             	add    %rcx,%rax
  800421010d:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004210111:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210115:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  8004210118:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421011c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210120:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210124:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210128:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800421012c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210131:	0f 85 1a ff ff ff    	jne    8004210051 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  8004210137:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421013b:	48 8b 00             	mov    (%rax),%rax
  800421013e:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004210142:	48 89 c2             	mov    %rax,%rdx
  8004210145:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210149:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  800421014d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210152:	c9                   	leaveq 
  8004210153:	c3                   	retq   

0000008004210154 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004210154:	55                   	push   %rbp
  8004210155:	48 89 e5             	mov    %rsp,%rbp
  8004210158:	48 83 ec 70          	sub    $0x70,%rsp
  800421015c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210160:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210164:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  8004210168:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421016d:	75 0a                	jne    8004210179 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  800421016f:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210174:	e9 0a 01 00 00       	jmpq   8004210283 <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  8004210179:	48 bf 58 85 21 04 80 	movabs $0x8004218558,%rdi
  8004210180:	00 00 00 
  8004210183:	48 b8 b4 44 21 04 80 	movabs $0x80042144b4,%rax
  800421018a:	00 00 00 
  800421018d:	ff d0                	callq  *%rax
  800421018f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004210193:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210198:	75 35                	jne    80042101cf <_dwarf_abbrev_find+0x7b>
  800421019a:	48 b9 4d 85 21 04 80 	movabs $0x800421854d,%rcx
  80042101a1:	00 00 00 
  80042101a4:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  80042101ab:	00 00 00 
  80042101ae:	be e5 01 00 00       	mov    $0x1e5,%esi
  80042101b3:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  80042101ba:	00 00 00 
  80042101bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042101c2:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042101c9:	00 00 00 
  80042101cc:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  80042101cf:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042101d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  80042101d7:	e9 8d 00 00 00       	jmpq   8004210269 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  80042101dc:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042101e0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042101e4:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  80042101e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042101ec:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  80042101f0:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042101f4:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  80042101f8:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  80042101fd:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004210201:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210206:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  800421020a:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800421020f:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004210213:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210218:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  800421021c:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210221:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004210225:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  800421022a:	48 89 c7             	mov    %rax,%rdi
  800421022d:	48 b8 d1 fe 20 04 80 	movabs $0x800420fed1,%rax
  8004210234:	00 00 00 
  8004210237:	ff d0                	callq  *%rax
  8004210239:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  800421023c:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004210240:	74 05                	je     8004210247 <_dwarf_abbrev_find+0xf3>
			return (ret);
  8004210242:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210245:	eb 3c                	jmp    8004210283 <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  8004210247:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421024b:	48 8b 00             	mov    (%rax),%rax
  800421024e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210252:	75 07                	jne    800421025b <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  8004210254:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210259:	eb 28                	jmp    8004210283 <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  800421025b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421025f:	48 8b 00             	mov    (%rax),%rax
  8004210262:	48 85 c0             	test   %rax,%rax
  8004210265:	75 02                	jne    8004210269 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  8004210267:	eb 15                	jmp    800421027e <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  8004210269:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421026d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210271:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210275:	48 39 c2             	cmp    %rax,%rdx
  8004210278:	0f 87 5e ff ff ff    	ja     80042101dc <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  800421027e:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210283:	c9                   	leaveq 
  8004210284:	c3                   	retq   

0000008004210285 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  8004210285:	55                   	push   %rbp
  8004210286:	48 89 e5             	mov    %rsp,%rbp
  8004210289:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004210290:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004210297:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421029e:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  80042102a5:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  80042102ac:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  80042102b3:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  80042102ba:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042102c1:	00 00 00 
  80042102c4:	48 b8 b4 44 21 04 80 	movabs $0x80042144b4,%rax
  80042102cb:	00 00 00 
  80042102ce:	ff d0                	callq  *%rax
  80042102d0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  80042102d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102d8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042102dc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  80042102e0:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042102e7:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042102eb:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  80042102ee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  80042102f5:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042102fc:	ba 60 00 00 00       	mov    $0x60,%edx
  8004210301:	be 00 00 00 00       	mov    $0x0,%esi
  8004210306:	48 89 c7             	mov    %rax,%rdi
  8004210309:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004210310:	00 00 00 
  8004210313:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  8004210315:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421031c:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  8004210323:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800421032a:	48 8b 00             	mov    (%rax),%rax
  800421032d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  8004210331:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210338:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421033c:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  8004210340:	8b 45 10             	mov    0x10(%rbp),%eax
  8004210343:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  8004210346:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800421034d:	00 

	switch (form) {
  800421034e:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  8004210355:	20 
  8004210356:	0f 87 82 04 00 00    	ja     80042107de <_dwarf_attr_init+0x559>
  800421035c:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004210363:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421036a:	00 
  800421036b:	48 b8 90 85 21 04 80 	movabs $0x8004218590,%rax
  8004210372:	00 00 00 
  8004210375:	48 01 d0             	add    %rdx,%rax
  8004210378:	48 8b 00             	mov    (%rax),%rax
  800421037b:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800421037d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210384:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210388:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421038f:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004210393:	0f b6 d2             	movzbl %dl,%edx
  8004210396:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421039d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042103a1:	48 89 cf             	mov    %rcx,%rdi
  80042103a4:	ff d0                	callq  *%rax
  80042103a6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042103aa:	e9 37 04 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  80042103af:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042103b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103ba:	48 89 d6             	mov    %rdx,%rsi
  80042103bd:	48 89 c7             	mov    %rax,%rdi
  80042103c0:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  80042103c7:	00 00 00 
  80042103ca:	ff d0                	callq  *%rax
  80042103cc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042103d0:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042103d4:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042103db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103df:	48 89 ce             	mov    %rcx,%rsi
  80042103e2:	48 89 c7             	mov    %rax,%rdi
  80042103e5:	48 b8 fc fa 20 04 80 	movabs $0x800420fafc,%rax
  80042103ec:	00 00 00 
  80042103ef:	ff d0                	callq  *%rax
  80042103f1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042103f5:	e9 ec 03 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  80042103fa:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210401:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210405:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421040c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210410:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210415:	48 89 cf             	mov    %rcx,%rdi
  8004210418:	ff d0                	callq  *%rax
  800421041a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421041e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210422:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210429:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421042d:	48 89 ce             	mov    %rcx,%rsi
  8004210430:	48 89 c7             	mov    %rax,%rdi
  8004210433:	48 b8 fc fa 20 04 80 	movabs $0x800420fafc,%rax
  800421043a:	00 00 00 
  800421043d:	ff d0                	callq  *%rax
  800421043f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210443:	e9 9e 03 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004210448:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421044f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210453:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421045a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421045e:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210463:	48 89 cf             	mov    %rcx,%rdi
  8004210466:	ff d0                	callq  *%rax
  8004210468:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421046c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210470:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210477:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421047b:	48 89 ce             	mov    %rcx,%rsi
  800421047e:	48 89 c7             	mov    %rax,%rdi
  8004210481:	48 b8 fc fa 20 04 80 	movabs $0x800420fafc,%rax
  8004210488:	00 00 00 
  800421048b:	ff d0                	callq  *%rax
  800421048d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210491:	e9 50 03 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004210496:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421049d:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042104a1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042104a8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042104ac:	ba 04 00 00 00       	mov    $0x4,%edx
  80042104b1:	48 89 cf             	mov    %rcx,%rdi
  80042104b4:	ff d0                	callq  *%rax
  80042104b6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042104ba:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042104be:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042104c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104c9:	48 89 ce             	mov    %rcx,%rsi
  80042104cc:	48 89 c7             	mov    %rax,%rdi
  80042104cf:	48 b8 fc fa 20 04 80 	movabs $0x800420fafc,%rax
  80042104d6:	00 00 00 
  80042104d9:	ff d0                	callq  *%rax
  80042104db:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042104df:	e9 02 03 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  80042104e4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042104eb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042104ef:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042104f6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042104fa:	ba 01 00 00 00       	mov    $0x1,%edx
  80042104ff:	48 89 cf             	mov    %rcx,%rdi
  8004210502:	ff d0                	callq  *%rax
  8004210504:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210508:	e9 d9 02 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800421050d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210514:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210518:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421051f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210523:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210528:	48 89 cf             	mov    %rcx,%rdi
  800421052b:	ff d0                	callq  *%rax
  800421052d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210531:	e9 b0 02 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004210536:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421053d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210541:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210548:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421054c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210551:	48 89 cf             	mov    %rcx,%rdi
  8004210554:	ff d0                	callq  *%rax
  8004210556:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421055a:	e9 87 02 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800421055f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210566:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421056a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210571:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210575:	ba 08 00 00 00       	mov    $0x8,%edx
  800421057a:	48 89 cf             	mov    %rcx,%rdi
  800421057d:	ff d0                	callq  *%rax
  800421057f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210583:	e9 5e 02 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004210588:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421058f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210593:	48 89 d6             	mov    %rdx,%rsi
  8004210596:	48 89 c7             	mov    %rax,%rdi
  8004210599:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  80042105a0:	00 00 00 
  80042105a3:	ff d0                	callq  *%rax
  80042105a5:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  80042105ac:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  80042105b3:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  80042105ba:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  80042105c1:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042105c8:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042105cf:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042105d6:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  80042105dd:	4d 89 c1             	mov    %r8,%r9
  80042105e0:	49 89 f8             	mov    %rdi,%r8
  80042105e3:	48 89 c7             	mov    %rax,%rdi
  80042105e6:	48 b8 85 02 21 04 80 	movabs $0x8004210285,%rax
  80042105ed:	00 00 00 
  80042105f0:	ff d0                	callq  *%rax
  80042105f2:	e9 1d 03 00 00       	jmpq   8004210914 <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  80042105f7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042105fe:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210602:	66 83 f8 02          	cmp    $0x2,%ax
  8004210606:	75 2f                	jne    8004210637 <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004210608:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421060f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210613:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421061a:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421061e:	0f b6 d2             	movzbl %dl,%edx
  8004210621:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210628:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421062c:	48 89 cf             	mov    %rcx,%rdi
  800421062f:	ff d0                	callq  *%rax
  8004210631:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004210635:	eb 39                	jmp    8004210670 <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  8004210637:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800421063e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210642:	66 83 f8 03          	cmp    $0x3,%ax
  8004210646:	75 28                	jne    8004210670 <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004210648:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421064f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210653:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004210657:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421065e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210662:	48 89 cf             	mov    %rcx,%rdi
  8004210665:	ff d0                	callq  *%rax
  8004210667:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421066b:	e9 76 01 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
  8004210670:	e9 71 01 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004210675:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421067c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210680:	48 89 d6             	mov    %rdx,%rsi
  8004210683:	48 89 c7             	mov    %rax,%rdi
  8004210686:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  800421068d:	00 00 00 
  8004210690:	ff d0                	callq  *%rax
  8004210692:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210696:	e9 4b 01 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800421069b:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042106a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106a6:	48 89 d6             	mov    %rdx,%rsi
  80042106a9:	48 89 c7             	mov    %rax,%rdi
  80042106ac:	48 b8 4b f8 20 04 80 	movabs $0x800420f84b,%rax
  80042106b3:	00 00 00 
  80042106b6:	ff d0                	callq  *%rax
  80042106b8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042106bc:	e9 25 01 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042106c1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042106c8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042106cc:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042106d0:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042106d7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042106db:	48 89 cf             	mov    %rcx,%rdi
  80042106de:	ff d0                	callq  *%rax
  80042106e0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042106e4:	e9 fd 00 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  80042106e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042106ed:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042106f1:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042106f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106fc:	48 89 ce             	mov    %rcx,%rsi
  80042106ff:	48 89 c7             	mov    %rax,%rdi
  8004210702:	48 b8 6d fa 20 04 80 	movabs $0x800420fa6d,%rax
  8004210709:	00 00 00 
  800421070c:	ff d0                	callq  *%rax
  800421070e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210712:	e9 cf 00 00 00       	jmpq   80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004210717:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421071e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210722:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004210726:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421072d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210731:	48 89 cf             	mov    %rcx,%rdi
  8004210734:	ff d0                	callq  *%rax
  8004210736:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  800421073a:	48 bf 72 85 21 04 80 	movabs $0x8004218572,%rdi
  8004210741:	00 00 00 
  8004210744:	48 b8 b4 44 21 04 80 	movabs $0x80042144b4,%rax
  800421074b:	00 00 00 
  800421074e:	ff d0                	callq  *%rax
  8004210750:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  8004210754:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210759:	75 35                	jne    8004210790 <_dwarf_attr_init+0x50b>
  800421075b:	48 b9 7d 85 21 04 80 	movabs $0x800421857d,%rcx
  8004210762:	00 00 00 
  8004210765:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  800421076c:	00 00 00 
  800421076f:	be 51 02 00 00       	mov    $0x251,%esi
  8004210774:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  800421077b:	00 00 00 
  800421077e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210783:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800421078a:	00 00 00 
  800421078d:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004210790:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210794:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210798:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421079c:	48 01 d0             	add    %rdx,%rax
  800421079f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042107a3:	eb 41                	jmp    80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  80042107a5:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  80042107ac:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  80042107ad:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042107b1:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042107b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107bc:	48 89 ce             	mov    %rcx,%rsi
  80042107bf:	48 89 c7             	mov    %rax,%rdi
  80042107c2:	48 b8 fc fa 20 04 80 	movabs $0x800420fafc,%rax
  80042107c9:	00 00 00 
  80042107cc:	ff d0                	callq  *%rax
  80042107ce:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042107d2:	eb 12                	jmp    80042107e6 <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  80042107d4:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  80042107db:	00 
		break;
  80042107dc:	eb 08                	jmp    80042107e6 <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  80042107de:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  80042107e5:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  80042107e6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042107ea:	0f 85 21 01 00 00    	jne    8004210911 <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  80042107f0:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  80042107f7:	09 
  80042107f8:	74 1e                	je     8004210818 <_dwarf_attr_init+0x593>
  80042107fa:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  8004210801:	0a 
  8004210802:	74 14                	je     8004210818 <_dwarf_attr_init+0x593>
  8004210804:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  800421080b:	03 
  800421080c:	74 0a                	je     8004210818 <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  800421080e:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  8004210815:	04 
  8004210816:	75 10                	jne    8004210828 <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  8004210818:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421081c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  8004210820:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210824:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  8004210828:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421082c:	48 83 f8 03          	cmp    $0x3,%rax
  8004210830:	75 39                	jne    800421086b <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  8004210832:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210836:	48 83 f8 08          	cmp    $0x8,%rax
  800421083a:	74 1c                	je     8004210858 <_dwarf_attr_init+0x5d3>
  800421083c:	48 83 f8 0e          	cmp    $0xe,%rax
  8004210840:	74 02                	je     8004210844 <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  8004210842:	eb 27                	jmp    800421086b <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  8004210844:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210848:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421084f:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004210856:	eb 13                	jmp    800421086b <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  8004210858:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421085c:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210863:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  800421086a:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  800421086b:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210872:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004210879:	8d 48 01             	lea    0x1(%rax),%ecx
  800421087c:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004210883:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004210889:	0f b6 c0             	movzbl %al,%eax
  800421088c:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004210893:	48 63 d0             	movslq %eax,%rdx
  8004210896:	48 89 d0             	mov    %rdx,%rax
  8004210899:	48 01 c0             	add    %rax,%rax
  800421089c:	48 01 d0             	add    %rdx,%rax
  800421089f:	48 c1 e0 05          	shl    $0x5,%rax
  80042108a3:	48 01 c8             	add    %rcx,%rax
  80042108a6:	48 05 70 03 00 00    	add    $0x370,%rax
  80042108ac:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042108b3:	48 89 10             	mov    %rdx,(%rax)
  80042108b6:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042108bd:	48 89 50 08          	mov    %rdx,0x8(%rax)
  80042108c1:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042108c5:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042108c9:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80042108cd:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042108d1:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042108d5:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042108d9:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042108dd:	48 89 50 28          	mov    %rdx,0x28(%rax)
  80042108e1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042108e5:	48 89 50 30          	mov    %rdx,0x30(%rax)
  80042108e9:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042108ed:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042108f1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042108f5:	48 89 50 40          	mov    %rdx,0x40(%rax)
  80042108f9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042108fd:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004210901:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210905:	48 89 50 50          	mov    %rdx,0x50(%rax)
  8004210909:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421090d:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  8004210911:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210914:	c9                   	leaveq 
  8004210915:	c3                   	retq   

0000008004210916 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004210916:	55                   	push   %rbp
  8004210917:	48 89 e5             	mov    %rsp,%rbp
  800421091a:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  8004210921:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  8004210928:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  800421092f:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  8004210936:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  800421093c:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  8004210943:	00 
  8004210944:	75 35                	jne    800421097b <dwarf_search_die_within_cu+0x65>
  8004210946:	48 b9 98 86 21 04 80 	movabs $0x8004218698,%rcx
  800421094d:	00 00 00 
  8004210950:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004210957:	00 00 00 
  800421095a:	be 86 02 00 00       	mov    $0x286,%esi
  800421095f:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  8004210966:	00 00 00 
  8004210969:	b8 00 00 00 00       	mov    $0x0,%eax
  800421096e:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004210975:	00 00 00 
  8004210978:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  800421097b:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004210982:	00 
  8004210983:	75 35                	jne    80042109ba <dwarf_search_die_within_cu+0xa4>
  8004210985:	48 b9 9c 86 21 04 80 	movabs $0x800421869c,%rcx
  800421098c:	00 00 00 
  800421098f:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004210996:	00 00 00 
  8004210999:	be 88 02 00 00       	mov    $0x288,%esi
  800421099e:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  80042109a5:	00 00 00 
  80042109a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042109ad:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042109b4:	00 00 00 
  80042109b7:	41 ff d0             	callq  *%r8

	level = 1;
  80042109ba:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  80042109c1:	e9 17 02 00 00       	jmpq   8004210bdd <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  80042109c6:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042109cd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  80042109d1:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042109d8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042109dc:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  80042109e3:	48 89 d6             	mov    %rdx,%rsi
  80042109e6:	48 89 c7             	mov    %rax,%rdi
  80042109e9:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  80042109f0:	00 00 00 
  80042109f3:	ff d0                	callq  *%rax
  80042109f5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  80042109f9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042109fe:	75 22                	jne    8004210a22 <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  8004210a00:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210a04:	74 09                	je     8004210a0f <dwarf_search_die_within_cu+0xf9>
  8004210a06:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004210a0d:	75 0a                	jne    8004210a19 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  8004210a0f:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210a14:	e9 f4 01 00 00       	jmpq   8004210c0d <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  8004210a19:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  8004210a1d:	e9 bb 01 00 00       	jmpq   8004210bdd <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  8004210a22:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004210a29:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210a2d:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210a34:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004210a38:	48 89 34 24          	mov    %rsi,(%rsp)
  8004210a3c:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  8004210a40:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  8004210a45:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  8004210a49:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004210a4e:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  8004210a52:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  8004210a57:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  8004210a5b:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  8004210a60:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  8004210a64:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004210a69:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  8004210a6d:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  8004210a72:	48 89 ce             	mov    %rcx,%rsi
  8004210a75:	48 89 c7             	mov    %rax,%rdi
  8004210a78:	48 b8 54 01 21 04 80 	movabs $0x8004210154,%rax
  8004210a7f:	00 00 00 
  8004210a82:	ff d0                	callq  *%rax
  8004210a84:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004210a87:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210a8b:	74 08                	je     8004210a95 <dwarf_search_die_within_cu+0x17f>
			return (ret);
  8004210a8d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210a90:	e9 78 01 00 00       	jmpq   8004210c0d <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  8004210a95:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210a9c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210aa0:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  8004210aa3:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210aaa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210aae:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  8004210ab2:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210ab9:	48 8d 78 20          	lea    0x20(%rax),%rdi
  8004210abd:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004210ac4:	b8 66 00 00 00       	mov    $0x66,%eax
  8004210ac9:	48 89 d6             	mov    %rdx,%rsi
  8004210acc:	48 89 c1             	mov    %rax,%rcx
  8004210acf:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  8004210ad2:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210ad9:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  8004210ae0:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  8004210ae7:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210aee:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004210af2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004210af9:	e9 8e 00 00 00       	jmpq   8004210b8c <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  8004210afe:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210b01:	48 63 d0             	movslq %eax,%rdx
  8004210b04:	48 89 d0             	mov    %rdx,%rax
  8004210b07:	48 01 c0             	add    %rax,%rax
  8004210b0a:	48 01 d0             	add    %rdx,%rax
  8004210b0d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210b11:	48 01 e8             	add    %rbp,%rax
  8004210b14:	48 2d 18 03 00 00    	sub    $0x318,%rax
  8004210b1a:	48 8b 08             	mov    (%rax),%rcx
  8004210b1d:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  8004210b24:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210b27:	48 63 d0             	movslq %eax,%rdx
  8004210b2a:	48 89 d0             	mov    %rdx,%rax
  8004210b2d:	48 01 c0             	add    %rax,%rax
  8004210b30:	48 01 d0             	add    %rdx,%rax
  8004210b33:	48 c1 e0 03          	shl    $0x3,%rax
  8004210b37:	48 83 c0 30          	add    $0x30,%rax
  8004210b3b:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  8004210b3f:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  8004210b46:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  8004210b4d:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210b54:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8004210b5b:	49 89 c9             	mov    %rcx,%r9
  8004210b5e:	49 89 f8             	mov    %rdi,%r8
  8004210b61:	48 89 d1             	mov    %rdx,%rcx
  8004210b64:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004210b68:	48 89 c7             	mov    %rax,%rdi
  8004210b6b:	48 b8 85 02 21 04 80 	movabs $0x8004210285,%rax
  8004210b72:	00 00 00 
  8004210b75:	ff d0                	callq  *%rax
  8004210b77:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004210b7a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210b7e:	74 08                	je     8004210b88 <dwarf_search_die_within_cu+0x272>
				return (ret);
  8004210b80:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210b83:	e9 85 00 00 00       	jmpq   8004210c0d <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004210b88:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004210b8c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210b8f:	48 63 d0             	movslq %eax,%rdx
  8004210b92:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004210b99:	48 39 c2             	cmp    %rax,%rdx
  8004210b9c:	0f 82 5c ff ff ff    	jb     8004210afe <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004210ba2:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004210ba9:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210bb0:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  8004210bb4:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004210bbb:	74 19                	je     8004210bd6 <dwarf_search_die_within_cu+0x2c0>
  8004210bbd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210bc1:	7e 13                	jle    8004210bd6 <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004210bc3:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004210bca:	3c 01                	cmp    $0x1,%al
  8004210bcc:	75 06                	jne    8004210bd4 <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  8004210bce:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004210bd2:	eb 09                	jmp    8004210bdd <dwarf_search_die_within_cu+0x2c7>
  8004210bd4:	eb 07                	jmp    8004210bdd <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004210bd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210bdb:	eb 30                	jmp    8004210c0d <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004210bdd:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004210be1:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210be8:	48 39 c2             	cmp    %rax,%rdx
  8004210beb:	76 1b                	jbe    8004210c08 <dwarf_search_die_within_cu+0x2f2>
  8004210bed:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210bf4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210bf8:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210bff:	48 39 c2             	cmp    %rax,%rdx
  8004210c02:	0f 87 be fd ff ff    	ja     80042109c6 <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  8004210c08:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210c0d:	c9                   	leaveq 
  8004210c0e:	c3                   	retq   

0000008004210c0f <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  8004210c0f:	55                   	push   %rbp
  8004210c10:	48 89 e5             	mov    %rsp,%rbp
  8004210c13:	48 83 ec 60          	sub    $0x60,%rsp
  8004210c17:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210c1b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210c1f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  8004210c23:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210c28:	75 35                	jne    8004210c5f <dwarf_offdie+0x50>
  8004210c2a:	48 b9 98 86 21 04 80 	movabs $0x8004218698,%rcx
  8004210c31:	00 00 00 
  8004210c34:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004210c3b:	00 00 00 
  8004210c3e:	be c4 02 00 00       	mov    $0x2c4,%esi
  8004210c43:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  8004210c4a:	00 00 00 
  8004210c4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c52:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004210c59:	00 00 00 
  8004210c5c:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210c5f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210c64:	75 35                	jne    8004210c9b <dwarf_offdie+0x8c>
  8004210c66:	48 b9 9c 86 21 04 80 	movabs $0x800421869c,%rcx
  8004210c6d:	00 00 00 
  8004210c70:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004210c77:	00 00 00 
  8004210c7a:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004210c7f:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  8004210c86:	00 00 00 
  8004210c89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c8e:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004210c95:	00 00 00 
  8004210c98:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004210c9b:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004210c9f:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210ca3:	76 66                	jbe    8004210d0b <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004210ca5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210ca9:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004210cad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210cb1:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  8004210cb5:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004210cb9:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004210cbd:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004210cc2:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  8004210cc6:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004210ccb:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004210ccf:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004210cd4:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  8004210cd8:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004210cdd:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004210ce1:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004210ce6:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  8004210cea:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  8004210cef:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004210cf4:	48 89 c7             	mov    %rax,%rdi
  8004210cf7:	48 b8 16 09 21 04 80 	movabs $0x8004210916,%rax
  8004210cfe:	00 00 00 
  8004210d01:	ff d0                	callq  *%rax
  8004210d03:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  8004210d06:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210d09:	eb 05                	jmp    8004210d10 <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004210d0b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210d10:	c9                   	leaveq 
  8004210d11:	c3                   	retq   

0000008004210d12 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004210d12:	55                   	push   %rbp
  8004210d13:	48 89 e5             	mov    %rsp,%rbp
  8004210d16:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210d1a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210d1e:	89 f0                	mov    %esi,%eax
  8004210d20:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  8004210d24:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210d2b:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004210d2c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004210d33:	eb 57                	jmp    8004210d8c <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  8004210d35:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210d39:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210d3c:	48 63 d0             	movslq %eax,%rdx
  8004210d3f:	48 89 d0             	mov    %rdx,%rax
  8004210d42:	48 01 c0             	add    %rax,%rax
  8004210d45:	48 01 d0             	add    %rdx,%rax
  8004210d48:	48 c1 e0 05          	shl    $0x5,%rax
  8004210d4c:	48 01 c8             	add    %rcx,%rax
  8004210d4f:	48 05 80 03 00 00    	add    $0x380,%rax
  8004210d55:	48 8b 10             	mov    (%rax),%rdx
  8004210d58:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004210d5c:	48 39 c2             	cmp    %rax,%rdx
  8004210d5f:	75 27                	jne    8004210d88 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004210d61:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210d64:	48 63 d0             	movslq %eax,%rdx
  8004210d67:	48 89 d0             	mov    %rdx,%rax
  8004210d6a:	48 01 c0             	add    %rax,%rax
  8004210d6d:	48 01 d0             	add    %rdx,%rax
  8004210d70:	48 c1 e0 05          	shl    $0x5,%rax
  8004210d74:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004210d7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d7f:	48 01 d0             	add    %rdx,%rax
  8004210d82:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004210d86:	eb 17                	jmp    8004210d9f <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004210d88:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004210d8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d90:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004210d97:	0f b6 c0             	movzbl %al,%eax
  8004210d9a:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004210d9d:	7f 96                	jg     8004210d35 <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004210d9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210da3:	c9                   	leaveq 
  8004210da4:	c3                   	retq   

0000008004210da5 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004210da5:	55                   	push   %rbp
  8004210da6:	48 89 e5             	mov    %rsp,%rbp
  8004210da9:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004210dad:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210db1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210db5:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004210db9:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004210dbd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210dc2:	75 35                	jne    8004210df9 <dwarf_siblingof+0x54>
  8004210dc4:	48 b9 98 86 21 04 80 	movabs $0x8004218698,%rcx
  8004210dcb:	00 00 00 
  8004210dce:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004210dd5:	00 00 00 
  8004210dd8:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004210ddd:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  8004210de4:	00 00 00 
  8004210de7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210dec:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004210df3:	00 00 00 
  8004210df6:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210df9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210dfe:	75 35                	jne    8004210e35 <dwarf_siblingof+0x90>
  8004210e00:	48 b9 9c 86 21 04 80 	movabs $0x800421869c,%rcx
  8004210e07:	00 00 00 
  8004210e0a:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004210e11:	00 00 00 
  8004210e14:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004210e19:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  8004210e20:	00 00 00 
  8004210e23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e28:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004210e2f:	00 00 00 
  8004210e32:	41 ff d0             	callq  *%r8
	assert(cu);
  8004210e35:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004210e3a:	75 35                	jne    8004210e71 <dwarf_siblingof+0xcc>
  8004210e3c:	48 b9 a4 86 21 04 80 	movabs $0x80042186a4,%rcx
  8004210e43:	00 00 00 
  8004210e46:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004210e4d:	00 00 00 
  8004210e50:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004210e55:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  8004210e5c:	00 00 00 
  8004210e5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e64:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004210e6b:	00 00 00 
  8004210e6e:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004210e71:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210e76:	75 65                	jne    8004210edd <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004210e78:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210e7c:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004210e80:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210e84:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210e88:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210e8c:	48 8b 38             	mov    (%rax),%rdi
  8004210e8f:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210e93:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004210e97:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210e9c:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004210ea0:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210ea5:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004210ea9:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210eae:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004210eb2:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210eb7:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004210ebb:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210ec0:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210ec4:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210ec9:	48 89 cf             	mov    %rcx,%rdi
  8004210ecc:	48 b8 0f 0c 21 04 80 	movabs $0x8004210c0f,%rax
  8004210ed3:	00 00 00 
  8004210ed6:	ff d0                	callq  *%rax
  8004210ed8:	e9 0a 01 00 00       	jmpq   8004210fe7 <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004210edd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004210ee4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210ee8:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004210eec:	84 c0                	test   %al,%al
  8004210eee:	75 0e                	jne    8004210efe <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  8004210ef0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210ef4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210ef8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210efc:	eb 6b                	jmp    8004210f69 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004210efe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f02:	be 01 00 00 00       	mov    $0x1,%esi
  8004210f07:	48 89 c7             	mov    %rax,%rdi
  8004210f0a:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  8004210f11:	00 00 00 
  8004210f14:	ff d0                	callq  *%rax
  8004210f16:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004210f1a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210f1f:	74 35                	je     8004210f56 <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  8004210f21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f25:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210f29:	48 83 f8 10          	cmp    $0x10,%rax
  8004210f2d:	74 19                	je     8004210f48 <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  8004210f2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f33:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210f37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210f3b:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210f3f:	48 01 d0             	add    %rdx,%rax
  8004210f42:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210f46:	eb 21                	jmp    8004210f69 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  8004210f48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f4c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210f50:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210f54:	eb 13                	jmp    8004210f69 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  8004210f56:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f5a:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210f5e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004210f62:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004210f69:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004210f6c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210f70:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004210f74:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004210f78:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210f7c:	4c 8b 00             	mov    (%rax),%r8
  8004210f7f:	4c 89 04 24          	mov    %r8,(%rsp)
  8004210f83:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004210f87:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004210f8c:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004210f90:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004210f95:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004210f99:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004210f9e:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004210fa2:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004210fa7:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004210fab:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004210fb0:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210fb4:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210fb9:	48 b8 16 09 21 04 80 	movabs $0x8004210916,%rax
  8004210fc0:	00 00 00 
  8004210fc3:	ff d0                	callq  *%rax
  8004210fc5:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  8004210fc8:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004210fcc:	75 07                	jne    8004210fd5 <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  8004210fce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210fd3:	eb 12                	jmp    8004210fe7 <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  8004210fd5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210fd9:	74 07                	je     8004210fe2 <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  8004210fdb:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210fe0:	eb 05                	jmp    8004210fe7 <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  8004210fe2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210fe7:	c9                   	leaveq 
  8004210fe8:	c3                   	retq   

0000008004210fe9 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004210fe9:	55                   	push   %rbp
  8004210fea:	48 89 e5             	mov    %rsp,%rbp
  8004210fed:	48 83 ec 70          	sub    $0x70,%rsp
  8004210ff1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210ff5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210ff9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210ffd:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004211001:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211006:	75 35                	jne    800421103d <dwarf_child+0x54>
  8004211008:	48 b9 a7 86 21 04 80 	movabs $0x80042186a7,%rcx
  800421100f:	00 00 00 
  8004211012:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004211019:	00 00 00 
  800421101c:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004211021:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  8004211028:	00 00 00 
  800421102b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211030:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004211037:	00 00 00 
  800421103a:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800421103d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211042:	75 35                	jne    8004211079 <dwarf_child+0x90>
  8004211044:	48 b9 9c 86 21 04 80 	movabs $0x800421869c,%rcx
  800421104b:	00 00 00 
  800421104e:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004211055:	00 00 00 
  8004211058:	be 1d 03 00 00       	mov    $0x31d,%esi
  800421105d:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  8004211064:	00 00 00 
  8004211067:	b8 00 00 00 00       	mov    $0x0,%eax
  800421106c:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004211073:	00 00 00 
  8004211076:	41 ff d0             	callq  *%r8
	assert(dbg);
  8004211079:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421107e:	75 35                	jne    80042110b5 <dwarf_child+0xcc>
  8004211080:	48 b9 98 86 21 04 80 	movabs $0x8004218698,%rcx
  8004211087:	00 00 00 
  800421108a:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  8004211091:	00 00 00 
  8004211094:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004211099:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  80042110a0:	00 00 00 
  80042110a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042110a8:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042110af:	00 00 00 
  80042110b2:	41 ff d0             	callq  *%r8
	assert(cu);
  80042110b5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042110ba:	75 35                	jne    80042110f1 <dwarf_child+0x108>
  80042110bc:	48 b9 a4 86 21 04 80 	movabs $0x80042186a4,%rcx
  80042110c3:	00 00 00 
  80042110c6:	48 ba 0a 85 21 04 80 	movabs $0x800421850a,%rdx
  80042110cd:	00 00 00 
  80042110d0:	be 1f 03 00 00       	mov    $0x31f,%esi
  80042110d5:	48 bf 1f 85 21 04 80 	movabs $0x800421851f,%rdi
  80042110dc:	00 00 00 
  80042110df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042110e4:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042110eb:	00 00 00 
  80042110ee:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  80042110f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110f5:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  80042110f9:	84 c0                	test   %al,%al
  80042110fb:	75 0a                	jne    8004211107 <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  80042110fd:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211102:	e9 84 00 00 00       	jmpq   800421118b <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004211107:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421110b:	48 8b 70 08          	mov    0x8(%rax),%rsi
  800421110f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211113:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004211117:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421111b:	48 8b 08             	mov    (%rax),%rcx
  800421111e:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211122:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004211126:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421112b:	48 8b 48 10          	mov    0x10(%rax),%rcx
  800421112f:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211134:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211138:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800421113d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211141:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211146:	48 8b 48 28          	mov    0x28(%rax),%rcx
  800421114a:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  800421114f:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211153:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211158:	b9 00 00 00 00       	mov    $0x0,%ecx
  800421115d:	48 b8 16 09 21 04 80 	movabs $0x8004210916,%rax
  8004211164:	00 00 00 
  8004211167:	ff d0                	callq  *%rax
  8004211169:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  800421116c:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004211170:	75 07                	jne    8004211179 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004211172:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211177:	eb 12                	jmp    800421118b <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  8004211179:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421117d:	74 07                	je     8004211186 <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  800421117f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211184:	eb 05                	jmp    800421118b <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  8004211186:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421118b:	c9                   	leaveq 
  800421118c:	c3                   	retq   

000000800421118d <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  800421118d:	55                   	push   %rbp
  800421118e:	48 89 e5             	mov    %rsp,%rbp
  8004211191:	48 83 ec 20          	sub    $0x20,%rsp
  8004211195:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004211199:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421119d:	48 8b 00             	mov    (%rax),%rax
  80042111a0:	48 89 c7             	mov    %rax,%rdi
  80042111a3:	48 b8 b4 44 21 04 80 	movabs $0x80042144b4,%rax
  80042111aa:	00 00 00 
  80042111ad:	ff d0                	callq  *%rax
  80042111af:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  80042111b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111b7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042111bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111bf:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  80042111c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111c7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042111cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111cf:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  80042111d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111d7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042111db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111df:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  80042111e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042111e8:	c9                   	leaveq 
  80042111e9:	c3                   	retq   

00000080042111ea <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  80042111ea:	55                   	push   %rbp
  80042111eb:	48 89 e5             	mov    %rsp,%rbp
  80042111ee:	48 83 ec 08          	sub    $0x8,%rsp
  80042111f2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  80042111f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111fa:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004211200:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211204:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  800421120a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421120e:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004211214:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211218:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  800421121e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211222:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004211228:	c9                   	leaveq 
  8004211229:	c3                   	retq   

000000800421122a <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  800421122a:	55                   	push   %rbp
  800421122b:	48 89 e5             	mov    %rsp,%rbp
  800421122e:	48 83 ec 40          	sub    $0x40,%rsp
  8004211232:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211236:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421123a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421123e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004211242:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  8004211246:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421124a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  800421124e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211252:	ba 80 00 00 00       	mov    $0x80,%edx
  8004211257:	be 00 00 00 00       	mov    $0x0,%esi
  800421125c:	48 89 c7             	mov    %rax,%rdi
  800421125f:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004211266:	00 00 00 
  8004211269:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  800421126b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421126f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211273:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  8004211277:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421127c:	75 07                	jne    8004211285 <dwarf_get_fde_at_pc+0x5b>
		return (DW_DLV_ERROR);
  800421127e:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211283:	eb 75                	jmp    80042112fa <dwarf_get_fde_at_pc+0xd0>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004211285:	eb 59                	jmp    80042112e0 <dwarf_get_fde_at_pc+0xb6>
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004211287:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800421128b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421128f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211293:	be 01 00 00 00       	mov    $0x1,%esi
  8004211298:	48 89 c7             	mov    %rax,%rdi
  800421129b:	48 b8 3f 34 21 04 80 	movabs $0x800421343f,%rax
  80042112a2:	00 00 00 
  80042112a5:	ff d0                	callq  *%rax
  80042112a7:	85 c0                	test   %eax,%eax
  80042112a9:	79 07                	jns    80042112b2 <dwarf_get_fde_at_pc+0x88>
		{
			return DW_DLV_NO_ENTRY;
  80042112ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042112b0:	eb 48                	jmp    80042112fa <dwarf_get_fde_at_pc+0xd0>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042112b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042112b6:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042112ba:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042112be:	77 20                	ja     80042112e0 <dwarf_get_fde_at_pc+0xb6>
  80042112c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042112c4:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  80042112c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042112cc:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042112d0:	48 01 d0             	add    %rdx,%rax
  80042112d3:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042112d7:	76 07                	jbe    80042112e0 <dwarf_get_fde_at_pc+0xb6>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  80042112d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042112de:	eb 1a                	jmp    80042112fa <dwarf_get_fde_at_pc+0xd0>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  80042112e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112e4:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042112e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112ec:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042112f0:	48 39 c2             	cmp    %rax,%rdx
  80042112f3:	72 92                	jb     8004211287 <dwarf_get_fde_at_pc+0x5d>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  80042112f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80042112fa:	c9                   	leaveq 
  80042112fb:	c3                   	retq   

00000080042112fc <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  80042112fc:	55                   	push   %rbp
  80042112fd:	48 89 e5             	mov    %rsp,%rbp
  8004211300:	53                   	push   %rbx
  8004211301:	48 83 ec 38          	sub    $0x38,%rsp
  8004211305:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211309:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421130d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211311:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	int i;

	assert(dest != NULL);
  8004211315:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421131a:	75 35                	jne    8004211351 <_dwarf_frame_regtable_copy+0x55>
  800421131c:	48 b9 ba 86 21 04 80 	movabs $0x80042186ba,%rcx
  8004211323:	00 00 00 
  8004211326:	48 ba c7 86 21 04 80 	movabs $0x80042186c7,%rdx
  800421132d:	00 00 00 
  8004211330:	be 57 00 00 00       	mov    $0x57,%esi
  8004211335:	48 bf dc 86 21 04 80 	movabs $0x80042186dc,%rdi
  800421133c:	00 00 00 
  800421133f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211344:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800421134b:	00 00 00 
  800421134e:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  8004211351:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211356:	75 35                	jne    800421138d <_dwarf_frame_regtable_copy+0x91>
  8004211358:	48 b9 f2 86 21 04 80 	movabs $0x80042186f2,%rcx
  800421135f:	00 00 00 
  8004211362:	48 ba c7 86 21 04 80 	movabs $0x80042186c7,%rdx
  8004211369:	00 00 00 
  800421136c:	be 58 00 00 00       	mov    $0x58,%esi
  8004211371:	48 bf dc 86 21 04 80 	movabs $0x80042186dc,%rdi
  8004211378:	00 00 00 
  800421137b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211380:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004211387:	00 00 00 
  800421138a:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  800421138d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211391:	48 8b 00             	mov    (%rax),%rax
  8004211394:	48 85 c0             	test   %rax,%rax
  8004211397:	75 39                	jne    80042113d2 <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  8004211399:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421139d:	48 bb e0 46 3d 04 80 	movabs $0x80043d46e0,%rbx
  80042113a4:	00 00 00 
  80042113a7:	48 89 18             	mov    %rbx,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  80042113aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042113ae:	48 8b 00             	mov    (%rax),%rax
  80042113b1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042113b5:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  80042113b9:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  80042113bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042113c1:	48 8b 00             	mov    (%rax),%rax
  80042113c4:	48 bb 20 49 3d 04 80 	movabs $0x80043d4920,%rbx
  80042113cb:	00 00 00 
  80042113ce:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  80042113d2:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042113d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042113da:	48 8b 00             	mov    (%rax),%rax
  80042113dd:	ba 18 00 00 00       	mov    $0x18,%edx
  80042113e2:	48 89 ce             	mov    %rcx,%rsi
  80042113e5:	48 89 c7             	mov    %rax,%rdi
  80042113e8:	48 b8 7f ef 20 04 80 	movabs $0x800420ef7f,%rax
  80042113ef:	00 00 00 
  80042113f2:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042113f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042113fb:	eb 5a                	jmp    8004211457 <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  80042113fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211401:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211405:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211408:	48 63 d0             	movslq %eax,%rdx
  800421140b:	48 89 d0             	mov    %rdx,%rax
  800421140e:	48 01 c0             	add    %rax,%rax
  8004211411:	48 01 d0             	add    %rdx,%rax
  8004211414:	48 c1 e0 03          	shl    $0x3,%rax
  8004211418:	48 01 c1             	add    %rax,%rcx
  800421141b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421141f:	48 8b 00             	mov    (%rax),%rax
  8004211422:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211426:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211429:	48 63 d0             	movslq %eax,%rdx
  800421142c:	48 89 d0             	mov    %rdx,%rax
  800421142f:	48 01 c0             	add    %rax,%rax
  8004211432:	48 01 d0             	add    %rdx,%rax
  8004211435:	48 c1 e0 03          	shl    $0x3,%rax
  8004211439:	48 01 f0             	add    %rsi,%rax
  800421143c:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211441:	48 89 ce             	mov    %rcx,%rsi
  8004211444:	48 89 c7             	mov    %rax,%rdi
  8004211447:	48 b8 7f ef 20 04 80 	movabs $0x800420ef7f,%rax
  800421144e:	00 00 00 
  8004211451:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004211453:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211457:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421145b:	48 8b 00             	mov    (%rax),%rax
  800421145e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211462:	0f b7 c0             	movzwl %ax,%eax
  8004211465:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004211468:	7e 10                	jle    800421147a <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  800421146a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421146e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211472:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211475:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004211478:	7f 83                	jg     80042113fd <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  800421147a:	eb 32                	jmp    80042114ae <_dwarf_frame_regtable_copy+0x1b2>
		(*dest)->rt3_rules[i].dw_regnum =
  800421147c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211480:	48 8b 00             	mov    (%rax),%rax
  8004211483:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211487:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421148a:	48 63 d0             	movslq %eax,%rdx
  800421148d:	48 89 d0             	mov    %rdx,%rax
  8004211490:	48 01 c0             	add    %rax,%rax
  8004211493:	48 01 d0             	add    %rdx,%rax
  8004211496:	48 c1 e0 03          	shl    $0x3,%rax
  800421149a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  800421149e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042114a2:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  80042114a6:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  80042114aa:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042114ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042114b2:	48 8b 00             	mov    (%rax),%rax
  80042114b5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042114b9:	0f b7 c0             	movzwl %ax,%eax
  80042114bc:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042114bf:	7f bb                	jg     800421147c <_dwarf_frame_regtable_copy+0x180>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  80042114c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042114c6:	48 83 c4 38          	add    $0x38,%rsp
  80042114ca:	5b                   	pop    %rbx
  80042114cb:	5d                   	pop    %rbp
  80042114cc:	c3                   	retq   

00000080042114cd <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  80042114cd:	55                   	push   %rbp
  80042114ce:	48 89 e5             	mov    %rsp,%rbp
  80042114d1:	53                   	push   %rbx
  80042114d2:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  80042114d9:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042114dd:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042114e1:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042114e5:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  80042114e9:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  80042114f0:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  80042114f7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  80042114fe:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004211505:	00 
  8004211506:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421150a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  800421150e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211512:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211516:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004211519:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421151d:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211521:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004211525:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211529:	48 89 c7             	mov    %rax,%rdi
  800421152c:	48 b8 fc 12 21 04 80 	movabs $0x80042112fc,%rax
  8004211533:	00 00 00 
  8004211536:	ff d0                	callq  *%rax
	p = insts;
  8004211538:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421153c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  8004211540:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211544:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004211548:	48 01 d0             	add    %rdx,%rax
  800421154b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  800421154f:	e9 3a 0d 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		if (*p == DW_CFA_nop) {
  8004211554:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211558:	0f b6 00             	movzbl (%rax),%eax
  800421155b:	84 c0                	test   %al,%al
  800421155d:	75 11                	jne    8004211570 <_dwarf_frame_run_inst+0xa3>
			p++;
  800421155f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211563:	48 83 c0 01          	add    $0x1,%rax
  8004211567:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  800421156b:	e9 1e 0d 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		}

		high2 = *p & 0xc0;
  8004211570:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211574:	0f b6 00             	movzbl (%rax),%eax
  8004211577:	83 e0 c0             	and    $0xffffffc0,%eax
  800421157a:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  800421157d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211581:	0f b6 00             	movzbl (%rax),%eax
  8004211584:	83 e0 3f             	and    $0x3f,%eax
  8004211587:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  800421158a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421158e:	48 83 c0 01          	add    $0x1,%rax
  8004211592:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  8004211596:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  800421159a:	0f 84 a1 01 00 00    	je     8004211741 <_dwarf_frame_run_inst+0x274>
			switch (high2) {
  80042115a0:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042115a4:	3d 80 00 00 00       	cmp    $0x80,%eax
  80042115a9:	74 38                	je     80042115e3 <_dwarf_frame_run_inst+0x116>
  80042115ab:	3d c0 00 00 00       	cmp    $0xc0,%eax
  80042115b0:	0f 84 01 01 00 00    	je     80042116b7 <_dwarf_frame_run_inst+0x1ea>
  80042115b6:	83 f8 40             	cmp    $0x40,%eax
  80042115b9:	0f 85 71 01 00 00    	jne    8004211730 <_dwarf_frame_run_inst+0x263>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  80042115bf:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042115c3:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042115ca:	ff 
  80042115cb:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  80042115cf:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042115d3:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042115d7:	73 05                	jae    80042115de <_dwarf_frame_run_inst+0x111>
			                goto program_done;
  80042115d9:	e9 be 0c 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			        break;
  80042115de:	e9 59 01 00 00       	jmpq   800421173c <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_offset:
			        *row_pc = pc;
  80042115e3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042115e7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042115eb:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  80042115ee:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042115f2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042115f6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042115fa:	66 39 c2             	cmp    %ax,%dx
  80042115fd:	72 0c                	jb     800421160b <_dwarf_frame_run_inst+0x13e>
  80042115ff:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211606:	e9 91 0c 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			        RL[low6].dw_offset_relevant = 1;
  800421160b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421160f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211613:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211617:	48 89 d0             	mov    %rdx,%rax
  800421161a:	48 01 c0             	add    %rax,%rax
  800421161d:	48 01 d0             	add    %rdx,%rax
  8004211620:	48 c1 e0 03          	shl    $0x3,%rax
  8004211624:	48 01 c8             	add    %rcx,%rax
  8004211627:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  800421162a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421162e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211632:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211636:	48 89 d0             	mov    %rdx,%rax
  8004211639:	48 01 c0             	add    %rax,%rax
  800421163c:	48 01 d0             	add    %rdx,%rax
  800421163f:	48 c1 e0 03          	shl    $0x3,%rax
  8004211643:	48 01 c8             	add    %rcx,%rax
  8004211646:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  800421164a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421164e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211652:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211656:	48 89 d0             	mov    %rdx,%rax
  8004211659:	48 01 c0             	add    %rax,%rax
  800421165c:	48 01 d0             	add    %rdx,%rax
  800421165f:	48 c1 e0 03          	shl    $0x3,%rax
  8004211663:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211667:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421166b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421166f:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  8004211673:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211677:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421167b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421167f:	48 89 d0             	mov    %rdx,%rax
  8004211682:	48 01 c0             	add    %rax,%rax
  8004211685:	48 01 d0             	add    %rdx,%rax
  8004211688:	48 c1 e0 03          	shl    $0x3,%rax
  800421168c:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  8004211690:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211694:	48 89 c7             	mov    %rax,%rdi
  8004211697:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  800421169e:	00 00 00 
  80042116a1:	ff d0                	callq  *%rax
  80042116a3:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042116aa:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  80042116ae:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  80042116b2:	e9 85 00 00 00       	jmpq   800421173c <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_restore:
			        *row_pc = pc;
  80042116b7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042116bb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042116bf:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  80042116c2:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042116c6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116ca:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042116ce:	66 39 c2             	cmp    %ax,%dx
  80042116d1:	72 0c                	jb     80042116df <_dwarf_frame_run_inst+0x212>
  80042116d3:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042116da:	e9 bd 0b 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			        memcpy(&RL[low6], &INITRL[low6],
  80042116df:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042116e3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042116e7:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042116eb:	48 89 d0             	mov    %rdx,%rax
  80042116ee:	48 01 c0             	add    %rax,%rax
  80042116f1:	48 01 d0             	add    %rdx,%rax
  80042116f4:	48 c1 e0 03          	shl    $0x3,%rax
  80042116f8:	48 01 c1             	add    %rax,%rcx
  80042116fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116ff:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211703:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211707:	48 89 d0             	mov    %rdx,%rax
  800421170a:	48 01 c0             	add    %rax,%rax
  800421170d:	48 01 d0             	add    %rdx,%rax
  8004211710:	48 c1 e0 03          	shl    $0x3,%rax
  8004211714:	48 01 f0             	add    %rsi,%rax
  8004211717:	ba 18 00 00 00       	mov    $0x18,%edx
  800421171c:	48 89 ce             	mov    %rcx,%rsi
  800421171f:	48 89 c7             	mov    %rax,%rdi
  8004211722:	48 b8 7f ef 20 04 80 	movabs $0x800420ef7f,%rax
  8004211729:	00 00 00 
  800421172c:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  800421172e:	eb 0c                	jmp    800421173c <_dwarf_frame_run_inst+0x26f>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004211730:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  8004211737:	e9 60 0b 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			}

			continue;
  800421173c:	e9 4d 0b 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		}

		switch (low6) {
  8004211741:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004211745:	83 f8 16             	cmp    $0x16,%eax
  8004211748:	0f 87 37 0b 00 00    	ja     8004212285 <_dwarf_frame_run_inst+0xdb8>
  800421174e:	89 c0                	mov    %eax,%eax
  8004211750:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004211757:	00 
  8004211758:	48 b8 00 87 21 04 80 	movabs $0x8004218700,%rax
  800421175f:	00 00 00 
  8004211762:	48 01 d0             	add    %rdx,%rax
  8004211765:	48 8b 00             	mov    (%rax),%rax
  8004211768:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  800421176a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421176e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211772:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211776:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004211779:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421177d:	89 ce                	mov    %ecx,%esi
  800421177f:	48 89 d7             	mov    %rdx,%rdi
  8004211782:	ff d0                	callq  *%rax
  8004211784:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004211788:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421178c:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211790:	73 05                	jae    8004211797 <_dwarf_frame_run_inst+0x2ca>
			        goto program_done;
  8004211792:	e9 05 0b 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			break;
  8004211797:	e9 f2 0a 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  800421179c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042117a0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042117a4:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042117a8:	be 01 00 00 00       	mov    $0x1,%esi
  80042117ad:	48 89 d7             	mov    %rdx,%rdi
  80042117b0:	ff d0                	callq  *%rax
  80042117b2:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042117b9:	ff 
  80042117ba:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042117be:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042117c2:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042117c6:	73 05                	jae    80042117cd <_dwarf_frame_run_inst+0x300>
			        goto program_done;
  80042117c8:	e9 cf 0a 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			break;
  80042117cd:	e9 bc 0a 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  80042117d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042117d6:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042117da:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042117de:	be 02 00 00 00       	mov    $0x2,%esi
  80042117e3:	48 89 d7             	mov    %rdx,%rdi
  80042117e6:	ff d0                	callq  *%rax
  80042117e8:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042117ef:	ff 
  80042117f0:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042117f4:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042117f8:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042117fc:	73 05                	jae    8004211803 <_dwarf_frame_run_inst+0x336>
			        goto program_done;
  80042117fe:	e9 99 0a 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			break;
  8004211803:	e9 86 0a 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  8004211808:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421180c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211810:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211814:	be 04 00 00 00       	mov    $0x4,%esi
  8004211819:	48 89 d7             	mov    %rdx,%rdi
  800421181c:	ff d0                	callq  *%rax
  800421181e:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211825:	ff 
  8004211826:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800421182a:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421182e:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211832:	73 05                	jae    8004211839 <_dwarf_frame_run_inst+0x36c>
			        goto program_done;
  8004211834:	e9 63 0a 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			break;
  8004211839:	e9 50 0a 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  800421183e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211842:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211846:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211849:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421184d:	48 89 c7             	mov    %rax,%rdi
  8004211850:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211857:	00 00 00 
  800421185a:	ff d0                	callq  *%rax
  800421185c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004211860:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211864:	48 89 c7             	mov    %rax,%rdi
  8004211867:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  800421186e:	00 00 00 
  8004211871:	ff d0                	callq  *%rax
  8004211873:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211877:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421187b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421187f:	0f b7 c0             	movzwl %ax,%eax
  8004211882:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211886:	77 0c                	ja     8004211894 <_dwarf_frame_run_inst+0x3c7>
  8004211888:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421188f:	e9 08 0a 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004211894:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211898:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421189c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042118a0:	48 89 d0             	mov    %rdx,%rax
  80042118a3:	48 01 c0             	add    %rax,%rax
  80042118a6:	48 01 d0             	add    %rdx,%rax
  80042118a9:	48 c1 e0 03          	shl    $0x3,%rax
  80042118ad:	48 01 c8             	add    %rcx,%rax
  80042118b0:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  80042118b3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118b7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042118bb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042118bf:	48 89 d0             	mov    %rdx,%rax
  80042118c2:	48 01 c0             	add    %rax,%rax
  80042118c5:	48 01 d0             	add    %rdx,%rax
  80042118c8:	48 c1 e0 03          	shl    $0x3,%rax
  80042118cc:	48 01 c8             	add    %rcx,%rax
  80042118cf:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042118d3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118d7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042118db:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042118df:	48 89 d0             	mov    %rdx,%rax
  80042118e2:	48 01 c0             	add    %rax,%rax
  80042118e5:	48 01 d0             	add    %rdx,%rax
  80042118e8:	48 c1 e0 03          	shl    $0x3,%rax
  80042118ec:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042118f0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042118f4:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042118f8:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  80042118fc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211900:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211904:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211908:	48 89 d0             	mov    %rdx,%rax
  800421190b:	48 01 c0             	add    %rax,%rax
  800421190e:	48 01 d0             	add    %rdx,%rax
  8004211911:	48 c1 e0 03          	shl    $0x3,%rax
  8004211915:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211919:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211920:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004211925:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211929:	e9 60 09 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  800421192e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211932:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211936:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211939:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421193d:	48 89 c7             	mov    %rax,%rdi
  8004211940:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211947:	00 00 00 
  800421194a:	ff d0                	callq  *%rax
  800421194c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211950:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211954:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211958:	0f b7 c0             	movzwl %ax,%eax
  800421195b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421195f:	77 0c                	ja     800421196d <_dwarf_frame_run_inst+0x4a0>
  8004211961:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211968:	e9 2f 09 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			memcpy(&RL[reg], &INITRL[reg],
  800421196d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211971:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211975:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211979:	48 89 d0             	mov    %rdx,%rax
  800421197c:	48 01 c0             	add    %rax,%rax
  800421197f:	48 01 d0             	add    %rdx,%rax
  8004211982:	48 c1 e0 03          	shl    $0x3,%rax
  8004211986:	48 01 c1             	add    %rax,%rcx
  8004211989:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421198d:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211991:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211995:	48 89 d0             	mov    %rdx,%rax
  8004211998:	48 01 c0             	add    %rax,%rax
  800421199b:	48 01 d0             	add    %rdx,%rax
  800421199e:	48 c1 e0 03          	shl    $0x3,%rax
  80042119a2:	48 01 f0             	add    %rsi,%rax
  80042119a5:	ba 18 00 00 00       	mov    $0x18,%edx
  80042119aa:	48 89 ce             	mov    %rcx,%rsi
  80042119ad:	48 89 c7             	mov    %rax,%rdi
  80042119b0:	48 b8 7f ef 20 04 80 	movabs $0x800420ef7f,%rax
  80042119b7:	00 00 00 
  80042119ba:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  80042119bc:	e9 cd 08 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_undefined:
			*row_pc = pc;
  80042119c1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042119c5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042119c9:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042119cc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042119d0:	48 89 c7             	mov    %rax,%rdi
  80042119d3:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  80042119da:	00 00 00 
  80042119dd:	ff d0                	callq  *%rax
  80042119df:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042119e3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119e7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042119eb:	0f b7 c0             	movzwl %ax,%eax
  80042119ee:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042119f2:	77 0c                	ja     8004211a00 <_dwarf_frame_run_inst+0x533>
  80042119f4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042119fb:	e9 9c 08 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004211a00:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a04:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211a08:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a0c:	48 89 d0             	mov    %rdx,%rax
  8004211a0f:	48 01 c0             	add    %rax,%rax
  8004211a12:	48 01 d0             	add    %rdx,%rax
  8004211a15:	48 c1 e0 03          	shl    $0x3,%rax
  8004211a19:	48 01 c8             	add    %rcx,%rax
  8004211a1c:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004211a1f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a23:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211a27:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a2b:	48 89 d0             	mov    %rdx,%rax
  8004211a2e:	48 01 c0             	add    %rax,%rax
  8004211a31:	48 01 d0             	add    %rdx,%rax
  8004211a34:	48 c1 e0 03          	shl    $0x3,%rax
  8004211a38:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211a3c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211a40:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  8004211a44:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004211a48:	e9 41 08 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  8004211a4d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a51:	48 89 c7             	mov    %rax,%rdi
  8004211a54:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211a5b:	00 00 00 
  8004211a5e:	ff d0                	callq  *%rax
  8004211a60:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211a64:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a68:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211a6c:	0f b7 c0             	movzwl %ax,%eax
  8004211a6f:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211a73:	77 0c                	ja     8004211a81 <_dwarf_frame_run_inst+0x5b4>
  8004211a75:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211a7c:	e9 1b 08 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004211a81:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a85:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211a89:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a8d:	48 89 d0             	mov    %rdx,%rax
  8004211a90:	48 01 c0             	add    %rax,%rax
  8004211a93:	48 01 d0             	add    %rdx,%rax
  8004211a96:	48 c1 e0 03          	shl    $0x3,%rax
  8004211a9a:	48 01 c8             	add    %rcx,%rax
  8004211a9d:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004211aa0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211aa4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211aa8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211aac:	48 89 d0             	mov    %rdx,%rax
  8004211aaf:	48 01 c0             	add    %rax,%rax
  8004211ab2:	48 01 d0             	add    %rdx,%rax
  8004211ab5:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ab9:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211abd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211ac1:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  8004211ac5:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004211ac9:	e9 c0 07 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_register:
			*row_pc = pc;
  8004211ace:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211ad2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211ad6:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211ad9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211add:	48 89 c7             	mov    %rax,%rdi
  8004211ae0:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211ae7:	00 00 00 
  8004211aea:	ff d0                	callq  *%rax
  8004211aec:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  8004211af0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211af4:	48 89 c7             	mov    %rax,%rdi
  8004211af7:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211afe:	00 00 00 
  8004211b01:	ff d0                	callq  *%rax
  8004211b03:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211b07:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b0b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211b0f:	0f b7 c0             	movzwl %ax,%eax
  8004211b12:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211b16:	77 0c                	ja     8004211b24 <_dwarf_frame_run_inst+0x657>
  8004211b18:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211b1f:	e9 78 07 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004211b24:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b28:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b2c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b30:	48 89 d0             	mov    %rdx,%rax
  8004211b33:	48 01 c0             	add    %rax,%rax
  8004211b36:	48 01 d0             	add    %rdx,%rax
  8004211b39:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b3d:	48 01 c8             	add    %rcx,%rax
  8004211b40:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  8004211b43:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b47:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b4b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b4f:	48 89 d0             	mov    %rdx,%rax
  8004211b52:	48 01 c0             	add    %rax,%rax
  8004211b55:	48 01 d0             	add    %rdx,%rax
  8004211b58:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b5c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211b60:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211b64:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004211b68:	e9 21 07 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004211b6d:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004211b71:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211b75:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004211b79:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211b7d:	48 89 c7             	mov    %rax,%rdi
  8004211b80:	48 b8 fc 12 21 04 80 	movabs $0x80042112fc,%rax
  8004211b87:	00 00 00 
  8004211b8a:	ff d0                	callq  *%rax
			break;
  8004211b8c:	e9 fd 06 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_state:
			*row_pc = pc;
  8004211b91:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211b95:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211b99:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004211b9c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004211ba0:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211ba4:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004211ba8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211bac:	48 89 c7             	mov    %rax,%rdi
  8004211baf:	48 b8 fc 12 21 04 80 	movabs $0x80042112fc,%rax
  8004211bb6:	00 00 00 
  8004211bb9:	ff d0                	callq  *%rax
			break;
  8004211bbb:	e9 ce 06 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  8004211bc0:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211bc4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211bc8:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211bcb:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211bcf:	48 89 c7             	mov    %rax,%rdi
  8004211bd2:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211bd9:	00 00 00 
  8004211bdc:	ff d0                	callq  *%rax
  8004211bde:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004211be2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211be6:	48 89 c7             	mov    %rax,%rdi
  8004211be9:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211bf0:	00 00 00 
  8004211bf3:	ff d0                	callq  *%rax
  8004211bf5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211bf9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211bfd:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211c00:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c04:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004211c08:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c0c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c10:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004211c14:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c18:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211c1c:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211c20:	e9 69 06 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  8004211c25:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211c29:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211c2d:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211c30:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211c34:	48 89 c7             	mov    %rax,%rdi
  8004211c37:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211c3e:	00 00 00 
  8004211c41:	ff d0                	callq  *%rax
  8004211c43:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  8004211c47:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c4b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c4f:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  8004211c53:	e9 36 06 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  8004211c58:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211c5c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211c60:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  8004211c63:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211c67:	48 89 c7             	mov    %rax,%rdi
  8004211c6a:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211c71:	00 00 00 
  8004211c74:	ff d0                	callq  *%rax
  8004211c76:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211c7a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c7e:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211c81:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c85:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004211c89:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c8d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211c91:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211c95:	e9 f4 05 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  8004211c9a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211c9e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211ca2:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  8004211ca5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ca9:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004211cac:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211cb0:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004211cb4:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004211cb8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211cbc:	48 89 c7             	mov    %rax,%rdi
  8004211cbf:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211cc6:	00 00 00 
  8004211cc9:	ff d0                	callq  *%rax
  8004211ccb:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  8004211ccf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211cd3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211cd7:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  8004211cdb:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211cdf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ce3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211ce7:	48 01 d0             	add    %rdx,%rax
  8004211cea:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004211cee:	e9 9b 05 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_expression:
			*row_pc = pc;
  8004211cf3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211cf7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211cfb:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211cfe:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d02:	48 89 c7             	mov    %rax,%rdi
  8004211d05:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211d0c:	00 00 00 
  8004211d0f:	ff d0                	callq  *%rax
  8004211d11:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211d15:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d19:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211d1d:	0f b7 c0             	movzwl %ax,%eax
  8004211d20:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211d24:	77 0c                	ja     8004211d32 <_dwarf_frame_run_inst+0x865>
  8004211d26:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211d2d:	e9 6a 05 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004211d32:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d36:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211d3a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d3e:	48 89 d0             	mov    %rdx,%rax
  8004211d41:	48 01 c0             	add    %rax,%rax
  8004211d44:	48 01 d0             	add    %rdx,%rax
  8004211d47:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d4b:	48 01 c8             	add    %rcx,%rax
  8004211d4e:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004211d51:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d55:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211d59:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d5d:	48 89 d0             	mov    %rdx,%rax
  8004211d60:	48 01 c0             	add    %rax,%rax
  8004211d63:	48 01 d0             	add    %rdx,%rax
  8004211d66:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d6a:	48 01 c8             	add    %rcx,%rax
  8004211d6d:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004211d71:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d75:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211d79:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d7d:	48 89 d0             	mov    %rdx,%rax
  8004211d80:	48 01 c0             	add    %rax,%rax
  8004211d83:	48 01 d0             	add    %rdx,%rax
  8004211d86:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d8a:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004211d8e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d92:	48 89 c7             	mov    %rax,%rdi
  8004211d95:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211d9c:	00 00 00 
  8004211d9f:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004211da1:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004211da5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211da9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211dad:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211db1:	48 89 d0             	mov    %rdx,%rax
  8004211db4:	48 01 c0             	add    %rax,%rax
  8004211db7:	48 01 d0             	add    %rdx,%rax
  8004211dba:	48 c1 e0 03          	shl    $0x3,%rax
  8004211dbe:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211dc2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211dc6:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004211dca:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004211dce:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211dd2:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211dd6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211dda:	48 89 d0             	mov    %rdx,%rax
  8004211ddd:	48 01 c0             	add    %rax,%rax
  8004211de0:	48 01 d0             	add    %rdx,%rax
  8004211de3:	48 c1 e0 03          	shl    $0x3,%rax
  8004211de7:	48 01 f0             	add    %rsi,%rax
  8004211dea:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211dee:	48 01 c8             	add    %rcx,%rax
  8004211df1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004211df5:	e9 94 04 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  8004211dfa:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211dfe:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211e02:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211e05:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211e09:	48 89 c7             	mov    %rax,%rdi
  8004211e0c:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211e13:	00 00 00 
  8004211e16:	ff d0                	callq  *%rax
  8004211e18:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004211e1c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211e20:	48 89 c7             	mov    %rax,%rdi
  8004211e23:	48 b8 6e f9 20 04 80 	movabs $0x800420f96e,%rax
  8004211e2a:	00 00 00 
  8004211e2d:	ff d0                	callq  *%rax
  8004211e2f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211e33:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e37:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211e3b:	0f b7 c0             	movzwl %ax,%eax
  8004211e3e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211e42:	77 0c                	ja     8004211e50 <_dwarf_frame_run_inst+0x983>
  8004211e44:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211e4b:	e9 4c 04 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004211e50:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e54:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e58:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e5c:	48 89 d0             	mov    %rdx,%rax
  8004211e5f:	48 01 c0             	add    %rax,%rax
  8004211e62:	48 01 d0             	add    %rdx,%rax
  8004211e65:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e69:	48 01 c8             	add    %rcx,%rax
  8004211e6c:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004211e6f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e73:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e77:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e7b:	48 89 d0             	mov    %rdx,%rax
  8004211e7e:	48 01 c0             	add    %rax,%rax
  8004211e81:	48 01 d0             	add    %rdx,%rax
  8004211e84:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e88:	48 01 c8             	add    %rcx,%rax
  8004211e8b:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211e8f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e93:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e97:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e9b:	48 89 d0             	mov    %rdx,%rax
  8004211e9e:	48 01 c0             	add    %rax,%rax
  8004211ea1:	48 01 d0             	add    %rdx,%rax
  8004211ea4:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ea8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211eac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211eb0:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211eb4:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004211eb8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ebc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ec0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ec4:	48 89 d0             	mov    %rdx,%rax
  8004211ec7:	48 01 c0             	add    %rax,%rax
  8004211eca:	48 01 d0             	add    %rdx,%rax
  8004211ecd:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ed1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211ed5:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211edc:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211ee1:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211ee5:	e9 a4 03 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  8004211eea:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211eee:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211ef2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211ef5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ef9:	48 89 c7             	mov    %rax,%rdi
  8004211efc:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211f03:	00 00 00 
  8004211f06:	ff d0                	callq  *%rax
  8004211f08:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004211f0c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211f10:	48 89 c7             	mov    %rax,%rdi
  8004211f13:	48 b8 6e f9 20 04 80 	movabs $0x800420f96e,%rax
  8004211f1a:	00 00 00 
  8004211f1d:	ff d0                	callq  *%rax
  8004211f1f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211f23:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f27:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211f2a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f2e:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004211f32:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f36:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f3a:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004211f3e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f42:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211f49:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211f4e:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211f52:	e9 37 03 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  8004211f57:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211f5b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211f5f:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  8004211f62:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211f66:	48 89 c7             	mov    %rax,%rdi
  8004211f69:	48 b8 6e f9 20 04 80 	movabs $0x800420f96e,%rax
  8004211f70:	00 00 00 
  8004211f73:	ff d0                	callq  *%rax
  8004211f75:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211f79:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f7d:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211f80:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f84:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004211f88:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f8c:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211f93:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211f98:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211f9c:	e9 ed 02 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset:
			*row_pc = pc;
  8004211fa1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211fa5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211fa9:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211fac:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211fb0:	48 89 c7             	mov    %rax,%rdi
  8004211fb3:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211fba:	00 00 00 
  8004211fbd:	ff d0                	callq  *%rax
  8004211fbf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004211fc3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211fc7:	48 89 c7             	mov    %rax,%rdi
  8004211fca:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004211fd1:	00 00 00 
  8004211fd4:	ff d0                	callq  *%rax
  8004211fd6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211fda:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211fde:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211fe2:	0f b7 c0             	movzwl %ax,%eax
  8004211fe5:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211fe9:	77 0c                	ja     8004211ff7 <_dwarf_frame_run_inst+0xb2a>
  8004211feb:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211ff2:	e9 a5 02 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004211ff7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ffb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211fff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212003:	48 89 d0             	mov    %rdx,%rax
  8004212006:	48 01 c0             	add    %rax,%rax
  8004212009:	48 01 d0             	add    %rdx,%rax
  800421200c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212010:	48 01 c8             	add    %rcx,%rax
  8004212013:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212016:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421201a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421201e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212022:	48 89 d0             	mov    %rdx,%rax
  8004212025:	48 01 c0             	add    %rax,%rax
  8004212028:	48 01 d0             	add    %rdx,%rax
  800421202b:	48 c1 e0 03          	shl    $0x3,%rax
  800421202f:	48 01 c8             	add    %rcx,%rax
  8004212032:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212036:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421203a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421203e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212042:	48 89 d0             	mov    %rdx,%rax
  8004212045:	48 01 c0             	add    %rax,%rax
  8004212048:	48 01 d0             	add    %rdx,%rax
  800421204b:	48 c1 e0 03          	shl    $0x3,%rax
  800421204f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212053:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212057:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421205b:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  800421205f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212063:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212067:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421206b:	48 89 d0             	mov    %rdx,%rax
  800421206e:	48 01 c0             	add    %rax,%rax
  8004212071:	48 01 d0             	add    %rdx,%rax
  8004212074:	48 c1 e0 03          	shl    $0x3,%rax
  8004212078:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421207c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212083:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212088:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800421208c:	e9 fd 01 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  8004212091:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212095:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212099:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800421209c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042120a0:	48 89 c7             	mov    %rax,%rdi
  80042120a3:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  80042120aa:	00 00 00 
  80042120ad:	ff d0                	callq  *%rax
  80042120af:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  80042120b3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042120b7:	48 89 c7             	mov    %rax,%rdi
  80042120ba:	48 b8 6e f9 20 04 80 	movabs $0x800420f96e,%rax
  80042120c1:	00 00 00 
  80042120c4:	ff d0                	callq  *%rax
  80042120c6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042120ca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120ce:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042120d2:	0f b7 c0             	movzwl %ax,%eax
  80042120d5:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042120d9:	77 0c                	ja     80042120e7 <_dwarf_frame_run_inst+0xc1a>
  80042120db:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042120e2:	e9 b5 01 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  80042120e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120eb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120ef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042120f3:	48 89 d0             	mov    %rdx,%rax
  80042120f6:	48 01 c0             	add    %rax,%rax
  80042120f9:	48 01 d0             	add    %rdx,%rax
  80042120fc:	48 c1 e0 03          	shl    $0x3,%rax
  8004212100:	48 01 c8             	add    %rcx,%rax
  8004212103:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212106:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421210a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421210e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212112:	48 89 d0             	mov    %rdx,%rax
  8004212115:	48 01 c0             	add    %rax,%rax
  8004212118:	48 01 d0             	add    %rdx,%rax
  800421211b:	48 c1 e0 03          	shl    $0x3,%rax
  800421211f:	48 01 c8             	add    %rcx,%rax
  8004212122:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212126:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421212a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421212e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212132:	48 89 d0             	mov    %rdx,%rax
  8004212135:	48 01 c0             	add    %rax,%rax
  8004212138:	48 01 d0             	add    %rdx,%rax
  800421213b:	48 c1 e0 03          	shl    $0x3,%rax
  800421213f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212143:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212147:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421214b:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  800421214f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212153:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212157:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421215b:	48 89 d0             	mov    %rdx,%rax
  800421215e:	48 01 c0             	add    %rax,%rax
  8004212161:	48 01 d0             	add    %rdx,%rax
  8004212164:	48 c1 e0 03          	shl    $0x3,%rax
  8004212168:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421216c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212173:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212178:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800421217c:	e9 0d 01 00 00       	jmpq   800421228e <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_expression:
			*row_pc = pc;
  8004212181:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212185:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212189:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800421218c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212190:	48 89 c7             	mov    %rax,%rdi
  8004212193:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  800421219a:	00 00 00 
  800421219d:	ff d0                	callq  *%rax
  800421219f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042121a3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121a7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042121ab:	0f b7 c0             	movzwl %ax,%eax
  80042121ae:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042121b2:	77 0c                	ja     80042121c0 <_dwarf_frame_run_inst+0xcf3>
  80042121b4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042121bb:	e9 dc 00 00 00       	jmpq   800421229c <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  80042121c0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121c4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042121c8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042121cc:	48 89 d0             	mov    %rdx,%rax
  80042121cf:	48 01 c0             	add    %rax,%rax
  80042121d2:	48 01 d0             	add    %rdx,%rax
  80042121d5:	48 c1 e0 03          	shl    $0x3,%rax
  80042121d9:	48 01 c8             	add    %rcx,%rax
  80042121dc:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  80042121df:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121e3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042121e7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042121eb:	48 89 d0             	mov    %rdx,%rax
  80042121ee:	48 01 c0             	add    %rax,%rax
  80042121f1:	48 01 d0             	add    %rdx,%rax
  80042121f4:	48 c1 e0 03          	shl    $0x3,%rax
  80042121f8:	48 01 c8             	add    %rcx,%rax
  80042121fb:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  80042121ff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212203:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212207:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421220b:	48 89 d0             	mov    %rdx,%rax
  800421220e:	48 01 c0             	add    %rax,%rax
  8004212211:	48 01 d0             	add    %rdx,%rax
  8004212214:	48 c1 e0 03          	shl    $0x3,%rax
  8004212218:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  800421221c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212220:	48 89 c7             	mov    %rax,%rdi
  8004212223:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  800421222a:	00 00 00 
  800421222d:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  800421222f:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004212233:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212237:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421223b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421223f:	48 89 d0             	mov    %rdx,%rax
  8004212242:	48 01 c0             	add    %rax,%rax
  8004212245:	48 01 d0             	add    %rdx,%rax
  8004212248:	48 c1 e0 03          	shl    $0x3,%rax
  800421224c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212250:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212254:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004212258:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800421225c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212260:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212264:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212268:	48 89 d0             	mov    %rdx,%rax
  800421226b:	48 01 c0             	add    %rax,%rax
  800421226e:	48 01 d0             	add    %rdx,%rax
  8004212271:	48 c1 e0 03          	shl    $0x3,%rax
  8004212275:	48 01 f0             	add    %rsi,%rax
  8004212278:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421227c:	48 01 c8             	add    %rcx,%rax
  800421227f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004212283:	eb 09                	jmp    800421228e <_dwarf_frame_run_inst+0xdc1>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004212285:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  800421228c:	eb 0e                	jmp    800421229c <_dwarf_frame_run_inst+0xdcf>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  800421228e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212292:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212296:	0f 82 b8 f2 ff ff    	jb     8004211554 <_dwarf_frame_run_inst+0x87>
			goto program_done;
		}
	}

program_done:
	return (ret);
  800421229c:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  800421229f:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  80042122a6:	5b                   	pop    %rbx
  80042122a7:	5d                   	pop    %rbp
  80042122a8:	c3                   	retq   

00000080042122a9 <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  80042122a9:	55                   	push   %rbp
  80042122aa:	48 89 e5             	mov    %rsp,%rbp
  80042122ad:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  80042122b1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042122b5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042122b9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042122bd:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042122c1:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  80042122c5:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  80042122c9:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042122ce:	75 35                	jne    8004212305 <_dwarf_frame_get_internal_table+0x5c>
  80042122d0:	48 b9 b8 87 21 04 80 	movabs $0x80042187b8,%rcx
  80042122d7:	00 00 00 
  80042122da:	48 ba c7 86 21 04 80 	movabs $0x80042186c7,%rdx
  80042122e1:	00 00 00 
  80042122e4:	be 83 01 00 00       	mov    $0x183,%esi
  80042122e9:	48 bf dc 86 21 04 80 	movabs $0x80042186dc,%rdi
  80042122f0:	00 00 00 
  80042122f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042122f8:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042122ff:	00 00 00 
  8004212302:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  8004212305:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421230a:	75 35                	jne    8004212341 <_dwarf_frame_get_internal_table+0x98>
  800421230c:	48 b9 c7 87 21 04 80 	movabs $0x80042187c7,%rcx
  8004212313:	00 00 00 
  8004212316:	48 ba c7 86 21 04 80 	movabs $0x80042186c7,%rdx
  800421231d:	00 00 00 
  8004212320:	be 86 01 00 00       	mov    $0x186,%esi
  8004212325:	48 bf dc 86 21 04 80 	movabs $0x80042186dc,%rdi
  800421232c:	00 00 00 
  800421232f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212334:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800421233b:	00 00 00 
  800421233e:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  8004212341:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212345:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212349:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  800421234d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212351:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212356:	be 00 00 00 00       	mov    $0x0,%esi
  800421235b:	48 89 c7             	mov    %rax,%rdi
  800421235e:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004212365:	00 00 00 
  8004212368:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  800421236a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421236e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212372:	0f b7 d0             	movzwl %ax,%edx
  8004212375:	48 89 d0             	mov    %rdx,%rax
  8004212378:	48 01 c0             	add    %rax,%rax
  800421237b:	48 01 d0             	add    %rdx,%rax
  800421237e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212382:	48 89 c2             	mov    %rax,%rdx
  8004212385:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212389:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421238d:	be 00 00 00 00       	mov    $0x0,%esi
  8004212392:	48 89 c7             	mov    %rax,%rdi
  8004212395:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  800421239c:	00 00 00 
  800421239f:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042123a1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042123a8:	eb 2f                	jmp    80042123d9 <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  80042123aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042123ae:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042123b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042123b5:	48 63 d0             	movslq %eax,%rdx
  80042123b8:	48 89 d0             	mov    %rdx,%rax
  80042123bb:	48 01 c0             	add    %rax,%rax
  80042123be:	48 01 d0             	add    %rdx,%rax
  80042123c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042123c5:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042123c9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042123cd:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  80042123d1:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042123d5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042123d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042123dd:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042123e1:	0f b7 c0             	movzwl %ax,%eax
  80042123e4:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042123e7:	7f c1                	jg     80042123aa <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  80042123e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042123ed:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042123f1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  80042123f5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042123fa:	75 35                	jne    8004212431 <_dwarf_frame_get_internal_table+0x188>
  80042123fc:	48 b9 d3 87 21 04 80 	movabs $0x80042187d3,%rcx
  8004212403:	00 00 00 
  8004212406:	48 ba c7 86 21 04 80 	movabs $0x80042186c7,%rdx
  800421240d:	00 00 00 
  8004212410:	be 95 01 00 00       	mov    $0x195,%esi
  8004212415:	48 bf dc 86 21 04 80 	movabs $0x80042186dc,%rdi
  800421241c:	00 00 00 
  800421241f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212424:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  800421242b:	00 00 00 
  800421242e:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004212431:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212435:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004212439:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421243d:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004212441:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212445:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004212449:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421244d:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004212451:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004212455:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212459:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  800421245d:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004212462:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004212466:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800421246b:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004212472:	ff ff 
  8004212474:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  800421247b:	00 
  800421247c:	48 89 c7             	mov    %rax,%rdi
  800421247f:	48 b8 cd 14 21 04 80 	movabs $0x80042114cd,%rax
  8004212486:	00 00 00 
  8004212489:	ff d0                	callq  *%rax
  800421248b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  800421248e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212492:	74 08                	je     800421249c <_dwarf_frame_get_internal_table+0x1f3>
		return (ret);
  8004212494:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212497:	e9 98 00 00 00       	jmpq   8004212534 <_dwarf_frame_get_internal_table+0x28b>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  800421249c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124a0:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042124a4:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042124a8:	77 6f                	ja     8004212519 <_dwarf_frame_get_internal_table+0x270>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  80042124aa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124ae:	48 8b 78 30          	mov    0x30(%rax),%rdi
  80042124b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124b6:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042124ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124be:	4c 8b 50 38          	mov    0x38(%rax),%r10
  80042124c2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124c6:	48 8b 48 58          	mov    0x58(%rax),%rcx
  80042124ca:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124ce:	48 8b 50 50          	mov    0x50(%rax),%rdx
  80042124d2:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042124d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042124da:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  80042124de:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  80042124e3:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  80042124e7:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  80042124ec:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  80042124f0:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042124f5:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042124f9:	4d 89 d0             	mov    %r10,%r8
  80042124fc:	48 89 c7             	mov    %rax,%rdi
  80042124ff:	48 b8 cd 14 21 04 80 	movabs $0x80042114cd,%rax
  8004212506:	00 00 00 
  8004212509:	ff d0                	callq  *%rax
  800421250b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  800421250e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212512:	74 05                	je     8004212519 <_dwarf_frame_get_internal_table+0x270>
			return (ret);
  8004212514:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212517:	eb 1b                	jmp    8004212534 <_dwarf_frame_get_internal_table+0x28b>
	}

	*ret_rt = rt;
  8004212519:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421251d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212521:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  8004212524:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212528:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421252c:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  800421252f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212534:	c9                   	leaveq 
  8004212535:	c3                   	retq   

0000008004212536 <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  8004212536:	55                   	push   %rbp
  8004212537:	48 89 e5             	mov    %rsp,%rbp
  800421253a:	48 83 ec 50          	sub    $0x50,%rsp
  800421253e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212542:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212546:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421254a:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  800421254e:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8004212552:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  8004212556:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421255b:	74 07                	je     8004212564 <dwarf_get_fde_info_for_all_regs+0x2e>
  800421255d:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004212562:	75 0a                	jne    800421256e <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004212564:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212569:	e9 eb 02 00 00       	jmpq   8004212859 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	assert(dbg != NULL);
  800421256e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212573:	75 35                	jne    80042125aa <dwarf_get_fde_info_for_all_regs+0x74>
  8004212575:	48 b9 c7 87 21 04 80 	movabs $0x80042187c7,%rcx
  800421257c:	00 00 00 
  800421257f:	48 ba c7 86 21 04 80 	movabs $0x80042186c7,%rdx
  8004212586:	00 00 00 
  8004212589:	be bf 01 00 00       	mov    $0x1bf,%esi
  800421258e:	48 bf dc 86 21 04 80 	movabs $0x80042186dc,%rdi
  8004212595:	00 00 00 
  8004212598:	b8 00 00 00 00       	mov    $0x0,%eax
  800421259d:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042125a4:	00 00 00 
  80042125a7:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  80042125aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042125ae:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042125b2:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042125b6:	77 19                	ja     80042125d1 <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  80042125b8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042125bc:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042125c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042125c4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042125c8:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  80042125cb:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042125cf:	77 0a                	ja     80042125db <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  80042125d1:	b8 01 00 00 00       	mov    $0x1,%eax
  80042125d6:	e9 7e 02 00 00       	jmpq   8004212859 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  80042125db:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  80042125df:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  80042125e3:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  80042125e7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042125eb:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042125ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042125f3:	4d 89 c1             	mov    %r8,%r9
  80042125f6:	49 89 f8             	mov    %rdi,%r8
  80042125f9:	48 89 c7             	mov    %rax,%rdi
  80042125fc:	48 b8 a9 22 21 04 80 	movabs $0x80042122a9,%rax
  8004212603:	00 00 00 
  8004212606:	ff d0                	callq  *%rax
  8004212608:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  800421260b:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421260f:	74 0a                	je     800421261b <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  8004212611:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212616:	e9 3e 02 00 00       	jmpq   8004212859 <dwarf_get_fde_info_for_all_regs+0x323>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  800421261b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421261f:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212623:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  8004212627:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  800421262c:	0f 87 b1 00 00 00    	ja     80042126e3 <dwarf_get_fde_info_for_all_regs+0x1ad>
		reg_table->rules[cfa].dw_offset_relevant =
  8004212632:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  8004212636:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421263a:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  800421263d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212641:	48 63 c9             	movslq %ecx,%rcx
  8004212644:	48 83 c1 01          	add    $0x1,%rcx
  8004212648:	48 c1 e1 04          	shl    $0x4,%rcx
  800421264c:	48 01 ca             	add    %rcx,%rdx
  800421264f:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  8004212651:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212655:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212659:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800421265d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212661:	48 63 c9             	movslq %ecx,%rcx
  8004212664:	48 83 c1 01          	add    $0x1,%rcx
  8004212668:	48 c1 e1 04          	shl    $0x4,%rcx
  800421266c:	48 01 ca             	add    %rcx,%rdx
  800421266f:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004212672:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212676:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421267a:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  800421267e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212682:	48 63 c9             	movslq %ecx,%rcx
  8004212685:	48 83 c1 01          	add    $0x1,%rcx
  8004212689:	48 c1 e1 04          	shl    $0x4,%rcx
  800421268d:	48 01 ca             	add    %rcx,%rdx
  8004212690:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004212694:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212698:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421269c:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042126a0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042126a4:	48 63 c9             	movslq %ecx,%rcx
  80042126a7:	48 83 c1 01          	add    $0x1,%rcx
  80042126ab:	48 c1 e1 04          	shl    $0x4,%rcx
  80042126af:	48 01 ca             	add    %rcx,%rdx
  80042126b2:	48 83 c2 08          	add    $0x8,%rdx
  80042126b6:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  80042126b9:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80042126bd:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042126c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042126c5:	48 63 d2             	movslq %edx,%rdx
  80042126c8:	48 83 c2 01          	add    $0x1,%rdx
  80042126cc:	48 c1 e2 04          	shl    $0x4,%rdx
  80042126d0:	48 01 d0             	add    %rdx,%rax
  80042126d3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042126d7:	48 8b 00             	mov    (%rax),%rax
  80042126da:	48 89 01             	mov    %rax,(%rcx)
  80042126dd:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  80042126e1:	eb 3c                	jmp    800421271f <dwarf_get_fde_info_for_all_regs+0x1e9>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  80042126e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126e7:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  80042126ea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042126ee:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  80042126f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126f4:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80042126f8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042126fc:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  80042126ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212703:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  8004212707:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421270b:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  800421270f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212713:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212717:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421271b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800421271f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004212726:	e9 fd 00 00 00       	jmpq   8004212828 <dwarf_get_fde_info_for_all_regs+0x2f2>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  800421272b:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  800421272f:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212732:	75 05                	jne    8004212739 <dwarf_get_fde_info_for_all_regs+0x203>
			continue;
  8004212734:	e9 eb 00 00 00       	jmpq   8004212824 <dwarf_get_fde_info_for_all_regs+0x2ee>

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  8004212739:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421273d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212741:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212744:	48 63 d0             	movslq %eax,%rdx
  8004212747:	48 89 d0             	mov    %rdx,%rax
  800421274a:	48 01 c0             	add    %rax,%rax
  800421274d:	48 01 d0             	add    %rdx,%rax
  8004212750:	48 c1 e0 03          	shl    $0x3,%rax
  8004212754:	48 01 c8             	add    %rcx,%rax
  8004212757:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  800421275a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421275e:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212761:	48 63 c9             	movslq %ecx,%rcx
  8004212764:	48 83 c1 01          	add    $0x1,%rcx
  8004212768:	48 c1 e1 04          	shl    $0x4,%rcx
  800421276c:	48 01 ca             	add    %rcx,%rdx
  800421276f:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  8004212771:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212775:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212779:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421277c:	48 63 d0             	movslq %eax,%rdx
  800421277f:	48 89 d0             	mov    %rdx,%rax
  8004212782:	48 01 c0             	add    %rax,%rax
  8004212785:	48 01 d0             	add    %rdx,%rax
  8004212788:	48 c1 e0 03          	shl    $0x3,%rax
  800421278c:	48 01 c8             	add    %rcx,%rax
  800421278f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  8004212793:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212797:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421279a:	48 63 c9             	movslq %ecx,%rcx
  800421279d:	48 83 c1 01          	add    $0x1,%rcx
  80042127a1:	48 c1 e1 04          	shl    $0x4,%rcx
  80042127a5:	48 01 ca             	add    %rcx,%rdx
  80042127a8:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  80042127ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127af:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042127b3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042127b6:	48 63 d0             	movslq %eax,%rdx
  80042127b9:	48 89 d0             	mov    %rdx,%rax
  80042127bc:	48 01 c0             	add    %rax,%rax
  80042127bf:	48 01 d0             	add    %rdx,%rax
  80042127c2:	48 c1 e0 03          	shl    $0x3,%rax
  80042127c6:	48 01 c8             	add    %rcx,%rax
  80042127c9:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042127cd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042127d1:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042127d4:	48 63 c9             	movslq %ecx,%rcx
  80042127d7:	48 83 c1 01          	add    $0x1,%rcx
  80042127db:	48 c1 e1 04          	shl    $0x4,%rcx
  80042127df:	48 01 ca             	add    %rcx,%rdx
  80042127e2:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  80042127e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127ea:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042127ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042127f1:	48 63 d0             	movslq %eax,%rdx
  80042127f4:	48 89 d0             	mov    %rdx,%rax
  80042127f7:	48 01 c0             	add    %rax,%rax
  80042127fa:	48 01 d0             	add    %rdx,%rax
  80042127fd:	48 c1 e0 03          	shl    $0x3,%rax
  8004212801:	48 01 c8             	add    %rcx,%rax
  8004212804:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  8004212808:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421280c:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421280f:	48 63 c9             	movslq %ecx,%rcx
  8004212812:	48 83 c1 01          	add    $0x1,%rcx
  8004212816:	48 c1 e1 04          	shl    $0x4,%rcx
  800421281a:	48 01 ca             	add    %rcx,%rdx
  800421281d:	48 83 c2 08          	add    $0x8,%rdx
  8004212821:	48 89 02             	mov    %rax,(%rdx)

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  8004212824:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004212828:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  800421282c:	7f 14                	jg     8004212842 <dwarf_get_fde_info_for_all_regs+0x30c>
  800421282e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212832:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8004212836:	0f b7 c0             	movzwl %ax,%eax
  8004212839:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421283c:	0f 8f e9 fe ff ff    	jg     800421272b <dwarf_get_fde_info_for_all_regs+0x1f5>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  8004212842:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004212847:	74 0b                	je     8004212854 <dwarf_get_fde_info_for_all_regs+0x31e>
  8004212849:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421284d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212851:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  8004212854:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212859:	c9                   	leaveq 
  800421285a:	c3                   	retq   

000000800421285b <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  800421285b:	55                   	push   %rbp
  800421285c:	48 89 e5             	mov    %rsp,%rbp
  800421285f:	48 83 ec 40          	sub    $0x40,%rsp
  8004212863:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212867:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421286b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421286f:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004212873:	44 89 c0             	mov    %r8d,%eax
  8004212876:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800421287a:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  800421287d:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004212881:	75 0a                	jne    800421288d <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004212883:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212888:	e9 e6 01 00 00       	jmpq   8004212a73 <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  800421288d:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212891:	83 e0 f0             	and    $0xfffffff0,%eax
  8004212894:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004212897:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  800421289b:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421289f:	83 f8 0c             	cmp    $0xc,%eax
  80042128a2:	0f 87 72 01 00 00    	ja     8004212a1a <_dwarf_frame_read_lsb_encoded+0x1bf>
  80042128a8:	89 c0                	mov    %eax,%eax
  80042128aa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042128b1:	00 
  80042128b2:	48 b8 e0 87 21 04 80 	movabs $0x80042187e0,%rax
  80042128b9:	00 00 00 
  80042128bc:	48 01 d0             	add    %rdx,%rax
  80042128bf:	48 8b 00             	mov    (%rax),%rax
  80042128c2:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  80042128c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128c8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042128cc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042128d0:	8b 52 28             	mov    0x28(%rdx),%edx
  80042128d3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042128d7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042128db:	48 89 cf             	mov    %rcx,%rdi
  80042128de:	ff d0                	callq  *%rax
  80042128e0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042128e4:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042128e7:	e9 35 01 00 00       	jmpq   8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042128ec:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042128f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042128f4:	48 89 d6             	mov    %rdx,%rsi
  80042128f7:	48 89 c7             	mov    %rax,%rdi
  80042128fa:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  8004212901:	00 00 00 
  8004212904:	ff d0                	callq  *%rax
  8004212906:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421290a:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421290d:	e9 0f 01 00 00       	jmpq   8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  8004212912:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212916:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421291a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421291e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212922:	ba 02 00 00 00       	mov    $0x2,%edx
  8004212927:	48 89 cf             	mov    %rcx,%rdi
  800421292a:	ff d0                	callq  *%rax
  800421292c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212930:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212933:	e9 e9 00 00 00       	jmpq   8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004212938:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421293c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212940:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212944:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212948:	ba 04 00 00 00       	mov    $0x4,%edx
  800421294d:	48 89 cf             	mov    %rcx,%rdi
  8004212950:	ff d0                	callq  *%rax
  8004212952:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212956:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212959:	e9 c3 00 00 00       	jmpq   8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  800421295e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212962:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212966:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421296a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421296e:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212973:	48 89 cf             	mov    %rcx,%rdi
  8004212976:	ff d0                	callq  *%rax
  8004212978:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421297c:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421297f:	e9 9d 00 00 00       	jmpq   8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004212984:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212988:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421298c:	48 89 d6             	mov    %rdx,%rsi
  800421298f:	48 89 c7             	mov    %rax,%rdi
  8004212992:	48 b8 4b f8 20 04 80 	movabs $0x800420f84b,%rax
  8004212999:	00 00 00 
  800421299c:	ff d0                	callq  *%rax
  800421299e:	48 89 c2             	mov    %rax,%rdx
  80042129a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129a5:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042129a8:	eb 77                	jmp    8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  80042129aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042129ae:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042129b2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042129b6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042129ba:	ba 02 00 00 00       	mov    $0x2,%edx
  80042129bf:	48 89 cf             	mov    %rcx,%rdi
  80042129c2:	ff d0                	callq  *%rax
  80042129c4:	48 0f bf d0          	movswq %ax,%rdx
  80042129c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129cc:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042129cf:	eb 50                	jmp    8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  80042129d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042129d5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042129d9:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042129dd:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042129e1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042129e6:	48 89 cf             	mov    %rcx,%rdi
  80042129e9:	ff d0                	callq  *%rax
  80042129eb:	48 63 d0             	movslq %eax,%rdx
  80042129ee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129f2:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042129f5:	eb 2a                	jmp    8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042129f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042129fb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042129ff:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212a03:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212a07:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212a0c:	48 89 cf             	mov    %rcx,%rdi
  8004212a0f:	ff d0                	callq  *%rax
  8004212a11:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212a15:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212a18:	eb 07                	jmp    8004212a21 <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212a1a:	b8 14 00 00 00       	mov    $0x14,%eax
  8004212a1f:	eb 52                	jmp    8004212a73 <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  8004212a21:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004212a25:	75 47                	jne    8004212a6e <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004212a27:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212a2b:	83 f8 01             	cmp    $0x1,%eax
  8004212a2e:	7c 3d                	jl     8004212a6d <_dwarf_frame_read_lsb_encoded+0x212>
  8004212a30:	83 f8 04             	cmp    $0x4,%eax
  8004212a33:	7e 0a                	jle    8004212a3f <_dwarf_frame_read_lsb_encoded+0x1e4>
  8004212a35:	83 e8 09             	sub    $0x9,%eax
  8004212a38:	83 f8 03             	cmp    $0x3,%eax
  8004212a3b:	77 30                	ja     8004212a6d <_dwarf_frame_read_lsb_encoded+0x212>
  8004212a3d:	eb 17                	jmp    8004212a56 <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004212a3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a43:	48 8b 10             	mov    (%rax),%rdx
  8004212a46:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a4a:	48 01 c2             	add    %rax,%rdx
  8004212a4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a51:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004212a54:	eb 18                	jmp    8004212a6e <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004212a56:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a5a:	48 8b 10             	mov    (%rax),%rdx
  8004212a5d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a61:	48 01 c2             	add    %rax,%rdx
  8004212a64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a68:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004212a6b:	eb 01                	jmp    8004212a6e <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004212a6d:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004212a6e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212a73:	c9                   	leaveq 
  8004212a74:	c3                   	retq   

0000008004212a75 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  8004212a75:	55                   	push   %rbp
  8004212a76:	48 89 e5             	mov    %rsp,%rbp
  8004212a79:	48 83 ec 50          	sub    $0x50,%rsp
  8004212a7d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212a81:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212a85:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004212a89:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a8d:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212a91:	48 85 c0             	test   %rax,%rax
  8004212a94:	74 0f                	je     8004212aa5 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004212a96:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a9a:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212a9e:	0f b6 00             	movzbl (%rax),%eax
  8004212aa1:	3c 7a                	cmp    $0x7a,%al
  8004212aa3:	74 35                	je     8004212ada <_dwarf_frame_parse_lsb_cie_augment+0x65>
  8004212aa5:	48 b9 48 88 21 04 80 	movabs $0x8004218848,%rcx
  8004212aac:	00 00 00 
  8004212aaf:	48 ba c7 86 21 04 80 	movabs $0x80042186c7,%rdx
  8004212ab6:	00 00 00 
  8004212ab9:	be 4a 02 00 00       	mov    $0x24a,%esi
  8004212abe:	48 bf dc 86 21 04 80 	movabs $0x80042186dc,%rdi
  8004212ac5:	00 00 00 
  8004212ac8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212acd:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004212ad4:	00 00 00 
  8004212ad7:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  8004212ada:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212ade:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212ae2:	48 83 c0 01          	add    $0x1,%rax
  8004212ae6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004212aea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212aee:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212af2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  8004212af6:	e9 af 00 00 00       	jmpq   8004212baa <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  8004212afb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212aff:	0f b6 00             	movzbl (%rax),%eax
  8004212b02:	0f b6 c0             	movzbl %al,%eax
  8004212b05:	83 f8 50             	cmp    $0x50,%eax
  8004212b08:	74 18                	je     8004212b22 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004212b0a:	83 f8 52             	cmp    $0x52,%eax
  8004212b0d:	74 77                	je     8004212b86 <_dwarf_frame_parse_lsb_cie_augment+0x111>
  8004212b0f:	83 f8 4c             	cmp    $0x4c,%eax
  8004212b12:	0f 85 86 00 00 00    	jne    8004212b9e <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004212b18:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004212b1d:	e9 83 00 00 00       	jmpq   8004212ba5 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004212b22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212b26:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212b2a:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004212b2e:	0f b6 00             	movzbl (%rax),%eax
  8004212b31:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  8004212b34:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004212b3b:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004212b3c:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  8004212b41:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004212b45:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212b49:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004212b4d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b51:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004212b55:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212b59:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004212b5f:	48 89 c7             	mov    %rax,%rdi
  8004212b62:	48 b8 5b 28 21 04 80 	movabs $0x800421285b,%rax
  8004212b69:	00 00 00 
  8004212b6c:	ff d0                	callq  *%rax
  8004212b6e:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004212b71:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004212b75:	74 05                	je     8004212b7c <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  8004212b77:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004212b7a:	eb 42                	jmp    8004212bbe <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004212b7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212b80:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  8004212b84:	eb 1f                	jmp    8004212ba5 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  8004212b86:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212b8a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212b8e:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004212b92:	0f b6 10             	movzbl (%rax),%edx
  8004212b95:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212b99:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004212b9c:	eb 07                	jmp    8004212ba5 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212b9e:	b8 14 00 00 00       	mov    $0x14,%eax
  8004212ba3:	eb 19                	jmp    8004212bbe <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  8004212ba5:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004212baa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212bae:	0f b6 00             	movzbl (%rax),%eax
  8004212bb1:	84 c0                	test   %al,%al
  8004212bb3:	0f 85 42 ff ff ff    	jne    8004212afb <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  8004212bb9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212bbe:	c9                   	leaveq 
  8004212bbf:	c3                   	retq   

0000008004212bc0 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  8004212bc0:	55                   	push   %rbp
  8004212bc1:	48 89 e5             	mov    %rsp,%rbp
  8004212bc4:	48 83 ec 60          	sub    $0x60,%rsp
  8004212bc8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212bcc:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212bd0:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212bd4:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212bd8:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  8004212bdc:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004212be1:	75 35                	jne    8004212c18 <_dwarf_frame_set_cie+0x58>
  8004212be3:	48 b9 7d 88 21 04 80 	movabs $0x800421887d,%rcx
  8004212bea:	00 00 00 
  8004212bed:	48 ba c7 86 21 04 80 	movabs $0x80042186c7,%rdx
  8004212bf4:	00 00 00 
  8004212bf7:	be 7b 02 00 00       	mov    $0x27b,%esi
  8004212bfc:	48 bf dc 86 21 04 80 	movabs $0x80042186dc,%rdi
  8004212c03:	00 00 00 
  8004212c06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212c0b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004212c12:	00 00 00 
  8004212c15:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004212c18:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212c1c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004212c20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c24:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c28:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004212c2b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212c2f:	48 8b 10             	mov    (%rax),%rdx
  8004212c32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c36:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212c3a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c3e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c42:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c46:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212c4a:	48 89 d1             	mov    %rdx,%rcx
  8004212c4d:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212c51:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212c56:	48 89 cf             	mov    %rcx,%rdi
  8004212c59:	ff d0                	callq  *%rax
  8004212c5b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212c5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212c64:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212c68:	75 2e                	jne    8004212c98 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004212c6a:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004212c71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c75:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c79:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c7d:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212c81:	48 89 d1             	mov    %rdx,%rcx
  8004212c84:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212c88:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212c8d:	48 89 cf             	mov    %rcx,%rdi
  8004212c90:	ff d0                	callq  *%rax
  8004212c92:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212c96:	eb 07                	jmp    8004212c9f <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004212c98:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004212c9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ca3:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212ca7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212cab:	48 8b 00             	mov    (%rax),%rax
  8004212cae:	48 29 c2             	sub    %rax,%rdx
  8004212cb1:	48 89 d0             	mov    %rdx,%rax
  8004212cb4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212cb8:	73 0a                	jae    8004212cc4 <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212cba:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212cbf:	e9 5d 03 00 00       	jmpq   8004213021 <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004212cc4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212cc8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ccc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212cd0:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212cd4:	48 89 d1             	mov    %rdx,%rcx
  8004212cd7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212cda:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212cde:	48 89 cf             	mov    %rcx,%rdi
  8004212ce1:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004212ce3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ce7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212ceb:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212cef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212cf3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212cf7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212cfb:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212cff:	48 89 d1             	mov    %rdx,%rcx
  8004212d02:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212d06:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212d0b:	48 89 cf             	mov    %rcx,%rdi
  8004212d0e:	ff d0                	callq  *%rax
  8004212d10:	89 c2                	mov    %eax,%edx
  8004212d12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d16:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212d1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d1e:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212d22:	66 83 f8 01          	cmp    $0x1,%ax
  8004212d26:	74 26                	je     8004212d4e <_dwarf_frame_set_cie+0x18e>
  8004212d28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d2c:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212d30:	66 83 f8 03          	cmp    $0x3,%ax
  8004212d34:	74 18                	je     8004212d4e <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  8004212d36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d3a:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212d3e:	66 83 f8 04          	cmp    $0x4,%ax
  8004212d42:	74 0a                	je     8004212d4e <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004212d44:	b8 16 00 00 00       	mov    $0x16,%eax
  8004212d49:	e9 d3 02 00 00       	jmpq   8004213021 <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212d4e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d52:	48 8b 10             	mov    (%rax),%rdx
  8004212d55:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d59:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212d5d:	48 01 d0             	add    %rdx,%rax
  8004212d60:	48 89 c2             	mov    %rax,%rdx
  8004212d63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d67:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004212d6b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d6f:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212d73:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004212d77:	90                   	nop
  8004212d78:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d7c:	48 8b 00             	mov    (%rax),%rax
  8004212d7f:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004212d83:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212d87:	48 89 0a             	mov    %rcx,(%rdx)
  8004212d8a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212d8e:	48 01 d0             	add    %rdx,%rax
  8004212d91:	0f b6 00             	movzbl (%rax),%eax
  8004212d94:	84 c0                	test   %al,%al
  8004212d96:	75 e0                	jne    8004212d78 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004212d98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d9c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212da0:	0f b6 00             	movzbl (%rax),%eax
  8004212da3:	84 c0                	test   %al,%al
  8004212da5:	74 48                	je     8004212def <_dwarf_frame_set_cie+0x22f>
  8004212da7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212dab:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212daf:	0f b6 00             	movzbl (%rax),%eax
  8004212db2:	3c 7a                	cmp    $0x7a,%al
  8004212db4:	74 39                	je     8004212def <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004212db6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212dba:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212dbe:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212dc2:	75 07                	jne    8004212dcb <_dwarf_frame_set_cie+0x20b>
  8004212dc4:	b8 04 00 00 00       	mov    $0x4,%eax
  8004212dc9:	eb 05                	jmp    8004212dd0 <_dwarf_frame_set_cie+0x210>
  8004212dcb:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004212dd0:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004212dd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212dd7:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004212ddb:	48 01 c2             	add    %rax,%rdx
  8004212dde:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212de2:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004212de5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212dea:	e9 32 02 00 00       	jmpq   8004213021 <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004212def:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212df3:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212df7:	48 be 85 88 21 04 80 	movabs $0x8004218885,%rsi
  8004212dfe:	00 00 00 
  8004212e01:	48 89 c7             	mov    %rax,%rdi
  8004212e04:	48 b8 02 f2 20 04 80 	movabs $0x800420f202,%rax
  8004212e0b:	00 00 00 
  8004212e0e:	ff d0                	callq  *%rax
  8004212e10:	48 85 c0             	test   %rax,%rax
  8004212e13:	74 28                	je     8004212e3d <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004212e15:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e19:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212e1d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212e21:	8b 52 28             	mov    0x28(%rdx),%edx
  8004212e24:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004212e28:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004212e2c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212e30:	48 89 cf             	mov    %rcx,%rdi
  8004212e33:	ff d0                	callq  *%rax
  8004212e35:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212e39:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212e3d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e41:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212e45:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212e49:	48 89 d6             	mov    %rdx,%rsi
  8004212e4c:	48 89 c7             	mov    %rax,%rdi
  8004212e4f:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  8004212e56:	00 00 00 
  8004212e59:	ff d0                	callq  *%rax
  8004212e5b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212e5f:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212e63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e67:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212e6b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212e6f:	48 89 d6             	mov    %rdx,%rsi
  8004212e72:	48 89 c7             	mov    %rax,%rdi
  8004212e75:	48 b8 4b f8 20 04 80 	movabs $0x800420f84b,%rax
  8004212e7c:	00 00 00 
  8004212e7f:	ff d0                	callq  *%rax
  8004212e81:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212e85:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004212e89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e8d:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212e91:	66 83 f8 01          	cmp    $0x1,%ax
  8004212e95:	75 2b                	jne    8004212ec2 <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212e97:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e9b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212e9f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212ea3:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212ea7:	48 89 d1             	mov    %rdx,%rcx
  8004212eaa:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212eae:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212eb3:	48 89 cf             	mov    %rcx,%rdi
  8004212eb6:	ff d0                	callq  *%rax
  8004212eb8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212ebc:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004212ec0:	eb 26                	jmp    8004212ee8 <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212ec2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ec6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212eca:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212ece:	48 89 d6             	mov    %rdx,%rsi
  8004212ed1:	48 89 c7             	mov    %rax,%rdi
  8004212ed4:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  8004212edb:	00 00 00 
  8004212ede:	ff d0                	callq  *%rax
  8004212ee0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212ee4:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004212ee8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212eec:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212ef0:	0f b6 00             	movzbl (%rax),%eax
  8004212ef3:	3c 7a                	cmp    $0x7a,%al
  8004212ef5:	0f 85 93 00 00 00    	jne    8004212f8e <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212efb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212eff:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212f03:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212f07:	48 89 d6             	mov    %rdx,%rsi
  8004212f0a:	48 89 c7             	mov    %rax,%rdi
  8004212f0d:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  8004212f14:	00 00 00 
  8004212f17:	ff d0                	callq  *%rax
  8004212f19:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212f1d:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212f21:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212f25:	48 8b 10             	mov    (%rax),%rdx
  8004212f28:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f2c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212f30:	48 01 d0             	add    %rdx,%rax
  8004212f33:	48 89 c2             	mov    %rax,%rdx
  8004212f36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f3a:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004212f3e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212f42:	48 8b 10             	mov    (%rax),%rdx
  8004212f45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f49:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004212f4d:	48 01 c2             	add    %rax,%rdx
  8004212f50:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212f54:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004212f57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f5b:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004212f5f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212f63:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212f67:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f6b:	48 89 ce             	mov    %rcx,%rsi
  8004212f6e:	48 89 c7             	mov    %rax,%rdi
  8004212f71:	48 b8 75 2a 21 04 80 	movabs $0x8004212a75,%rax
  8004212f78:	00 00 00 
  8004212f7b:	ff d0                	callq  *%rax
  8004212f7d:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004212f80:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212f84:	74 08                	je     8004212f8e <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  8004212f86:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212f89:	e9 93 00 00 00       	jmpq   8004213021 <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212f8e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212f92:	48 8b 10             	mov    (%rax),%rdx
  8004212f95:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f99:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212f9d:	48 01 d0             	add    %rdx,%rax
  8004212fa0:	48 89 c2             	mov    %rax,%rdx
  8004212fa3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fa7:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004212fab:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212faf:	75 2a                	jne    8004212fdb <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004212fb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fb5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212fb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212fbd:	48 01 c2             	add    %rax,%rdx
  8004212fc0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212fc4:	48 8b 00             	mov    (%rax),%rax
  8004212fc7:	48 29 c2             	sub    %rax,%rdx
  8004212fca:	48 89 d0             	mov    %rdx,%rax
  8004212fcd:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004212fd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fd5:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004212fd9:	eb 28                	jmp    8004213003 <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004212fdb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fdf:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212fe3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212fe7:	48 01 c2             	add    %rax,%rdx
  8004212fea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212fee:	48 8b 00             	mov    (%rax),%rax
  8004212ff1:	48 29 c2             	sub    %rax,%rdx
  8004212ff4:	48 89 d0             	mov    %rdx,%rax
  8004212ff7:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004212ffb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fff:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004213003:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213007:	48 8b 10             	mov    (%rax),%rdx
  800421300a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421300e:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004213012:	48 01 c2             	add    %rax,%rdx
  8004213015:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213019:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  800421301c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213021:	c9                   	leaveq 
  8004213022:	c3                   	retq   

0000008004213023 <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004213023:	55                   	push   %rbp
  8004213024:	48 89 e5             	mov    %rsp,%rbp
  8004213027:	48 83 ec 70          	sub    $0x70,%rsp
  800421302b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421302f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213033:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213037:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800421303b:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  800421303f:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004213043:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213047:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  800421304b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421304f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213053:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213056:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421305a:	48 8b 10             	mov    (%rax),%rdx
  800421305d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213061:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213065:	48 01 d0             	add    %rdx,%rax
  8004213068:	48 89 c2             	mov    %rax,%rdx
  800421306b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421306f:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004213073:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213077:	48 8b 10             	mov    (%rax),%rdx
  800421307a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421307e:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213082:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213086:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421308a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421308e:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213092:	48 89 d1             	mov    %rdx,%rcx
  8004213095:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213099:	ba 04 00 00 00       	mov    $0x4,%edx
  800421309e:	48 89 cf             	mov    %rcx,%rdi
  80042130a1:	ff d0                	callq  *%rax
  80042130a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  80042130a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042130ac:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042130b0:	75 2e                	jne    80042130e0 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  80042130b2:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  80042130b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130bd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042130c1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042130c5:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042130c9:	48 89 d1             	mov    %rdx,%rcx
  80042130cc:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042130d0:	ba 08 00 00 00       	mov    $0x8,%edx
  80042130d5:	48 89 cf             	mov    %rcx,%rdi
  80042130d8:	ff d0                	callq  *%rax
  80042130da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042130de:	eb 07                	jmp    80042130e7 <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  80042130e0:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  80042130e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130eb:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042130ef:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042130f3:	48 8b 00             	mov    (%rax),%rax
  80042130f6:	48 29 c2             	sub    %rax,%rdx
  80042130f9:	48 89 d0             	mov    %rdx,%rax
  80042130fc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213100:	73 0a                	jae    800421310c <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213102:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213107:	e9 ca 02 00 00       	jmpq   80042133d6 <_dwarf_frame_set_fde+0x3b3>
	}

	fde->fde_length = length;
  800421310c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213110:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213114:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004213118:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800421311c:	74 5e                	je     800421317c <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  800421311e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213122:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213126:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421312a:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421312e:	48 89 d1             	mov    %rdx,%rcx
  8004213131:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213135:	ba 04 00 00 00       	mov    $0x4,%edx
  800421313a:	48 89 cf             	mov    %rcx,%rdi
  800421313d:	ff d0                	callq  *%rax
  800421313f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213143:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004213147:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421314b:	48 8b 10             	mov    (%rax),%rdx
  800421314e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213152:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213156:	48 29 c2             	sub    %rax,%rdx
  8004213159:	48 89 d0             	mov    %rdx,%rax
  800421315c:	48 83 e8 04          	sub    $0x4,%rax
  8004213160:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004213164:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213168:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421316c:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213170:	75 3d                	jne    80042131af <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004213172:	b8 13 00 00 00       	mov    $0x13,%eax
  8004213177:	e9 5a 02 00 00       	jmpq   80042133d6 <_dwarf_frame_set_fde+0x3b3>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  800421317c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213180:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213184:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213188:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421318c:	48 89 d1             	mov    %rdx,%rcx
  800421318f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213192:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213196:	48 89 cf             	mov    %rcx,%rdi
  8004213199:	ff d0                	callq  *%rax
  800421319b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421319f:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  80042131a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131a7:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042131ab:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  80042131af:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042131b3:	0f 84 c9 00 00 00    	je     8004213282 <_dwarf_frame_set_fde+0x25f>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  80042131b9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042131bd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042131c1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131c5:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042131c8:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  80042131cc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042131d0:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042131d4:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  80042131d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042131dc:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042131e0:	48 89 c2             	mov    %rax,%rdx
  80042131e3:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042131e7:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80042131eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042131ef:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  80042131f3:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042131f7:	48 89 c7             	mov    %rax,%rdi
  80042131fa:	48 b8 5b 28 21 04 80 	movabs $0x800421285b,%rax
  8004213201:	00 00 00 
  8004213204:	ff d0                	callq  *%rax
  8004213206:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004213209:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421320d:	74 08                	je     8004213217 <_dwarf_frame_set_fde+0x1f4>
			return (ret);
  800421320f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213212:	e9 bf 01 00 00       	jmpq   80042133d6 <_dwarf_frame_set_fde+0x3b3>
		fde->fde_initloc = val;
  8004213217:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421321b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421321f:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  8004213223:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213227:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421322b:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  800421322f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213233:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213237:	48 89 c2             	mov    %rax,%rdx
  800421323a:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800421323e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213242:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213246:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  800421324a:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421324e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004213254:	48 89 c7             	mov    %rax,%rdi
  8004213257:	48 b8 5b 28 21 04 80 	movabs $0x800421285b,%rax
  800421325e:	00 00 00 
  8004213261:	ff d0                	callq  *%rax
  8004213263:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004213266:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421326a:	74 08                	je     8004213274 <_dwarf_frame_set_fde+0x251>
			return (ret);
  800421326c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421326f:	e9 62 01 00 00       	jmpq   80042133d6 <_dwarf_frame_set_fde+0x3b3>
		fde->fde_adrange = val;
  8004213274:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213278:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421327c:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004213280:	eb 50                	jmp    80042132d2 <_dwarf_frame_set_fde+0x2af>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213282:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213286:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421328a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421328e:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213291:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213295:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213299:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421329d:	48 89 cf             	mov    %rcx,%rdi
  80042132a0:	ff d0                	callq  *%rax
  80042132a2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042132a6:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042132aa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132ae:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042132b2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042132b6:	8b 52 28             	mov    0x28(%rdx),%edx
  80042132b9:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042132bd:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  80042132c1:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042132c5:	48 89 cf             	mov    %rcx,%rdi
  80042132c8:	ff d0                	callq  *%rax
  80042132ca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042132ce:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  80042132d2:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042132d6:	74 6b                	je     8004213343 <_dwarf_frame_set_fde+0x320>
  80042132d8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042132dc:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042132e0:	0f b6 00             	movzbl (%rax),%eax
  80042132e3:	3c 7a                	cmp    $0x7a,%al
  80042132e5:	75 5c                	jne    8004213343 <_dwarf_frame_set_fde+0x320>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042132e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132eb:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042132ef:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042132f3:	48 89 d6             	mov    %rdx,%rsi
  80042132f6:	48 89 c7             	mov    %rax,%rdi
  80042132f9:	48 b8 ef f8 20 04 80 	movabs $0x800420f8ef,%rax
  8004213300:	00 00 00 
  8004213303:	ff d0                	callq  *%rax
  8004213305:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213309:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421330d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213311:	48 8b 10             	mov    (%rax),%rdx
  8004213314:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213318:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421331c:	48 01 d0             	add    %rdx,%rax
  800421331f:	48 89 c2             	mov    %rax,%rdx
  8004213322:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213326:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  800421332a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421332e:	48 8b 10             	mov    (%rax),%rdx
  8004213331:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213335:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004213339:	48 01 c2             	add    %rax,%rdx
  800421333c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213340:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213343:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213347:	48 8b 10             	mov    (%rax),%rdx
  800421334a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421334e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213352:	48 01 d0             	add    %rdx,%rax
  8004213355:	48 89 c2             	mov    %rax,%rdx
  8004213358:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421335c:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004213360:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213364:	75 2a                	jne    8004213390 <_dwarf_frame_set_fde+0x36d>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004213366:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421336a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421336e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213372:	48 01 c2             	add    %rax,%rdx
  8004213375:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213379:	48 8b 00             	mov    (%rax),%rax
  800421337c:	48 29 c2             	sub    %rax,%rdx
  800421337f:	48 89 d0             	mov    %rdx,%rax
  8004213382:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213386:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421338a:	48 89 50 58          	mov    %rdx,0x58(%rax)
  800421338e:	eb 28                	jmp    80042133b8 <_dwarf_frame_set_fde+0x395>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004213390:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213394:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213398:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421339c:	48 01 c2             	add    %rax,%rdx
  800421339f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133a3:	48 8b 00             	mov    (%rax),%rax
  80042133a6:	48 29 c2             	sub    %rax,%rdx
  80042133a9:	48 89 d0             	mov    %rdx,%rax
  80042133ac:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042133b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133b4:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  80042133b8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133bc:	48 8b 10             	mov    (%rax),%rdx
  80042133bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133c3:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042133c7:	48 01 c2             	add    %rax,%rdx
  80042133ca:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133ce:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  80042133d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042133d6:	c9                   	leaveq 
  80042133d7:	c3                   	retq   

00000080042133d8 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  80042133d8:	55                   	push   %rbp
  80042133d9:	48 89 e5             	mov    %rsp,%rbp
  80042133dc:	48 83 ec 20          	sub    $0x20,%rsp
  80042133e0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042133e4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  80042133e8:	48 b8 a0 46 3d 04 80 	movabs $0x80043d46a0,%rax
  80042133ef:	00 00 00 
  80042133f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  80042133f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133fa:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042133fe:	48 85 c0             	test   %rax,%rax
  8004213401:	74 07                	je     800421340a <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  8004213403:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213408:	eb 33                	jmp    800421343d <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  800421340a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421340e:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  8004213412:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213416:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  800421341a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421341e:	48 b9 60 4f 3d 04 80 	movabs $0x80043d4f60,%rcx
  8004213425:	00 00 00 
  8004213428:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  800421342c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213430:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213434:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  8004213438:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421343d:	c9                   	leaveq 
  800421343e:	c3                   	retq   

000000800421343f <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  800421343f:	55                   	push   %rbp
  8004213440:	48 89 e5             	mov    %rsp,%rbp
  8004213443:	48 83 ec 60          	sub    $0x60,%rsp
  8004213447:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421344b:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800421344e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213452:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004213456:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800421345d:	00 00 00 
  8004213460:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004213464:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  800421346b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421346f:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213473:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004213477:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421347b:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421347f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213483:	48 39 c2             	cmp    %rax,%rdx
  8004213486:	0f 86 fe 01 00 00    	jbe    800421368a <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  800421348c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213490:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004213494:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213498:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421349c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042134a0:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042134a4:	48 89 d1             	mov    %rdx,%rcx
  80042134a7:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042134ab:	ba 04 00 00 00       	mov    $0x4,%edx
  80042134b0:	48 89 cf             	mov    %rcx,%rdi
  80042134b3:	ff d0                	callq  *%rax
  80042134b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  80042134b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042134be:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042134c2:	75 2e                	jne    80042134f2 <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  80042134c4:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  80042134cb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042134cf:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042134d3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042134d7:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042134db:	48 89 d1             	mov    %rdx,%rcx
  80042134de:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042134e2:	ba 08 00 00 00       	mov    $0x8,%edx
  80042134e7:	48 89 cf             	mov    %rcx,%rdi
  80042134ea:	ff d0                	callq  *%rax
  80042134ec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042134f0:	eb 07                	jmp    80042134f9 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  80042134f2:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  80042134f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042134fd:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213501:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213505:	48 29 c2             	sub    %rax,%rdx
  8004213508:	48 89 d0             	mov    %rdx,%rax
  800421350b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421350f:	72 0d                	jb     800421351e <_dwarf_get_next_fde+0xdf>
  8004213511:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213516:	75 10                	jne    8004213528 <_dwarf_get_next_fde+0xe9>
  8004213518:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421351c:	75 0a                	jne    8004213528 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800421351e:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213523:	e9 67 01 00 00       	jmpq   800421368f <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004213528:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421352c:	74 11                	je     800421353f <_dwarf_get_next_fde+0x100>
  800421352e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213533:	75 0a                	jne    800421353f <_dwarf_get_next_fde+0x100>
			return(-1);
  8004213535:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421353a:	e9 50 01 00 00       	jmpq   800421368f <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  800421353f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213543:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213547:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421354b:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421354f:	48 89 d1             	mov    %rdx,%rcx
  8004213552:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213555:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004213559:	48 89 cf             	mov    %rcx,%rdi
  800421355c:	ff d0                	callq  *%rax
  800421355e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  8004213562:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004213566:	74 79                	je     80042135e1 <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004213568:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421356d:	75 32                	jne    80042135a1 <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  800421356f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213573:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004213577:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421357b:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421357f:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004213583:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213587:	49 89 f8             	mov    %rdi,%r8
  800421358a:	48 89 c7             	mov    %rax,%rdi
  800421358d:	48 b8 c0 2b 21 04 80 	movabs $0x8004212bc0,%rax
  8004213594:	00 00 00 
  8004213597:	ff d0                	callq  *%rax
  8004213599:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421359c:	e9 c8 00 00 00       	jmpq   8004213669 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  80042135a1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042135a5:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042135a9:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042135ad:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042135b1:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042135b5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042135b9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042135bd:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042135c1:	4d 89 c1             	mov    %r8,%r9
  80042135c4:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80042135ca:	48 89 c7             	mov    %rax,%rdi
  80042135cd:	48 b8 23 30 21 04 80 	movabs $0x8004213023,%rax
  80042135d4:	00 00 00 
  80042135d7:	ff d0                	callq  *%rax
  80042135d9:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042135dc:	e9 88 00 00 00       	jmpq   8004213669 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  80042135e1:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042135e5:	75 0b                	jne    80042135f2 <_dwarf_get_next_fde+0x1b3>
  80042135e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042135ec:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042135f0:	74 0d                	je     80042135ff <_dwarf_get_next_fde+0x1c0>
  80042135f2:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  80042135f6:	75 36                	jne    800421362e <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  80042135f8:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  80042135fd:	75 2f                	jne    800421362e <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042135ff:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213603:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004213607:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421360b:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421360f:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004213613:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213617:	49 89 f8             	mov    %rdi,%r8
  800421361a:	48 89 c7             	mov    %rax,%rdi
  800421361d:	48 b8 c0 2b 21 04 80 	movabs $0x8004212bc0,%rax
  8004213624:	00 00 00 
  8004213627:	ff d0                	callq  *%rax
  8004213629:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421362c:	eb 3b                	jmp    8004213669 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  800421362e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213632:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004213636:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800421363a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421363e:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213642:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213646:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421364a:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421364e:	4d 89 c1             	mov    %r8,%r9
  8004213651:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004213657:	48 89 c7             	mov    %rax,%rdi
  800421365a:	48 b8 23 30 21 04 80 	movabs $0x8004213023,%rax
  8004213661:	00 00 00 
  8004213664:	ff d0                	callq  *%rax
  8004213666:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004213669:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  800421366d:	74 07                	je     8004213676 <_dwarf_get_next_fde+0x237>
			return(-1);
  800421366f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213674:	eb 19                	jmp    800421368f <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  8004213676:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421367a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  800421367e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213682:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213686:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  800421368a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421368f:	c9                   	leaveq 
  8004213690:	c3                   	retq   

0000008004213691 <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004213691:	55                   	push   %rbp
  8004213692:	48 89 e5             	mov    %rsp,%rbp
  8004213695:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004213699:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421369d:	89 f0                	mov    %esi,%eax
  800421369f:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  80042136a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042136a7:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042136ab:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  80042136af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042136b3:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80042136b7:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  80042136bb:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  80042136bf:	c9                   	leaveq 
  80042136c0:	c3                   	retq   

00000080042136c1 <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  80042136c1:	55                   	push   %rbp
  80042136c2:	48 89 e5             	mov    %rsp,%rbp
  80042136c5:	48 83 ec 10          	sub    $0x10,%rsp
  80042136c9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042136cd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  80042136d1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042136d6:	75 0a                	jne    80042136e2 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  80042136d8:	b8 01 00 00 00       	mov    $0x1,%eax
  80042136dd:	e9 85 00 00 00       	jmpq   8004213767 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  80042136e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042136e6:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042136ea:	48 85 c0             	test   %rax,%rax
  80042136ed:	75 25                	jne    8004213714 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  80042136ef:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042136f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042136f7:	48 89 d6             	mov    %rdx,%rsi
  80042136fa:	48 89 c7             	mov    %rax,%rdi
  80042136fd:	48 b8 d8 33 21 04 80 	movabs $0x80042133d8,%rax
  8004213704:	00 00 00 
  8004213707:	ff d0                	callq  *%rax
  8004213709:	85 c0                	test   %eax,%eax
  800421370b:	74 07                	je     8004213714 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  800421370d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213712:	eb 53                	jmp    8004213767 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  8004213714:	48 bf a0 b6 22 04 80 	movabs $0x800422b6a0,%rdi
  800421371b:	00 00 00 
  800421371e:	48 b8 8d 11 21 04 80 	movabs $0x800421118d,%rax
  8004213725:	00 00 00 
  8004213728:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  800421372a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421372e:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  8004213735:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  8004213736:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800421373d:	00 00 00 
  8004213740:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213748:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  800421374c:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004213753:	00 00 00 
  8004213756:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421375a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421375e:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  8004213762:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213767:	c9                   	leaveq 
  8004213768:	c3                   	retq   

0000008004213769 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213769:	55                   	push   %rbp
  800421376a:	48 89 e5             	mov    %rsp,%rbp
  800421376d:	53                   	push   %rbx
  800421376e:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004213775:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004213779:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  800421377d:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004213784:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  800421378b:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  8004213792:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004213799:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421379d:	48 83 c0 48          	add    $0x48,%rax
  80042137a1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  80042137a5:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042137ac:	00 
  80042137ad:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  80042137b4:	00 
  80042137b5:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  80042137bc:	00 
  80042137bd:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042137c4:	00 
  80042137c5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042137c9:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042137cd:	0f b6 c0             	movzbl %al,%eax
  80042137d0:	89 45 cc             	mov    %eax,-0x34(%rbp)
  80042137d3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  80042137da:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042137e1:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  80042137e8:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  80042137ef:	e9 0a 05 00 00       	jmpq   8004213cfe <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  80042137f4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042137fb:	0f b6 00             	movzbl (%rax),%eax
  80042137fe:	84 c0                	test   %al,%al
  8004213800:	0f 85 78 01 00 00    	jne    800421397e <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  8004213806:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421380d:	48 83 c0 01          	add    $0x1,%rax
  8004213811:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004213818:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421381f:	48 89 c7             	mov    %rax,%rdi
  8004213822:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004213829:	00 00 00 
  800421382c:	ff d0                	callq  *%rax
  800421382e:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  8004213832:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213839:	0f b6 00             	movzbl (%rax),%eax
  800421383c:	0f b6 c0             	movzbl %al,%eax
  800421383f:	83 f8 02             	cmp    $0x2,%eax
  8004213842:	74 7a                	je     80042138be <_dwarf_lineno_run_program+0x155>
  8004213844:	83 f8 03             	cmp    $0x3,%eax
  8004213847:	0f 84 b3 00 00 00    	je     8004213900 <_dwarf_lineno_run_program+0x197>
  800421384d:	83 f8 01             	cmp    $0x1,%eax
  8004213850:	0f 85 09 01 00 00    	jne    800421395f <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  8004213856:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421385d:	48 83 c0 01          	add    $0x1,%rax
  8004213861:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  8004213868:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  800421386f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004213876:	00 
  8004213877:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421387e:	00 
  800421387f:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004213886:	00 
  8004213887:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421388e:	00 
  800421388f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213893:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004213897:	0f b6 c0             	movzbl %al,%eax
  800421389a:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421389d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  80042138a4:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042138ab:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  80042138b2:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  80042138b9:	e9 bb 00 00 00       	jmpq   8004213979 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  80042138be:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042138c5:	48 83 c0 01          	add    $0x1,%rax
  80042138c9:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  80042138d0:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  80042138d7:	00 00 00 
  80042138da:	48 8b 00             	mov    (%rax),%rax
  80042138dd:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042138e1:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80042138e5:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042138e9:	0f b6 ca             	movzbl %dl,%ecx
  80042138ec:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  80042138f3:	89 ce                	mov    %ecx,%esi
  80042138f5:	48 89 d7             	mov    %rdx,%rdi
  80042138f8:	ff d0                	callq  *%rax
  80042138fa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  80042138fe:	eb 79                	jmp    8004213979 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  8004213900:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213907:	48 83 c0 01          	add    $0x1,%rax
  800421390b:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004213912:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213919:	00 00 00 
  800421391c:	48 8b 08             	mov    (%rax),%rcx
  800421391f:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004213926:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  800421392d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213931:	49 89 c8             	mov    %rcx,%r8
  8004213934:	48 89 d1             	mov    %rdx,%rcx
  8004213937:	ba 00 00 00 00       	mov    $0x0,%edx
  800421393c:	48 89 c7             	mov    %rax,%rdi
  800421393f:	48 b8 21 3d 21 04 80 	movabs $0x8004213d21,%rax
  8004213946:	00 00 00 
  8004213949:	ff d0                	callq  *%rax
  800421394b:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  800421394e:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  8004213952:	74 09                	je     800421395d <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  8004213954:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  8004213955:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004213958:	e9 ba 03 00 00       	jmpq   8004213d17 <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  800421395d:	eb 1a                	jmp    8004213979 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  800421395f:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004213966:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421396a:	48 01 d0             	add    %rdx,%rax
  800421396d:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004213974:	e9 85 03 00 00       	jmpq   8004213cfe <_dwarf_lineno_run_program+0x595>
  8004213979:	e9 80 03 00 00       	jmpq   8004213cfe <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  800421397e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213985:	0f b6 00             	movzbl (%rax),%eax
  8004213988:	84 c0                	test   %al,%al
  800421398a:	0f 84 3c 02 00 00    	je     8004213bcc <_dwarf_lineno_run_program+0x463>
  8004213990:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213997:	0f b6 10             	movzbl (%rax),%edx
  800421399a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421399e:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042139a2:	38 c2                	cmp    %al,%dl
  80042139a4:	0f 83 22 02 00 00    	jae    8004213bcc <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  80042139aa:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042139b1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042139b5:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  80042139bc:	0f b6 00             	movzbl (%rax),%eax
  80042139bf:	0f b6 c0             	movzbl %al,%eax
  80042139c2:	83 f8 0c             	cmp    $0xc,%eax
  80042139c5:	0f 87 fb 01 00 00    	ja     8004213bc6 <_dwarf_lineno_run_program+0x45d>
  80042139cb:	89 c0                	mov    %eax,%eax
  80042139cd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042139d4:	00 
  80042139d5:	48 b8 88 88 21 04 80 	movabs $0x8004218888,%rax
  80042139dc:	00 00 00 
  80042139df:	48 01 d0             	add    %rdx,%rax
  80042139e2:	48 8b 00             	mov    (%rax),%rax
  80042139e5:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  80042139e7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042139ee:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042139f2:	73 0a                	jae    80042139fe <_dwarf_lineno_run_program+0x295>
  80042139f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042139f9:	e9 19 03 00 00       	jmpq   8004213d17 <_dwarf_lineno_run_program+0x5ae>
  80042139fe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a02:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213a06:	48 89 10             	mov    %rdx,(%rax)
  8004213a09:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a0d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213a14:	00 
  8004213a15:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a19:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213a1d:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213a21:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a25:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213a29:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213a2d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213a31:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a35:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213a39:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a3d:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004213a40:	89 50 28             	mov    %edx,0x28(%rax)
  8004213a43:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a47:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004213a4a:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004213a4d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a51:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004213a54:	89 50 30             	mov    %edx,0x30(%rax)
  8004213a57:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213a5b:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213a62:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213a66:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213a6a:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  8004213a71:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  8004213a78:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  8004213a7f:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004213a86:	e9 3c 01 00 00       	jmpq   8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004213a8b:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213a92:	48 89 c7             	mov    %rax,%rdi
  8004213a95:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004213a9c:	00 00 00 
  8004213a9f:	ff d0                	callq  *%rax
					li->li_minlen;
  8004213aa1:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004213aa5:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004213aa9:	0f b6 d2             	movzbl %dl,%edx
  8004213aac:	48 0f af c2          	imul   %rdx,%rax
  8004213ab0:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  8004213ab4:	e9 0e 01 00 00       	jmpq   8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004213ab9:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213ac0:	48 89 c7             	mov    %rax,%rdi
  8004213ac3:	48 b8 6e f9 20 04 80 	movabs $0x800420f96e,%rax
  8004213aca:	00 00 00 
  8004213acd:	ff d0                	callq  *%rax
  8004213acf:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  8004213ad3:	e9 ef 00 00 00       	jmpq   8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004213ad8:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213adf:	48 89 c7             	mov    %rax,%rdi
  8004213ae2:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004213ae9:	00 00 00 
  8004213aec:	ff d0                	callq  *%rax
  8004213aee:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  8004213af2:	e9 d0 00 00 00       	jmpq   8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  8004213af7:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213afe:	48 89 c7             	mov    %rax,%rdi
  8004213b01:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004213b08:	00 00 00 
  8004213b0b:	ff d0                	callq  *%rax
  8004213b0d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  8004213b11:	e9 b1 00 00 00       	jmpq   8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  8004213b16:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004213b1a:	0f 94 c0             	sete   %al
  8004213b1d:	0f b6 c0             	movzbl %al,%eax
  8004213b20:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  8004213b23:	e9 9f 00 00 00       	jmpq   8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  8004213b28:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  8004213b2f:	e9 93 00 00 00       	jmpq   8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  8004213b34:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213b38:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213b3c:	0f b6 c0             	movzbl %al,%eax
  8004213b3f:	ba ff 00 00 00       	mov    $0xff,%edx
  8004213b44:	89 d1                	mov    %edx,%ecx
  8004213b46:	29 c1                	sub    %eax,%ecx
  8004213b48:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213b4c:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213b50:	0f b6 d8             	movzbl %al,%ebx
  8004213b53:	89 c8                	mov    %ecx,%eax
  8004213b55:	99                   	cltd   
  8004213b56:	f7 fb                	idiv   %ebx
  8004213b58:	89 c2                	mov    %eax,%edx
  8004213b5a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213b5e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213b62:	0f b6 c0             	movzbl %al,%eax
  8004213b65:	0f af c2             	imul   %edx,%eax
  8004213b68:	48 98                	cltq   
  8004213b6a:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004213b6e:	eb 57                	jmp    8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004213b70:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213b77:	00 00 00 
  8004213b7a:	48 8b 00             	mov    (%rax),%rax
  8004213b7d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213b81:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004213b88:	be 02 00 00 00       	mov    $0x2,%esi
  8004213b8d:	48 89 d7             	mov    %rdx,%rdi
  8004213b90:	ff d0                	callq  *%rax
  8004213b92:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004213b96:	eb 2f                	jmp    8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004213b98:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  8004213b9f:	eb 26                	jmp    8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004213ba1:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  8004213ba8:	eb 1d                	jmp    8004213bc7 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004213baa:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213bb1:	48 89 c7             	mov    %rax,%rdi
  8004213bb4:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004213bbb:	00 00 00 
  8004213bbe:	ff d0                	callq  *%rax
  8004213bc0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  8004213bc4:	eb 01                	jmp    8004213bc7 <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  8004213bc6:	90                   	nop
			}

		} else {
  8004213bc7:	e9 32 01 00 00       	jmpq   8004213cfe <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  8004213bcc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213bd0:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  8004213bd4:	0f be c8             	movsbl %al,%ecx
  8004213bd7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213bde:	0f b6 00             	movzbl (%rax),%eax
  8004213be1:	0f b6 d0             	movzbl %al,%edx
  8004213be4:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213be8:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213bec:	0f b6 c0             	movzbl %al,%eax
  8004213bef:	29 c2                	sub    %eax,%edx
  8004213bf1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213bf5:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213bf9:	0f b6 f0             	movzbl %al,%esi
  8004213bfc:	89 d0                	mov    %edx,%eax
  8004213bfe:	99                   	cltd   
  8004213bff:	f7 fe                	idiv   %esi
  8004213c01:	89 d0                	mov    %edx,%eax
  8004213c03:	01 c8                	add    %ecx,%eax
  8004213c05:	48 98                	cltq   
  8004213c07:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  8004213c0b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213c12:	0f b6 00             	movzbl (%rax),%eax
  8004213c15:	0f b6 d0             	movzbl %al,%edx
  8004213c18:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213c1c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213c20:	0f b6 c0             	movzbl %al,%eax
  8004213c23:	89 d1                	mov    %edx,%ecx
  8004213c25:	29 c1                	sub    %eax,%ecx
  8004213c27:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213c2b:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213c2f:	0f b6 d8             	movzbl %al,%ebx
  8004213c32:	89 c8                	mov    %ecx,%eax
  8004213c34:	99                   	cltd   
  8004213c35:	f7 fb                	idiv   %ebx
  8004213c37:	89 c2                	mov    %eax,%edx
  8004213c39:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213c3d:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213c41:	0f b6 c0             	movzbl %al,%eax
  8004213c44:	0f af c2             	imul   %edx,%eax
  8004213c47:	48 98                	cltq   
  8004213c49:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  8004213c4d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213c54:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213c58:	73 0a                	jae    8004213c64 <_dwarf_lineno_run_program+0x4fb>
  8004213c5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213c5f:	e9 b3 00 00 00       	jmpq   8004213d17 <_dwarf_lineno_run_program+0x5ae>
  8004213c64:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c68:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213c6c:	48 89 10             	mov    %rdx,(%rax)
  8004213c6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c73:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213c7a:	00 
  8004213c7b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c7f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213c83:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213c87:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c8b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213c8f:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213c93:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c97:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c9b:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213c9f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ca3:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004213ca6:	89 50 28             	mov    %edx,0x28(%rax)
  8004213ca9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213cad:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004213cb0:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004213cb3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213cb7:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004213cba:	89 50 30             	mov    %edx,0x30(%rax)
  8004213cbd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213cc1:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213cc8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213ccc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213cd0:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004213cd7:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  8004213cde:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  8004213ce5:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  8004213cec:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213cf3:	48 83 c0 01          	add    $0x1,%rax
  8004213cf7:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004213cfe:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213d05:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  8004213d0c:	0f 82 e2 fa ff ff    	jb     80042137f4 <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004213d12:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  8004213d17:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004213d1e:	5b                   	pop    %rbx
  8004213d1f:	5d                   	pop    %rbp
  8004213d20:	c3                   	retq   

0000008004213d21 <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004213d21:	55                   	push   %rbp
  8004213d22:	48 89 e5             	mov    %rsp,%rbp
  8004213d25:	53                   	push   %rbx
  8004213d26:	48 83 ec 48          	sub    $0x48,%rsp
  8004213d2a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004213d2e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004213d32:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004213d36:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213d3a:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004213d3e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d42:	48 8b 00             	mov    (%rax),%rax
  8004213d45:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004213d49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213d4d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004213d51:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004213d55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d59:	48 89 c7             	mov    %rax,%rdi
  8004213d5c:	48 b8 d8 ea 20 04 80 	movabs $0x800420ead8,%rax
  8004213d63:	00 00 00 
  8004213d66:	ff d0                	callq  *%rax
  8004213d68:	48 98                	cltq   
  8004213d6a:	48 83 c0 01          	add    $0x1,%rax
  8004213d6e:	48 01 d8             	add    %rbx,%rax
  8004213d71:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004213d75:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213d79:	48 89 c7             	mov    %rax,%rdi
  8004213d7c:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004213d83:	00 00 00 
  8004213d86:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004213d88:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213d8c:	48 89 c7             	mov    %rax,%rdi
  8004213d8f:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004213d96:	00 00 00 
  8004213d99:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004213d9b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213d9f:	48 89 c7             	mov    %rax,%rdi
  8004213da2:	48 b8 00 fa 20 04 80 	movabs $0x800420fa00,%rax
  8004213da9:	00 00 00 
  8004213dac:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004213dae:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213db2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213db6:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004213db9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213dbe:	48 83 c4 48          	add    $0x48,%rsp
  8004213dc2:	5b                   	pop    %rbx
  8004213dc3:	5d                   	pop    %rbp
  8004213dc4:	c3                   	retq   

0000008004213dc5 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004213dc5:	55                   	push   %rbp
  8004213dc6:	48 89 e5             	mov    %rsp,%rbp
  8004213dc9:	53                   	push   %rbx
  8004213dca:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004213dd1:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004213dd8:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004213ddf:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004213de6:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004213ded:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004213df4:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004213dfb:	00 
  8004213dfc:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004213e03:	00 
  8004213e04:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004213e0b:	00 
  8004213e0c:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004213e13:	00 
  8004213e14:	48 b8 f0 88 21 04 80 	movabs $0x80042188f0,%rax
  8004213e1b:	00 00 00 
  8004213e1e:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004213e22:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004213e26:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004213e2a:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004213e31:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004213e38:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004213e3c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004213e41:	75 35                	jne    8004213e78 <_dwarf_lineno_init+0xb3>
  8004213e43:	48 b9 fc 88 21 04 80 	movabs $0x80042188fc,%rcx
  8004213e4a:	00 00 00 
  8004213e4d:	48 ba 07 89 21 04 80 	movabs $0x8004218907,%rdx
  8004213e54:	00 00 00 
  8004213e57:	be 13 01 00 00       	mov    $0x113,%esi
  8004213e5c:	48 bf 1c 89 21 04 80 	movabs $0x800421891c,%rdi
  8004213e63:	00 00 00 
  8004213e66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213e6b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004213e72:	00 00 00 
  8004213e75:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004213e78:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213e7f:	00 00 00 
  8004213e82:	48 8b 00             	mov    (%rax),%rax
  8004213e85:	48 85 c0             	test   %rax,%rax
  8004213e88:	75 35                	jne    8004213ebf <_dwarf_lineno_init+0xfa>
  8004213e8a:	48 b9 33 89 21 04 80 	movabs $0x8004218933,%rcx
  8004213e91:	00 00 00 
  8004213e94:	48 ba 07 89 21 04 80 	movabs $0x8004218907,%rdx
  8004213e9b:	00 00 00 
  8004213e9e:	be 14 01 00 00       	mov    $0x114,%esi
  8004213ea3:	48 bf 1c 89 21 04 80 	movabs $0x800421891c,%rdi
  8004213eaa:	00 00 00 
  8004213ead:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213eb2:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004213eb9:	00 00 00 
  8004213ebc:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004213ebf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213ec3:	48 89 c7             	mov    %rax,%rdi
  8004213ec6:	48 b8 8d 11 21 04 80 	movabs $0x800421118d,%rax
  8004213ecd:	00 00 00 
  8004213ed0:	ff d0                	callq  *%rax
  8004213ed2:	85 c0                	test   %eax,%eax
  8004213ed4:	74 0a                	je     8004213ee0 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004213ed6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213edb:	e9 4f 04 00 00       	jmpq   800421432f <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004213ee0:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004213ee7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004213eeb:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213ef2:	00 00 00 
  8004213ef5:	48 8b 00             	mov    (%rax),%rax
  8004213ef8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213efc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f00:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f04:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213f0b:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213f10:	48 89 cf             	mov    %rcx,%rdi
  8004213f13:	ff d0                	callq  *%rax
  8004213f15:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004213f19:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213f1e:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004213f22:	75 37                	jne    8004213f5b <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004213f24:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004213f2b:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213f32:	00 00 00 
  8004213f35:	48 8b 00             	mov    (%rax),%rax
  8004213f38:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f3c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f40:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f44:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213f4b:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213f50:	48 89 cf             	mov    %rcx,%rdi
  8004213f53:	ff d0                	callq  *%rax
  8004213f55:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004213f59:	eb 07                	jmp    8004213f62 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004213f5b:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004213f62:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213f66:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213f6a:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213f71:	48 29 c2             	sub    %rax,%rdx
  8004213f74:	48 89 d0             	mov    %rdx,%rax
  8004213f77:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213f7b:	73 0a                	jae    8004213f87 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004213f7d:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004213f82:	e9 a8 03 00 00       	jmpq   800421432f <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004213f87:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f8b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f8f:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004213f92:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004213f99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f9d:	48 01 d0             	add    %rdx,%rax
  8004213fa0:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004213fa4:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213fab:	00 00 00 
  8004213fae:	48 8b 00             	mov    (%rax),%rax
  8004213fb1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213fb5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213fb9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213fbd:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213fc4:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213fc9:	48 89 cf             	mov    %rcx,%rdi
  8004213fcc:	ff d0                	callq  *%rax
  8004213fce:	89 c2                	mov    %eax,%edx
  8004213fd0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213fd4:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004213fd8:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213fdf:	00 00 00 
  8004213fe2:	48 8b 00             	mov    (%rax),%rax
  8004213fe5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213fe9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213fed:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213ff1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004213ff4:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213ffb:	48 89 cf             	mov    %rcx,%rdi
  8004213ffe:	ff d0                	callq  *%rax
  8004214000:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214004:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004214008:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800421400f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004214013:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800421401a:	00 00 00 
  800421401d:	48 8b 00             	mov    (%rax),%rax
  8004214020:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214024:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214028:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421402c:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214033:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214038:	48 89 cf             	mov    %rcx,%rdi
  800421403b:	ff d0                	callq  *%rax
  800421403d:	89 c2                	mov    %eax,%edx
  800421403f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214043:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004214046:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800421404d:	00 00 00 
  8004214050:	48 8b 00             	mov    (%rax),%rax
  8004214053:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214057:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421405b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421405f:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214066:	ba 01 00 00 00       	mov    $0x1,%edx
  800421406b:	48 89 cf             	mov    %rcx,%rdi
  800421406e:	ff d0                	callq  *%rax
  8004214070:	89 c2                	mov    %eax,%edx
  8004214072:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214076:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004214079:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004214080:	00 00 00 
  8004214083:	48 8b 00             	mov    (%rax),%rax
  8004214086:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421408a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421408e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214092:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214099:	ba 01 00 00 00       	mov    $0x1,%edx
  800421409e:	48 89 cf             	mov    %rcx,%rdi
  80042140a1:	ff d0                	callq  *%rax
  80042140a3:	89 c2                	mov    %eax,%edx
  80042140a5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140a9:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  80042140ac:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  80042140b3:	00 00 00 
  80042140b6:	48 8b 00             	mov    (%rax),%rax
  80042140b9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042140bd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042140c1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042140c5:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042140cc:	ba 01 00 00 00       	mov    $0x1,%edx
  80042140d1:	48 89 cf             	mov    %rcx,%rdi
  80042140d4:	ff d0                	callq  *%rax
  80042140d6:	89 c2                	mov    %eax,%edx
  80042140d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140dc:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  80042140df:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  80042140e6:	00 00 00 
  80042140e9:	48 8b 00             	mov    (%rax),%rax
  80042140ec:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042140f0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042140f4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042140f8:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042140ff:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214104:	48 89 cf             	mov    %rcx,%rdi
  8004214107:	ff d0                	callq  *%rax
  8004214109:	89 c2                	mov    %eax,%edx
  800421410b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421410f:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004214112:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214116:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421411a:	8d 50 fb             	lea    -0x5(%rax),%edx
  800421411d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214121:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214125:	0f b6 c0             	movzbl %al,%eax
  8004214128:	83 e8 01             	sub    $0x1,%eax
  800421412b:	39 c2                	cmp    %eax,%edx
  800421412d:	7d 0c                	jge    800421413b <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  800421412f:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214136:	e9 f1 01 00 00       	jmpq   800421432c <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  800421413b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421413f:	48 bb a0 55 3d 04 80 	movabs $0x80043d55a0,%rbx
  8004214146:	00 00 00 
  8004214149:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  800421414d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004214154:	eb 41                	jmp    8004214197 <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004214156:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421415a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421415e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004214161:	48 98                	cltq   
  8004214163:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004214167:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800421416e:	00 00 00 
  8004214171:	48 8b 00             	mov    (%rax),%rax
  8004214174:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214178:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421417c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214180:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214187:	ba 01 00 00 00       	mov    $0x1,%edx
  800421418c:	48 89 cf             	mov    %rcx,%rdi
  800421418f:	ff d0                	callq  *%rax
  8004214191:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214193:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004214197:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421419b:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421419f:	0f b6 c0             	movzbl %al,%eax
  80042141a2:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  80042141a5:	7f af                	jg     8004214156 <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  80042141a7:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042141ae:	00 
	p = ds->ds_data + offset;
  80042141af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042141b3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042141b7:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042141be:	48 01 d0             	add    %rdx,%rax
  80042141c1:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  80042141c8:	eb 1f                	jmp    80042141e9 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  80042141ca:	90                   	nop
  80042141cb:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042141d2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042141d6:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  80042141dd:	0f b6 00             	movzbl (%rax),%eax
  80042141e0:	84 c0                	test   %al,%al
  80042141e2:	75 e7                	jne    80042141cb <_dwarf_lineno_init+0x406>
			;
		length++;
  80042141e4:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  80042141e9:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042141f0:	0f b6 00             	movzbl (%rax),%eax
  80042141f3:	84 c0                	test   %al,%al
  80042141f5:	75 d3                	jne    80042141ca <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  80042141f7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042141fb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042141ff:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004214203:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421420a:	48 89 c2             	mov    %rax,%rdx
  800421420d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214211:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214215:	48 29 c2             	sub    %rax,%rdx
  8004214218:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421421c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214220:	48 98                	cltq   
  8004214222:	48 39 c2             	cmp    %rax,%rdx
  8004214225:	7e 0c                	jle    8004214233 <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214227:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  800421422e:	e9 f9 00 00 00       	jmpq   800421432c <_dwarf_lineno_init+0x567>
	}
	p++;
  8004214233:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421423a:	48 83 c0 01          	add    $0x1,%rax
  800421423e:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214245:	eb 3c                	jmp    8004214283 <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004214247:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800421424e:	00 00 00 
  8004214251:	48 8b 08             	mov    (%rax),%rcx
  8004214254:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800421425b:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004214262:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214266:	49 89 c8             	mov    %rcx,%r8
  8004214269:	48 89 d1             	mov    %rdx,%rcx
  800421426c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214271:	48 89 c7             	mov    %rax,%rdi
  8004214274:	48 b8 21 3d 21 04 80 	movabs $0x8004213d21,%rax
  800421427b:	00 00 00 
  800421427e:	ff d0                	callq  *%rax
  8004214280:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214283:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421428a:	0f b6 00             	movzbl (%rax),%eax
  800421428d:	84 c0                	test   %al,%al
  800421428f:	75 b6                	jne    8004214247 <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004214291:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214298:	48 83 c0 01          	add    $0x1,%rax
  800421429c:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  80042142a3:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042142aa:	48 89 c2             	mov    %rax,%rdx
  80042142ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042142b1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042142b5:	48 29 c2             	sub    %rax,%rdx
  80042142b8:	48 89 d0             	mov    %rdx,%rax
  80042142bb:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  80042142bf:	48 89 c2             	mov    %rax,%rdx
  80042142c2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042142c6:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042142ca:	48 39 c2             	cmp    %rax,%rdx
  80042142cd:	74 09                	je     80042142d8 <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042142cf:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042142d6:	eb 54                	jmp    800421432c <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  80042142d8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042142dc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042142e0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042142e4:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042142e8:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042142ef:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  80042142f6:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  80042142fd:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004214301:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214305:	4d 89 c1             	mov    %r8,%r9
  8004214308:	49 89 f8             	mov    %rdi,%r8
  800421430b:	48 89 c7             	mov    %rax,%rdi
  800421430e:	48 b8 69 37 21 04 80 	movabs $0x8004213769,%rax
  8004214315:	00 00 00 
  8004214318:	ff d0                	callq  *%rax
  800421431a:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  800421431d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214321:	74 02                	je     8004214325 <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  8004214323:	eb 07                	jmp    800421432c <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  8004214325:	b8 00 00 00 00       	mov    $0x0,%eax
  800421432a:	eb 03                	jmp    800421432f <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  800421432c:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  800421432f:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004214336:	5b                   	pop    %rbx
  8004214337:	5d                   	pop    %rbp
  8004214338:	c3                   	retq   

0000008004214339 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214339:	55                   	push   %rbp
  800421433a:	48 89 e5             	mov    %rsp,%rbp
  800421433d:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004214344:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800421434b:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004214352:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004214359:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004214360:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004214367:	00 
  8004214368:	75 35                	jne    800421439f <dwarf_srclines+0x66>
  800421436a:	48 b9 3f 89 21 04 80 	movabs $0x800421893f,%rcx
  8004214371:	00 00 00 
  8004214374:	48 ba 07 89 21 04 80 	movabs $0x8004218907,%rdx
  800421437b:	00 00 00 
  800421437e:	be 9a 01 00 00       	mov    $0x19a,%esi
  8004214383:	48 bf 1c 89 21 04 80 	movabs $0x800421891c,%rdi
  800421438a:	00 00 00 
  800421438d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214392:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004214399:	00 00 00 
  800421439c:	41 ff d0             	callq  *%r8
	assert(linebuf);
  800421439f:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  80042143a6:	00 
  80042143a7:	75 35                	jne    80042143de <dwarf_srclines+0xa5>
  80042143a9:	48 b9 43 89 21 04 80 	movabs $0x8004218943,%rcx
  80042143b0:	00 00 00 
  80042143b3:	48 ba 07 89 21 04 80 	movabs $0x8004218907,%rdx
  80042143ba:	00 00 00 
  80042143bd:	be 9b 01 00 00       	mov    $0x19b,%esi
  80042143c2:	48 bf 1c 89 21 04 80 	movabs $0x800421891c,%rdi
  80042143c9:	00 00 00 
  80042143cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042143d1:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042143d8:	00 00 00 
  80042143db:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042143de:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042143e5:	ba 88 00 00 00       	mov    $0x88,%edx
  80042143ea:	be 00 00 00 00       	mov    $0x0,%esi
  80042143ef:	48 89 c7             	mov    %rax,%rdi
  80042143f2:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  80042143f9:	00 00 00 
  80042143fc:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  80042143fe:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214405:	be 10 00 00 00       	mov    $0x10,%esi
  800421440a:	48 89 c7             	mov    %rax,%rdi
  800421440d:	48 b8 12 0d 21 04 80 	movabs $0x8004210d12,%rax
  8004214414:	00 00 00 
  8004214417:	ff d0                	callq  *%rax
  8004214419:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421441d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214422:	75 0a                	jne    800421442e <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004214424:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214429:	e9 84 00 00 00       	jmpq   80042144b2 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  800421442e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214432:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004214436:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  800421443d:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004214444:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  800421444b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214452:	49 89 f8             	mov    %rdi,%r8
  8004214455:	48 89 c7             	mov    %rax,%rdi
  8004214458:	48 b8 c5 3d 21 04 80 	movabs $0x8004213dc5,%rax
  800421445f:	00 00 00 
  8004214462:	ff d0                	callq  *%rax
  8004214464:	85 c0                	test   %eax,%eax
  8004214466:	74 07                	je     800421446f <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004214468:	b8 01 00 00 00       	mov    $0x1,%eax
  800421446d:	eb 43                	jmp    80042144b2 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  800421446f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004214476:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800421447a:	48 89 10             	mov    %rdx,(%rax)
  800421447d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214481:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004214485:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214489:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421448d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214491:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214495:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214499:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421449d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042144a1:	48 89 50 28          	mov    %rdx,0x28(%rax)
  80042144a5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042144a9:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  80042144ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042144b2:	c9                   	leaveq 
  80042144b3:	c3                   	retq   

00000080042144b4 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  80042144b4:	55                   	push   %rbp
  80042144b5:	48 89 e5             	mov    %rsp,%rbp
  80042144b8:	48 83 ec 20          	sub    $0x20,%rsp
  80042144bc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  80042144c0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042144c7:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042144c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042144cf:	eb 57                	jmp    8004214528 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  80042144d1:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042144d8:	00 00 00 
  80042144db:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042144de:	48 63 d2             	movslq %edx,%rdx
  80042144e1:	48 c1 e2 05          	shl    $0x5,%rdx
  80042144e5:	48 01 d0             	add    %rdx,%rax
  80042144e8:	48 8b 00             	mov    (%rax),%rax
  80042144eb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042144ef:	48 89 d6             	mov    %rdx,%rsi
  80042144f2:	48 89 c7             	mov    %rax,%rdi
  80042144f5:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  80042144fc:	00 00 00 
  80042144ff:	ff d0                	callq  *%rax
  8004214501:	85 c0                	test   %eax,%eax
  8004214503:	75 1f                	jne    8004214524 <_dwarf_find_section+0x70>
			ret = (section_info + i);
  8004214505:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214508:	48 98                	cltq   
  800421450a:	48 c1 e0 05          	shl    $0x5,%rax
  800421450e:	48 89 c2             	mov    %rax,%rdx
  8004214511:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214518:	00 00 00 
  800421451b:	48 01 d0             	add    %rdx,%rax
  800421451e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004214522:	eb 0a                	jmp    800421452e <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004214524:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214528:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421452c:	7e a3                	jle    80042144d1 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  800421452e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004214532:	c9                   	leaveq 
  8004214533:	c3                   	retq   

0000008004214534 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004214534:	55                   	push   %rbp
  8004214535:	48 89 e5             	mov    %rsp,%rbp
  8004214538:	48 83 ec 40          	sub    $0x40,%rsp
  800421453c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  8004214540:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214544:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  8004214548:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  800421454f:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004214550:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214554:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004214558:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421455c:	48 01 d0             	add    %rdx,%rax
  800421455f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004214563:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214567:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800421456b:	0f b7 c0             	movzwl %ax,%eax
  800421456e:	48 c1 e0 06          	shl    $0x6,%rax
  8004214572:	48 89 c2             	mov    %rax,%rdx
  8004214575:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214579:	48 01 d0             	add    %rdx,%rax
  800421457c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004214580:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214584:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004214588:	0f b7 c0             	movzwl %ax,%eax
  800421458b:	48 c1 e0 06          	shl    $0x6,%rax
  800421458f:	48 89 c2             	mov    %rax,%rdx
  8004214592:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214596:	48 01 d0             	add    %rdx,%rax
  8004214599:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  800421459d:	e9 4b 02 00 00       	jmpq   80042147ed <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  80042145a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042145a6:	8b 00                	mov    (%rax),%eax
  80042145a8:	89 c2                	mov    %eax,%edx
  80042145aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042145ae:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042145b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042145b6:	48 01 c8             	add    %rcx,%rax
  80042145b9:	48 01 d0             	add    %rdx,%rax
  80042145bc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  80042145c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145c4:	48 be 4b 89 21 04 80 	movabs $0x800421894b,%rsi
  80042145cb:	00 00 00 
  80042145ce:	48 89 c7             	mov    %rax,%rdi
  80042145d1:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  80042145d8:	00 00 00 
  80042145db:	ff d0                	callq  *%rax
  80042145dd:	85 c0                	test   %eax,%eax
  80042145df:	75 4b                	jne    800421462c <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  80042145e1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042145e5:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042145ec:	00 00 00 
  80042145ef:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  80042145f3:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042145fa:	00 00 00 
  80042145fd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214601:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  8004214605:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214609:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421460d:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214614:	00 00 00 
  8004214617:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  800421461b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421461f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214623:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214627:	e9 bc 01 00 00       	jmpq   80042147e8 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  800421462c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214630:	48 be 57 89 21 04 80 	movabs $0x8004218957,%rsi
  8004214637:	00 00 00 
  800421463a:	48 89 c7             	mov    %rax,%rdi
  800421463d:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  8004214644:	00 00 00 
  8004214647:	ff d0                	callq  *%rax
  8004214649:	85 c0                	test   %eax,%eax
  800421464b:	75 4b                	jne    8004214698 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  800421464d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214651:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214658:	00 00 00 
  800421465b:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  800421465f:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214666:	00 00 00 
  8004214669:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421466d:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004214671:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214675:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214679:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214680:	00 00 00 
  8004214683:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004214687:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421468b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421468f:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214693:	e9 50 01 00 00       	jmpq   80042147e8 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004214698:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421469c:	48 be 6f 89 21 04 80 	movabs $0x800421896f,%rsi
  80042146a3:	00 00 00 
  80042146a6:	48 89 c7             	mov    %rax,%rdi
  80042146a9:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  80042146b0:	00 00 00 
  80042146b3:	ff d0                	callq  *%rax
  80042146b5:	85 c0                	test   %eax,%eax
  80042146b7:	75 4b                	jne    8004214704 <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  80042146b9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042146bd:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042146c4:	00 00 00 
  80042146c7:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  80042146cb:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042146d2:	00 00 00 
  80042146d5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042146d9:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  80042146dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042146e1:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042146e5:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042146ec:	00 00 00 
  80042146ef:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  80042146f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042146f7:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042146fb:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042146ff:	e9 e4 00 00 00       	jmpq   80042147e8 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  8004214704:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214708:	48 be 65 89 21 04 80 	movabs $0x8004218965,%rsi
  800421470f:	00 00 00 
  8004214712:	48 89 c7             	mov    %rax,%rdi
  8004214715:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  800421471c:	00 00 00 
  800421471f:	ff d0                	callq  *%rax
  8004214721:	85 c0                	test   %eax,%eax
  8004214723:	75 53                	jne    8004214778 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  8004214725:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214729:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421472d:	48 89 c2             	mov    %rax,%rdx
  8004214730:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214737:	00 00 00 
  800421473a:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  800421473e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214742:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004214746:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  800421474d:	00 00 00 
  8004214750:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004214754:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214758:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421475c:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214763:	00 00 00 
  8004214766:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  800421476a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421476e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214772:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214776:	eb 70                	jmp    80042147e8 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004214778:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421477c:	48 be 7b 89 21 04 80 	movabs $0x800421897b,%rsi
  8004214783:	00 00 00 
  8004214786:	48 89 c7             	mov    %rax,%rdi
  8004214789:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  8004214790:	00 00 00 
  8004214793:	ff d0                	callq  *%rax
  8004214795:	85 c0                	test   %eax,%eax
  8004214797:	75 4f                	jne    80042147e8 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004214799:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421479d:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042147a4:	00 00 00 
  80042147a7:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  80042147ae:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042147b5:	00 00 00 
  80042147b8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042147bc:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  80042147c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042147c7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042147cb:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042147d2:	00 00 00 
  80042147d5:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  80042147dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042147e0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042147e4:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  80042147e8:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  80042147ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042147f1:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042147f5:	0f 82 a7 fd ff ff    	jb     80042145a2 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  80042147fb:	c9                   	leaveq 
  80042147fc:	c3                   	retq   

00000080042147fd <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042147fd:	55                   	push   %rbp
  80042147fe:	48 89 e5             	mov    %rsp,%rbp
  8004214801:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004214808:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  800421480f:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  8004214816:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  800421481d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214822:	ba 14 00 00 00       	mov    $0x14,%edx
  8004214827:	48 89 f7             	mov    %rsi,%rdi
  800421482a:	48 89 d1             	mov    %rdx,%rcx
  800421482d:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  8004214830:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004214837:	00 
  8004214838:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421483c:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004214843:	48 01 d0             	add    %rdx,%rax
  8004214846:	48 83 e8 01          	sub    $0x1,%rax
  800421484a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421484e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214852:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214857:	48 f7 75 e8          	divq   -0x18(%rbp)
  800421485b:	48 89 d0             	mov    %rdx,%rax
  800421485e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214862:	48 29 c2             	sub    %rax,%rdx
  8004214865:	48 89 d0             	mov    %rdx,%rax
  8004214868:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  800421486c:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004214873:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004214877:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421487b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  800421487f:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004214886:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004214887:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800421488e:	00 00 00 
  8004214891:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004214898:	75 11                	jne    80042148ab <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  800421489a:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042148a1:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042148a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042148a9:	eb 26                	jmp    80042148d1 <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  80042148ab:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042148b2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042148b6:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042148bd:	48 01 c2             	add    %rax,%rdx
  80042148c0:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042148c7:	ff ff ff 
  80042148ca:	48 01 d0             	add    %rdx,%rax
  80042148cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  80042148d1:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042148d8:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042148dc:	0f b7 c0             	movzwl %ax,%eax
  80042148df:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  80042148e2:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042148e9:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  80042148ed:	0f b7 c0             	movzwl %ax,%eax
  80042148f0:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  80042148f3:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042148fa:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042148fe:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004214901:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004214905:	48 63 f0             	movslq %eax,%rsi
  8004214908:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421490c:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214913:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214917:	48 89 c7             	mov    %rax,%rdi
  800421491a:	48 b8 3c 4f 21 04 80 	movabs $0x8004214f3c,%rax
  8004214921:	00 00 00 
  8004214924:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004214926:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421492a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  800421492e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214932:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214938:	48 89 c2             	mov    %rax,%rdx
  800421493b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421493f:	48 29 d0             	sub    %rdx,%rax
  8004214942:	48 89 c2             	mov    %rax,%rdx
  8004214945:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214949:	48 01 d0             	add    %rdx,%rax
  800421494c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004214950:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214957:	eb 24                	jmp    800421497d <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004214959:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421495c:	48 98                	cltq   
  800421495e:	48 c1 e0 06          	shl    $0x6,%rax
  8004214962:	48 89 c2             	mov    %rax,%rdx
  8004214965:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214969:	48 01 c2             	add    %rax,%rdx
  800421496c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421496f:	48 98                	cltq   
  8004214971:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004214978:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004214979:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421497d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214980:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214983:	7c d4                	jl     8004214959 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004214985:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214989:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800421498d:	0f b7 c0             	movzwl %ax,%eax
  8004214990:	48 98                	cltq   
  8004214992:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214999:	ff 
  800421499a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  800421499e:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042149a5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  80042149a9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042149ad:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042149b1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042149b5:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042149b9:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042149c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042149c4:	48 01 c8             	add    %rcx,%rax
  80042149c7:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042149ce:	48 89 c7             	mov    %rax,%rdi
  80042149d1:	48 b8 3c 4f 21 04 80 	movabs $0x8004214f3c,%rax
  80042149d8:	00 00 00 
  80042149db:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  80042149dd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042149e1:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042149e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042149e9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042149ed:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042149f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042149f5:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042149fb:	48 29 c2             	sub    %rax,%rdx
  80042149fe:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214a02:	48 01 c2             	add    %rax,%rdx
  8004214a05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a09:	48 01 d0             	add    %rdx,%rax
  8004214a0c:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  8004214a10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214a17:	e9 04 05 00 00       	jmpq   8004214f20 <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004214a1c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a1f:	48 98                	cltq   
  8004214a21:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214a28:	ff 
  8004214a29:	8b 00                	mov    (%rax),%eax
  8004214a2b:	89 c2                	mov    %eax,%edx
  8004214a2d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214a31:	48 01 d0             	add    %rdx,%rax
  8004214a34:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  8004214a38:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214a3f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214a44:	48 85 c0             	test   %rax,%rax
  8004214a47:	74 35                	je     8004214a7e <read_section_headers+0x281>
  8004214a49:	48 b9 86 89 21 04 80 	movabs $0x8004218986,%rcx
  8004214a50:	00 00 00 
  8004214a53:	48 ba 9f 89 21 04 80 	movabs $0x800421899f,%rdx
  8004214a5a:	00 00 00 
  8004214a5d:	be 86 00 00 00       	mov    $0x86,%esi
  8004214a62:	48 bf b4 89 21 04 80 	movabs $0x80042189b4,%rdi
  8004214a69:	00 00 00 
  8004214a6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214a71:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004214a78:	00 00 00 
  8004214a7b:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004214a7e:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214a85:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004214a89:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214a8d:	48 be 4b 89 21 04 80 	movabs $0x800421894b,%rsi
  8004214a94:	00 00 00 
  8004214a97:	48 89 c7             	mov    %rax,%rdi
  8004214a9a:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  8004214aa1:	00 00 00 
  8004214aa4:	ff d0                	callq  *%rax
  8004214aa6:	85 c0                	test   %eax,%eax
  8004214aa8:	0f 85 d8 00 00 00    	jne    8004214b86 <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214aae:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214ab1:	48 98                	cltq   
  8004214ab3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214aba:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214abb:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214abf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214ac2:	48 98                	cltq   
  8004214ac4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214acb:	ff 
  8004214acc:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214ad0:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214ad7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214adb:	48 01 c8             	add    %rcx,%rax
  8004214ade:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214ae5:	48 89 c7             	mov    %rax,%rdi
  8004214ae8:	48 b8 3c 4f 21 04 80 	movabs $0x8004214f3c,%rax
  8004214aef:	00 00 00 
  8004214af2:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214af4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214af7:	48 98                	cltq   
  8004214af9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b00:	ff 
  8004214b01:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214b05:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b08:	48 98                	cltq   
  8004214b0a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b11:	ff 
  8004214b12:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b16:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004214b1a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214b1e:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214b24:	48 29 c2             	sub    %rax,%rdx
  8004214b27:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214b2b:	48 01 c2             	add    %rax,%rdx
  8004214b2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214b32:	48 01 c2             	add    %rax,%rdx
  8004214b35:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214b3c:	00 00 00 
  8004214b3f:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004214b43:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214b4a:	00 00 00 
  8004214b4d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214b51:	48 89 c2             	mov    %rax,%rdx
  8004214b54:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214b5b:	00 00 00 
  8004214b5e:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004214b62:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b65:	48 98                	cltq   
  8004214b67:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b6e:	ff 
  8004214b6f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214b73:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214b7a:	00 00 00 
  8004214b7d:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214b81:	e9 96 03 00 00       	jmpq   8004214f1c <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004214b86:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214b8a:	48 be 57 89 21 04 80 	movabs $0x8004218957,%rsi
  8004214b91:	00 00 00 
  8004214b94:	48 89 c7             	mov    %rax,%rdi
  8004214b97:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  8004214b9e:	00 00 00 
  8004214ba1:	ff d0                	callq  *%rax
  8004214ba3:	85 c0                	test   %eax,%eax
  8004214ba5:	0f 85 de 00 00 00    	jne    8004214c89 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214bab:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214bae:	48 98                	cltq   
  8004214bb0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214bb7:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214bb8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214bbc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214bbf:	48 98                	cltq   
  8004214bc1:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214bc8:	ff 
  8004214bc9:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214bcd:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214bd4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214bd8:	48 01 c8             	add    %rcx,%rax
  8004214bdb:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214be2:	48 89 c7             	mov    %rax,%rdi
  8004214be5:	48 b8 3c 4f 21 04 80 	movabs $0x8004214f3c,%rax
  8004214bec:	00 00 00 
  8004214bef:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214bf1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214bf4:	48 98                	cltq   
  8004214bf6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214bfd:	ff 
  8004214bfe:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214c02:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c05:	48 98                	cltq   
  8004214c07:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c0e:	ff 
  8004214c0f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c13:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004214c1a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214c21:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214c27:	48 29 c2             	sub    %rax,%rdx
  8004214c2a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214c2e:	48 01 c2             	add    %rax,%rdx
  8004214c31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214c35:	48 01 c2             	add    %rax,%rdx
  8004214c38:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214c3f:	00 00 00 
  8004214c42:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004214c46:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214c4d:	00 00 00 
  8004214c50:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214c54:	48 89 c2             	mov    %rax,%rdx
  8004214c57:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214c5e:	00 00 00 
  8004214c61:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004214c65:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c68:	48 98                	cltq   
  8004214c6a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c71:	ff 
  8004214c72:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214c76:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214c7d:	00 00 00 
  8004214c80:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214c84:	e9 93 02 00 00       	jmpq   8004214f1c <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004214c89:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214c8d:	48 be 6f 89 21 04 80 	movabs $0x800421896f,%rsi
  8004214c94:	00 00 00 
  8004214c97:	48 89 c7             	mov    %rax,%rdi
  8004214c9a:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  8004214ca1:	00 00 00 
  8004214ca4:	ff d0                	callq  *%rax
  8004214ca6:	85 c0                	test   %eax,%eax
  8004214ca8:	0f 85 de 00 00 00    	jne    8004214d8c <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214cae:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cb1:	48 98                	cltq   
  8004214cb3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214cba:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214cbb:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214cbf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cc2:	48 98                	cltq   
  8004214cc4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214ccb:	ff 
  8004214ccc:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214cd0:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214cd7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214cdb:	48 01 c8             	add    %rcx,%rax
  8004214cde:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214ce5:	48 89 c7             	mov    %rax,%rdi
  8004214ce8:	48 b8 3c 4f 21 04 80 	movabs $0x8004214f3c,%rax
  8004214cef:	00 00 00 
  8004214cf2:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214cf4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cf7:	48 98                	cltq   
  8004214cf9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d00:	ff 
  8004214d01:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214d05:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d08:	48 98                	cltq   
  8004214d0a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d11:	ff 
  8004214d12:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d16:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004214d1d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004214d24:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214d2a:	48 29 c2             	sub    %rax,%rdx
  8004214d2d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214d31:	48 01 c2             	add    %rax,%rdx
  8004214d34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214d38:	48 01 c2             	add    %rax,%rdx
  8004214d3b:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214d42:	00 00 00 
  8004214d45:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004214d49:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214d50:	00 00 00 
  8004214d53:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004214d57:	48 89 c2             	mov    %rax,%rdx
  8004214d5a:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214d61:	00 00 00 
  8004214d64:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004214d68:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d6b:	48 98                	cltq   
  8004214d6d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d74:	ff 
  8004214d75:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214d79:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214d80:	00 00 00 
  8004214d83:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004214d87:	e9 90 01 00 00       	jmpq   8004214f1c <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004214d8c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214d90:	48 be 65 89 21 04 80 	movabs $0x8004218965,%rsi
  8004214d97:	00 00 00 
  8004214d9a:	48 89 c7             	mov    %rax,%rdi
  8004214d9d:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  8004214da4:	00 00 00 
  8004214da7:	ff d0                	callq  *%rax
  8004214da9:	85 c0                	test   %eax,%eax
  8004214dab:	75 65                	jne    8004214e12 <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004214dad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214db0:	48 98                	cltq   
  8004214db2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214db9:	ff 
  8004214dba:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214dbe:	48 89 c2             	mov    %rax,%rdx
  8004214dc1:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214dc8:	00 00 00 
  8004214dcb:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004214dcf:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214dd6:	00 00 00 
  8004214dd9:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004214ddd:	48 89 c2             	mov    %rax,%rdx
  8004214de0:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214de7:	00 00 00 
  8004214dea:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004214dee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214df1:	48 98                	cltq   
  8004214df3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214dfa:	ff 
  8004214dfb:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214dff:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214e06:	00 00 00 
  8004214e09:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004214e0d:	e9 0a 01 00 00       	jmpq   8004214f1c <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004214e12:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214e16:	48 be 7b 89 21 04 80 	movabs $0x800421897b,%rsi
  8004214e1d:	00 00 00 
  8004214e20:	48 89 c7             	mov    %rax,%rdi
  8004214e23:	48 b8 a6 ec 20 04 80 	movabs $0x800420eca6,%rax
  8004214e2a:	00 00 00 
  8004214e2d:	ff d0                	callq  *%rax
  8004214e2f:	85 c0                	test   %eax,%eax
  8004214e31:	0f 85 e5 00 00 00    	jne    8004214f1c <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214e37:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214e3a:	48 98                	cltq   
  8004214e3c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214e43:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214e44:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214e48:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214e4b:	48 98                	cltq   
  8004214e4d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214e54:	ff 
  8004214e55:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214e59:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214e60:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214e64:	48 01 c8             	add    %rcx,%rax
  8004214e67:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214e6e:	48 89 c7             	mov    %rax,%rdi
  8004214e71:	48 b8 3c 4f 21 04 80 	movabs $0x8004214f3c,%rax
  8004214e78:	00 00 00 
  8004214e7b:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214e7d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214e80:	48 98                	cltq   
  8004214e82:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214e89:	ff 
  8004214e8a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214e8e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214e91:	48 98                	cltq   
  8004214e93:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214e9a:	ff 
  8004214e9b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214e9f:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004214ea6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214ead:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214eb3:	48 29 c2             	sub    %rax,%rdx
  8004214eb6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214eba:	48 01 c2             	add    %rax,%rdx
  8004214ebd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214ec1:	48 01 c2             	add    %rax,%rdx
  8004214ec4:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214ecb:	00 00 00 
  8004214ece:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004214ed5:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214edc:	00 00 00 
  8004214edf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004214ee6:	48 89 c2             	mov    %rax,%rdx
  8004214ee9:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214ef0:	00 00 00 
  8004214ef3:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004214efa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214efd:	48 98                	cltq   
  8004214eff:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214f06:	ff 
  8004214f07:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214f0b:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214f12:	00 00 00 
  8004214f15:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004214f1c:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214f20:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214f23:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214f26:	0f 8c f0 fa ff ff    	jl     8004214a1c <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004214f2c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214f30:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214f37:	48 01 d0             	add    %rdx,%rax
}
  8004214f3a:	c9                   	leaveq 
  8004214f3b:	c3                   	retq   

0000008004214f3c <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004214f3c:	55                   	push   %rbp
  8004214f3d:	48 89 e5             	mov    %rsp,%rbp
  8004214f40:	48 83 ec 30          	sub    $0x30,%rsp
  8004214f44:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214f48:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004214f4c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004214f50:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004214f54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214f58:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004214f5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214f60:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214f64:	48 01 d0             	add    %rdx,%rax
  8004214f67:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004214f6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f6f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214f74:	48 85 c0             	test   %rax,%rax
  8004214f77:	74 35                	je     8004214fae <readseg+0x72>
  8004214f79:	48 b9 c2 89 21 04 80 	movabs $0x80042189c2,%rcx
  8004214f80:	00 00 00 
  8004214f83:	48 ba 9f 89 21 04 80 	movabs $0x800421899f,%rdx
  8004214f8a:	00 00 00 
  8004214f8d:	be c0 00 00 00       	mov    $0xc0,%esi
  8004214f92:	48 bf b4 89 21 04 80 	movabs $0x80042189b4,%rdi
  8004214f99:	00 00 00 
  8004214f9c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214fa1:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004214fa8:	00 00 00 
  8004214fab:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004214fae:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004214fb5:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004214fb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214fba:	48 c1 e8 09          	shr    $0x9,%rax
  8004214fbe:	48 83 c0 01          	add    $0x1,%rax
  8004214fc2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004214fc6:	eb 3c                	jmp    8004215004 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004214fc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214fcc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214fd0:	48 89 d6             	mov    %rdx,%rsi
  8004214fd3:	48 89 c7             	mov    %rax,%rdi
  8004214fd6:	48 b8 cc 50 21 04 80 	movabs $0x80042150cc,%rax
  8004214fdd:	00 00 00 
  8004214fe0:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004214fe2:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004214fe9:	00 
		*kvoffset += SECTSIZE;
  8004214fea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214fee:	48 8b 00             	mov    (%rax),%rax
  8004214ff1:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004214ff8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214ffc:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004214fff:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215004:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215008:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800421500c:	72 ba                	jb     8004214fc8 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  800421500e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215012:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215017:	48 89 c2             	mov    %rax,%rdx
  800421501a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421501e:	48 01 d0             	add    %rdx,%rax
  8004215021:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004215027:	76 2f                	jbe    8004215058 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004215029:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421502d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215031:	48 89 d6             	mov    %rdx,%rsi
  8004215034:	48 89 c7             	mov    %rax,%rdi
  8004215037:	48 b8 cc 50 21 04 80 	movabs $0x80042150cc,%rax
  800421503e:	00 00 00 
  8004215041:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004215043:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215047:	48 8b 00             	mov    (%rax),%rax
  800421504a:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215051:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215055:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004215058:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421505c:	48 8b 00             	mov    (%rax),%rax
  800421505f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215064:	48 85 c0             	test   %rax,%rax
  8004215067:	74 35                	je     800421509e <readseg+0x162>
  8004215069:	48 b9 d5 89 21 04 80 	movabs $0x80042189d5,%rcx
  8004215070:	00 00 00 
  8004215073:	48 ba 9f 89 21 04 80 	movabs $0x800421899f,%rdx
  800421507a:	00 00 00 
  800421507d:	be d6 00 00 00       	mov    $0xd6,%esi
  8004215082:	48 bf b4 89 21 04 80 	movabs $0x80042189b4,%rdi
  8004215089:	00 00 00 
  800421508c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215091:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004215098:	00 00 00 
  800421509b:	41 ff d0             	callq  *%r8
}
  800421509e:	c9                   	leaveq 
  800421509f:	c3                   	retq   

00000080042150a0 <waitdisk>:

void
waitdisk(void)
{
  80042150a0:	55                   	push   %rbp
  80042150a1:	48 89 e5             	mov    %rsp,%rbp
  80042150a4:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  80042150a8:	90                   	nop
  80042150a9:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042150b0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042150b3:	89 c2                	mov    %eax,%edx
  80042150b5:	ec                   	in     (%dx),%al
  80042150b6:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042150b9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042150bd:	0f b6 c0             	movzbl %al,%eax
  80042150c0:	25 c0 00 00 00       	and    $0xc0,%eax
  80042150c5:	83 f8 40             	cmp    $0x40,%eax
  80042150c8:	75 df                	jne    80042150a9 <waitdisk+0x9>
		/* do nothing */;
}
  80042150ca:	c9                   	leaveq 
  80042150cb:	c3                   	retq   

00000080042150cc <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  80042150cc:	55                   	push   %rbp
  80042150cd:	48 89 e5             	mov    %rsp,%rbp
  80042150d0:	48 83 ec 60          	sub    $0x60,%rsp
  80042150d4:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042150d8:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  80042150dc:	48 b8 a0 50 21 04 80 	movabs $0x80042150a0,%rax
  80042150e3:	00 00 00 
  80042150e6:	ff d0                	callq  *%rax
  80042150e8:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  80042150ef:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042150f3:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042150f7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042150fa:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  80042150fb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042150ff:	0f b6 c0             	movzbl %al,%eax
  8004215102:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004215109:	88 45 f3             	mov    %al,-0xd(%rbp)
  800421510c:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004215110:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215113:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004215114:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215118:	48 c1 e8 08          	shr    $0x8,%rax
  800421511c:	0f b6 c0             	movzbl %al,%eax
  800421511f:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004215126:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004215129:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800421512d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215130:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004215131:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215135:	48 c1 e8 10          	shr    $0x10,%rax
  8004215139:	0f b6 c0             	movzbl %al,%eax
  800421513c:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004215143:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004215146:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800421514a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421514d:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  800421514e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215152:	48 c1 e8 18          	shr    $0x18,%rax
  8004215156:	83 c8 e0             	or     $0xffffffe0,%eax
  8004215159:	0f b6 c0             	movzbl %al,%eax
  800421515c:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004215163:	88 45 db             	mov    %al,-0x25(%rbp)
  8004215166:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800421516a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421516d:	ee                   	out    %al,(%dx)
  800421516e:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004215175:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004215179:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800421517d:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215180:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004215181:	48 b8 a0 50 21 04 80 	movabs $0x80042150a0,%rax
  8004215188:	00 00 00 
  800421518b:	ff d0                	callq  *%rax
  800421518d:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004215194:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215198:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800421519c:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  80042151a3:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042151a6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042151aa:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042151ad:	48 89 ce             	mov    %rcx,%rsi
  80042151b0:	48 89 f7             	mov    %rsi,%rdi
  80042151b3:	89 c1                	mov    %eax,%ecx
  80042151b5:	fc                   	cld    
  80042151b6:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  80042151b8:	89 c8                	mov    %ecx,%eax
  80042151ba:	48 89 fe             	mov    %rdi,%rsi
  80042151bd:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042151c1:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  80042151c4:	c9                   	leaveq 
  80042151c5:	c3                   	retq   
  80042151c6:	66 90                	xchg   %ax,%ax

00000080042151c8 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  80042151c8:	fa                   	cli    
	xorw    %ax, %ax
  80042151c9:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  80042151cb:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042151cd:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042151cf:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  80042151d1:	0f 01 16             	lgdt   (%rsi)
  80042151d4:	e0 70                	loopne 8004215246 <start64+0x10>
	movl    %cr0, %eax
  80042151d6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  80042151d9:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  80042151dd:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  80042151e0:	ea                   	(bad)  
  80042151e1:	1d 70 08 00 66       	sbb    $0x66000870,%eax

00000080042151e5 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  80042151e5:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  80042151e9:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042151eb:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042151ed:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  80042151ef:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  80042151f3:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  80042151f5:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  80042151f7:	b8 20 00 00 00       	mov    $0x20,%eax

	movl %eax,%cr4
  80042151fc:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  80042151ff:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 421c2c6 <_start+0x401c2ba>
	movl    %cr0, %eax
  8004215206:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215209:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  800421520c:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  800421520f:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004215214:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004215217:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  800421521c:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  800421521e:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004215222:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004215224:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004215227:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  800421522c:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  800421522f:	ea                   	(bad)  
  8004215230:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004215231:	70 00                	jo     8004215233 <start32+0x4e>
  8004215233:	00 08                	add    %cl,(%rax)
	...

0000008004215236 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004215236:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  800421523a:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421523c:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421523e:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215240:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215244:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215246:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004215248:	48 a1 18 47 3d 04 80 	movabs 0x80043d4718,%rax
  800421524f:	00 00 00 
	movq    %rax,%rsp
  8004215252:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004215255:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  800421525c:	48 b8 c1 03 20 04 80 	movabs $0x80042003c1,%rax
  8004215263:	00 00 00 
	call    *%rax
  8004215266:	ff d0                	callq  *%rax

0000008004215268 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004215268:	eb fe                	jmp    8004215268 <spin>
  800421526a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004215270 <gdt>:
	...
  8004215278:	ff                   	(bad)  
  8004215279:	ff 00                	incl   (%rax)
  800421527b:	00 00                	add    %al,(%rax)
  800421527d:	9a                   	(bad)  
  800421527e:	af                   	scas   %es:(%rdi),%eax
  800421527f:	00 ff                	add    %bh,%bh
  8004215281:	ff 00                	incl   (%rax)
  8004215283:	00 00                	add    %al,(%rax)
  8004215285:	92                   	xchg   %eax,%edx
  8004215286:	af                   	scas   %es:(%rdi),%eax
	...

0000008004215288 <gdtdesc>:
  8004215288:	17                   	(bad)  
  8004215289:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  800421528f:	90                   	nop

0000008004215290 <gdt32>:
	...
  8004215298:	ff                   	(bad)  
  8004215299:	ff 00                	incl   (%rax)
  800421529b:	00 00                	add    %al,(%rax)
  800421529d:	9a                   	(bad)  
  800421529e:	cf                   	iret   
  800421529f:	00 ff                	add    %bh,%bh
  80042152a1:	ff 00                	incl   (%rax)
  80042152a3:	00 00                	add    %al,(%rax)
  80042152a5:	92                   	xchg   %eax,%edx
  80042152a6:	cf                   	iret   
	...

00000080042152a8 <gdt32desc>:
  80042152a8:	17                   	(bad)  
  80042152a9:	00 c8                	add    %cl,%al
  80042152ab:	70 00                	jo     80042152ad <gdt32desc+0x5>
	...

00000080042152ae <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  80042152ae:	90                   	nop

00000080042152af <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  80042152af:	55                   	push   %rbp
  80042152b0:	48 89 e5             	mov    %rsp,%rbp
  80042152b3:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042152b7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042152bb:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  80042152be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  80042152c5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042152cc:	eb 1a                	jmp    80042152e8 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  80042152ce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042152d1:	48 63 d0             	movslq %eax,%rdx
  80042152d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152d8:	48 01 d0             	add    %rdx,%rax
  80042152db:	0f b6 00             	movzbl (%rax),%eax
  80042152de:	0f b6 c0             	movzbl %al,%eax
  80042152e1:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  80042152e4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042152e8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042152eb:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042152ee:	7c de                	jl     80042152ce <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  80042152f0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80042152f3:	c9                   	leaveq 
  80042152f4:	c3                   	retq   

00000080042152f5 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  80042152f5:	55                   	push   %rbp
  80042152f6:	48 89 e5             	mov    %rsp,%rbp
  80042152f9:	48 83 ec 40          	sub    $0x40,%rsp
  80042152fd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215301:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004215304:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215308:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421530c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215310:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215314:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215317:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421531a:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004215321:	00 00 00 
  8004215324:	48 8b 00             	mov    (%rax),%rax
  8004215327:	48 39 c2             	cmp    %rax,%rdx
  800421532a:	72 32                	jb     800421535e <mpsearch1+0x69>
  800421532c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215330:	48 89 c1             	mov    %rax,%rcx
  8004215333:	48 ba f0 89 21 04 80 	movabs $0x80042189f0,%rdx
  800421533a:	00 00 00 
  800421533d:	be 58 00 00 00       	mov    $0x58,%esi
  8004215342:	48 bf 13 8a 21 04 80 	movabs $0x8004218a13,%rdi
  8004215349:	00 00 00 
  800421534c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215351:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004215358:	00 00 00 
  800421535b:	41 ff d0             	callq  *%r8
  800421535e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215365:	00 00 00 
  8004215368:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421536c:	48 01 d0             	add    %rdx,%rax
  800421536f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215373:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215376:	48 63 d0             	movslq %eax,%rdx
  8004215379:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421537d:	48 01 d0             	add    %rdx,%rax
  8004215380:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004215384:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215388:	48 c1 e8 0c          	shr    $0xc,%rax
  800421538c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421538f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215392:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004215399:	00 00 00 
  800421539c:	48 8b 00             	mov    (%rax),%rax
  800421539f:	48 39 c2             	cmp    %rax,%rdx
  80042153a2:	72 32                	jb     80042153d6 <mpsearch1+0xe1>
  80042153a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042153a8:	48 89 c1             	mov    %rax,%rcx
  80042153ab:	48 ba f0 89 21 04 80 	movabs $0x80042189f0,%rdx
  80042153b2:	00 00 00 
  80042153b5:	be 58 00 00 00       	mov    $0x58,%esi
  80042153ba:	48 bf 13 8a 21 04 80 	movabs $0x8004218a13,%rdi
  80042153c1:	00 00 00 
  80042153c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042153c9:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042153d0:	00 00 00 
  80042153d3:	41 ff d0             	callq  *%r8
  80042153d6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042153dd:	00 00 00 
  80042153e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042153e4:	48 01 d0             	add    %rdx,%rax
  80042153e7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  80042153eb:	eb 4d                	jmp    800421543a <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042153ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042153f1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042153f6:	48 be 23 8a 21 04 80 	movabs $0x8004218a23,%rsi
  80042153fd:	00 00 00 
  8004215400:	48 89 c7             	mov    %rax,%rdi
  8004215403:	48 b8 b3 ef 20 04 80 	movabs $0x800420efb3,%rax
  800421540a:	00 00 00 
  800421540d:	ff d0                	callq  *%rax
  800421540f:	85 c0                	test   %eax,%eax
  8004215411:	75 22                	jne    8004215435 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004215413:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215417:	be 10 00 00 00       	mov    $0x10,%esi
  800421541c:	48 89 c7             	mov    %rax,%rdi
  800421541f:	48 b8 af 52 21 04 80 	movabs $0x80042152af,%rax
  8004215426:	00 00 00 
  8004215429:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421542b:	84 c0                	test   %al,%al
  800421542d:	75 06                	jne    8004215435 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  800421542f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215433:	eb 14                	jmp    8004215449 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004215435:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  800421543a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421543e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004215442:	72 a9                	jb     80042153ed <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004215444:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215449:	c9                   	leaveq 
  800421544a:	c3                   	retq   

000000800421544b <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  800421544b:	55                   	push   %rbp
  800421544c:	48 89 e5             	mov    %rsp,%rbp
  800421544f:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004215453:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800421545a:	00 
  800421545b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421545f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215463:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004215466:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215469:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004215470:	00 00 00 
  8004215473:	48 8b 00             	mov    (%rax),%rax
  8004215476:	48 39 c2             	cmp    %rax,%rdx
  8004215479:	72 32                	jb     80042154ad <mpsearch+0x62>
  800421547b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421547f:	48 89 c1             	mov    %rax,%rcx
  8004215482:	48 ba f0 89 21 04 80 	movabs $0x80042189f0,%rdx
  8004215489:	00 00 00 
  800421548c:	be 70 00 00 00       	mov    $0x70,%esi
  8004215491:	48 bf 13 8a 21 04 80 	movabs $0x8004218a13,%rdi
  8004215498:	00 00 00 
  800421549b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154a0:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  80042154a7:	00 00 00 
  80042154aa:	41 ff d0             	callq  *%r8
  80042154ad:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042154b4:	00 00 00 
  80042154b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154bb:	48 01 d0             	add    %rdx,%rax
  80042154be:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  80042154c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154c6:	48 83 c0 0e          	add    $0xe,%rax
  80042154ca:	0f b7 00             	movzwl (%rax),%eax
  80042154cd:	0f b7 c0             	movzwl %ax,%eax
  80042154d0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042154d3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042154d7:	74 2c                	je     8004215505 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  80042154d9:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  80042154dd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042154e0:	be 00 04 00 00       	mov    $0x400,%esi
  80042154e5:	48 89 c7             	mov    %rax,%rdi
  80042154e8:	48 b8 f5 52 21 04 80 	movabs $0x80042152f5,%rax
  80042154ef:	00 00 00 
  80042154f2:	ff d0                	callq  *%rax
  80042154f4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042154f8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042154fd:	74 49                	je     8004215548 <mpsearch+0xfd>
			return mp;
  80042154ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215503:	eb 59                	jmp    800421555e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004215505:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215509:	48 83 c0 13          	add    $0x13,%rax
  800421550d:	0f b7 00             	movzwl (%rax),%eax
  8004215510:	0f b7 c0             	movzwl %ax,%eax
  8004215513:	c1 e0 0a             	shl    $0xa,%eax
  8004215516:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004215519:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421551c:	2d 00 04 00 00       	sub    $0x400,%eax
  8004215521:	89 c0                	mov    %eax,%eax
  8004215523:	be 00 04 00 00       	mov    $0x400,%esi
  8004215528:	48 89 c7             	mov    %rax,%rdi
  800421552b:	48 b8 f5 52 21 04 80 	movabs $0x80042152f5,%rax
  8004215532:	00 00 00 
  8004215535:	ff d0                	callq  *%rax
  8004215537:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421553b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004215540:	74 06                	je     8004215548 <mpsearch+0xfd>
			return mp;
  8004215542:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215546:	eb 16                	jmp    800421555e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004215548:	be 00 00 01 00       	mov    $0x10000,%esi
  800421554d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004215552:	48 b8 f5 52 21 04 80 	movabs $0x80042152f5,%rax
  8004215559:	00 00 00 
  800421555c:	ff d0                	callq  *%rax
}
  800421555e:	c9                   	leaveq 
  800421555f:	c3                   	retq   

0000008004215560 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004215560:	55                   	push   %rbp
  8004215561:	48 89 e5             	mov    %rsp,%rbp
  8004215564:	48 83 ec 30          	sub    $0x30,%rsp
  8004215568:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421556c:	48 b8 4b 54 21 04 80 	movabs $0x800421544b,%rax
  8004215573:	00 00 00 
  8004215576:	ff d0                	callq  *%rax
  8004215578:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421557c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215581:	75 0a                	jne    800421558d <mpconfig+0x2d>
		return NULL;
  8004215583:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215588:	e9 f6 01 00 00       	jmpq   8004215783 <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421558d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215591:	8b 40 04             	mov    0x4(%rax),%eax
  8004215594:	85 c0                	test   %eax,%eax
  8004215596:	74 0c                	je     80042155a4 <mpconfig+0x44>
  8004215598:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421559c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  80042155a0:	84 c0                	test   %al,%al
  80042155a2:	74 25                	je     80042155c9 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  80042155a4:	48 bf 28 8a 21 04 80 	movabs $0x8004218a28,%rdi
  80042155ab:	00 00 00 
  80042155ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042155b3:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042155ba:	00 00 00 
  80042155bd:	ff d2                	callq  *%rdx
		return NULL;
  80042155bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042155c4:	e9 ba 01 00 00       	jmpq   8004215783 <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  80042155c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042155cd:	8b 40 04             	mov    0x4(%rax),%eax
  80042155d0:	89 c0                	mov    %eax,%eax
  80042155d2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042155d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042155da:	48 c1 e8 0c          	shr    $0xc,%rax
  80042155de:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042155e1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042155e4:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  80042155eb:	00 00 00 
  80042155ee:	48 8b 00             	mov    (%rax),%rax
  80042155f1:	48 39 c2             	cmp    %rax,%rdx
  80042155f4:	72 32                	jb     8004215628 <mpconfig+0xc8>
  80042155f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042155fa:	48 89 c1             	mov    %rax,%rcx
  80042155fd:	48 ba f0 89 21 04 80 	movabs $0x80042189f0,%rdx
  8004215604:	00 00 00 
  8004215607:	be 91 00 00 00       	mov    $0x91,%esi
  800421560c:	48 bf 13 8a 21 04 80 	movabs $0x8004218a13,%rdi
  8004215613:	00 00 00 
  8004215616:	b8 00 00 00 00       	mov    $0x0,%eax
  800421561b:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004215622:	00 00 00 
  8004215625:	41 ff d0             	callq  *%r8
  8004215628:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421562f:	00 00 00 
  8004215632:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215636:	48 01 d0             	add    %rdx,%rax
  8004215639:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  800421563d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215641:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215646:	48 be 55 8a 21 04 80 	movabs $0x8004218a55,%rsi
  800421564d:	00 00 00 
  8004215650:	48 89 c7             	mov    %rax,%rdi
  8004215653:	48 b8 b3 ef 20 04 80 	movabs $0x800420efb3,%rax
  800421565a:	00 00 00 
  800421565d:	ff d0                	callq  *%rax
  800421565f:	85 c0                	test   %eax,%eax
  8004215661:	74 25                	je     8004215688 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004215663:	48 bf 60 8a 21 04 80 	movabs $0x8004218a60,%rdi
  800421566a:	00 00 00 
  800421566d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215672:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004215679:	00 00 00 
  800421567c:	ff d2                	callq  *%rdx
		return NULL;
  800421567e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215683:	e9 fb 00 00 00       	jmpq   8004215783 <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004215688:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421568c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004215690:	0f b7 d0             	movzwl %ax,%edx
  8004215693:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215697:	89 d6                	mov    %edx,%esi
  8004215699:	48 89 c7             	mov    %rax,%rdi
  800421569c:	48 b8 af 52 21 04 80 	movabs $0x80042152af,%rax
  80042156a3:	00 00 00 
  80042156a6:	ff d0                	callq  *%rax
  80042156a8:	84 c0                	test   %al,%al
  80042156aa:	74 25                	je     80042156d1 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  80042156ac:	48 bf 98 8a 21 04 80 	movabs $0x8004218a98,%rdi
  80042156b3:	00 00 00 
  80042156b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042156bb:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042156c2:	00 00 00 
  80042156c5:	ff d2                	callq  *%rdx
		return NULL;
  80042156c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042156cc:	e9 b2 00 00 00       	jmpq   8004215783 <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  80042156d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156d5:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042156d9:	3c 01                	cmp    $0x1,%al
  80042156db:	74 3b                	je     8004215718 <mpconfig+0x1b8>
  80042156dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156e1:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042156e5:	3c 04                	cmp    $0x4,%al
  80042156e7:	74 2f                	je     8004215718 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  80042156e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156ed:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042156f1:	0f b6 c0             	movzbl %al,%eax
  80042156f4:	89 c6                	mov    %eax,%esi
  80042156f6:	48 bf c0 8a 21 04 80 	movabs $0x8004218ac0,%rdi
  80042156fd:	00 00 00 
  8004215700:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215705:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  800421570c:	00 00 00 
  800421570f:	ff d2                	callq  *%rdx
		return NULL;
  8004215711:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215716:	eb 6b                	jmp    8004215783 <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004215718:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421571c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004215720:	0f b7 c0             	movzwl %ax,%eax
  8004215723:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215727:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  800421572b:	0f b7 ca             	movzwl %dx,%ecx
  800421572e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215732:	48 01 ca             	add    %rcx,%rdx
  8004215735:	89 c6                	mov    %eax,%esi
  8004215737:	48 89 d7             	mov    %rdx,%rdi
  800421573a:	48 b8 af 52 21 04 80 	movabs $0x80042152af,%rax
  8004215741:	00 00 00 
  8004215744:	ff d0                	callq  *%rax
  8004215746:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421574a:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  800421574e:	38 d0                	cmp    %dl,%al
  8004215750:	74 22                	je     8004215774 <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004215752:	48 bf e0 8a 21 04 80 	movabs $0x8004218ae0,%rdi
  8004215759:	00 00 00 
  800421575c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215761:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004215768:	00 00 00 
  800421576b:	ff d2                	callq  *%rdx
		return NULL;
  800421576d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215772:	eb 0f                	jmp    8004215783 <mpconfig+0x223>
	}
	*pmp = mp;
  8004215774:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215778:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421577c:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  800421577f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004215783:	c9                   	leaveq 
  8004215784:	c3                   	retq   

0000008004215785 <mp_init>:

void
mp_init(void)
{
  8004215785:	55                   	push   %rbp
  8004215786:	48 89 e5             	mov    %rsp,%rbp
  8004215789:	53                   	push   %rbx
  800421578a:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421578e:	48 b8 e0 63 3d 04 80 	movabs $0x80043d63e0,%rax
  8004215795:	00 00 00 
  8004215798:	48 bb 20 60 3d 04 80 	movabs $0x80043d6020,%rbx
  800421579f:	00 00 00 
  80042157a2:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  80042157a5:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  80042157a9:	48 89 c7             	mov    %rax,%rdi
  80042157ac:	48 b8 60 55 21 04 80 	movabs $0x8004215560,%rax
  80042157b3:	00 00 00 
  80042157b6:	ff d0                	callq  *%rax
  80042157b8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042157bc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042157c1:	75 05                	jne    80042157c8 <mp_init+0x43>
		return;
  80042157c3:	e9 71 03 00 00       	jmpq   8004215b39 <mp_init+0x3b4>
	ismp = 1;
  80042157c8:	48 b8 00 60 3d 04 80 	movabs $0x80043d6000,%rax
  80042157cf:	00 00 00 
  80042157d2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  80042157d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157dc:	8b 40 24             	mov    0x24(%rax),%eax
  80042157df:	89 c2                	mov    %eax,%edx
  80042157e1:	48 b8 00 70 45 04 80 	movabs $0x8004457000,%rax
  80042157e8:	00 00 00 
  80042157eb:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042157ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157f2:	48 83 c0 2c          	add    $0x2c,%rax
  80042157f6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042157fa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004215801:	e9 18 02 00 00       	jmpq   8004215a1e <mp_init+0x299>
		switch (*p) {
  8004215806:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421580a:	0f b6 00             	movzbl (%rax),%eax
  800421580d:	0f b6 c0             	movzbl %al,%eax
  8004215810:	85 c0                	test   %eax,%eax
  8004215812:	74 16                	je     800421582a <mp_init+0xa5>
  8004215814:	85 c0                	test   %eax,%eax
  8004215816:	0f 88 b9 01 00 00    	js     80042159d5 <mp_init+0x250>
  800421581c:	83 f8 04             	cmp    $0x4,%eax
  800421581f:	0f 8f b0 01 00 00    	jg     80042159d5 <mp_init+0x250>
  8004215825:	e9 a4 01 00 00       	jmpq   80042159ce <mp_init+0x249>
		case MPPROC:
			proc = (struct mpproc *)p;
  800421582a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421582e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  8004215832:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215836:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421583a:	0f b6 c0             	movzbl %al,%eax
  800421583d:	83 e0 02             	and    $0x2,%eax
  8004215840:	85 c0                	test   %eax,%eax
  8004215842:	74 51                	je     8004215895 <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  8004215844:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  800421584b:	00 00 00 
  800421584e:	8b 00                	mov    (%rax),%eax
  8004215850:	48 98                	cltq   
  8004215852:	48 c1 e0 03          	shl    $0x3,%rax
  8004215856:	48 89 c2             	mov    %rax,%rdx
  8004215859:	48 c1 e2 04          	shl    $0x4,%rdx
  800421585d:	48 29 c2             	sub    %rax,%rdx
  8004215860:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  8004215867:	00 00 00 
  800421586a:	48 01 c2             	add    %rax,%rdx
  800421586d:	48 b8 e0 63 3d 04 80 	movabs $0x80043d63e0,%rax
  8004215874:	00 00 00 
  8004215877:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  800421587a:	48 bf 0d 8b 21 04 80 	movabs $0x8004218b0d,%rdi
  8004215881:	00 00 00 
  8004215884:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215889:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004215890:	00 00 00 
  8004215893:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004215895:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  800421589c:	00 00 00 
  800421589f:	8b 00                	mov    (%rax),%eax
  80042158a1:	83 f8 07             	cmp    $0x7,%eax
  80042158a4:	0f 8f f5 00 00 00    	jg     800421599f <mp_init+0x21a>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  80042158aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158ae:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  80042158b2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158b6:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042158ba:	0f b6 f0             	movzbl %al,%esi
  80042158bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158c1:	8b 78 08             	mov    0x8(%rax),%edi
  80042158c4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158c8:	4c 8d 50 04          	lea    0x4(%rax),%r10
  80042158cc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158d0:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  80042158d4:	0f b6 c8             	movzbl %al,%ecx
  80042158d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158db:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80042158df:	0f b6 d0             	movzbl %al,%edx
  80042158e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158e6:	0f b6 00             	movzbl (%rax),%eax
  80042158e9:	0f b6 c0             	movzbl %al,%eax
  80042158ec:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042158f1:	89 34 24             	mov    %esi,(%rsp)
  80042158f4:	41 89 f9             	mov    %edi,%r9d
  80042158f7:	4d 89 d0             	mov    %r10,%r8
  80042158fa:	89 c6                	mov    %eax,%esi
  80042158fc:	48 bf 20 8b 21 04 80 	movabs $0x8004218b20,%rdi
  8004215903:	00 00 00 
  8004215906:	b8 00 00 00 00       	mov    $0x0,%eax
  800421590b:	49 ba c2 87 20 04 80 	movabs $0x80042087c2,%r10
  8004215912:	00 00 00 
  8004215915:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  8004215918:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421591c:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004215920:	0f b6 c0             	movzbl %al,%eax
  8004215923:	83 e0 01             	and    $0x1,%eax
  8004215926:	85 c0                	test   %eax,%eax
  8004215928:	74 58                	je     8004215982 <mp_init+0x1fd>
					cpus[ncpu].cpu_id = ncpu;
  800421592a:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  8004215931:	00 00 00 
  8004215934:	8b 10                	mov    (%rax),%edx
  8004215936:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  800421593d:	00 00 00 
  8004215940:	8b 00                	mov    (%rax),%eax
  8004215942:	89 c1                	mov    %eax,%ecx
  8004215944:	48 be 20 60 3d 04 80 	movabs $0x80043d6020,%rsi
  800421594b:	00 00 00 
  800421594e:	48 63 c2             	movslq %edx,%rax
  8004215951:	48 c1 e0 03          	shl    $0x3,%rax
  8004215955:	48 89 c2             	mov    %rax,%rdx
  8004215958:	48 c1 e2 04          	shl    $0x4,%rdx
  800421595c:	48 29 c2             	sub    %rax,%rdx
  800421595f:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  8004215963:	88 08                	mov    %cl,(%rax)
					ncpu++;
  8004215965:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  800421596c:	00 00 00 
  800421596f:	8b 00                	mov    (%rax),%eax
  8004215971:	8d 50 01             	lea    0x1(%rax),%edx
  8004215974:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  800421597b:	00 00 00 
  800421597e:	89 10                	mov    %edx,(%rax)
  8004215980:	eb 45                	jmp    80042159c7 <mp_init+0x242>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004215982:	48 bf 70 8b 21 04 80 	movabs $0x8004218b70,%rdi
  8004215989:	00 00 00 
  800421598c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215991:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004215998:	00 00 00 
  800421599b:	ff d2                	callq  *%rdx
  800421599d:	eb 28                	jmp    80042159c7 <mp_init+0x242>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  800421599f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042159a3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  80042159a7:	0f b6 c0             	movzbl %al,%eax
  80042159aa:	89 c6                	mov    %eax,%esi
  80042159ac:	48 bf a0 8b 21 04 80 	movabs $0x8004218ba0,%rdi
  80042159b3:	00 00 00 
  80042159b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042159bb:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042159c2:	00 00 00 
  80042159c5:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  80042159c7:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  80042159cc:	eb 4c                	jmp    8004215a1a <mp_init+0x295>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  80042159ce:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  80042159d3:	eb 45                	jmp    8004215a1a <mp_init+0x295>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  80042159d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042159d9:	0f b6 00             	movzbl (%rax),%eax
  80042159dc:	0f b6 c0             	movzbl %al,%eax
  80042159df:	89 c6                	mov    %eax,%esi
  80042159e1:	48 bf c8 8b 21 04 80 	movabs $0x8004218bc8,%rdi
  80042159e8:	00 00 00 
  80042159eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042159f0:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  80042159f7:	00 00 00 
  80042159fa:	ff d2                	callq  *%rdx
			ismp = 0;
  80042159fc:	48 b8 00 60 3d 04 80 	movabs $0x80043d6000,%rax
  8004215a03:	00 00 00 
  8004215a06:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004215a0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a10:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215a14:	0f b7 c0             	movzwl %ax,%eax
  8004215a17:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004215a1a:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004215a1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a22:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215a26:	0f b7 c0             	movzwl %ax,%eax
  8004215a29:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004215a2c:	0f 87 d4 fd ff ff    	ja     8004215806 <mp_init+0x81>
			i = conf->entry;
		}
	}


	bootcpu->cpu_status = CPU_STARTED;
  8004215a32:	48 b8 e0 63 3d 04 80 	movabs $0x80043d63e0,%rax
  8004215a39:	00 00 00 
  8004215a3c:	48 8b 00             	mov    (%rax),%rax
  8004215a3f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004215a46:	48 b8 00 60 3d 04 80 	movabs $0x80043d6000,%rax
  8004215a4d:	00 00 00 
  8004215a50:	8b 00                	mov    (%rax),%eax
  8004215a52:	85 c0                	test   %eax,%eax
  8004215a54:	75 41                	jne    8004215a97 <mp_init+0x312>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004215a56:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  8004215a5d:	00 00 00 
  8004215a60:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004215a66:	48 b8 00 70 45 04 80 	movabs $0x8004457000,%rax
  8004215a6d:	00 00 00 
  8004215a70:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004215a77:	48 bf e8 8b 21 04 80 	movabs $0x8004218be8,%rdi
  8004215a7e:	00 00 00 
  8004215a81:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215a86:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004215a8d:	00 00 00 
  8004215a90:	ff d2                	callq  *%rdx
		return;
  8004215a92:	e9 a2 00 00 00       	jmpq   8004215b39 <mp_init+0x3b4>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004215a97:	48 b8 e8 63 3d 04 80 	movabs $0x80043d63e8,%rax
  8004215a9e:	00 00 00 
  8004215aa1:	8b 10                	mov    (%rax),%edx
  8004215aa3:	48 b8 e0 63 3d 04 80 	movabs $0x80043d63e0,%rax
  8004215aaa:	00 00 00 
  8004215aad:	48 8b 00             	mov    (%rax),%rax
  8004215ab0:	0f b6 00             	movzbl (%rax),%eax
  8004215ab3:	0f b6 c0             	movzbl %al,%eax
  8004215ab6:	89 c6                	mov    %eax,%esi
  8004215ab8:	48 bf 14 8c 21 04 80 	movabs $0x8004218c14,%rdi
  8004215abf:	00 00 00 
  8004215ac2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215ac7:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  8004215ace:	00 00 00 
  8004215ad1:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004215ad3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215ad7:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004215adb:	84 c0                	test   %al,%al
  8004215add:	74 5a                	je     8004215b39 <mp_init+0x3b4>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004215adf:	48 bf 38 8c 21 04 80 	movabs $0x8004218c38,%rdi
  8004215ae6:	00 00 00 
  8004215ae9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215aee:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004215af5:	00 00 00 
  8004215af8:	ff d2                	callq  *%rdx
  8004215afa:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004215b01:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215b05:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004215b09:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215b0c:	ee                   	out    %al,(%dx)
  8004215b0d:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215b14:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215b17:	89 c2                	mov    %eax,%edx
  8004215b19:	ec                   	in     (%dx),%al
  8004215b1a:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004215b1d:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004215b21:	83 c8 01             	or     $0x1,%eax
  8004215b24:	0f b6 c0             	movzbl %al,%eax
  8004215b27:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  8004215b2e:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215b31:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004215b35:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004215b38:	ee                   	out    %al,(%dx)
	}
}
  8004215b39:	48 83 c4 58          	add    $0x58,%rsp
  8004215b3d:	5b                   	pop    %rbx
  8004215b3e:	5d                   	pop    %rbp
  8004215b3f:	c3                   	retq   

0000008004215b40 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004215b40:	55                   	push   %rbp
  8004215b41:	48 89 e5             	mov    %rsp,%rbp
  8004215b44:	48 83 ec 08          	sub    $0x8,%rsp
  8004215b48:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004215b4b:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  8004215b4e:	48 b8 08 70 45 04 80 	movabs $0x8004457008,%rax
  8004215b55:	00 00 00 
  8004215b58:	48 8b 00             	mov    (%rax),%rax
  8004215b5b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215b5e:	48 63 d2             	movslq %edx,%rdx
  8004215b61:	48 c1 e2 02          	shl    $0x2,%rdx
  8004215b65:	48 01 c2             	add    %rax,%rdx
  8004215b68:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004215b6b:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  8004215b6d:	48 b8 08 70 45 04 80 	movabs $0x8004457008,%rax
  8004215b74:	00 00 00 
  8004215b77:	48 8b 00             	mov    (%rax),%rax
  8004215b7a:	48 83 c0 20          	add    $0x20,%rax
  8004215b7e:	8b 00                	mov    (%rax),%eax
}
  8004215b80:	c9                   	leaveq 
  8004215b81:	c3                   	retq   

0000008004215b82 <lapic_init>:

void
lapic_init(void)
{
  8004215b82:	55                   	push   %rbp
  8004215b83:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004215b86:	48 b8 00 70 45 04 80 	movabs $0x8004457000,%rax
  8004215b8d:	00 00 00 
  8004215b90:	48 8b 00             	mov    (%rax),%rax
  8004215b93:	48 85 c0             	test   %rax,%rax
  8004215b96:	75 05                	jne    8004215b9d <lapic_init+0x1b>
		return;
  8004215b98:	e9 da 01 00 00       	jmpq   8004215d77 <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  8004215b9d:	48 b8 00 70 45 04 80 	movabs $0x8004457000,%rax
  8004215ba4:	00 00 00 
  8004215ba7:	48 8b 00             	mov    (%rax),%rax
  8004215baa:	be 00 10 00 00       	mov    $0x1000,%esi
  8004215baf:	48 89 c7             	mov    %rax,%rdi
  8004215bb2:	48 b8 df 32 20 04 80 	movabs $0x80042032df,%rax
  8004215bb9:	00 00 00 
  8004215bbc:	ff d0                	callq  *%rax
  8004215bbe:	48 ba 08 70 45 04 80 	movabs $0x8004457008,%rdx
  8004215bc5:	00 00 00 
  8004215bc8:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  8004215bcb:	be 27 01 00 00       	mov    $0x127,%esi
  8004215bd0:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004215bd5:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215bdc:	00 00 00 
  8004215bdf:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004215be1:	be 0b 00 00 00       	mov    $0xb,%esi
  8004215be6:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004215beb:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215bf2:	00 00 00 
  8004215bf5:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004215bf7:	be 20 00 02 00       	mov    $0x20020,%esi
  8004215bfc:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215c01:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215c08:	00 00 00 
  8004215c0b:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004215c0d:	be 80 96 98 00       	mov    $0x989680,%esi
  8004215c12:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004215c17:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215c1e:	00 00 00 
  8004215c21:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004215c23:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004215c2a:	00 00 00 
  8004215c2d:	ff d0                	callq  *%rax
  8004215c2f:	48 98                	cltq   
  8004215c31:	48 c1 e0 03          	shl    $0x3,%rax
  8004215c35:	48 89 c2             	mov    %rax,%rdx
  8004215c38:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215c3c:	48 29 c2             	sub    %rax,%rdx
  8004215c3f:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  8004215c46:	00 00 00 
  8004215c49:	48 01 c2             	add    %rax,%rdx
  8004215c4c:	48 b8 e0 63 3d 04 80 	movabs $0x80043d63e0,%rax
  8004215c53:	00 00 00 
  8004215c56:	48 8b 00             	mov    (%rax),%rax
  8004215c59:	48 39 c2             	cmp    %rax,%rdx
  8004215c5c:	74 16                	je     8004215c74 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  8004215c5e:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215c63:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004215c68:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215c6f:	00 00 00 
  8004215c72:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004215c74:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215c79:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004215c7e:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215c85:	00 00 00 
  8004215c88:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004215c8a:	48 b8 08 70 45 04 80 	movabs $0x8004457008,%rax
  8004215c91:	00 00 00 
  8004215c94:	48 8b 00             	mov    (%rax),%rax
  8004215c97:	48 83 c0 30          	add    $0x30,%rax
  8004215c9b:	8b 00                	mov    (%rax),%eax
  8004215c9d:	c1 e8 10             	shr    $0x10,%eax
  8004215ca0:	0f b6 c0             	movzbl %al,%eax
  8004215ca3:	83 f8 03             	cmp    $0x3,%eax
  8004215ca6:	76 16                	jbe    8004215cbe <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  8004215ca8:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215cad:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004215cb2:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215cb9:	00 00 00 
  8004215cbc:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004215cbe:	be 33 00 00 00       	mov    $0x33,%esi
  8004215cc3:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004215cc8:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215ccf:	00 00 00 
  8004215cd2:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004215cd4:	be 00 00 00 00       	mov    $0x0,%esi
  8004215cd9:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215cde:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215ce5:	00 00 00 
  8004215ce8:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004215cea:	be 00 00 00 00       	mov    $0x0,%esi
  8004215cef:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215cf4:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215cfb:	00 00 00 
  8004215cfe:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004215d00:	be 00 00 00 00       	mov    $0x0,%esi
  8004215d05:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215d0a:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215d11:	00 00 00 
  8004215d14:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004215d16:	be 00 00 00 00       	mov    $0x0,%esi
  8004215d1b:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215d20:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215d27:	00 00 00 
  8004215d2a:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004215d2c:	be 00 85 08 00       	mov    $0x88500,%esi
  8004215d31:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215d36:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215d3d:	00 00 00 
  8004215d40:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004215d42:	90                   	nop
  8004215d43:	48 b8 08 70 45 04 80 	movabs $0x8004457008,%rax
  8004215d4a:	00 00 00 
  8004215d4d:	48 8b 00             	mov    (%rax),%rax
  8004215d50:	48 05 00 03 00 00    	add    $0x300,%rax
  8004215d56:	8b 00                	mov    (%rax),%eax
  8004215d58:	25 00 10 00 00       	and    $0x1000,%eax
  8004215d5d:	85 c0                	test   %eax,%eax
  8004215d5f:	75 e2                	jne    8004215d43 <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004215d61:	be 00 00 00 00       	mov    $0x0,%esi
  8004215d66:	bf 20 00 00 00       	mov    $0x20,%edi
  8004215d6b:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215d72:	00 00 00 
  8004215d75:	ff d0                	callq  *%rax
}
  8004215d77:	5d                   	pop    %rbp
  8004215d78:	c3                   	retq   

0000008004215d79 <cpunum>:

int
cpunum(void)
{
  8004215d79:	55                   	push   %rbp
  8004215d7a:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215d7d:	48 b8 08 70 45 04 80 	movabs $0x8004457008,%rax
  8004215d84:	00 00 00 
  8004215d87:	48 8b 00             	mov    (%rax),%rax
  8004215d8a:	48 85 c0             	test   %rax,%rax
  8004215d8d:	74 18                	je     8004215da7 <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004215d8f:	48 b8 08 70 45 04 80 	movabs $0x8004457008,%rax
  8004215d96:	00 00 00 
  8004215d99:	48 8b 00             	mov    (%rax),%rax
  8004215d9c:	48 83 c0 20          	add    $0x20,%rax
  8004215da0:	8b 00                	mov    (%rax),%eax
  8004215da2:	c1 e8 18             	shr    $0x18,%eax
  8004215da5:	eb 05                	jmp    8004215dac <cpunum+0x33>
	return 0;
  8004215da7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215dac:	5d                   	pop    %rbp
  8004215dad:	c3                   	retq   

0000008004215dae <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004215dae:	55                   	push   %rbp
  8004215daf:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215db2:	48 b8 08 70 45 04 80 	movabs $0x8004457008,%rax
  8004215db9:	00 00 00 
  8004215dbc:	48 8b 00             	mov    (%rax),%rax
  8004215dbf:	48 85 c0             	test   %rax,%rax
  8004215dc2:	74 16                	je     8004215dda <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004215dc4:	be 00 00 00 00       	mov    $0x0,%esi
  8004215dc9:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215dce:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215dd5:	00 00 00 
  8004215dd8:	ff d0                	callq  *%rax
}
  8004215dda:	5d                   	pop    %rbp
  8004215ddb:	c3                   	retq   

0000008004215ddc <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004215ddc:	55                   	push   %rbp
  8004215ddd:	48 89 e5             	mov    %rsp,%rbp
  8004215de0:	48 83 ec 04          	sub    $0x4,%rsp
  8004215de4:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004215de7:	c9                   	leaveq 
  8004215de8:	c3                   	retq   

0000008004215de9 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004215de9:	55                   	push   %rbp
  8004215dea:	48 89 e5             	mov    %rsp,%rbp
  8004215ded:	48 83 ec 40          	sub    $0x40,%rsp
  8004215df1:	89 f8                	mov    %edi,%eax
  8004215df3:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004215df6:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004215df9:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004215e00:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004215e04:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215e08:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215e0b:	ee                   	out    %al,(%dx)
  8004215e0c:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004215e13:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004215e17:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215e1b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215e1e:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004215e1f:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004215e26:	00 
  8004215e27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215e2b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215e2f:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215e32:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215e35:	48 b8 30 47 3d 04 80 	movabs $0x80043d4730,%rax
  8004215e3c:	00 00 00 
  8004215e3f:	48 8b 00             	mov    (%rax),%rax
  8004215e42:	48 39 c2             	cmp    %rax,%rdx
  8004215e45:	72 32                	jb     8004215e79 <lapic_startap+0x90>
  8004215e47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215e4b:	48 89 c1             	mov    %rax,%rcx
  8004215e4e:	48 ba 80 8c 21 04 80 	movabs $0x8004218c80,%rdx
  8004215e55:	00 00 00 
  8004215e58:	be 98 00 00 00       	mov    $0x98,%esi
  8004215e5d:	48 bf a3 8c 21 04 80 	movabs $0x8004218ca3,%rdi
  8004215e64:	00 00 00 
  8004215e67:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215e6c:	49 b8 87 04 20 04 80 	movabs $0x8004200487,%r8
  8004215e73:	00 00 00 
  8004215e76:	41 ff d0             	callq  *%r8
  8004215e79:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215e80:	00 00 00 
  8004215e83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215e87:	48 01 d0             	add    %rdx,%rax
  8004215e8a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004215e8e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e92:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004215e97:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e9b:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004215e9f:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004215ea2:	c1 e8 04             	shr    $0x4,%eax
  8004215ea5:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004215ea8:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215eac:	c1 e0 18             	shl    $0x18,%eax
  8004215eaf:	89 c6                	mov    %eax,%esi
  8004215eb1:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215eb6:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215ebd:	00 00 00 
  8004215ec0:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004215ec2:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004215ec7:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215ecc:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215ed3:	00 00 00 
  8004215ed6:	ff d0                	callq  *%rax
	microdelay(200);
  8004215ed8:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215edd:	48 b8 dc 5d 21 04 80 	movabs $0x8004215ddc,%rax
  8004215ee4:	00 00 00 
  8004215ee7:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004215ee9:	be 00 85 00 00       	mov    $0x8500,%esi
  8004215eee:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215ef3:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215efa:	00 00 00 
  8004215efd:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004215eff:	bf 64 00 00 00       	mov    $0x64,%edi
  8004215f04:	48 b8 dc 5d 21 04 80 	movabs $0x8004215ddc,%rax
  8004215f0b:	00 00 00 
  8004215f0e:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215f10:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215f17:	eb 4b                	jmp    8004215f64 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004215f19:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215f1d:	c1 e0 18             	shl    $0x18,%eax
  8004215f20:	89 c6                	mov    %eax,%esi
  8004215f22:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215f27:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215f2e:	00 00 00 
  8004215f31:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004215f33:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004215f36:	c1 e8 0c             	shr    $0xc,%eax
  8004215f39:	80 cc 06             	or     $0x6,%ah
  8004215f3c:	89 c6                	mov    %eax,%esi
  8004215f3e:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215f43:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215f4a:	00 00 00 
  8004215f4d:	ff d0                	callq  *%rax
		microdelay(200);
  8004215f4f:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215f54:	48 b8 dc 5d 21 04 80 	movabs $0x8004215ddc,%rax
  8004215f5b:	00 00 00 
  8004215f5e:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215f60:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215f64:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004215f68:	7e af                	jle    8004215f19 <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004215f6a:	c9                   	leaveq 
  8004215f6b:	c3                   	retq   

0000008004215f6c <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004215f6c:	55                   	push   %rbp
  8004215f6d:	48 89 e5             	mov    %rsp,%rbp
  8004215f70:	48 83 ec 08          	sub    $0x8,%rsp
  8004215f74:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004215f77:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215f7a:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004215f7f:	89 c6                	mov    %eax,%esi
  8004215f81:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215f86:	48 b8 40 5b 21 04 80 	movabs $0x8004215b40,%rax
  8004215f8d:	00 00 00 
  8004215f90:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004215f92:	90                   	nop
  8004215f93:	48 b8 08 70 45 04 80 	movabs $0x8004457008,%rax
  8004215f9a:	00 00 00 
  8004215f9d:	48 8b 00             	mov    (%rax),%rax
  8004215fa0:	48 05 00 03 00 00    	add    $0x300,%rax
  8004215fa6:	8b 00                	mov    (%rax),%eax
  8004215fa8:	25 00 10 00 00       	and    $0x1000,%eax
  8004215fad:	85 c0                	test   %eax,%eax
  8004215faf:	75 e2                	jne    8004215f93 <lapic_ipi+0x27>
		;
}
  8004215fb1:	c9                   	leaveq 
  8004215fb2:	c3                   	retq   

0000008004215fb3 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004215fb3:	55                   	push   %rbp
  8004215fb4:	48 89 e5             	mov    %rsp,%rbp
  8004215fb7:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215fbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215fbf:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004215fc2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215fc6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215fc9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004215fcd:	f0 87 02             	lock xchg %eax,(%rdx)
  8004215fd0:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004215fd3:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004215fd6:	c9                   	leaveq 
  8004215fd7:	c3                   	retq   

0000008004215fd8 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004215fd8:	55                   	push   %rbp
  8004215fd9:	48 89 e5             	mov    %rsp,%rbp
  8004215fdc:	48 83 ec 28          	sub    $0x28,%rsp
  8004215fe0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004215fe4:	48 89 e8             	mov    %rbp,%rax
  8004215fe7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004215feb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004215fef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004215ff3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215ffa:	eb 45                	jmp    8004216041 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004215ffc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216001:	74 44                	je     8004216047 <get_caller_pcs+0x6f>
  8004216003:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800421600a:	00 00 00 
  800421600d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004216011:	76 34                	jbe    8004216047 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004216013:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216016:	48 98                	cltq   
  8004216018:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421601f:	00 
  8004216020:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216024:	48 01 c2             	add    %rax,%rdx
  8004216027:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421602b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421602f:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004216032:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216036:	48 8b 00             	mov    (%rax),%rax
  8004216039:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  800421603d:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216041:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216045:	7e b5                	jle    8004215ffc <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216047:	eb 1f                	jmp    8004216068 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004216049:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421604c:	48 98                	cltq   
  800421604e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216055:	00 
  8004216056:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421605a:	48 01 d0             	add    %rdx,%rax
  800421605d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216064:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216068:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  800421606c:	7e db                	jle    8004216049 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  800421606e:	c9                   	leaveq 
  800421606f:	c3                   	retq   

0000008004216070 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004216070:	55                   	push   %rbp
  8004216071:	48 89 e5             	mov    %rsp,%rbp
  8004216074:	53                   	push   %rbx
  8004216075:	48 83 ec 18          	sub    $0x18,%rsp
  8004216079:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  800421607d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216081:	8b 00                	mov    (%rax),%eax
  8004216083:	85 c0                	test   %eax,%eax
  8004216085:	74 3d                	je     80042160c4 <holding+0x54>
  8004216087:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421608b:	48 8b 58 10          	mov    0x10(%rax),%rbx
  800421608f:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004216096:	00 00 00 
  8004216099:	ff d0                	callq  *%rax
  800421609b:	48 98                	cltq   
  800421609d:	48 c1 e0 03          	shl    $0x3,%rax
  80042160a1:	48 89 c2             	mov    %rax,%rdx
  80042160a4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042160a8:	48 29 c2             	sub    %rax,%rdx
  80042160ab:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  80042160b2:	00 00 00 
  80042160b5:	48 01 d0             	add    %rdx,%rax
  80042160b8:	48 39 c3             	cmp    %rax,%rbx
  80042160bb:	75 07                	jne    80042160c4 <holding+0x54>
  80042160bd:	b8 01 00 00 00       	mov    $0x1,%eax
  80042160c2:	eb 05                	jmp    80042160c9 <holding+0x59>
  80042160c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042160c9:	48 83 c4 18          	add    $0x18,%rsp
  80042160cd:	5b                   	pop    %rbx
  80042160ce:	5d                   	pop    %rbp
  80042160cf:	c3                   	retq   

00000080042160d0 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  80042160d0:	55                   	push   %rbp
  80042160d1:	48 89 e5             	mov    %rsp,%rbp
  80042160d4:	48 83 ec 10          	sub    $0x10,%rsp
  80042160d8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042160dc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  80042160e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160e4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  80042160ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160ee:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042160f2:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  80042160f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160fa:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216101:	00 
#endif
}
  8004216102:	c9                   	leaveq 
  8004216103:	c3                   	retq   

0000008004216104 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004216104:	55                   	push   %rbp
  8004216105:	48 89 e5             	mov    %rsp,%rbp
  8004216108:	53                   	push   %rbx
  8004216109:	48 83 ec 18          	sub    $0x18,%rsp
  800421610d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004216111:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216115:	48 89 c7             	mov    %rax,%rdi
  8004216118:	48 b8 70 60 21 04 80 	movabs $0x8004216070,%rax
  800421611f:	00 00 00 
  8004216122:	ff d0                	callq  *%rax
  8004216124:	85 c0                	test   %eax,%eax
  8004216126:	74 44                	je     800421616c <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004216128:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421612c:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216130:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004216137:	00 00 00 
  800421613a:	ff d0                	callq  *%rax
  800421613c:	49 89 d8             	mov    %rbx,%r8
  800421613f:	89 c1                	mov    %eax,%ecx
  8004216141:	48 ba c0 8c 21 04 80 	movabs $0x8004218cc0,%rdx
  8004216148:	00 00 00 
  800421614b:	be 41 00 00 00       	mov    $0x41,%esi
  8004216150:	48 bf ea 8c 21 04 80 	movabs $0x8004218cea,%rdi
  8004216157:	00 00 00 
  800421615a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421615f:	49 b9 87 04 20 04 80 	movabs $0x8004200487,%r9
  8004216166:	00 00 00 
  8004216169:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  800421616c:	eb 02                	jmp    8004216170 <spin_lock+0x6c>
		asm volatile ("pause");
  800421616e:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216170:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216174:	be 01 00 00 00       	mov    $0x1,%esi
  8004216179:	48 89 c7             	mov    %rax,%rdi
  800421617c:	48 b8 b3 5f 21 04 80 	movabs $0x8004215fb3,%rax
  8004216183:	00 00 00 
  8004216186:	ff d0                	callq  *%rax
  8004216188:	85 c0                	test   %eax,%eax
  800421618a:	75 e2                	jne    800421616e <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  800421618c:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004216193:	00 00 00 
  8004216196:	ff d0                	callq  *%rax
  8004216198:	48 98                	cltq   
  800421619a:	48 c1 e0 03          	shl    $0x3,%rax
  800421619e:	48 89 c2             	mov    %rax,%rdx
  80042161a1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042161a5:	48 29 c2             	sub    %rax,%rdx
  80042161a8:	48 b8 20 60 3d 04 80 	movabs $0x80043d6020,%rax
  80042161af:	00 00 00 
  80042161b2:	48 01 c2             	add    %rax,%rdx
  80042161b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042161b9:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  80042161bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042161c1:	48 83 c0 18          	add    $0x18,%rax
  80042161c5:	48 89 c7             	mov    %rax,%rdi
  80042161c8:	48 b8 d8 5f 21 04 80 	movabs $0x8004215fd8,%rax
  80042161cf:	00 00 00 
  80042161d2:	ff d0                	callq  *%rax
#endif
}
  80042161d4:	48 83 c4 18          	add    $0x18,%rsp
  80042161d8:	5b                   	pop    %rbx
  80042161d9:	5d                   	pop    %rbp
  80042161da:	c3                   	retq   

00000080042161db <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  80042161db:	55                   	push   %rbp
  80042161dc:	48 89 e5             	mov    %rsp,%rbp
  80042161df:	41 54                	push   %r12
  80042161e1:	53                   	push   %rbx
  80042161e2:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  80042161e9:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  80042161f0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042161f7:	48 89 c7             	mov    %rax,%rdi
  80042161fa:	48 b8 70 60 21 04 80 	movabs $0x8004216070,%rax
  8004216201:	00 00 00 
  8004216204:	ff d0                	callq  *%rax
  8004216206:	85 c0                	test   %eax,%eax
  8004216208:	0f 85 d2 01 00 00    	jne    80042163e0 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  800421620e:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216215:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004216219:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004216220:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216225:	48 89 ce             	mov    %rcx,%rsi
  8004216228:	48 89 c7             	mov    %rax,%rdi
  800421622b:	48 b8 68 ee 20 04 80 	movabs $0x800420ee68,%rax
  8004216232:	00 00 00 
  8004216235:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004216237:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421623e:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216242:	48 85 c0             	test   %rax,%rax
  8004216245:	75 39                	jne    8004216280 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004216247:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421624e:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216252:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  8004216259:	00 00 00 
  800421625c:	ff d0                	callq  *%rax
  800421625e:	48 89 da             	mov    %rbx,%rdx
  8004216261:	89 c6                	mov    %eax,%esi
  8004216263:	48 bf 00 8d 21 04 80 	movabs $0x8004218d00,%rdi
  800421626a:	00 00 00 
  800421626d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216272:	48 b9 c2 87 20 04 80 	movabs $0x80042087c2,%rcx
  8004216279:	00 00 00 
  800421627c:	ff d1                	callq  *%rcx
  800421627e:	eb 4d                	jmp    80042162cd <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004216280:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216287:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421628b:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  800421628e:	44 0f b6 e0          	movzbl %al,%r12d
  8004216292:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216299:	48 8b 58 08          	mov    0x8(%rax),%rbx
  800421629d:	48 b8 79 5d 21 04 80 	movabs $0x8004215d79,%rax
  80042162a4:	00 00 00 
  80042162a7:	ff d0                	callq  *%rax
  80042162a9:	44 89 e1             	mov    %r12d,%ecx
  80042162ac:	48 89 da             	mov    %rbx,%rdx
  80042162af:	89 c6                	mov    %eax,%esi
  80042162b1:	48 bf 40 8d 21 04 80 	movabs $0x8004218d40,%rdi
  80042162b8:	00 00 00 
  80042162bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042162c0:	49 b8 c2 87 20 04 80 	movabs $0x80042087c2,%r8
  80042162c7:	00 00 00 
  80042162ca:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042162cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042162d4:	e9 c3 00 00 00       	jmpq   800421639c <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  80042162d9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042162dc:	48 98                	cltq   
  80042162de:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042162e5:	89 c0                	mov    %eax,%eax
  80042162e7:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  80042162ee:	48 89 d6             	mov    %rdx,%rsi
  80042162f1:	48 89 c7             	mov    %rax,%rdi
  80042162f4:	48 b8 38 da 20 04 80 	movabs $0x800420da38,%rax
  80042162fb:	00 00 00 
  80042162fe:	ff d0                	callq  *%rax
  8004216300:	85 c0                	test   %eax,%eax
  8004216302:	78 6b                	js     800421636f <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216304:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216307:	48 98                	cltq   
  8004216309:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216310:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216312:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216319:	48 29 c2             	sub    %rax,%rdx
  800421631c:	49 89 d0             	mov    %rdx,%r8
  800421631f:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004216326:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  800421632c:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004216332:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004216339:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421633c:	48 98                	cltq   
  800421633e:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216345:	4c 89 04 24          	mov    %r8,(%rsp)
  8004216349:	49 89 f9             	mov    %rdi,%r9
  800421634c:	41 89 f0             	mov    %esi,%r8d
  800421634f:	89 c6                	mov    %eax,%esi
  8004216351:	48 bf 76 8d 21 04 80 	movabs $0x8004218d76,%rdi
  8004216358:	00 00 00 
  800421635b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216360:	49 ba c2 87 20 04 80 	movabs $0x80042087c2,%r10
  8004216367:	00 00 00 
  800421636a:	41 ff d2             	callq  *%r10
  800421636d:	eb 29                	jmp    8004216398 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  800421636f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216372:	48 98                	cltq   
  8004216374:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421637b:	89 c6                	mov    %eax,%esi
  800421637d:	48 bf 8d 8d 21 04 80 	movabs $0x8004218d8d,%rdi
  8004216384:	00 00 00 
  8004216387:	b8 00 00 00 00       	mov    $0x0,%eax
  800421638c:	48 ba c2 87 20 04 80 	movabs $0x80042087c2,%rdx
  8004216393:	00 00 00 
  8004216396:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216398:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800421639c:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042163a0:	7f 14                	jg     80042163b6 <spin_unlock+0x1db>
  80042163a2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042163a5:	48 98                	cltq   
  80042163a7:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042163ae:	85 c0                	test   %eax,%eax
  80042163b0:	0f 85 23 ff ff ff    	jne    80042162d9 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  80042163b6:	48 ba 95 8d 21 04 80 	movabs $0x8004218d95,%rdx
  80042163bd:	00 00 00 
  80042163c0:	be 6b 00 00 00       	mov    $0x6b,%esi
  80042163c5:	48 bf ea 8c 21 04 80 	movabs $0x8004218cea,%rdi
  80042163cc:	00 00 00 
  80042163cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163d4:	48 b9 87 04 20 04 80 	movabs $0x8004200487,%rcx
  80042163db:	00 00 00 
  80042163de:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  80042163e0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042163e7:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80042163ee:	00 
	lk->cpu = 0;
  80042163ef:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042163f6:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80042163fd:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  80042163fe:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216405:	be 00 00 00 00       	mov    $0x0,%esi
  800421640a:	48 89 c7             	mov    %rax,%rdi
  800421640d:	48 b8 b3 5f 21 04 80 	movabs $0x8004215fb3,%rax
  8004216414:	00 00 00 
  8004216417:	ff d0                	callq  *%rax
}
  8004216419:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004216420:	5b                   	pop    %rbx
  8004216421:	41 5c                	pop    %r12
  8004216423:	5d                   	pop    %rbp
  8004216424:	c3                   	retq   
