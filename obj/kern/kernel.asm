
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
	
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

    movw $0x1234,0x472			# warm boot	
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax	
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 b0 22 04 80 	movabs $0x800422b038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 b0 22 04 80 	movabs $0x800422b000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 60 b7 22 04 80 	movabs $0x800422b760,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 74 5f 21 04 80 	movabs $0x8004215f74,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <i386_init>:



void
i386_init(void)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420009d:	48 ba 10 20 74 04 80 	movabs $0x8004742010,%rdx
  80042000a4:	00 00 00 
  80042000a7:	48 b8 07 da 6b 04 80 	movabs $0x80046bda07,%rax
  80042000ae:	00 00 00 
  80042000b1:	48 29 c2             	sub    %rax,%rdx
  80042000b4:	48 89 d0             	mov    %rdx,%rax
  80042000b7:	48 89 c2             	mov    %rax,%rdx
  80042000ba:	be 00 00 00 00       	mov    $0x0,%esi
  80042000bf:	48 bf 07 da 6b 04 80 	movabs $0x80046bda07,%rdi
  80042000c6:	00 00 00 
  80042000c9:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  80042000d0:	00 00 00 
  80042000d3:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042000d5:	48 b8 7f 11 20 04 80 	movabs $0x800420117f,%rax
  80042000dc:	00 00 00 
  80042000df:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000e1:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000e6:	48 bf a0 62 21 04 80 	movabs $0x80042162a0,%rdi
  80042000ed:	00 00 00 
  80042000f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000f5:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042000fc:	00 00 00 
  80042000ff:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
  8004200101:	48 b8 10 20 74 04 80 	movabs $0x8004742010,%rax
  8004200108:	00 00 00 
  800420010b:	48 89 c6             	mov    %rax,%rsi
  800420010e:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200115:	00 00 00 
  8004200118:	48 b8 6b 46 21 04 80 	movabs $0x800421466b,%rax
  800420011f:	00 00 00 
  8004200122:	ff d0                	callq  *%rax
  8004200124:	48 ba 08 f7 6b 04 80 	movabs $0x80046bf708,%rdx
  800420012b:	00 00 00 
  800420012e:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200131:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200136:	48 ba 3b 22 20 04 80 	movabs $0x800420223b,%rdx
  800420013d:	00 00 00 
  8004200140:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200142:	48 b8 8f 73 20 04 80 	movabs $0x800420738f,%rax
  8004200149:	00 00 00 
  800420014c:	ff d0                	callq  *%rax
	trap_init();
  800420014e:	48 b8 62 88 20 04 80 	movabs $0x8004208862,%rax
  8004200155:	00 00 00 
  8004200158:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  800420015a:	48 b8 f5 55 21 04 80 	movabs $0x80042155f5,%rax
  8004200161:	00 00 00 
  8004200164:	ff d0                	callq  *%rax
	lapic_init();
  8004200166:	48 b8 f2 59 21 04 80 	movabs $0x80042159f2,%rax
  800420016d:	00 00 00 
  8004200170:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200172:	48 b8 1a 84 20 04 80 	movabs $0x800420841a,%rax
  8004200179:	00 00 00 
  800420017c:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:
	lock_kernel();
  800420017e:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200185:	00 00 00 
  8004200188:	ff d0                	callq  *%rax

	// Starting non-boot CPUs
	boot_aps();
  800420018a:	48 b8 e4 01 20 04 80 	movabs $0x80042001e4,%rax
  8004200191:	00 00 00 
  8004200194:	ff d0                	callq  *%rax




	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  8004200196:	be 01 00 00 00       	mov    $0x1,%esi
  800420019b:	48 bf 3c 85 5a 04 80 	movabs $0x80045a853c,%rdi
  80042001a2:	00 00 00 
  80042001a5:	48 b8 85 7a 20 04 80 	movabs $0x8004207a85,%rax
  80042001ac:	00 00 00 
  80042001af:	ff d0                	callq  *%rax


#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  80042001b1:	be 00 00 00 00       	mov    $0x0,%esi
  80042001b6:	48 bf 0d 82 66 04 80 	movabs $0x800466820d,%rdi
  80042001bd:	00 00 00 
  80042001c0:	48 b8 85 7a 20 04 80 	movabs $0x8004207a85,%rax
  80042001c7:	00 00 00 
  80042001ca:	ff d0                	callq  *%rax

	ENV_CREATE(user_icode, ENV_TYPE_USER);
#endif // TEST*

	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  80042001cc:	48 b8 b1 0f 20 04 80 	movabs $0x8004200fb1,%rax
  80042001d3:	00 00 00 
  80042001d6:	ff d0                	callq  *%rax

	// Schedule and run the first user environment!
	sched_yield();
  80042001d8:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  80042001df:	00 00 00 
  80042001e2:	ff d0                	callq  *%rax

00000080042001e4 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  80042001e4:	55                   	push   %rbp
  80042001e5:	48 89 e5             	mov    %rsp,%rbp
  80042001e8:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  80042001ec:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  80042001f3:	00 
  80042001f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042001f8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042001fc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042001ff:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200202:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004200209:	00 00 00 
  800420020c:	48 8b 00             	mov    (%rax),%rax
  800420020f:	48 39 c2             	cmp    %rax,%rdx
  8004200212:	72 32                	jb     8004200246 <boot_aps+0x62>
  8004200214:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200218:	48 89 c1             	mov    %rax,%rcx
  800420021b:	48 ba c0 62 21 04 80 	movabs $0x80042162c0,%rdx
  8004200222:	00 00 00 
  8004200225:	be 6a 00 00 00       	mov    $0x6a,%esi
  800420022a:	48 bf e3 62 21 04 80 	movabs $0x80042162e3,%rdi
  8004200231:	00 00 00 
  8004200234:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200239:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004200240:	00 00 00 
  8004200243:	41 ff d0             	callq  *%r8
  8004200246:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420024d:	00 00 00 
  8004200250:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200254:	48 01 d0             	add    %rdx,%rax
  8004200257:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  800420025b:	48 ba 1e 51 21 04 80 	movabs $0x800421511e,%rdx
  8004200262:	00 00 00 
  8004200265:	48 b8 38 50 21 04 80 	movabs $0x8004215038,%rax
  800420026c:	00 00 00 
  800420026f:	48 29 c2             	sub    %rax,%rdx
  8004200272:	48 89 d0             	mov    %rdx,%rax
  8004200275:	48 89 c2             	mov    %rax,%rdx
  8004200278:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420027c:	48 be 38 50 21 04 80 	movabs $0x8004215038,%rsi
  8004200283:	00 00 00 
  8004200286:	48 89 c7             	mov    %rax,%rdi
  8004200289:	48 b8 d6 ec 20 04 80 	movabs $0x800420ecd6,%rax
  8004200290:	00 00 00 
  8004200293:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200295:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  800420029c:	00 00 00 
  800420029f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042002a3:	e9 0b 01 00 00       	jmpq   80042003b3 <boot_aps+0x1cf>
		if (c == cpus + cpunum())  // We've started already.
  80042002a8:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042002af:	00 00 00 
  80042002b2:	ff d0                	callq  *%rax
  80042002b4:	48 98                	cltq   
  80042002b6:	48 c1 e0 03          	shl    $0x3,%rax
  80042002ba:	48 89 c2             	mov    %rax,%rdx
  80042002bd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042002c1:	48 29 c2             	sub    %rax,%rdx
  80042002c4:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  80042002cb:	00 00 00 
  80042002ce:	48 01 d0             	add    %rdx,%rax
  80042002d1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042002d5:	75 05                	jne    80042002dc <boot_aps+0xf8>
			continue;
  80042002d7:	e9 d2 00 00 00       	jmpq   80042003ae <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  80042002dc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042002e0:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  80042002e7:	00 00 00 
  80042002ea:	48 29 c2             	sub    %rax,%rdx
  80042002ed:	48 89 d0             	mov    %rdx,%rax
  80042002f0:	48 c1 f8 03          	sar    $0x3,%rax
  80042002f4:	48 89 c2             	mov    %rax,%rdx
  80042002f7:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  80042002fe:	ee ee ee 
  8004200301:	48 0f af c2          	imul   %rdx,%rax
  8004200305:	48 83 c0 01          	add    $0x1,%rax
  8004200309:	48 c1 e0 10          	shl    $0x10,%rax
  800420030d:	48 89 c2             	mov    %rax,%rdx
  8004200310:	48 b8 00 20 6c 04 80 	movabs $0x80046c2000,%rax
  8004200317:	00 00 00 
  800420031a:	48 01 c2             	add    %rax,%rdx
  800420031d:	48 b8 18 f7 6b 04 80 	movabs $0x80046bf718,%rax
  8004200324:	00 00 00 
  8004200327:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  800420032a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420032e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200332:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200339:	00 00 00 
  800420033c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004200340:	77 32                	ja     8004200374 <boot_aps+0x190>
  8004200342:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200346:	48 89 c1             	mov    %rax,%rcx
  8004200349:	48 ba f0 62 21 04 80 	movabs $0x80042162f0,%rdx
  8004200350:	00 00 00 
  8004200353:	be 74 00 00 00       	mov    $0x74,%esi
  8004200358:	48 bf e3 62 21 04 80 	movabs $0x80042162e3,%rdi
  800420035f:	00 00 00 
  8004200362:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200367:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420036e:	00 00 00 
  8004200371:	41 ff d0             	callq  *%r8
  8004200374:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420037b:	ff ff ff 
  800420037e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200382:	48 01 d0             	add    %rdx,%rax
  8004200385:	89 c2                	mov    %eax,%edx
  8004200387:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420038b:	0f b6 00             	movzbl (%rax),%eax
  800420038e:	0f b6 c0             	movzbl %al,%eax
  8004200391:	89 d6                	mov    %edx,%esi
  8004200393:	89 c7                	mov    %eax,%edi
  8004200395:	48 b8 59 5c 21 04 80 	movabs $0x8004215c59,%rax
  800420039c:	00 00 00 
  800420039f:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042003a1:	90                   	nop
  80042003a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003a6:	8b 40 04             	mov    0x4(%rax),%eax
  80042003a9:	83 f8 01             	cmp    $0x1,%eax
  80042003ac:	75 f4                	jne    80042003a2 <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003ae:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  80042003b3:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  80042003ba:	00 00 00 
  80042003bd:	8b 00                	mov    (%rax),%eax
  80042003bf:	48 98                	cltq   
  80042003c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042003c5:	48 89 c2             	mov    %rax,%rdx
  80042003c8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003cc:	48 29 c2             	sub    %rax,%rdx
  80042003cf:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  80042003d6:	00 00 00 
  80042003d9:	48 01 d0             	add    %rdx,%rax
  80042003dc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042003e0:	0f 87 c2 fe ff ff    	ja     80042002a8 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  80042003e6:	c9                   	leaveq 
  80042003e7:	c3                   	retq   

00000080042003e8 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  80042003e8:	55                   	push   %rbp
  80042003e9:	48 89 e5             	mov    %rsp,%rbp
  80042003ec:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir
	lcr3(boot_cr3);
  80042003f0:	48 b8 20 f7 6b 04 80 	movabs $0x80046bf720,%rax
  80042003f7:	00 00 00 
  80042003fa:	48 8b 00             	mov    (%rax),%rax
  80042003fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200401:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200405:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  8004200408:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420040f:	00 00 00 
  8004200412:	ff d0                	callq  *%rax
  8004200414:	89 c6                	mov    %eax,%esi
  8004200416:	48 bf 14 63 21 04 80 	movabs $0x8004216314,%rdi
  800420041d:	00 00 00 
  8004200420:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200425:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420042c:	00 00 00 
  800420042f:	ff d2                	callq  *%rdx

	lapic_init();
  8004200431:	48 b8 f2 59 21 04 80 	movabs $0x80042159f2,%rax
  8004200438:	00 00 00 
  800420043b:	ff d0                	callq  *%rax
	env_init_percpu();
  800420043d:	48 b8 df 74 20 04 80 	movabs $0x80042074df,%rax
  8004200444:	00 00 00 
  8004200447:	ff d0                	callq  *%rax
	trap_init_percpu();
  8004200449:	48 b8 12 b0 20 04 80 	movabs $0x800420b012,%rax
  8004200450:	00 00 00 
  8004200453:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  8004200455:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420045c:	00 00 00 
  800420045f:	ff d0                	callq  *%rax
  8004200461:	48 98                	cltq   
  8004200463:	48 c1 e0 03          	shl    $0x3,%rax
  8004200467:	48 89 c2             	mov    %rax,%rdx
  800420046a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420046e:	48 29 c2             	sub    %rax,%rdx
  8004200471:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  8004200478:	00 00 00 
  800420047b:	48 01 d0             	add    %rdx,%rax
  800420047e:	48 83 c0 04          	add    $0x4,%rax
  8004200482:	be 01 00 00 00       	mov    $0x1,%esi
  8004200487:	48 89 c7             	mov    %rax,%rdi
  800420048a:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200491:	00 00 00 
  8004200494:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  8004200496:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  800420049d:	00 00 00 
  80042004a0:	ff d0                	callq  *%rax
	sched_yield();
  80042004a2:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  80042004a9:	00 00 00 
  80042004ac:	ff d0                	callq  *%rax

00000080042004ae <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042004ae:	55                   	push   %rbp
  80042004af:	48 89 e5             	mov    %rsp,%rbp
  80042004b2:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042004b9:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042004c0:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042004c6:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042004cd:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042004d4:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042004db:	84 c0                	test   %al,%al
  80042004dd:	74 20                	je     80042004ff <_panic+0x51>
  80042004df:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042004e3:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042004e7:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042004eb:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042004ef:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042004f3:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042004f7:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042004fb:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042004ff:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  8004200506:	48 b8 10 f7 6b 04 80 	movabs $0x80046bf710,%rax
  800420050d:	00 00 00 
  8004200510:	48 8b 00             	mov    (%rax),%rax
  8004200513:	48 85 c0             	test   %rax,%rax
  8004200516:	74 05                	je     800420051d <_panic+0x6f>
		goto dead;
  8004200518:	e9 b5 00 00 00       	jmpq   80042005d2 <_panic+0x124>
	panicstr = fmt;
  800420051d:	48 b8 10 f7 6b 04 80 	movabs $0x80046bf710,%rax
  8004200524:	00 00 00 
  8004200527:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420052e:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200531:	fa                   	cli    
  8004200532:	fc                   	cld    

	va_start(ap, fmt);
  8004200533:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420053a:	00 00 00 
  800420053d:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200544:	00 00 00 
  8004200547:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420054b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200552:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200559:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  8004200560:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004200567:	00 00 00 
  800420056a:	ff d0                	callq  *%rax
  800420056c:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  8004200572:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004200579:	89 c6                	mov    %eax,%esi
  800420057b:	48 bf 30 63 21 04 80 	movabs $0x8004216330,%rdi
  8004200582:	00 00 00 
  8004200585:	b8 00 00 00 00       	mov    $0x0,%eax
  800420058a:	49 b8 ea 86 20 04 80 	movabs $0x80042086ea,%r8
  8004200591:	00 00 00 
  8004200594:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  8004200597:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420059e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042005a5:	48 89 d6             	mov    %rdx,%rsi
  80042005a8:	48 89 c7             	mov    %rax,%rdi
  80042005ab:	48 b8 8b 86 20 04 80 	movabs $0x800420868b,%rax
  80042005b2:	00 00 00 
  80042005b5:	ff d0                	callq  *%rax
	cprintf("\n");
  80042005b7:	48 bf 52 63 21 04 80 	movabs $0x8004216352,%rdi
  80042005be:	00 00 00 
  80042005c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005c6:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042005cd:	00 00 00 
  80042005d0:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  80042005d2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042005d7:	48 b8 7a 16 20 04 80 	movabs $0x800420167a,%rax
  80042005de:	00 00 00 
  80042005e1:	ff d0                	callq  *%rax
  80042005e3:	eb ed                	jmp    80042005d2 <_panic+0x124>

00000080042005e5 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  80042005e5:	55                   	push   %rbp
  80042005e6:	48 89 e5             	mov    %rsp,%rbp
  80042005e9:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042005f0:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042005f7:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042005fd:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200604:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420060b:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200612:	84 c0                	test   %al,%al
  8004200614:	74 20                	je     8004200636 <_warn+0x51>
  8004200616:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420061a:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420061e:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200622:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200626:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420062a:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420062e:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200632:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200636:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420063d:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200644:	00 00 00 
  8004200647:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420064e:	00 00 00 
  8004200651:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200655:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420065c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200663:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  800420066a:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200670:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200677:	48 89 c6             	mov    %rax,%rsi
  800420067a:	48 bf 54 63 21 04 80 	movabs $0x8004216354,%rdi
  8004200681:	00 00 00 
  8004200684:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200689:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  8004200690:	00 00 00 
  8004200693:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  8004200695:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420069c:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006a3:	48 89 d6             	mov    %rdx,%rsi
  80042006a6:	48 89 c7             	mov    %rax,%rdi
  80042006a9:	48 b8 8b 86 20 04 80 	movabs $0x800420868b,%rax
  80042006b0:	00 00 00 
  80042006b3:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006b5:	48 bf 52 63 21 04 80 	movabs $0x8004216352,%rdi
  80042006bc:	00 00 00 
  80042006bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006c4:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042006cb:	00 00 00 
  80042006ce:	ff d2                	callq  *%rdx
	va_end(ap);
}
  80042006d0:	c9                   	leaveq 
  80042006d1:	c3                   	retq   

00000080042006d2 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  80042006d2:	55                   	push   %rbp
  80042006d3:	48 89 e5             	mov    %rsp,%rbp
  80042006d6:	48 83 ec 20          	sub    $0x20,%rsp
  80042006da:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042006e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042006e4:	89 c2                	mov    %eax,%edx
  80042006e6:	ec                   	in     (%dx),%al
  80042006e7:	88 45 fb             	mov    %al,-0x5(%rbp)
  80042006ea:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  80042006f1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042006f4:	89 c2                	mov    %eax,%edx
  80042006f6:	ec                   	in     (%dx),%al
  80042006f7:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042006fa:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200701:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200704:	89 c2                	mov    %eax,%edx
  8004200706:	ec                   	in     (%dx),%al
  8004200707:	88 45 eb             	mov    %al,-0x15(%rbp)
  800420070a:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  8004200711:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200714:	89 c2                	mov    %eax,%edx
  8004200716:	ec                   	in     (%dx),%al
  8004200717:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  800420071a:	c9                   	leaveq 
  800420071b:	c3                   	retq   

000000800420071c <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  800420071c:	55                   	push   %rbp
  800420071d:	48 89 e5             	mov    %rsp,%rbp
  8004200720:	48 83 ec 10          	sub    $0x10,%rsp
  8004200724:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  800420072b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420072e:	89 c2                	mov    %eax,%edx
  8004200730:	ec                   	in     (%dx),%al
  8004200731:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004200734:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200738:	0f b6 c0             	movzbl %al,%eax
  800420073b:	83 e0 01             	and    $0x1,%eax
  800420073e:	85 c0                	test   %eax,%eax
  8004200740:	75 07                	jne    8004200749 <serial_proc_data+0x2d>
		return -1;
  8004200742:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200747:	eb 17                	jmp    8004200760 <serial_proc_data+0x44>
  8004200749:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200750:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200753:	89 c2                	mov    %eax,%edx
  8004200755:	ec                   	in     (%dx),%al
  8004200756:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200759:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  800420075d:	0f b6 c0             	movzbl %al,%eax
}
  8004200760:	c9                   	leaveq 
  8004200761:	c3                   	retq   

0000008004200762 <serial_intr>:

void
serial_intr(void)
{
  8004200762:	55                   	push   %rbp
  8004200763:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  8004200766:	48 b8 00 e0 6b 04 80 	movabs $0x80046be000,%rax
  800420076d:	00 00 00 
  8004200770:	0f b6 00             	movzbl (%rax),%eax
  8004200773:	84 c0                	test   %al,%al
  8004200775:	74 16                	je     800420078d <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  8004200777:	48 bf 1c 07 20 04 80 	movabs $0x800420071c,%rdi
  800420077e:	00 00 00 
  8004200781:	48 b8 02 10 20 04 80 	movabs $0x8004201002,%rax
  8004200788:	00 00 00 
  800420078b:	ff d0                	callq  *%rax
}
  800420078d:	5d                   	pop    %rbp
  800420078e:	c3                   	retq   

000000800420078f <serial_putc>:

static void
serial_putc(int c)
{
  800420078f:	55                   	push   %rbp
  8004200790:	48 89 e5             	mov    %rsp,%rbp
  8004200793:	48 83 ec 28          	sub    $0x28,%rsp
  8004200797:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  800420079a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042007a1:	eb 10                	jmp    80042007b3 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042007a3:	48 b8 d2 06 20 04 80 	movabs $0x80042006d2,%rax
  80042007aa:	00 00 00 
  80042007ad:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  80042007af:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042007b3:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007ba:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042007bd:	89 c2                	mov    %eax,%edx
  80042007bf:	ec                   	in     (%dx),%al
  80042007c0:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042007c3:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007c7:	0f b6 c0             	movzbl %al,%eax
  80042007ca:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  80042007cd:	85 c0                	test   %eax,%eax
  80042007cf:	75 09                	jne    80042007da <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007d1:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042007d8:	7e c9                	jle    80042007a3 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  80042007da:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042007dd:	0f b6 c0             	movzbl %al,%eax
  80042007e0:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  80042007e7:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042007ea:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042007ee:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042007f1:	ee                   	out    %al,(%dx)
}
  80042007f2:	c9                   	leaveq 
  80042007f3:	c3                   	retq   

00000080042007f4 <serial_init>:

static void
serial_init(void)
{
  80042007f4:	55                   	push   %rbp
  80042007f5:	48 89 e5             	mov    %rsp,%rbp
  80042007f8:	48 83 ec 50          	sub    $0x50,%rsp
  80042007fc:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200803:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  8004200807:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420080b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420080e:	ee                   	out    %al,(%dx)
  800420080f:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  8004200816:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  800420081a:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  800420081e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200821:	ee                   	out    %al,(%dx)
  8004200822:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  8004200829:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  800420082d:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200831:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200834:	ee                   	out    %al,(%dx)
  8004200835:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  800420083c:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  8004200840:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200844:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200847:	ee                   	out    %al,(%dx)
  8004200848:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  800420084f:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  8004200853:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200857:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420085a:	ee                   	out    %al,(%dx)
  800420085b:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  8004200862:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  8004200866:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800420086a:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420086d:	ee                   	out    %al,(%dx)
  800420086e:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  8004200875:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  8004200879:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800420087d:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200880:	ee                   	out    %al,(%dx)
  8004200881:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200888:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420088b:	89 c2                	mov    %eax,%edx
  800420088d:	ec                   	in     (%dx),%al
  800420088e:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004200891:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  8004200895:	3c ff                	cmp    $0xff,%al
  8004200897:	0f 95 c2             	setne  %dl
  800420089a:	48 b8 00 e0 6b 04 80 	movabs $0x80046be000,%rax
  80042008a1:	00 00 00 
  80042008a4:	88 10                	mov    %dl,(%rax)
  80042008a6:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008ad:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042008b0:	89 c2                	mov    %eax,%edx
  80042008b2:	ec                   	in     (%dx),%al
  80042008b3:	88 45 bb             	mov    %al,-0x45(%rbp)
  80042008b6:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  80042008bd:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042008c0:	89 c2                	mov    %eax,%edx
  80042008c2:	ec                   	in     (%dx),%al
  80042008c3:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  80042008c6:	48 b8 00 e0 6b 04 80 	movabs $0x80046be000,%rax
  80042008cd:	00 00 00 
  80042008d0:	0f b6 00             	movzbl (%rax),%eax
  80042008d3:	84 c0                	test   %al,%al
  80042008d5:	74 23                	je     80042008fa <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  80042008d7:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  80042008de:	00 00 00 
  80042008e1:	0f b7 00             	movzwl (%rax),%eax
  80042008e4:	0f b7 c0             	movzwl %ax,%eax
  80042008e7:	25 ef ff 00 00       	and    $0xffef,%eax
  80042008ec:	89 c7                	mov    %eax,%edi
  80042008ee:	48 b8 6c 85 20 04 80 	movabs $0x800420856c,%rax
  80042008f5:	00 00 00 
  80042008f8:	ff d0                	callq  *%rax
}
  80042008fa:	c9                   	leaveq 
  80042008fb:	c3                   	retq   

00000080042008fc <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  80042008fc:	55                   	push   %rbp
  80042008fd:	48 89 e5             	mov    %rsp,%rbp
  8004200900:	48 83 ec 38          	sub    $0x38,%rsp
  8004200904:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200907:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420090e:	eb 10                	jmp    8004200920 <lpt_putc+0x24>
		delay();
  8004200910:	48 b8 d2 06 20 04 80 	movabs $0x80042006d2,%rax
  8004200917:	00 00 00 
  800420091a:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420091c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200920:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200927:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420092a:	89 c2                	mov    %eax,%edx
  800420092c:	ec                   	in     (%dx),%al
  800420092d:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200930:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200934:	84 c0                	test   %al,%al
  8004200936:	78 09                	js     8004200941 <lpt_putc+0x45>
  8004200938:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420093f:	7e cf                	jle    8004200910 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200941:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200944:	0f b6 c0             	movzbl %al,%eax
  8004200947:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  800420094e:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200951:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200955:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200958:	ee                   	out    %al,(%dx)
  8004200959:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200960:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  8004200964:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200968:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420096b:	ee                   	out    %al,(%dx)
  800420096c:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200973:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200977:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420097b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800420097e:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  800420097f:	c9                   	leaveq 
  8004200980:	c3                   	retq   

0000008004200981 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200981:	55                   	push   %rbp
  8004200982:	48 89 e5             	mov    %rsp,%rbp
  8004200985:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200989:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200990:	00 00 00 
  8004200993:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200997:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420099b:	0f b7 00             	movzwl (%rax),%eax
  800420099e:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  80042009a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009a6:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  80042009ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009af:	0f b7 00             	movzwl (%rax),%eax
  80042009b2:	66 3d 5a a5          	cmp    $0xa55a,%ax
  80042009b6:	74 20                	je     80042009d8 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  80042009b8:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  80042009bf:	00 00 00 
  80042009c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  80042009c6:	48 b8 04 e0 6b 04 80 	movabs $0x80046be004,%rax
  80042009cd:	00 00 00 
  80042009d0:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  80042009d6:	eb 1b                	jmp    80042009f3 <cga_init+0x72>
	} else {
		*cp = was;
  80042009d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009dc:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80042009e0:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  80042009e3:	48 b8 04 e0 6b 04 80 	movabs $0x80046be004,%rax
  80042009ea:	00 00 00 
  80042009ed:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  80042009f3:	48 b8 04 e0 6b 04 80 	movabs $0x80046be004,%rax
  80042009fa:	00 00 00 
  80042009fd:	8b 00                	mov    (%rax),%eax
  80042009ff:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200a02:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200a06:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200a0a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200a0d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a0e:	48 b8 04 e0 6b 04 80 	movabs $0x80046be004,%rax
  8004200a15:	00 00 00 
  8004200a18:	8b 00                	mov    (%rax),%eax
  8004200a1a:	83 c0 01             	add    $0x1,%eax
  8004200a1d:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a20:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200a23:	89 c2                	mov    %eax,%edx
  8004200a25:	ec                   	in     (%dx),%al
  8004200a26:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200a29:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200a2d:	0f b6 c0             	movzbl %al,%eax
  8004200a30:	c1 e0 08             	shl    $0x8,%eax
  8004200a33:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200a36:	48 b8 04 e0 6b 04 80 	movabs $0x80046be004,%rax
  8004200a3d:	00 00 00 
  8004200a40:	8b 00                	mov    (%rax),%eax
  8004200a42:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200a45:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a49:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200a4d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200a50:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200a51:	48 b8 04 e0 6b 04 80 	movabs $0x80046be004,%rax
  8004200a58:	00 00 00 
  8004200a5b:	8b 00                	mov    (%rax),%eax
  8004200a5d:	83 c0 01             	add    $0x1,%eax
  8004200a60:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a63:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200a66:	89 c2                	mov    %eax,%edx
  8004200a68:	ec                   	in     (%dx),%al
  8004200a69:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200a6c:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200a70:	0f b6 c0             	movzbl %al,%eax
  8004200a73:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200a76:	48 b8 08 e0 6b 04 80 	movabs $0x80046be008,%rax
  8004200a7d:	00 00 00 
  8004200a80:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200a84:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200a87:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200a8a:	89 c2                	mov    %eax,%edx
  8004200a8c:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200a93:	00 00 00 
  8004200a96:	66 89 10             	mov    %dx,(%rax)
}
  8004200a99:	c9                   	leaveq 
  8004200a9a:	c3                   	retq   

0000008004200a9b <cga_putc>:



static void
cga_putc(int c)
{
  8004200a9b:	55                   	push   %rbp
  8004200a9c:	48 89 e5             	mov    %rsp,%rbp
  8004200a9f:	48 83 ec 40          	sub    $0x40,%rsp
  8004200aa3:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200aa6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200aa9:	b0 00                	mov    $0x0,%al
  8004200aab:	85 c0                	test   %eax,%eax
  8004200aad:	75 07                	jne    8004200ab6 <cga_putc+0x1b>
		c |= 0x0700;
  8004200aaf:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200ab6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ab9:	0f b6 c0             	movzbl %al,%eax
  8004200abc:	83 f8 09             	cmp    $0x9,%eax
  8004200abf:	0f 84 f6 00 00 00    	je     8004200bbb <cga_putc+0x120>
  8004200ac5:	83 f8 09             	cmp    $0x9,%eax
  8004200ac8:	7f 0a                	jg     8004200ad4 <cga_putc+0x39>
  8004200aca:	83 f8 08             	cmp    $0x8,%eax
  8004200acd:	74 18                	je     8004200ae7 <cga_putc+0x4c>
  8004200acf:	e9 3e 01 00 00       	jmpq   8004200c12 <cga_putc+0x177>
  8004200ad4:	83 f8 0a             	cmp    $0xa,%eax
  8004200ad7:	74 75                	je     8004200b4e <cga_putc+0xb3>
  8004200ad9:	83 f8 0d             	cmp    $0xd,%eax
  8004200adc:	0f 84 89 00 00 00    	je     8004200b6b <cga_putc+0xd0>
  8004200ae2:	e9 2b 01 00 00       	jmpq   8004200c12 <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200ae7:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200aee:	00 00 00 
  8004200af1:	0f b7 00             	movzwl (%rax),%eax
  8004200af4:	66 85 c0             	test   %ax,%ax
  8004200af7:	74 50                	je     8004200b49 <cga_putc+0xae>
			crt_pos--;
  8004200af9:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200b00:	00 00 00 
  8004200b03:	0f b7 00             	movzwl (%rax),%eax
  8004200b06:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b09:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200b10:	00 00 00 
  8004200b13:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200b16:	48 b8 08 e0 6b 04 80 	movabs $0x80046be008,%rax
  8004200b1d:	00 00 00 
  8004200b20:	48 8b 10             	mov    (%rax),%rdx
  8004200b23:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200b2a:	00 00 00 
  8004200b2d:	0f b7 00             	movzwl (%rax),%eax
  8004200b30:	0f b7 c0             	movzwl %ax,%eax
  8004200b33:	48 01 c0             	add    %rax,%rax
  8004200b36:	48 01 c2             	add    %rax,%rdx
  8004200b39:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b3c:	b0 00                	mov    $0x0,%al
  8004200b3e:	83 c8 20             	or     $0x20,%eax
  8004200b41:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200b44:	e9 04 01 00 00       	jmpq   8004200c4d <cga_putc+0x1b2>
  8004200b49:	e9 ff 00 00 00       	jmpq   8004200c4d <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200b4e:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200b55:	00 00 00 
  8004200b58:	0f b7 00             	movzwl (%rax),%eax
  8004200b5b:	8d 50 50             	lea    0x50(%rax),%edx
  8004200b5e:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200b65:	00 00 00 
  8004200b68:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200b6b:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200b72:	00 00 00 
  8004200b75:	0f b7 30             	movzwl (%rax),%esi
  8004200b78:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200b7f:	00 00 00 
  8004200b82:	0f b7 08             	movzwl (%rax),%ecx
  8004200b85:	0f b7 c1             	movzwl %cx,%eax
  8004200b88:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200b8e:	c1 e8 10             	shr    $0x10,%eax
  8004200b91:	89 c2                	mov    %eax,%edx
  8004200b93:	66 c1 ea 06          	shr    $0x6,%dx
  8004200b97:	89 d0                	mov    %edx,%eax
  8004200b99:	c1 e0 02             	shl    $0x2,%eax
  8004200b9c:	01 d0                	add    %edx,%eax
  8004200b9e:	c1 e0 04             	shl    $0x4,%eax
  8004200ba1:	29 c1                	sub    %eax,%ecx
  8004200ba3:	89 ca                	mov    %ecx,%edx
  8004200ba5:	29 d6                	sub    %edx,%esi
  8004200ba7:	89 f2                	mov    %esi,%edx
  8004200ba9:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200bb0:	00 00 00 
  8004200bb3:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200bb6:	e9 92 00 00 00       	jmpq   8004200c4d <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200bbb:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bc0:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200bc7:	00 00 00 
  8004200bca:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bcc:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bd1:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200bd8:	00 00 00 
  8004200bdb:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bdd:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200be2:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200be9:	00 00 00 
  8004200bec:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bee:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bf3:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200bfa:	00 00 00 
  8004200bfd:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bff:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c04:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200c0b:	00 00 00 
  8004200c0e:	ff d0                	callq  *%rax
		break;
  8004200c10:	eb 3b                	jmp    8004200c4d <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c12:	48 b8 08 e0 6b 04 80 	movabs $0x80046be008,%rax
  8004200c19:	00 00 00 
  8004200c1c:	48 8b 30             	mov    (%rax),%rsi
  8004200c1f:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200c26:	00 00 00 
  8004200c29:	0f b7 00             	movzwl (%rax),%eax
  8004200c2c:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200c2f:	48 ba 10 e0 6b 04 80 	movabs $0x80046be010,%rdx
  8004200c36:	00 00 00 
  8004200c39:	66 89 0a             	mov    %cx,(%rdx)
  8004200c3c:	0f b7 c0             	movzwl %ax,%eax
  8004200c3f:	48 01 c0             	add    %rax,%rax
  8004200c42:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200c46:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c49:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200c4c:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200c4d:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200c54:	00 00 00 
  8004200c57:	0f b7 00             	movzwl (%rax),%eax
  8004200c5a:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200c5e:	0f 86 89 00 00 00    	jbe    8004200ced <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200c64:	48 b8 08 e0 6b 04 80 	movabs $0x80046be008,%rax
  8004200c6b:	00 00 00 
  8004200c6e:	48 8b 00             	mov    (%rax),%rax
  8004200c71:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200c78:	48 b8 08 e0 6b 04 80 	movabs $0x80046be008,%rax
  8004200c7f:	00 00 00 
  8004200c82:	48 8b 00             	mov    (%rax),%rax
  8004200c85:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200c8a:	48 89 ce             	mov    %rcx,%rsi
  8004200c8d:	48 89 c7             	mov    %rax,%rdi
  8004200c90:	48 b8 d6 ec 20 04 80 	movabs $0x800420ecd6,%rax
  8004200c97:	00 00 00 
  8004200c9a:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200c9c:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200ca3:	eb 22                	jmp    8004200cc7 <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200ca5:	48 b8 08 e0 6b 04 80 	movabs $0x80046be008,%rax
  8004200cac:	00 00 00 
  8004200caf:	48 8b 00             	mov    (%rax),%rax
  8004200cb2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200cb5:	48 63 d2             	movslq %edx,%rdx
  8004200cb8:	48 01 d2             	add    %rdx,%rdx
  8004200cbb:	48 01 d0             	add    %rdx,%rax
  8004200cbe:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200cc3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200cc7:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200cce:	7e d5                	jle    8004200ca5 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200cd0:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200cd7:	00 00 00 
  8004200cda:	0f b7 00             	movzwl (%rax),%eax
  8004200cdd:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200ce0:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200ce7:	00 00 00 
  8004200cea:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200ced:	48 b8 04 e0 6b 04 80 	movabs $0x80046be004,%rax
  8004200cf4:	00 00 00 
  8004200cf7:	8b 00                	mov    (%rax),%eax
  8004200cf9:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200cfc:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d00:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d04:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d07:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d08:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200d0f:	00 00 00 
  8004200d12:	0f b7 00             	movzwl (%rax),%eax
  8004200d15:	66 c1 e8 08          	shr    $0x8,%ax
  8004200d19:	0f b6 c0             	movzbl %al,%eax
  8004200d1c:	48 ba 04 e0 6b 04 80 	movabs $0x80046be004,%rdx
  8004200d23:	00 00 00 
  8004200d26:	8b 12                	mov    (%rdx),%edx
  8004200d28:	83 c2 01             	add    $0x1,%edx
  8004200d2b:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200d2e:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200d31:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200d35:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200d38:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200d39:	48 b8 04 e0 6b 04 80 	movabs $0x80046be004,%rax
  8004200d40:	00 00 00 
  8004200d43:	8b 00                	mov    (%rax),%eax
  8004200d45:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200d48:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200d4c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200d50:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200d53:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200d54:	48 b8 10 e0 6b 04 80 	movabs $0x80046be010,%rax
  8004200d5b:	00 00 00 
  8004200d5e:	0f b7 00             	movzwl (%rax),%eax
  8004200d61:	0f b6 c0             	movzbl %al,%eax
  8004200d64:	48 ba 04 e0 6b 04 80 	movabs $0x80046be004,%rdx
  8004200d6b:	00 00 00 
  8004200d6e:	8b 12                	mov    (%rdx),%edx
  8004200d70:	83 c2 01             	add    $0x1,%edx
  8004200d73:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200d76:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200d79:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200d7d:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200d80:	ee                   	out    %al,(%dx)
}
  8004200d81:	c9                   	leaveq 
  8004200d82:	c3                   	retq   

0000008004200d83 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200d83:	55                   	push   %rbp
  8004200d84:	48 89 e5             	mov    %rsp,%rbp
  8004200d87:	48 83 ec 20          	sub    $0x20,%rsp
  8004200d8b:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200d92:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200d95:	89 c2                	mov    %eax,%edx
  8004200d97:	ec                   	in     (%dx),%al
  8004200d98:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200d9b:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200d9f:	0f b6 c0             	movzbl %al,%eax
  8004200da2:	83 e0 01             	and    $0x1,%eax
  8004200da5:	85 c0                	test   %eax,%eax
  8004200da7:	75 0a                	jne    8004200db3 <kbd_proc_data+0x30>
		return -1;
  8004200da9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200dae:	e9 fc 01 00 00       	jmpq   8004200faf <kbd_proc_data+0x22c>
  8004200db3:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200dba:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200dbd:	89 c2                	mov    %eax,%edx
  8004200dbf:	ec                   	in     (%dx),%al
  8004200dc0:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200dc3:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200dc7:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200dca:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200dce:	75 27                	jne    8004200df7 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200dd0:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200dd7:	00 00 00 
  8004200dda:	8b 00                	mov    (%rax),%eax
  8004200ddc:	83 c8 40             	or     $0x40,%eax
  8004200ddf:	89 c2                	mov    %eax,%edx
  8004200de1:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200de8:	00 00 00 
  8004200deb:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200ded:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200df2:	e9 b8 01 00 00       	jmpq   8004200faf <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200df7:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200dfb:	84 c0                	test   %al,%al
  8004200dfd:	79 65                	jns    8004200e64 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200dff:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200e06:	00 00 00 
  8004200e09:	8b 00                	mov    (%rax),%eax
  8004200e0b:	83 e0 40             	and    $0x40,%eax
  8004200e0e:	85 c0                	test   %eax,%eax
  8004200e10:	75 09                	jne    8004200e1b <kbd_proc_data+0x98>
  8004200e12:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e16:	83 e0 7f             	and    $0x7f,%eax
  8004200e19:	eb 04                	jmp    8004200e1f <kbd_proc_data+0x9c>
  8004200e1b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e1f:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200e22:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e26:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200e2d:	00 00 00 
  8004200e30:	48 98                	cltq   
  8004200e32:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e36:	83 c8 40             	or     $0x40,%eax
  8004200e39:	0f b6 c0             	movzbl %al,%eax
  8004200e3c:	f7 d0                	not    %eax
  8004200e3e:	89 c2                	mov    %eax,%edx
  8004200e40:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200e47:	00 00 00 
  8004200e4a:	8b 00                	mov    (%rax),%eax
  8004200e4c:	21 c2                	and    %eax,%edx
  8004200e4e:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200e55:	00 00 00 
  8004200e58:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e5f:	e9 4b 01 00 00       	jmpq   8004200faf <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200e64:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200e6b:	00 00 00 
  8004200e6e:	8b 00                	mov    (%rax),%eax
  8004200e70:	83 e0 40             	and    $0x40,%eax
  8004200e73:	85 c0                	test   %eax,%eax
  8004200e75:	74 21                	je     8004200e98 <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200e77:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200e7b:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200e82:	00 00 00 
  8004200e85:	8b 00                	mov    (%rax),%eax
  8004200e87:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200e8a:	89 c2                	mov    %eax,%edx
  8004200e8c:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200e93:	00 00 00 
  8004200e96:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200e98:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e9c:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200ea3:	00 00 00 
  8004200ea6:	48 98                	cltq   
  8004200ea8:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200eac:	0f b6 d0             	movzbl %al,%edx
  8004200eaf:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200eb6:	00 00 00 
  8004200eb9:	8b 00                	mov    (%rax),%eax
  8004200ebb:	09 c2                	or     %eax,%edx
  8004200ebd:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200ec4:	00 00 00 
  8004200ec7:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200ec9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ecd:	48 ba 60 b1 22 04 80 	movabs $0x800422b160,%rdx
  8004200ed4:	00 00 00 
  8004200ed7:	48 98                	cltq   
  8004200ed9:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200edd:	0f b6 d0             	movzbl %al,%edx
  8004200ee0:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200ee7:	00 00 00 
  8004200eea:	8b 00                	mov    (%rax),%eax
  8004200eec:	31 c2                	xor    %eax,%edx
  8004200eee:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200ef5:	00 00 00 
  8004200ef8:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200efa:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200f01:	00 00 00 
  8004200f04:	8b 00                	mov    (%rax),%eax
  8004200f06:	83 e0 03             	and    $0x3,%eax
  8004200f09:	89 c2                	mov    %eax,%edx
  8004200f0b:	48 b8 60 b5 22 04 80 	movabs $0x800422b560,%rax
  8004200f12:	00 00 00 
  8004200f15:	89 d2                	mov    %edx,%edx
  8004200f17:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200f1b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f1f:	48 01 d0             	add    %rdx,%rax
  8004200f22:	0f b6 00             	movzbl (%rax),%eax
  8004200f25:	0f b6 c0             	movzbl %al,%eax
  8004200f28:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200f2b:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200f32:	00 00 00 
  8004200f35:	8b 00                	mov    (%rax),%eax
  8004200f37:	83 e0 08             	and    $0x8,%eax
  8004200f3a:	85 c0                	test   %eax,%eax
  8004200f3c:	74 22                	je     8004200f60 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200f3e:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200f42:	7e 0c                	jle    8004200f50 <kbd_proc_data+0x1cd>
  8004200f44:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200f48:	7f 06                	jg     8004200f50 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200f4a:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200f4e:	eb 10                	jmp    8004200f60 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200f50:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200f54:	7e 0a                	jle    8004200f60 <kbd_proc_data+0x1dd>
  8004200f56:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200f5a:	7f 04                	jg     8004200f60 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200f5c:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200f60:	48 b8 28 e2 6b 04 80 	movabs $0x80046be228,%rax
  8004200f67:	00 00 00 
  8004200f6a:	8b 00                	mov    (%rax),%eax
  8004200f6c:	f7 d0                	not    %eax
  8004200f6e:	83 e0 06             	and    $0x6,%eax
  8004200f71:	85 c0                	test   %eax,%eax
  8004200f73:	75 37                	jne    8004200fac <kbd_proc_data+0x229>
  8004200f75:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200f7c:	75 2e                	jne    8004200fac <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200f7e:	48 bf 6e 63 21 04 80 	movabs $0x800421636e,%rdi
  8004200f85:	00 00 00 
  8004200f88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f8d:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004200f94:	00 00 00 
  8004200f97:	ff d2                	callq  *%rdx
  8004200f99:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004200fa0:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200fa4:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200fa8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200fab:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
	return c;
  8004200fac:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200faf:	c9                   	leaveq 
  8004200fb0:	c3                   	retq   

0000008004200fb1 <kbd_intr>:

void
kbd_intr(void)
{
  8004200fb1:	55                   	push   %rbp
  8004200fb2:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004200fb5:	48 bf 83 0d 20 04 80 	movabs $0x8004200d83,%rdi
  8004200fbc:	00 00 00 
  8004200fbf:	48 b8 02 10 20 04 80 	movabs $0x8004201002,%rax
  8004200fc6:	00 00 00 
  8004200fc9:	ff d0                	callq  *%rax
}
  8004200fcb:	5d                   	pop    %rbp
  8004200fcc:	c3                   	retq   

0000008004200fcd <kbd_init>:

static void
kbd_init(void)
{
  8004200fcd:	55                   	push   %rbp
  8004200fce:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004200fd1:	48 b8 b1 0f 20 04 80 	movabs $0x8004200fb1,%rax
  8004200fd8:	00 00 00 
  8004200fdb:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004200fdd:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  8004200fe4:	00 00 00 
  8004200fe7:	0f b7 00             	movzwl (%rax),%eax
  8004200fea:	0f b7 c0             	movzwl %ax,%eax
  8004200fed:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004200ff2:	89 c7                	mov    %eax,%edi
  8004200ff4:	48 b8 6c 85 20 04 80 	movabs $0x800420856c,%rax
  8004200ffb:	00 00 00 
  8004200ffe:	ff d0                	callq  *%rax
}
  8004201000:	5d                   	pop    %rbp
  8004201001:	c3                   	retq   

0000008004201002 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201002:	55                   	push   %rbp
  8004201003:	48 89 e5             	mov    %rsp,%rbp
  8004201006:	48 83 ec 20          	sub    $0x20,%rsp
  800420100a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  800420100e:	eb 6a                	jmp    800420107a <cons_intr+0x78>
		if (c == 0)
  8004201010:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201014:	75 02                	jne    8004201018 <cons_intr+0x16>
			continue;
  8004201016:	eb 62                	jmp    800420107a <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004201018:	48 b8 20 e0 6b 04 80 	movabs $0x80046be020,%rax
  800420101f:	00 00 00 
  8004201022:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201028:	8d 48 01             	lea    0x1(%rax),%ecx
  800420102b:	48 ba 20 e0 6b 04 80 	movabs $0x80046be020,%rdx
  8004201032:	00 00 00 
  8004201035:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  800420103b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420103e:	89 d1                	mov    %edx,%ecx
  8004201040:	48 ba 20 e0 6b 04 80 	movabs $0x80046be020,%rdx
  8004201047:	00 00 00 
  800420104a:	89 c0                	mov    %eax,%eax
  800420104c:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  800420104f:	48 b8 20 e0 6b 04 80 	movabs $0x80046be020,%rax
  8004201056:	00 00 00 
  8004201059:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420105f:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201064:	75 14                	jne    800420107a <cons_intr+0x78>
			cons.wpos = 0;
  8004201066:	48 b8 20 e0 6b 04 80 	movabs $0x80046be020,%rax
  800420106d:	00 00 00 
  8004201070:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  8004201077:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  800420107a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420107e:	ff d0                	callq  *%rax
  8004201080:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201083:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004201087:	75 87                	jne    8004201010 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004201089:	c9                   	leaveq 
  800420108a:	c3                   	retq   

000000800420108b <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  800420108b:	55                   	push   %rbp
  800420108c:	48 89 e5             	mov    %rsp,%rbp
  800420108f:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201093:	48 b8 62 07 20 04 80 	movabs $0x8004200762,%rax
  800420109a:	00 00 00 
  800420109d:	ff d0                	callq  *%rax
	kbd_intr();
  800420109f:	48 b8 b1 0f 20 04 80 	movabs $0x8004200fb1,%rax
  80042010a6:	00 00 00 
  80042010a9:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  80042010ab:	48 b8 20 e0 6b 04 80 	movabs $0x80046be020,%rax
  80042010b2:	00 00 00 
  80042010b5:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  80042010bb:	48 b8 20 e0 6b 04 80 	movabs $0x80046be020,%rax
  80042010c2:	00 00 00 
  80042010c5:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010cb:	39 c2                	cmp    %eax,%edx
  80042010cd:	74 69                	je     8004201138 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  80042010cf:	48 b8 20 e0 6b 04 80 	movabs $0x80046be020,%rax
  80042010d6:	00 00 00 
  80042010d9:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042010df:	8d 48 01             	lea    0x1(%rax),%ecx
  80042010e2:	48 ba 20 e0 6b 04 80 	movabs $0x80046be020,%rdx
  80042010e9:	00 00 00 
  80042010ec:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  80042010f2:	48 ba 20 e0 6b 04 80 	movabs $0x80046be020,%rdx
  80042010f9:	00 00 00 
  80042010fc:	89 c0                	mov    %eax,%eax
  80042010fe:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201102:	0f b6 c0             	movzbl %al,%eax
  8004201105:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004201108:	48 b8 20 e0 6b 04 80 	movabs $0x80046be020,%rax
  800420110f:	00 00 00 
  8004201112:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201118:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420111d:	75 14                	jne    8004201133 <cons_getc+0xa8>
			cons.rpos = 0;
  800420111f:	48 b8 20 e0 6b 04 80 	movabs $0x80046be020,%rax
  8004201126:	00 00 00 
  8004201129:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201130:	00 00 00 
		return c;
  8004201133:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201136:	eb 05                	jmp    800420113d <cons_getc+0xb2>
	}
	return 0;
  8004201138:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420113d:	c9                   	leaveq 
  800420113e:	c3                   	retq   

000000800420113f <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  800420113f:	55                   	push   %rbp
  8004201140:	48 89 e5             	mov    %rsp,%rbp
  8004201143:	48 83 ec 10          	sub    $0x10,%rsp
  8004201147:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  800420114a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420114d:	89 c7                	mov    %eax,%edi
  800420114f:	48 b8 8f 07 20 04 80 	movabs $0x800420078f,%rax
  8004201156:	00 00 00 
  8004201159:	ff d0                	callq  *%rax
	lpt_putc(c);
  800420115b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420115e:	89 c7                	mov    %eax,%edi
  8004201160:	48 b8 fc 08 20 04 80 	movabs $0x80042008fc,%rax
  8004201167:	00 00 00 
  800420116a:	ff d0                	callq  *%rax
	cga_putc(c);
  800420116c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420116f:	89 c7                	mov    %eax,%edi
  8004201171:	48 b8 9b 0a 20 04 80 	movabs $0x8004200a9b,%rax
  8004201178:	00 00 00 
  800420117b:	ff d0                	callq  *%rax
}
  800420117d:	c9                   	leaveq 
  800420117e:	c3                   	retq   

000000800420117f <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  800420117f:	55                   	push   %rbp
  8004201180:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004201183:	48 b8 81 09 20 04 80 	movabs $0x8004200981,%rax
  800420118a:	00 00 00 
  800420118d:	ff d0                	callq  *%rax
	kbd_init();
  800420118f:	48 b8 cd 0f 20 04 80 	movabs $0x8004200fcd,%rax
  8004201196:	00 00 00 
  8004201199:	ff d0                	callq  *%rax
	serial_init();
  800420119b:	48 b8 f4 07 20 04 80 	movabs $0x80042007f4,%rax
  80042011a2:	00 00 00 
  80042011a5:	ff d0                	callq  *%rax

	if (!serial_exists)
  80042011a7:	48 b8 00 e0 6b 04 80 	movabs $0x80046be000,%rax
  80042011ae:	00 00 00 
  80042011b1:	0f b6 00             	movzbl (%rax),%eax
  80042011b4:	83 f0 01             	xor    $0x1,%eax
  80042011b7:	84 c0                	test   %al,%al
  80042011b9:	74 1b                	je     80042011d6 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  80042011bb:	48 bf 7a 63 21 04 80 	movabs $0x800421637a,%rdi
  80042011c2:	00 00 00 
  80042011c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042011ca:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042011d1:	00 00 00 
  80042011d4:	ff d2                	callq  *%rdx
}
  80042011d6:	5d                   	pop    %rbp
  80042011d7:	c3                   	retq   

00000080042011d8 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  80042011d8:	55                   	push   %rbp
  80042011d9:	48 89 e5             	mov    %rsp,%rbp
  80042011dc:	48 83 ec 10          	sub    $0x10,%rsp
  80042011e0:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  80042011e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011e6:	89 c7                	mov    %eax,%edi
  80042011e8:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  80042011ef:	00 00 00 
  80042011f2:	ff d0                	callq  *%rax
}
  80042011f4:	c9                   	leaveq 
  80042011f5:	c3                   	retq   

00000080042011f6 <getchar>:

int
getchar(void)
{
  80042011f6:	55                   	push   %rbp
  80042011f7:	48 89 e5             	mov    %rsp,%rbp
  80042011fa:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  80042011fe:	48 b8 8b 10 20 04 80 	movabs $0x800420108b,%rax
  8004201205:	00 00 00 
  8004201208:	ff d0                	callq  *%rax
  800420120a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420120d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201211:	74 eb                	je     80042011fe <getchar+0x8>
		/* do nothing */;
	return c;
  8004201213:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201216:	c9                   	leaveq 
  8004201217:	c3                   	retq   

0000008004201218 <iscons>:

int
iscons(int fdnum)
{
  8004201218:	55                   	push   %rbp
  8004201219:	48 89 e5             	mov    %rsp,%rbp
  800420121c:	48 83 ec 04          	sub    $0x4,%rsp
  8004201220:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  8004201223:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201228:	c9                   	leaveq 
  8004201229:	c3                   	retq   

000000800420122a <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  800420122a:	55                   	push   %rbp
  800420122b:	48 89 e5             	mov    %rsp,%rbp
  800420122e:	48 83 ec 30          	sub    $0x30,%rsp
  8004201232:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201235:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201239:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  800420123d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004201244:	eb 6c                	jmp    80042012b2 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  8004201246:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  800420124d:	00 00 00 
  8004201250:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201253:	48 63 d0             	movslq %eax,%rdx
  8004201256:	48 89 d0             	mov    %rdx,%rax
  8004201259:	48 01 c0             	add    %rax,%rax
  800420125c:	48 01 d0             	add    %rdx,%rax
  800420125f:	48 c1 e0 03          	shl    $0x3,%rax
  8004201263:	48 01 c8             	add    %rcx,%rax
  8004201266:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800420126a:	48 be 80 b5 22 04 80 	movabs $0x800422b580,%rsi
  8004201271:	00 00 00 
  8004201274:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201277:	48 63 d0             	movslq %eax,%rdx
  800420127a:	48 89 d0             	mov    %rdx,%rax
  800420127d:	48 01 c0             	add    %rax,%rax
  8004201280:	48 01 d0             	add    %rdx,%rax
  8004201283:	48 c1 e0 03          	shl    $0x3,%rax
  8004201287:	48 01 f0             	add    %rsi,%rax
  800420128a:	48 8b 00             	mov    (%rax),%rax
  800420128d:	48 89 ca             	mov    %rcx,%rdx
  8004201290:	48 89 c6             	mov    %rax,%rsi
  8004201293:	48 bf ed 63 21 04 80 	movabs $0x80042163ed,%rdi
  800420129a:	00 00 00 
  800420129d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012a2:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  80042012a9:	00 00 00 
  80042012ac:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012ae:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042012b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012b5:	83 f8 01             	cmp    $0x1,%eax
  80042012b8:	76 8c                	jbe    8004201246 <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  80042012ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042012bf:	c9                   	leaveq 
  80042012c0:	c3                   	retq   

00000080042012c1 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  80042012c1:	55                   	push   %rbp
  80042012c2:	48 89 e5             	mov    %rsp,%rbp
  80042012c5:	48 83 ec 30          	sub    $0x30,%rsp
  80042012c9:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012cc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012d0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  80042012d4:	48 bf f6 63 21 04 80 	movabs $0x80042163f6,%rdi
  80042012db:	00 00 00 
  80042012de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012e3:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042012ea:	00 00 00 
  80042012ed:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  80042012ef:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  80042012f6:	00 00 00 
  80042012f9:	48 bf 10 64 21 04 80 	movabs $0x8004216410,%rdi
  8004201300:	00 00 00 
  8004201303:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201308:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420130f:	00 00 00 
  8004201312:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  8004201314:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  800420131b:	00 00 00 
  800420131e:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  8004201325:	00 00 00 
  8004201328:	48 bf 38 64 21 04 80 	movabs $0x8004216438,%rdi
  800420132f:	00 00 00 
  8004201332:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201337:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  800420133e:	00 00 00 
  8004201341:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  8004201343:	48 ba 95 62 21 00 00 	movabs $0x216295,%rdx
  800420134a:	00 00 00 
  800420134d:	48 be 95 62 21 04 80 	movabs $0x8004216295,%rsi
  8004201354:	00 00 00 
  8004201357:	48 bf 60 64 21 04 80 	movabs $0x8004216460,%rdi
  800420135e:	00 00 00 
  8004201361:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201366:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  800420136d:	00 00 00 
  8004201370:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201372:	48 ba 07 da 6b 00 00 	movabs $0x6bda07,%rdx
  8004201379:	00 00 00 
  800420137c:	48 be 07 da 6b 04 80 	movabs $0x80046bda07,%rsi
  8004201383:	00 00 00 
  8004201386:	48 bf 88 64 21 04 80 	movabs $0x8004216488,%rdi
  800420138d:	00 00 00 
  8004201390:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201395:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  800420139c:	00 00 00 
  800420139f:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  80042013a1:	48 ba 10 20 74 00 00 	movabs $0x742010,%rdx
  80042013a8:	00 00 00 
  80042013ab:	48 be 10 20 74 04 80 	movabs $0x8004742010,%rsi
  80042013b2:	00 00 00 
  80042013b5:	48 bf b0 64 21 04 80 	movabs $0x80042164b0,%rdi
  80042013bc:	00 00 00 
  80042013bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013c4:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  80042013cb:	00 00 00 
  80042013ce:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  80042013d0:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042013d7:	00 
  80042013d8:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  80042013df:	00 00 00 
  80042013e2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042013e6:	48 29 c2             	sub    %rax,%rdx
  80042013e9:	48 b8 10 20 74 04 80 	movabs $0x8004742010,%rax
  80042013f0:	00 00 00 
  80042013f3:	48 83 e8 01          	sub    $0x1,%rax
  80042013f7:	48 01 d0             	add    %rdx,%rax
  80042013fa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042013fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201402:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201407:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420140b:	48 89 d0             	mov    %rdx,%rax
  800420140e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004201412:	48 29 c2             	sub    %rax,%rdx
  8004201415:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  8004201418:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  800420141f:	48 85 c0             	test   %rax,%rax
  8004201422:	48 0f 48 c2          	cmovs  %rdx,%rax
  8004201426:	48 c1 f8 0a          	sar    $0xa,%rax
  800420142a:	48 89 c6             	mov    %rax,%rsi
  800420142d:	48 bf d8 64 21 04 80 	movabs $0x80042164d8,%rdi
  8004201434:	00 00 00 
  8004201437:	b8 00 00 00 00       	mov    $0x0,%eax
  800420143c:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004201443:	00 00 00 
  8004201446:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  8004201448:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420144d:	c9                   	leaveq 
  800420144e:	c3                   	retq   

000000800420144f <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  800420144f:	55                   	push   %rbp
  8004201450:	48 89 e5             	mov    %rsp,%rbp
  8004201453:	48 83 ec 18          	sub    $0x18,%rsp
  8004201457:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420145a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420145e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// Your code here.
	return 0;
  8004201462:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201467:	c9                   	leaveq 
  8004201468:	c3                   	retq   

0000008004201469 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201469:	55                   	push   %rbp
  800420146a:	48 89 e5             	mov    %rsp,%rbp
  800420146d:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201474:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420147b:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201482:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  8004201489:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420148c:	48 98                	cltq   
  800420148e:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201495:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  800420149a:	eb 15                	jmp    80042014b1 <runcmd+0x48>
			*buf++ = 0;
  800420149c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042014a3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042014a7:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  80042014ae:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042014b1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042014b8:	0f b6 00             	movzbl (%rax),%eax
  80042014bb:	84 c0                	test   %al,%al
  80042014bd:	74 2a                	je     80042014e9 <runcmd+0x80>
  80042014bf:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042014c6:	0f b6 00             	movzbl (%rax),%eax
  80042014c9:	0f be c0             	movsbl %al,%eax
  80042014cc:	89 c6                	mov    %eax,%esi
  80042014ce:	48 bf 02 65 21 04 80 	movabs $0x8004216502,%rdi
  80042014d5:	00 00 00 
  80042014d8:	48 b8 d8 eb 20 04 80 	movabs $0x800420ebd8,%rax
  80042014df:	00 00 00 
  80042014e2:	ff d0                	callq  *%rax
  80042014e4:	48 85 c0             	test   %rax,%rax
  80042014e7:	75 b3                	jne    800420149c <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  80042014e9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042014f0:	0f b6 00             	movzbl (%rax),%eax
  80042014f3:	84 c0                	test   %al,%al
  80042014f5:	75 21                	jne    8004201518 <runcmd+0xaf>
			break;
  80042014f7:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042014f8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042014fb:	48 98                	cltq   
  80042014fd:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201504:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  8004201509:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420150d:	0f 85 a1 00 00 00    	jne    80042015b4 <runcmd+0x14b>
  8004201513:	e9 92 00 00 00       	jmpq   80042015aa <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  8004201518:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  800420151c:	75 2a                	jne    8004201548 <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  800420151e:	be 10 00 00 00       	mov    $0x10,%esi
  8004201523:	48 bf 07 65 21 04 80 	movabs $0x8004216507,%rdi
  800420152a:	00 00 00 
  800420152d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201532:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004201539:	00 00 00 
  800420153c:	ff d2                	callq  *%rdx
			return 0;
  800420153e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201543:	e9 30 01 00 00       	jmpq   8004201678 <runcmd+0x20f>
		}
		argv[argc++] = buf;
  8004201548:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420154b:	8d 50 01             	lea    0x1(%rax),%edx
  800420154e:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201551:	48 98                	cltq   
  8004201553:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800420155a:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201561:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201562:	eb 08                	jmp    800420156c <runcmd+0x103>
			buf++;
  8004201564:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  800420156b:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  800420156c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201573:	0f b6 00             	movzbl (%rax),%eax
  8004201576:	84 c0                	test   %al,%al
  8004201578:	74 2a                	je     80042015a4 <runcmd+0x13b>
  800420157a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201581:	0f b6 00             	movzbl (%rax),%eax
  8004201584:	0f be c0             	movsbl %al,%eax
  8004201587:	89 c6                	mov    %eax,%esi
  8004201589:	48 bf 02 65 21 04 80 	movabs $0x8004216502,%rdi
  8004201590:	00 00 00 
  8004201593:	48 b8 d8 eb 20 04 80 	movabs $0x800420ebd8,%rax
  800420159a:	00 00 00 
  800420159d:	ff d0                	callq  *%rax
  800420159f:	48 85 c0             	test   %rax,%rax
  80042015a2:	74 c0                	je     8004201564 <runcmd+0xfb>
			buf++;
	}
  80042015a4:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042015a5:	e9 07 ff ff ff       	jmpq   80042014b1 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  80042015aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015af:	e9 c4 00 00 00       	jmpq   8004201678 <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  80042015b4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042015bb:	e9 82 00 00 00       	jmpq   8004201642 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  80042015c0:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  80042015c7:	00 00 00 
  80042015ca:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042015cd:	48 63 d0             	movslq %eax,%rdx
  80042015d0:	48 89 d0             	mov    %rdx,%rax
  80042015d3:	48 01 c0             	add    %rax,%rax
  80042015d6:	48 01 d0             	add    %rdx,%rax
  80042015d9:	48 c1 e0 03          	shl    $0x3,%rax
  80042015dd:	48 01 c8             	add    %rcx,%rax
  80042015e0:	48 8b 10             	mov    (%rax),%rdx
  80042015e3:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042015ea:	48 89 d6             	mov    %rdx,%rsi
  80042015ed:	48 89 c7             	mov    %rax,%rdi
  80042015f0:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  80042015f7:	00 00 00 
  80042015fa:	ff d0                	callq  *%rax
  80042015fc:	85 c0                	test   %eax,%eax
  80042015fe:	75 3e                	jne    800420163e <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201600:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004201607:	00 00 00 
  800420160a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420160d:	48 63 d0             	movslq %eax,%rdx
  8004201610:	48 89 d0             	mov    %rdx,%rax
  8004201613:	48 01 c0             	add    %rax,%rax
  8004201616:	48 01 d0             	add    %rdx,%rax
  8004201619:	48 c1 e0 03          	shl    $0x3,%rax
  800420161d:	48 01 c8             	add    %rcx,%rax
  8004201620:	48 83 c0 10          	add    $0x10,%rax
  8004201624:	48 8b 00             	mov    (%rax),%rax
  8004201627:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420162e:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201635:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201638:	89 cf                	mov    %ecx,%edi
  800420163a:	ff d0                	callq  *%rax
  800420163c:	eb 3a                	jmp    8004201678 <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  800420163e:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201642:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201645:	83 f8 01             	cmp    $0x1,%eax
  8004201648:	0f 86 72 ff ff ff    	jbe    80042015c0 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  800420164e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201655:	48 89 c6             	mov    %rax,%rsi
  8004201658:	48 bf 24 65 21 04 80 	movabs $0x8004216524,%rdi
  800420165f:	00 00 00 
  8004201662:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201667:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420166e:	00 00 00 
  8004201671:	ff d2                	callq  *%rdx
	return 0;
  8004201673:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201678:	c9                   	leaveq 
  8004201679:	c3                   	retq   

000000800420167a <monitor>:

void
monitor(struct Trapframe *tf)
{
  800420167a:	55                   	push   %rbp
  800420167b:	48 89 e5             	mov    %rsp,%rbp
  800420167e:	48 83 ec 20          	sub    $0x20,%rsp
  8004201682:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201686:	48 bf 40 65 21 04 80 	movabs $0x8004216540,%rdi
  800420168d:	00 00 00 
  8004201690:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201695:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420169c:	00 00 00 
  800420169f:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  80042016a1:	48 bf 68 65 21 04 80 	movabs $0x8004216568,%rdi
  80042016a8:	00 00 00 
  80042016ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016b0:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042016b7:	00 00 00 
  80042016ba:	ff d2                	callq  *%rdx

	if (tf != NULL)
  80042016bc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042016c1:	74 13                	je     80042016d6 <monitor+0x5c>
		print_trapframe(tf);
  80042016c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042016c7:	48 89 c7             	mov    %rax,%rdi
  80042016ca:	48 b8 71 b2 20 04 80 	movabs $0x800420b271,%rax
  80042016d1:	00 00 00 
  80042016d4:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  80042016d6:	48 bf 8d 65 21 04 80 	movabs $0x800421658d,%rdi
  80042016dd:	00 00 00 
  80042016e0:	48 b8 f1 e7 20 04 80 	movabs $0x800420e7f1,%rax
  80042016e7:	00 00 00 
  80042016ea:	ff d0                	callq  *%rax
  80042016ec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  80042016f0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042016f5:	74 20                	je     8004201717 <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  80042016f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042016fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042016ff:	48 89 d6             	mov    %rdx,%rsi
  8004201702:	48 89 c7             	mov    %rax,%rdi
  8004201705:	48 b8 69 14 20 04 80 	movabs $0x8004201469,%rax
  800420170c:	00 00 00 
  800420170f:	ff d0                	callq  *%rax
  8004201711:	85 c0                	test   %eax,%eax
  8004201713:	79 02                	jns    8004201717 <monitor+0x9d>
				break;
  8004201715:	eb 02                	jmp    8004201719 <monitor+0x9f>
	}
  8004201717:	eb bd                	jmp    80042016d6 <monitor+0x5c>
}
  8004201719:	c9                   	leaveq 
  800420171a:	c3                   	retq   

000000800420171b <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420171b:	55                   	push   %rbp
  800420171c:	48 89 e5             	mov    %rsp,%rbp
  800420171f:	48 83 ec 08          	sub    $0x8,%rsp
  8004201723:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201727:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420172b:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  8004201732:	00 00 00 
  8004201735:	48 8b 00             	mov    (%rax),%rax
  8004201738:	48 29 c2             	sub    %rax,%rdx
  800420173b:	48 89 d0             	mov    %rdx,%rax
  800420173e:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201742:	c9                   	leaveq 
  8004201743:	c3                   	retq   

0000008004201744 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201744:	55                   	push   %rbp
  8004201745:	48 89 e5             	mov    %rsp,%rbp
  8004201748:	48 83 ec 08          	sub    $0x8,%rsp
  800420174c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201750:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201754:	48 89 c7             	mov    %rax,%rdi
  8004201757:	48 b8 1b 17 20 04 80 	movabs $0x800420171b,%rax
  800420175e:	00 00 00 
  8004201761:	ff d0                	callq  *%rax
  8004201763:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201767:	c9                   	leaveq 
  8004201768:	c3                   	retq   

0000008004201769 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201769:	55                   	push   %rbp
  800420176a:	48 89 e5             	mov    %rsp,%rbp
  800420176d:	48 83 ec 10          	sub    $0x10,%rsp
  8004201771:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201775:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201779:	48 c1 e8 0c          	shr    $0xc,%rax
  800420177d:	48 89 c2             	mov    %rax,%rdx
  8004201780:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004201787:	00 00 00 
  800420178a:	48 8b 00             	mov    (%rax),%rax
  800420178d:	48 39 c2             	cmp    %rax,%rdx
  8004201790:	72 2a                	jb     80042017bc <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201792:	48 ba 98 65 21 04 80 	movabs $0x8004216598,%rdx
  8004201799:	00 00 00 
  800420179c:	be 54 00 00 00       	mov    $0x54,%esi
  80042017a1:	48 bf b7 65 21 04 80 	movabs $0x80042165b7,%rdi
  80042017a8:	00 00 00 
  80042017ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017b0:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042017b7:	00 00 00 
  80042017ba:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042017bc:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  80042017c3:	00 00 00 
  80042017c6:	48 8b 00             	mov    (%rax),%rax
  80042017c9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042017cd:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042017d1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042017d5:	48 01 d0             	add    %rdx,%rax
}
  80042017d8:	c9                   	leaveq 
  80042017d9:	c3                   	retq   

00000080042017da <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042017da:	55                   	push   %rbp
  80042017db:	48 89 e5             	mov    %rsp,%rbp
  80042017de:	48 83 ec 20          	sub    $0x20,%rsp
  80042017e2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042017e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042017ea:	48 89 c7             	mov    %rax,%rdi
  80042017ed:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  80042017f4:	00 00 00 
  80042017f7:	ff d0                	callq  *%rax
  80042017f9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042017fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201801:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201805:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201808:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420180b:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004201812:	00 00 00 
  8004201815:	48 8b 00             	mov    (%rax),%rax
  8004201818:	48 39 c2             	cmp    %rax,%rdx
  800420181b:	72 32                	jb     800420184f <page2kva+0x75>
  800420181d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201821:	48 89 c1             	mov    %rax,%rcx
  8004201824:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  800420182b:	00 00 00 
  800420182e:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201833:	48 bf b7 65 21 04 80 	movabs $0x80042165b7,%rdi
  800420183a:	00 00 00 
  800420183d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201842:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004201849:	00 00 00 
  800420184c:	41 ff d0             	callq  *%r8
  800420184f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201856:	00 00 00 
  8004201859:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420185d:	48 01 d0             	add    %rdx,%rax
}
  8004201860:	c9                   	leaveq 
  8004201861:	c3                   	retq   

0000008004201862 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201862:	55                   	push   %rbp
  8004201863:	48 89 e5             	mov    %rsp,%rbp
  8004201866:	48 83 ec 08          	sub    $0x8,%rsp
  800420186a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420186d:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201870:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201874:	74 06                	je     800420187c <restrictive_type+0x1a>
  8004201876:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  800420187a:	75 07                	jne    8004201883 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  800420187c:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201881:	eb 3e                	jmp    80042018c1 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201883:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201887:	74 06                	je     800420188f <restrictive_type+0x2d>
  8004201889:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  800420188d:	75 07                	jne    8004201896 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  800420188f:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201894:	eb 2b                	jmp    80042018c1 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201896:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  800420189a:	74 06                	je     80042018a2 <restrictive_type+0x40>
  800420189c:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  80042018a0:	75 07                	jne    80042018a9 <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  80042018a2:	b8 02 00 00 00       	mov    $0x2,%eax
  80042018a7:	eb 18                	jmp    80042018c1 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  80042018a9:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  80042018ad:	74 06                	je     80042018b5 <restrictive_type+0x53>
  80042018af:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  80042018b3:	75 07                	jne    80042018bc <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  80042018b5:	b8 03 00 00 00       	mov    $0x3,%eax
  80042018ba:	eb 05                	jmp    80042018c1 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  80042018bc:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042018c1:	c9                   	leaveq 
  80042018c2:	c3                   	retq   

00000080042018c3 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  80042018c3:	55                   	push   %rbp
  80042018c4:	48 89 e5             	mov    %rsp,%rbp
  80042018c7:	53                   	push   %rbx
  80042018c8:	48 83 ec 18          	sub    $0x18,%rsp
  80042018cc:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  80042018cf:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042018d2:	89 c7                	mov    %eax,%edi
  80042018d4:	48 b8 9e 83 20 04 80 	movabs $0x800420839e,%rax
  80042018db:	00 00 00 
  80042018de:	ff d0                	callq  *%rax
  80042018e0:	89 c3                	mov    %eax,%ebx
  80042018e2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042018e5:	83 c0 01             	add    $0x1,%eax
  80042018e8:	89 c7                	mov    %eax,%edi
  80042018ea:	48 b8 9e 83 20 04 80 	movabs $0x800420839e,%rax
  80042018f1:	00 00 00 
  80042018f4:	ff d0                	callq  *%rax
  80042018f6:	c1 e0 08             	shl    $0x8,%eax
  80042018f9:	09 d8                	or     %ebx,%eax
}
  80042018fb:	48 83 c4 18          	add    $0x18,%rsp
  80042018ff:	5b                   	pop    %rbx
  8004201900:	5d                   	pop    %rbp
  8004201901:	c3                   	retq   

0000008004201902 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201902:	55                   	push   %rbp
  8004201903:	48 89 e5             	mov    %rsp,%rbp
  8004201906:	41 54                	push   %r12
  8004201908:	53                   	push   %rbx
  8004201909:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201910:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201917:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  800420191e:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201925:	48 89 e0             	mov    %rsp,%rax
  8004201928:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  800420192b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201932:	8b 40 30             	mov    0x30(%rax),%eax
  8004201935:	89 c0                	mov    %eax,%eax
  8004201937:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  800420193b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201942:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201945:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  800420194a:	f7 e2                	mul    %edx
  800420194c:	89 d0                	mov    %edx,%eax
  800420194e:	c1 e8 04             	shr    $0x4,%eax
  8004201951:	89 c0                	mov    %eax,%eax
  8004201953:	48 89 c2             	mov    %rax,%rdx
  8004201956:	48 83 ea 01          	sub    $0x1,%rdx
  800420195a:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420195e:	49 89 c0             	mov    %rax,%r8
  8004201961:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201967:	48 89 c1             	mov    %rax,%rcx
  800420196a:	bb 00 00 00 00       	mov    $0x0,%ebx
  800420196f:	48 c1 e0 03          	shl    $0x3,%rax
  8004201973:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201977:	b8 10 00 00 00       	mov    $0x10,%eax
  800420197c:	48 83 e8 01          	sub    $0x1,%rax
  8004201980:	48 01 d0             	add    %rdx,%rax
  8004201983:	bb 10 00 00 00       	mov    $0x10,%ebx
  8004201988:	ba 00 00 00 00       	mov    $0x0,%edx
  800420198d:	48 f7 f3             	div    %rbx
  8004201990:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201994:	48 29 c4             	sub    %rax,%rsp
  8004201997:	48 89 e0             	mov    %rsp,%rax
  800420199a:	48 83 c0 07          	add    $0x7,%rax
  800420199e:	48 c1 e8 03          	shr    $0x3,%rax
  80042019a2:	48 c1 e0 03          	shl    $0x3,%rax
  80042019a6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  80042019aa:	48 bf eb 65 21 04 80 	movabs $0x80042165eb,%rdi
  80042019b1:	00 00 00 
  80042019b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019b9:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042019c0:	00 00 00 
  80042019c3:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042019c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042019cc:	e9 6c 01 00 00       	jmpq   8004201b3d <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  80042019d1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042019d4:	48 63 d0             	movslq %eax,%rdx
  80042019d7:	48 89 d0             	mov    %rdx,%rax
  80042019da:	48 01 c0             	add    %rax,%rax
  80042019dd:	48 01 d0             	add    %rdx,%rax
  80042019e0:	48 c1 e0 03          	shl    $0x3,%rax
  80042019e4:	48 89 c2             	mov    %rax,%rdx
  80042019e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042019eb:	48 01 d0             	add    %rdx,%rax
  80042019ee:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  80042019f2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042019f6:	8b 40 08             	mov    0x8(%rax),%eax
  80042019f9:	89 c0                	mov    %eax,%eax
  80042019fb:	48 c1 e0 20          	shl    $0x20,%rax
  80042019ff:	48 89 c2             	mov    %rax,%rdx
  8004201a02:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a06:	8b 40 04             	mov    0x4(%rax),%eax
  8004201a09:	89 c0                	mov    %eax,%eax
  8004201a0b:	48 01 d0             	add    %rdx,%rax
  8004201a0e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201a12:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a16:	8b 40 10             	mov    0x10(%rax),%eax
  8004201a19:	89 c0                	mov    %eax,%eax
  8004201a1b:	48 c1 e0 20          	shl    $0x20,%rax
  8004201a1f:	48 89 c2             	mov    %rax,%rdx
  8004201a22:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a26:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201a29:	89 c0                	mov    %eax,%eax
  8004201a2b:	48 01 d0             	add    %rdx,%rax
  8004201a2e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size,
  8004201a32:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a36:	8b 70 14             	mov    0x14(%rax),%esi
  8004201a39:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a3d:	8b 00                	mov    (%rax),%eax
  8004201a3f:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201a43:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201a47:	41 89 f0             	mov    %esi,%r8d
  8004201a4a:	89 c6                	mov    %eax,%esi
  8004201a4c:	48 bf 00 66 21 04 80 	movabs $0x8004216600,%rdi
  8004201a53:	00 00 00 
  8004201a56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a5b:	49 b9 ea 86 20 04 80 	movabs $0x80042086ea,%r9
  8004201a62:	00 00 00 
  8004201a65:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201a68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a6c:	8b 40 14             	mov    0x14(%rax),%eax
  8004201a6f:	83 f8 05             	cmp    $0x5,%eax
  8004201a72:	77 0b                	ja     8004201a7f <multiboot_read+0x17d>
  8004201a74:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a78:	8b 40 14             	mov    0x14(%rax),%eax
  8004201a7b:	85 c0                	test   %eax,%eax
  8004201a7d:	75 0b                	jne    8004201a8a <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004201a7f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a83:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)

		//Insert into the sorted list
		int j = 0;
  8004201a8a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201a91:	e9 85 00 00 00       	jmpq   8004201b1b <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004201a96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201a9a:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201a9d:	48 63 d2             	movslq %edx,%rdx
  8004201aa0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201aa4:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201aa8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201aac:	8b 40 08             	mov    0x8(%rax),%eax
  8004201aaf:	89 c0                	mov    %eax,%eax
  8004201ab1:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ab5:	48 89 c2             	mov    %rax,%rdx
  8004201ab8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201abc:	8b 40 04             	mov    0x4(%rax),%eax
  8004201abf:	89 c0                	mov    %eax,%eax
  8004201ac1:	48 01 d0             	add    %rdx,%rax
  8004201ac4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201ac8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201acc:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201ad0:	76 45                	jbe    8004201b17 <multiboot_read+0x215>
				int last = i+1;
  8004201ad2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ad5:	83 c0 01             	add    $0x1,%eax
  8004201ad8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201adb:	eb 30                	jmp    8004201b0d <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201add:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201ae1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201ae4:	48 63 d2             	movslq %edx,%rdx
  8004201ae7:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201aeb:	48 01 c2             	add    %rax,%rdx
  8004201aee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201af2:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201af5:	48 63 c9             	movslq %ecx,%rcx
  8004201af8:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201afc:	48 83 e9 08          	sub    $0x8,%rcx
  8004201b00:	48 01 c8             	add    %rcx,%rax
  8004201b03:	48 8b 00             	mov    (%rax),%rax
  8004201b06:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201b09:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201b0d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201b10:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201b13:	75 c8                	jne    8004201add <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break;
  8004201b15:	eb 10                	jmp    8004201b27 <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;

		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201b17:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201b1b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201b1e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201b21:	0f 8c 6f ff ff ff    	jl     8004201a96 <multiboot_read+0x194>
					last--;
				}
				break;
			}
		}
		mmap_list[j] = mmap;
  8004201b27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201b2b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201b2e:	48 63 d2             	movslq %edx,%rdx
  8004201b31:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201b35:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201b39:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201b3d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201b40:	48 63 c8             	movslq %eax,%rcx
  8004201b43:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201b4a:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201b4d:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201b52:	f7 e2                	mul    %edx
  8004201b54:	89 d0                	mov    %edx,%eax
  8004201b56:	c1 e8 04             	shr    $0x4,%eax
  8004201b59:	89 c0                	mov    %eax,%eax
  8004201b5b:	48 39 c1             	cmp    %rax,%rcx
  8004201b5e:	0f 82 6d fe ff ff    	jb     80042019d1 <multiboot_read+0xcf>
				break;
			}
		}
		mmap_list[j] = mmap;
	}
	cprintf("\n");
  8004201b64:	48 bf 37 66 21 04 80 	movabs $0x8004216637,%rdi
  8004201b6b:	00 00 00 
  8004201b6e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b73:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004201b7a:	00 00 00 
  8004201b7d:	ff d2                	callq  *%rdx

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201b7f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004201b86:	e9 93 01 00 00       	jmpq   8004201d1e <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  8004201b8b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201b8e:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201b91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201b95:	48 63 d2             	movslq %edx,%rdx
  8004201b98:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201b9c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004201ba0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201ba4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201ba7:	48 63 d2             	movslq %edx,%rdx
  8004201baa:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201bae:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201bb2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201bb6:	8b 40 08             	mov    0x8(%rax),%eax
  8004201bb9:	89 c0                	mov    %eax,%eax
  8004201bbb:	48 c1 e0 20          	shl    $0x20,%rax
  8004201bbf:	48 89 c2             	mov    %rax,%rdx
  8004201bc2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201bc6:	8b 40 04             	mov    0x4(%rax),%eax
  8004201bc9:	89 c0                	mov    %eax,%eax
  8004201bcb:	48 01 d0             	add    %rdx,%rax
  8004201bce:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004201bd2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201bd6:	8b 40 08             	mov    0x8(%rax),%eax
  8004201bd9:	89 c0                	mov    %eax,%eax
  8004201bdb:	48 c1 e0 20          	shl    $0x20,%rax
  8004201bdf:	48 89 c2             	mov    %rax,%rdx
  8004201be2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201be6:	8b 40 04             	mov    0x4(%rax),%eax
  8004201be9:	89 c0                	mov    %eax,%eax
  8004201beb:	48 01 d0             	add    %rdx,%rax
  8004201bee:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004201bf2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201bf6:	8b 40 10             	mov    0x10(%rax),%eax
  8004201bf9:	89 c0                	mov    %eax,%eax
  8004201bfb:	48 c1 e0 20          	shl    $0x20,%rax
  8004201bff:	48 89 c2             	mov    %rax,%rdx
  8004201c02:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201c06:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201c09:	89 c0                	mov    %eax,%eax
  8004201c0b:	48 01 d0             	add    %rdx,%rax
  8004201c0e:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004201c15:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c19:	8b 40 10             	mov    0x10(%rax),%eax
  8004201c1c:	89 c0                	mov    %eax,%eax
  8004201c1e:	48 c1 e0 20          	shl    $0x20,%rax
  8004201c22:	48 89 c2             	mov    %rax,%rdx
  8004201c25:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c29:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201c2c:	89 c0                	mov    %eax,%eax
  8004201c2e:	48 01 d0             	add    %rdx,%rax
  8004201c31:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004201c38:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201c3f:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201c43:	48 01 d0             	add    %rdx,%rax
  8004201c46:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201c4a:	75 7c                	jne    8004201cc8 <multiboot_read+0x3c6>
  8004201c4c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201c50:	8b 50 14             	mov    0x14(%rax),%edx
  8004201c53:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c57:	8b 40 14             	mov    0x14(%rax),%eax
  8004201c5a:	39 c2                	cmp    %eax,%edx
  8004201c5c:	75 6a                	jne    8004201cc8 <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004201c5e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201c65:	89 c2                	mov    %eax,%edx
  8004201c67:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201c6e:	01 c2                	add    %eax,%edx
  8004201c70:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c74:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004201c77:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201c7e:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004201c85:	48 01 d0             	add    %rdx,%rax
  8004201c88:	48 c1 e8 20          	shr    $0x20,%rax
  8004201c8c:	89 c2                	mov    %eax,%edx
  8004201c8e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c92:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004201c95:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201c99:	8b 50 04             	mov    0x4(%rax),%edx
  8004201c9c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201ca0:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004201ca3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201ca7:	8b 50 08             	mov    0x8(%rax),%edx
  8004201caa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201cae:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004201cb1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201cb4:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201cb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201cbb:	48 63 d2             	movslq %edx,%rdx
  8004201cbe:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004201cc5:	00 
  8004201cc6:	eb 52                	jmp    8004201d1a <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  8004201cc8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201ccf:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201cd3:	48 01 d0             	add    %rdx,%rax
  8004201cd6:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201cda:	76 3e                	jbe    8004201d1a <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004201cdc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201ce0:	8b 50 14             	mov    0x14(%rax),%edx
  8004201ce3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201ce7:	8b 40 14             	mov    0x14(%rax),%eax
  8004201cea:	89 d6                	mov    %edx,%esi
  8004201cec:	89 c7                	mov    %eax,%edi
  8004201cee:	48 b8 62 18 20 04 80 	movabs $0x8004201862,%rax
  8004201cf5:	00 00 00 
  8004201cf8:	ff d0                	callq  *%rax
  8004201cfa:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004201d00:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201d04:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201d0a:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004201d0d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d11:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201d17:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;
	}
	cprintf("\n");

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201d1a:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201d1e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d21:	48 63 c8             	movslq %eax,%rcx
  8004201d24:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201d2b:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201d2e:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201d33:	f7 e2                	mul    %edx
  8004201d35:	89 d0                	mov    %edx,%eax
  8004201d37:	c1 e8 04             	shr    $0x4,%eax
  8004201d3a:	89 c0                	mov    %eax,%eax
  8004201d3c:	48 39 c1             	cmp    %rax,%rcx
  8004201d3f:	0f 82 46 fe ff ff    	jb     8004201b8b <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201d45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201d4c:	e9 dc 00 00 00       	jmpq   8004201e2d <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004201d51:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d55:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201d58:	48 63 d2             	movslq %edx,%rdx
  8004201d5b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201d5f:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004201d66:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004201d6d:	00 
  8004201d6e:	0f 84 b5 00 00 00    	je     8004201e29 <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004201d74:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d7b:	8b 40 14             	mov    0x14(%rax),%eax
  8004201d7e:	83 f8 01             	cmp    $0x1,%eax
  8004201d81:	74 13                	je     8004201d96 <multiboot_read+0x494>
  8004201d83:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d8a:	8b 40 14             	mov    0x14(%rax),%eax
  8004201d8d:	83 f8 03             	cmp    $0x3,%eax
  8004201d90:	0f 85 93 00 00 00    	jne    8004201e29 <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004201d96:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201d9d:	8b 40 04             	mov    0x4(%rax),%eax
  8004201da0:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004201da5:	77 49                	ja     8004201df0 <multiboot_read+0x4ee>
  8004201da7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201dae:	8b 40 08             	mov    0x8(%rax),%eax
  8004201db1:	85 c0                	test   %eax,%eax
  8004201db3:	75 3b                	jne    8004201df0 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201db5:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201dbc:	48 8b 10             	mov    (%rax),%rdx
  8004201dbf:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201dc6:	8b 40 10             	mov    0x10(%rax),%eax
  8004201dc9:	89 c0                	mov    %eax,%eax
  8004201dcb:	48 c1 e0 20          	shl    $0x20,%rax
  8004201dcf:	48 89 c1             	mov    %rax,%rcx
  8004201dd2:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201dd9:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201ddc:	89 c0                	mov    %eax,%eax
  8004201dde:	48 01 c8             	add    %rcx,%rax
  8004201de1:	48 01 c2             	add    %rax,%rdx
  8004201de4:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201deb:	48 89 10             	mov    %rdx,(%rax)
  8004201dee:	eb 39                	jmp    8004201e29 <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201df0:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201df7:	48 8b 10             	mov    (%rax),%rdx
  8004201dfa:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201e01:	8b 40 10             	mov    0x10(%rax),%eax
  8004201e04:	89 c0                	mov    %eax,%eax
  8004201e06:	48 c1 e0 20          	shl    $0x20,%rax
  8004201e0a:	48 89 c1             	mov    %rax,%rcx
  8004201e0d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201e14:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201e17:	89 c0                	mov    %eax,%eax
  8004201e19:	48 01 c8             	add    %rcx,%rax
  8004201e1c:	48 01 c2             	add    %rax,%rdx
  8004201e1f:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201e26:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201e29:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201e2d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201e30:	48 63 c8             	movslq %eax,%rcx
  8004201e33:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e3a:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201e3d:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201e42:	f7 e2                	mul    %edx
  8004201e44:	89 d0                	mov    %edx,%eax
  8004201e46:	c1 e8 04             	shr    $0x4,%eax
  8004201e49:	89 c0                	mov    %eax,%eax
  8004201e4b:	48 39 c1             	cmp    %rax,%rcx
  8004201e4e:	0f 82 fd fe ff ff    	jb     8004201d51 <multiboot_read+0x44f>
  8004201e54:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004201e57:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004201e5b:	5b                   	pop    %rbx
  8004201e5c:	41 5c                	pop    %r12
  8004201e5e:	5d                   	pop    %rbp
  8004201e5f:	c3                   	retq   

0000008004201e60 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004201e60:	55                   	push   %rbp
  8004201e61:	48 89 e5             	mov    %rsp,%rbp
  8004201e64:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004201e68:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004201e6f:	00 
	size_t extmem = 0;
  8004201e70:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004201e77:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004201e78:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004201e7f:	00 00 00 
  8004201e82:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004201e86:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201e8a:	48 8b 00             	mov    (%rax),%rax
  8004201e8d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004201e91:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201e96:	74 2d                	je     8004201ec5 <i386_detect_memory+0x65>
  8004201e98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201e9c:	8b 00                	mov    (%rax),%eax
  8004201e9e:	83 e0 40             	and    $0x40,%eax
  8004201ea1:	85 c0                	test   %eax,%eax
  8004201ea3:	74 20                	je     8004201ec5 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004201ea5:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8004201ea9:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8004201ead:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201eb1:	48 89 ce             	mov    %rcx,%rsi
  8004201eb4:	48 89 c7             	mov    %rax,%rdi
  8004201eb7:	48 b8 02 19 20 04 80 	movabs $0x8004201902,%rax
  8004201ebe:	00 00 00 
  8004201ec1:	ff d0                	callq  *%rax
  8004201ec3:	eb 34                	jmp    8004201ef9 <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004201ec5:	bf 15 00 00 00       	mov    $0x15,%edi
  8004201eca:	48 b8 c3 18 20 04 80 	movabs $0x80042018c3,%rax
  8004201ed1:	00 00 00 
  8004201ed4:	ff d0                	callq  *%rax
  8004201ed6:	c1 e0 0a             	shl    $0xa,%eax
  8004201ed9:	48 98                	cltq   
  8004201edb:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004201edf:	bf 17 00 00 00       	mov    $0x17,%edi
  8004201ee4:	48 b8 c3 18 20 04 80 	movabs $0x80042018c3,%rax
  8004201eeb:	00 00 00 
  8004201eee:	ff d0                	callq  *%rax
  8004201ef0:	c1 e0 0a             	shl    $0xa,%eax
  8004201ef3:	48 98                	cltq   
  8004201ef5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  8004201ef9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201efd:	48 85 c0             	test   %rax,%rax
  8004201f00:	75 35                	jne    8004201f37 <i386_detect_memory+0xd7>
  8004201f02:	48 b9 39 66 21 04 80 	movabs $0x8004216639,%rcx
  8004201f09:	00 00 00 
  8004201f0c:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004201f13:	00 00 00 
  8004201f16:	be 86 00 00 00       	mov    $0x86,%esi
  8004201f1b:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004201f22:	00 00 00 
  8004201f25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f2a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004201f31:	00 00 00 
  8004201f34:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004201f37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f3b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201f3f:	48 89 c2             	mov    %rax,%rdx
  8004201f42:	48 b8 30 e2 6b 04 80 	movabs $0x80046be230,%rax
  8004201f49:	00 00 00 
  8004201f4c:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004201f4f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201f53:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201f57:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004201f5b:	bf 17 00 00 00       	mov    $0x17,%edi
  8004201f60:	48 b8 c3 18 20 04 80 	movabs $0x80042018c3,%rax
  8004201f67:	00 00 00 
  8004201f6a:	ff d0                	callq  *%rax
  8004201f6c:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004201f71:	75 2c                	jne    8004201f9f <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004201f73:	bf 34 00 00 00       	mov    $0x34,%edi
  8004201f78:	48 b8 c3 18 20 04 80 	movabs $0x80042018c3,%rax
  8004201f7f:	00 00 00 
  8004201f82:	ff d0                	callq  *%rax
  8004201f84:	c1 e0 10             	shl    $0x10,%eax
  8004201f87:	48 98                	cltq   
  8004201f89:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004201f8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201f91:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004201f97:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201f9b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004201f9f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201fa4:	74 1a                	je     8004201fc0 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004201fa6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201faa:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004201fb1:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004201fb8:	00 00 00 
  8004201fbb:	48 89 10             	mov    %rdx,(%rax)
  8004201fbe:	eb 1a                	jmp    8004201fda <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004201fc0:	48 b8 30 e2 6b 04 80 	movabs $0x80046be230,%rax
  8004201fc7:	00 00 00 
  8004201fca:	48 8b 10             	mov    (%rax),%rdx
  8004201fcd:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004201fd4:	00 00 00 
  8004201fd7:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201fda:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004201fe1:	00 00 00 
  8004201fe4:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004201fe7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201feb:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201fef:	48 c1 e8 0a          	shr    $0xa,%rax
  8004201ff3:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004201ff6:	48 b8 30 e2 6b 04 80 	movabs $0x80046be230,%rax
  8004201ffd:	00 00 00 
  8004202000:	48 8b 00             	mov    (%rax),%rax
  8004202003:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202007:	48 c1 e8 0a          	shr    $0xa,%rax
  800420200b:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  800420200e:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004202015:	00 00 00 
  8004202018:	48 8b 00             	mov    (%rax),%rax
  800420201b:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420201f:	48 c1 e8 14          	shr    $0x14,%rax
  8004202023:	49 89 f0             	mov    %rsi,%r8
  8004202026:	48 89 c6             	mov    %rax,%rsi
  8004202029:	48 bf 68 66 21 04 80 	movabs $0x8004216668,%rdi
  8004202030:	00 00 00 
  8004202033:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202038:	49 b9 ea 86 20 04 80 	movabs $0x80042086ea,%r9
  800420203f:	00 00 00 
  8004202042:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202045:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420204c:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  800420204d:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202054:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202055:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202059:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  800420205d:	48 c1 e8 14          	shr    $0x14,%rax
  8004202061:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202064:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202068:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  800420206c:	48 c1 e8 14          	shr    $0x14,%rax
  8004202070:	48 89 c6             	mov    %rax,%rsi
  8004202073:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004202077:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420207b:	49 89 c8             	mov    %rcx,%r8
  800420207e:	48 89 d1             	mov    %rdx,%rcx
  8004202081:	48 89 f2             	mov    %rsi,%rdx
  8004202084:	48 89 c6             	mov    %rax,%rsi
  8004202087:	48 bf b8 66 21 04 80 	movabs $0x80042166b8,%rdi
  800420208e:	00 00 00 
  8004202091:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202096:	49 b9 ea 86 20 04 80 	movabs $0x80042086ea,%r9
  800420209d:	00 00 00 
  80042020a0:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  80042020a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042020a7:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  80042020ab:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  80042020b0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  80042020b4:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  80042020bb:	00 00 00 
  80042020be:	48 8b 00             	mov    (%rax),%rax
  80042020c1:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042020c5:	76 3a                	jbe    8004202101 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  80042020c7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020cb:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042020d2:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  80042020d9:	00 00 00 
  80042020dc:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042020df:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020e3:	48 89 c6             	mov    %rax,%rsi
  80042020e6:	48 bf 20 67 21 04 80 	movabs $0x8004216720,%rdi
  80042020ed:	00 00 00 
  80042020f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042020f5:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042020fc:	00 00 00 
  80042020ff:	ff d2                	callq  *%rdx
	}
}
  8004202101:	c9                   	leaveq 
  8004202102:	c3                   	retq   

0000008004202103 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  8004202103:	55                   	push   %rbp
  8004202104:	48 89 e5             	mov    %rsp,%rbp
  8004202107:	48 83 ec 40          	sub    $0x40,%rsp
  800420210b:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  800420210e:	48 b8 48 e2 6b 04 80 	movabs $0x80046be248,%rax
  8004202115:	00 00 00 
  8004202118:	48 8b 00             	mov    (%rax),%rax
  800420211b:	48 85 c0             	test   %rax,%rax
  800420211e:	75 4b                	jne    800420216b <boot_alloc+0x68>
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  8004202120:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004202127:	00 
  8004202128:	48 b8 10 20 74 04 80 	movabs $0x8004742010,%rax
  800420212f:	00 00 00 
  8004202132:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004202136:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420213a:	48 01 d0             	add    %rdx,%rax
  800420213d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202141:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202145:	ba 00 00 00 00       	mov    $0x0,%edx
  800420214a:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420214e:	48 89 d0             	mov    %rdx,%rax
  8004202151:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004202155:	48 29 c2             	sub    %rax,%rdx
  8004202158:	48 89 d0             	mov    %rdx,%rax
  800420215b:	48 89 c2             	mov    %rax,%rdx
  800420215e:	48 b8 48 e2 6b 04 80 	movabs $0x80046be248,%rax
  8004202165:	00 00 00 
  8004202168:	48 89 10             	mov    %rdx,(%rax)
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.

		if((uint64_t)(nextfree + n) > (npages * PGSIZE + KERNBASE)){
  800420216b:	48 b8 48 e2 6b 04 80 	movabs $0x80046be248,%rax
  8004202172:	00 00 00 
  8004202175:	48 8b 10             	mov    (%rax),%rdx
  8004202178:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420217b:	48 01 d0             	add    %rdx,%rax
  800420217e:	48 89 c2             	mov    %rax,%rdx
  8004202181:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004202188:	00 00 00 
  800420218b:	48 8b 00             	mov    (%rax),%rax
  800420218e:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004202194:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202198:	48 39 c2             	cmp    %rax,%rdx
  800420219b:	76 2a                	jbe    80042021c7 <boot_alloc+0xc4>
			panic("out of memory in boot_alloc");
  800420219d:	48 ba 49 67 21 04 80 	movabs $0x8004216749,%rdx
  80042021a4:	00 00 00 
  80042021a7:	be e0 00 00 00       	mov    $0xe0,%esi
  80042021ac:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042021b3:	00 00 00 
  80042021b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042021bb:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042021c2:	00 00 00 
  80042021c5:	ff d1                	callq  *%rcx
		}
		result = nextfree;
  80042021c7:	48 b8 48 e2 6b 04 80 	movabs $0x80046be248,%rax
  80042021ce:	00 00 00 
  80042021d1:	48 8b 00             	mov    (%rax),%rax
  80042021d4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(n != 0)
  80042021d8:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042021dc:	74 57                	je     8004202235 <boot_alloc+0x132>
			nextfree = ROUNDUP(nextfree + n, PGSIZE);
  80042021de:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  80042021e5:	00 
  80042021e6:	48 b8 48 e2 6b 04 80 	movabs $0x80046be248,%rax
  80042021ed:	00 00 00 
  80042021f0:	48 8b 10             	mov    (%rax),%rdx
  80042021f3:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042021f6:	48 01 d0             	add    %rdx,%rax
  80042021f9:	48 89 c2             	mov    %rax,%rdx
  80042021fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202200:	48 01 d0             	add    %rdx,%rax
  8004202203:	48 83 e8 01          	sub    $0x1,%rax
  8004202207:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420220b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420220f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202214:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202218:	48 89 d0             	mov    %rdx,%rax
  800420221b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420221f:	48 29 c2             	sub    %rax,%rdx
  8004202222:	48 89 d0             	mov    %rdx,%rax
  8004202225:	48 89 c2             	mov    %rax,%rdx
  8004202228:	48 b8 48 e2 6b 04 80 	movabs $0x80046be248,%rax
  800420222f:	00 00 00 
  8004202232:	48 89 10             	mov    %rdx,(%rax)
		return result;
  8004202235:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004202239:	c9                   	leaveq 
  800420223a:	c3                   	retq   

000000800420223b <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  800420223b:	55                   	push   %rbp
  800420223c:	48 89 e5             	mov    %rsp,%rbp
  800420223f:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202246:	48 b8 60 1e 20 04 80 	movabs $0x8004201e60,%rax
  800420224d:	00 00 00 
  8004202250:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  8004202252:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202257:	48 b8 03 21 20 04 80 	movabs $0x8004202103,%rax
  800420225e:	00 00 00 
  8004202261:	ff d0                	callq  *%rax
  8004202263:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202267:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420226b:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202270:	be 00 00 00 00       	mov    $0x0,%esi
  8004202275:	48 89 c7             	mov    %rax,%rdi
  8004202278:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  800420227f:	00 00 00 
  8004202282:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004202284:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  800420228b:	00 00 00 
  800420228e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202292:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  8004202295:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202299:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420229d:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042022a4:	00 00 00 
  80042022a7:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80042022ab:	77 32                	ja     80042022df <x64_vm_init+0xa4>
  80042022ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042022b1:	48 89 c1             	mov    %rax,%rcx
  80042022b4:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042022bb:	00 00 00 
  80042022be:	be 01 01 00 00       	mov    $0x101,%esi
  80042022c3:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042022ca:	00 00 00 
  80042022cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042022d2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042022d9:	00 00 00 
  80042022dc:	41 ff d0             	callq  *%r8
  80042022df:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042022e6:	ff ff ff 
  80042022e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042022ed:	48 01 c2             	add    %rax,%rdx
  80042022f0:	48 b8 20 f7 6b 04 80 	movabs $0x80046bf720,%rax
  80042022f7:	00 00 00 
  80042022fa:	48 89 10             	mov    %rdx,(%rax)
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:

		n = ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE);
  80042022fd:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004202304:	00 
  8004202305:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  800420230c:	00 00 00 
  800420230f:	48 8b 00             	mov    (%rax),%rax
  8004202312:	48 c1 e0 04          	shl    $0x4,%rax
  8004202316:	48 89 c2             	mov    %rax,%rdx
  8004202319:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420231d:	48 01 d0             	add    %rdx,%rax
  8004202320:	48 83 e8 01          	sub    $0x1,%rax
  8004202324:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202328:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420232c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202331:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004202335:	48 89 d0             	mov    %rdx,%rax
  8004202338:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420233c:	48 29 c2             	sub    %rax,%rdx
  800420233f:	48 89 d0             	mov    %rdx,%rax
  8004202342:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		pages = boot_alloc(n);
  8004202346:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420234a:	89 c7                	mov    %eax,%edi
  800420234c:	48 b8 03 21 20 04 80 	movabs $0x8004202103,%rax
  8004202353:	00 00 00 
  8004202356:	ff d0                	callq  *%rax
  8004202358:	48 ba 38 f7 6b 04 80 	movabs $0x80046bf738,%rdx
  800420235f:	00 00 00 
  8004202362:	48 89 02             	mov    %rax,(%rdx)
		memset(pages, 0, n);
  8004202365:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  800420236c:	00 00 00 
  800420236f:	48 8b 00             	mov    (%rax),%rax
  8004202372:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004202376:	be 00 00 00 00       	mov    $0x0,%esi
  800420237b:	48 89 c7             	mov    %rax,%rdi
  800420237e:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004202385:	00 00 00 
  8004202388:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	uint32_t env_size = sizeof(struct Env) * NENV;
  800420238a:	c7 45 d4 00 80 04 00 	movl   $0x48000,-0x2c(%rbp)
	envs = boot_alloc(env_size);
  8004202391:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004202394:	89 c7                	mov    %eax,%edi
  8004202396:	48 b8 03 21 20 04 80 	movabs $0x8004202103,%rax
  800420239d:	00 00 00 
  80042023a0:	ff d0                	callq  *%rax
  80042023a2:	48 ba 50 e2 6b 04 80 	movabs $0x80046be250,%rdx
  80042023a9:	00 00 00 
  80042023ac:	48 89 02             	mov    %rax,(%rdx)
	env = envs;
  80042023af:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  80042023b6:	00 00 00 
  80042023b9:	48 8b 00             	mov    (%rax),%rax
  80042023bc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  80042023c0:	48 b8 b7 28 20 04 80 	movabs $0x80042028b7,%rax
  80042023c7:	00 00 00 
  80042023ca:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
	n = npages*sizeof(struct PageInfo);
  80042023cc:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  80042023d3:	00 00 00 
  80042023d6:	48 8b 00             	mov    (%rax),%rax
  80042023d9:	48 c1 e0 04          	shl    $0x4,%rax
  80042023dd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	boot_map_region(boot_pml4e, UPAGES, n, PADDR(pages), PTE_U);
  80042023e1:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  80042023e8:	00 00 00 
  80042023eb:	48 8b 00             	mov    (%rax),%rax
  80042023ee:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042023f2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042023f9:	00 00 00 
  80042023fc:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202400:	77 32                	ja     8004202434 <x64_vm_init+0x1f9>
  8004202402:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202406:	48 89 c1             	mov    %rax,%rcx
  8004202409:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004202410:	00 00 00 
  8004202413:	be 26 01 00 00       	mov    $0x126,%esi
  8004202418:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420241f:	00 00 00 
  8004202422:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202427:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420242e:	00 00 00 
  8004202431:	41 ff d0             	callq  *%r8
  8004202434:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420243b:	ff ff ff 
  800420243e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202442:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202446:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  800420244d:	00 00 00 
  8004202450:	48 8b 00             	mov    (%rax),%rax
  8004202453:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004202457:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  800420245d:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202464:	00 00 00 
  8004202467:	48 89 c7             	mov    %rax,%rdi
  800420246a:	48 b8 f6 2f 20 04 80 	movabs $0x8004202ff6,%rax
  8004202471:	00 00 00 
  8004202474:	ff d0                	callq  *%rax

	boot_map_region(pml4e, (uintptr_t) pages, PGSIZE, PADDR(pages), PTE_W);
  8004202476:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  800420247d:	00 00 00 
  8004202480:	48 8b 00             	mov    (%rax),%rax
  8004202483:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202487:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420248e:	00 00 00 
  8004202491:	48 39 45 b8          	cmp    %rax,-0x48(%rbp)
  8004202495:	77 32                	ja     80042024c9 <x64_vm_init+0x28e>
  8004202497:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420249b:	48 89 c1             	mov    %rax,%rcx
  800420249e:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042024a5:	00 00 00 
  80042024a8:	be 28 01 00 00       	mov    $0x128,%esi
  80042024ad:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042024b4:	00 00 00 
  80042024b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042024bc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042024c3:	00 00 00 
  80042024c6:	41 ff d0             	callq  *%r8
  80042024c9:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042024d0:	ff ff ff 
  80042024d3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042024d7:	48 01 c2             	add    %rax,%rdx
  80042024da:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  80042024e1:	00 00 00 
  80042024e4:	48 8b 00             	mov    (%rax),%rax
  80042024e7:	48 89 c6             	mov    %rax,%rsi
  80042024ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042024ee:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  80042024f4:	48 89 d1             	mov    %rdx,%rcx
  80042024f7:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042024fc:	48 89 c7             	mov    %rax,%rdi
  80042024ff:	48 b8 f6 2f 20 04 80 	movabs $0x8004202ff6,%rax
  8004202506:	00 00 00 
  8004202509:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(boot_pml4e, UENVS, env_size, PADDR(env), PTE_U);
  800420250b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420250f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004202513:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420251a:	00 00 00 
  800420251d:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  8004202521:	77 32                	ja     8004202555 <x64_vm_init+0x31a>
  8004202523:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202527:	48 89 c1             	mov    %rax,%rcx
  800420252a:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004202531:	00 00 00 
  8004202534:	be 31 01 00 00       	mov    $0x131,%esi
  8004202539:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004202540:	00 00 00 
  8004202543:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202548:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420254f:	00 00 00 
  8004202552:	41 ff d0             	callq  *%r8
  8004202555:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420255c:	ff ff ff 
  800420255f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202563:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202567:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420256a:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004202571:	00 00 00 
  8004202574:	48 8b 00             	mov    (%rax),%rax
  8004202577:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  800420257d:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202584:	00 00 00 
  8004202587:	48 89 c7             	mov    %rax,%rdi
  800420258a:	48 b8 f6 2f 20 04 80 	movabs $0x8004202ff6,%rax
  8004202591:	00 00 00 
  8004202594:	ff d0                	callq  *%rax
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(pml4e, KSTACKTOP-KSTKSIZE, 16*PGSIZE, PADDR(bootstack), PTE_W);
  8004202596:	48 b8 00 b0 21 04 80 	movabs $0x800421b000,%rax
  800420259d:	00 00 00 
  80042025a0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042025a4:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042025ab:	00 00 00 
  80042025ae:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  80042025b2:	77 32                	ja     80042025e6 <x64_vm_init+0x3ab>
  80042025b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042025b8:	48 89 c1             	mov    %rax,%rcx
  80042025bb:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042025c2:	00 00 00 
  80042025c5:	be 3f 01 00 00       	mov    $0x13f,%esi
  80042025ca:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042025d1:	00 00 00 
  80042025d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025d9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042025e0:	00 00 00 
  80042025e3:	41 ff d0             	callq  *%r8
  80042025e6:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042025ed:	ff ff ff 
  80042025f0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042025f4:	48 01 c2             	add    %rax,%rdx
  80042025f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042025fb:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  8004202601:	48 89 d1             	mov    %rdx,%rcx
  8004202604:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202609:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  8004202610:	00 00 00 
  8004202613:	48 89 c7             	mov    %rax,%rdi
  8004202616:	48 b8 f6 2f 20 04 80 	movabs $0x8004202ff6,%rax
  800420261d:	00 00 00 
  8004202620:	ff d0                	callq  *%rax
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(pml4e, KERNBASE, npages * PGSIZE, (physaddr_t)0x0, PTE_W);;
  8004202622:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004202629:	00 00 00 
  800420262c:	48 8b 00             	mov    (%rax),%rax
  800420262f:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202633:	48 89 c2             	mov    %rax,%rdx
  8004202636:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420263a:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  8004202640:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202645:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  800420264c:	00 00 00 
  800420264f:	48 89 c7             	mov    %rax,%rdi
  8004202652:	48 b8 f6 2f 20 04 80 	movabs $0x8004202ff6,%rax
  8004202659:	00 00 00 
  800420265c:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  800420265e:	48 b8 d7 27 20 04 80 	movabs $0x80042027d7,%rax
  8004202665:	00 00 00 
  8004202668:	ff d0                	callq  *%rax

	check_page_free_list(1);
  800420266a:	bf 01 00 00 00       	mov    $0x1,%edi
  800420266f:	48 b8 07 36 20 04 80 	movabs $0x8004203607,%rax
  8004202676:	00 00 00 
  8004202679:	ff d0                	callq  *%rax
	check_page_alloc();
  800420267b:	48 b8 34 3b 20 04 80 	movabs $0x8004203b34,%rax
  8004202682:	00 00 00 
  8004202685:	ff d0                	callq  *%rax
	page_check();
  8004202687:	48 b8 e8 4e 20 04 80 	movabs $0x8004204ee8,%rax
  800420268e:	00 00 00 
  8004202691:	ff d0                	callq  *%rax
	check_page_free_list(0);
  8004202693:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202698:	48 b8 07 36 20 04 80 	movabs $0x8004203607,%rax
  800420269f:	00 00 00 
  80042026a2:	ff d0                	callq  *%rax
	check_boot_pml4e(boot_pml4e);
  80042026a4:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042026ab:	00 00 00 
  80042026ae:	48 8b 00             	mov    (%rax),%rax
  80042026b1:	48 89 c7             	mov    %rax,%rdi
  80042026b4:	48 b8 20 45 20 04 80 	movabs $0x8004204520,%rax
  80042026bb:	00 00 00 
  80042026be:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  80042026c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042026c4:	48 83 c0 08          	add    $0x8,%rax
  80042026c8:	48 8b 00             	mov    (%rax),%rax
  80042026cb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042026d1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042026d5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042026d9:	48 c1 e8 0c          	shr    $0xc,%rax
  80042026dd:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042026e0:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042026e3:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  80042026ea:	00 00 00 
  80042026ed:	48 8b 00             	mov    (%rax),%rax
  80042026f0:	48 39 c2             	cmp    %rax,%rdx
  80042026f3:	72 32                	jb     8004202727 <x64_vm_init+0x4ec>
  80042026f5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042026f9:	48 89 c1             	mov    %rax,%rcx
  80042026fc:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004202703:	00 00 00 
  8004202706:	be 57 01 00 00       	mov    $0x157,%esi
  800420270b:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004202712:	00 00 00 
  8004202715:	b8 00 00 00 00       	mov    $0x0,%eax
  800420271a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202721:	00 00 00 
  8004202724:	41 ff d0             	callq  *%r8
  8004202727:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420272e:	00 00 00 
  8004202731:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202735:	48 01 d0             	add    %rdx,%rax
  8004202738:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  800420273c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202740:	48 8b 00             	mov    (%rax),%rax
  8004202743:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202749:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800420274d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202751:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202755:	89 45 84             	mov    %eax,-0x7c(%rbp)
  8004202758:	8b 55 84             	mov    -0x7c(%rbp),%edx
  800420275b:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004202762:	00 00 00 
  8004202765:	48 8b 00             	mov    (%rax),%rax
  8004202768:	48 39 c2             	cmp    %rax,%rdx
  800420276b:	72 32                	jb     800420279f <x64_vm_init+0x564>
  800420276d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202771:	48 89 c1             	mov    %rax,%rcx
  8004202774:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  800420277b:	00 00 00 
  800420277e:	be 58 01 00 00       	mov    $0x158,%esi
  8004202783:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420278a:	00 00 00 
  800420278d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202792:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202799:	00 00 00 
  800420279c:	41 ff d0             	callq  *%r8
  800420279f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042027a6:	00 00 00 
  80042027a9:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042027ad:	48 01 d0             	add    %rdx,%rax
  80042027b0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	lcr3(boot_cr3);
  80042027b7:	48 b8 20 f7 6b 04 80 	movabs $0x80046bf720,%rax
  80042027be:	00 00 00 
  80042027c1:	48 8b 00             	mov    (%rax),%rax
  80042027c4:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  80042027cb:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042027d2:	0f 22 d8             	mov    %rax,%cr3
}
  80042027d5:	c9                   	leaveq 
  80042027d6:	c3                   	retq   

00000080042027d7 <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  80042027d7:	55                   	push   %rbp
  80042027d8:	48 89 e5             	mov    %rsp,%rbp
  80042027db:	48 83 ec 20          	sub    $0x20,%rsp
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int cpu_num;
	uintptr_t top = KSTACKTOP;
  80042027df:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042027e6:	00 00 00 
  80042027e9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (cpu_num = 0; cpu_num < NCPU; ++cpu_num)
  80042027ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042027f4:	e9 b2 00 00 00       	jmpq   80042028ab <mem_init_mp+0xd4>
	{
		top -= KSTKSIZE;
  80042027f9:	48 81 6d f0 00 00 01 	subq   $0x10000,-0x10(%rbp)
  8004202800:	00 
		boot_map_region(boot_pml4e, top, KSTKSIZE, PADDR(percpu_kstacks[cpu_num]), PTE_W);
  8004202801:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202804:	48 98                	cltq   
  8004202806:	48 c1 e0 10          	shl    $0x10,%rax
  800420280a:	48 89 c2             	mov    %rax,%rdx
  800420280d:	48 b8 00 20 6c 04 80 	movabs $0x80046c2000,%rax
  8004202814:	00 00 00 
  8004202817:	48 01 d0             	add    %rdx,%rax
  800420281a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420281e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202825:	00 00 00 
  8004202828:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420282c:	77 32                	ja     8004202860 <mem_init_mp+0x89>
  800420282e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202832:	48 89 c1             	mov    %rax,%rcx
  8004202835:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  800420283c:	00 00 00 
  800420283f:	be 78 01 00 00       	mov    $0x178,%esi
  8004202844:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420284b:	00 00 00 
  800420284e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202853:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420285a:	00 00 00 
  800420285d:	41 ff d0             	callq  *%r8
  8004202860:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202867:	ff ff ff 
  800420286a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420286e:	48 01 c2             	add    %rax,%rdx
  8004202871:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004202878:	00 00 00 
  800420287b:	48 8b 00             	mov    (%rax),%rax
  800420287e:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004202882:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  8004202888:	48 89 d1             	mov    %rdx,%rcx
  800420288b:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202890:	48 89 c7             	mov    %rax,%rdi
  8004202893:	48 b8 f6 2f 20 04 80 	movabs $0x8004202ff6,%rax
  800420289a:	00 00 00 
  800420289d:	ff d0                	callq  *%rax
		top -= KSTKGAP;
  800420289f:	48 81 6d f0 00 80 00 	subq   $0x8000,-0x10(%rbp)
  80042028a6:	00 
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int cpu_num;
	uintptr_t top = KSTACKTOP;
	for (cpu_num = 0; cpu_num < NCPU; ++cpu_num)
  80042028a7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042028ab:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  80042028af:	0f 8e 44 ff ff ff    	jle    80042027f9 <mem_init_mp+0x22>
		top -= KSTKSIZE;
		boot_map_region(boot_pml4e, top, KSTKSIZE, PADDR(percpu_kstacks[cpu_num]), PTE_W);
		top -= KSTKGAP;
	}

}
  80042028b5:	c9                   	leaveq 
  80042028b6:	c3                   	retq   

00000080042028b7 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  80042028b7:	55                   	push   %rbp
  80042028b8:	48 89 e5             	mov    %rsp,%rbp
  80042028bb:	48 83 ec 10          	sub    $0x10,%rsp
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	// page_free_list = NULL;

	int num_alloc = ((uint64_t)boot_alloc(0) - KERNBASE) / PGSIZE;
  80042028bf:	bf 00 00 00 00       	mov    $0x0,%edi
  80042028c4:	48 b8 03 21 20 04 80 	movabs $0x8004202103,%rax
  80042028cb:	00 00 00 
  80042028ce:	ff d0                	callq  *%rax
  80042028d0:	48 89 c2             	mov    %rax,%rdx
  80042028d3:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042028da:	ff ff ff 
  80042028dd:	48 01 d0             	add    %rdx,%rax
  80042028e0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042028e4:	89 45 f4             	mov    %eax,-0xc(%rbp)
	int num_iohole = 96;
  80042028e7:	c7 45 f0 60 00 00 00 	movl   $0x60,-0x10(%rbp)

	// pages[0].pp_ref = 1;
	for(i = 1; i < MPENTRY_PADDR/PGSIZE; i++)
  80042028ee:	48 c7 45 f8 01 00 00 	movq   $0x1,-0x8(%rbp)
  80042028f5:	00 
  80042028f6:	eb 70                	jmp    8004202968 <page_init+0xb1>
	{
	  pages[i].pp_ref = 0;
  80042028f8:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  80042028ff:	00 00 00 
  8004202902:	48 8b 00             	mov    (%rax),%rax
  8004202905:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202909:	48 c1 e2 04          	shl    $0x4,%rdx
  800420290d:	48 01 d0             	add    %rdx,%rax
  8004202910:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
	  pages[i].pp_link = page_free_list;
  8004202916:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  800420291d:	00 00 00 
  8004202920:	48 8b 00             	mov    (%rax),%rax
  8004202923:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202927:	48 c1 e2 04          	shl    $0x4,%rdx
  800420292b:	48 01 c2             	add    %rax,%rdx
  800420292e:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004202935:	00 00 00 
  8004202938:	48 8b 00             	mov    (%rax),%rax
  800420293b:	48 89 02             	mov    %rax,(%rdx)
	  page_free_list = &pages[i];
  800420293e:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  8004202945:	00 00 00 
  8004202948:	48 8b 00             	mov    (%rax),%rax
  800420294b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420294f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202953:	48 01 c2             	add    %rax,%rdx
  8004202956:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  800420295d:	00 00 00 
  8004202960:	48 89 10             	mov    %rdx,(%rax)

	int num_alloc = ((uint64_t)boot_alloc(0) - KERNBASE) / PGSIZE;
	int num_iohole = 96;

	// pages[0].pp_ref = 1;
	for(i = 1; i < MPENTRY_PADDR/PGSIZE; i++)
  8004202963:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202968:	48 83 7d f8 06       	cmpq   $0x6,-0x8(%rbp)
  800420296d:	76 89                	jbe    80042028f8 <page_init+0x41>
	  pages[i].pp_ref = 0;
	  pages[i].pp_link = page_free_list;
	  page_free_list = &pages[i];
	}

	for(i = npages_basemem; i < npages_basemem + num_iohole + num_alloc; i++)
  800420296f:	48 b8 30 e2 6b 04 80 	movabs $0x80046be230,%rax
  8004202976:	00 00 00 
  8004202979:	48 8b 00             	mov    (%rax),%rax
  800420297c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004202980:	eb 23                	jmp    80042029a5 <page_init+0xee>
	  pages[i].pp_ref = 1;
  8004202982:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  8004202989:	00 00 00 
  800420298c:	48 8b 00             	mov    (%rax),%rax
  800420298f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202993:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202997:	48 01 d0             	add    %rdx,%rax
  800420299a:	66 c7 40 08 01 00    	movw   $0x1,0x8(%rax)
	  pages[i].pp_ref = 0;
	  pages[i].pp_link = page_free_list;
	  page_free_list = &pages[i];
	}

	for(i = npages_basemem; i < npages_basemem + num_iohole + num_alloc; i++)
  80042029a0:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042029a5:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80042029a8:	48 63 d0             	movslq %eax,%rdx
  80042029ab:	48 b8 30 e2 6b 04 80 	movabs $0x80046be230,%rax
  80042029b2:	00 00 00 
  80042029b5:	48 8b 00             	mov    (%rax),%rax
  80042029b8:	48 01 c2             	add    %rax,%rdx
  80042029bb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042029be:	48 98                	cltq   
  80042029c0:	48 01 d0             	add    %rdx,%rax
  80042029c3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042029c7:	77 b9                	ja     8004202982 <page_init+0xcb>
	  pages[i].pp_ref = 1;
	for(; i < npages; i++)
  80042029c9:	eb 70                	jmp    8004202a3b <page_init+0x184>
	{
	  pages[i].pp_ref = 0;
  80042029cb:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  80042029d2:	00 00 00 
  80042029d5:	48 8b 00             	mov    (%rax),%rax
  80042029d8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042029dc:	48 c1 e2 04          	shl    $0x4,%rdx
  80042029e0:	48 01 d0             	add    %rdx,%rax
  80042029e3:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
	  pages[i].pp_link = page_free_list;
  80042029e9:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  80042029f0:	00 00 00 
  80042029f3:	48 8b 00             	mov    (%rax),%rax
  80042029f6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042029fa:	48 c1 e2 04          	shl    $0x4,%rdx
  80042029fe:	48 01 c2             	add    %rax,%rdx
  8004202a01:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004202a08:	00 00 00 
  8004202a0b:	48 8b 00             	mov    (%rax),%rax
  8004202a0e:	48 89 02             	mov    %rax,(%rdx)
	  page_free_list = &pages[i];
  8004202a11:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  8004202a18:	00 00 00 
  8004202a1b:	48 8b 00             	mov    (%rax),%rax
  8004202a1e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202a22:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a26:	48 01 c2             	add    %rax,%rdx
  8004202a29:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004202a30:	00 00 00 
  8004202a33:	48 89 10             	mov    %rdx,(%rax)
	  page_free_list = &pages[i];
	}

	for(i = npages_basemem; i < npages_basemem + num_iohole + num_alloc; i++)
	  pages[i].pp_ref = 1;
	for(; i < npages; i++)
  8004202a36:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202a3b:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004202a42:	00 00 00 
  8004202a45:	48 8b 00             	mov    (%rax),%rax
  8004202a48:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202a4c:	0f 82 79 ff ff ff    	jb     80042029cb <page_init+0x114>
	{
	  pages[i].pp_ref = 0;
	  pages[i].pp_link = page_free_list;
	  page_free_list = &pages[i];
	}
}
  8004202a52:	c9                   	leaveq 
  8004202a53:	c3                   	retq   

0000008004202a54 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202a54:	55                   	push   %rbp
  8004202a55:	48 89 e5             	mov    %rsp,%rbp
  8004202a58:	48 83 ec 20          	sub    $0x20,%rsp
  8004202a5c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	if (!page_free_list)
  8004202a5f:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004202a66:	00 00 00 
  8004202a69:	48 8b 00             	mov    (%rax),%rax
  8004202a6c:	48 85 c0             	test   %rax,%rax
  8004202a6f:	75 07                	jne    8004202a78 <page_alloc+0x24>
	 		return NULL;
  8004202a71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a76:	eb 6a                	jmp    8004202ae2 <page_alloc+0x8e>

	 	struct PageInfo *page = page_free_list;
  8004202a78:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004202a7f:	00 00 00 
  8004202a82:	48 8b 00             	mov    (%rax),%rax
  8004202a85:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	 	page_free_list = page->pp_link;
  8004202a89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202a8d:	48 8b 10             	mov    (%rax),%rdx
  8004202a90:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004202a97:	00 00 00 
  8004202a9a:	48 89 10             	mov    %rdx,(%rax)

	 	if (alloc_flags & ALLOC_ZERO)
  8004202a9d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202aa0:	83 e0 01             	and    $0x1,%eax
  8004202aa3:	85 c0                	test   %eax,%eax
  8004202aa5:	74 2c                	je     8004202ad3 <page_alloc+0x7f>
			memset(page2kva(page), '\0', PGSIZE);
  8004202aa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202aab:	48 89 c7             	mov    %rax,%rdi
  8004202aae:	48 b8 da 17 20 04 80 	movabs $0x80042017da,%rax
  8004202ab5:	00 00 00 
  8004202ab8:	ff d0                	callq  *%rax
  8004202aba:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202abf:	be 00 00 00 00       	mov    $0x0,%esi
  8004202ac4:	48 89 c7             	mov    %rax,%rdi
  8004202ac7:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004202ace:	00 00 00 
  8004202ad1:	ff d0                	callq  *%rax

		page->pp_link = NULL;
  8004202ad3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ad7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

		return page;
  8004202ade:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004202ae2:	c9                   	leaveq 
  8004202ae3:	c3                   	retq   

0000008004202ae4 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202ae4:	55                   	push   %rbp
  8004202ae5:	48 89 e5             	mov    %rsp,%rbp
  8004202ae8:	48 83 ec 10          	sub    $0x10,%rsp
  8004202aec:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202af0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202af4:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202af9:	be 00 00 00 00       	mov    $0x0,%esi
  8004202afe:	48 89 c7             	mov    %rax,%rdi
  8004202b01:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004202b08:	00 00 00 
  8004202b0b:	ff d0                	callq  *%rax
}
  8004202b0d:	c9                   	leaveq 
  8004202b0e:	c3                   	retq   

0000008004202b0f <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004202b0f:	55                   	push   %rbp
  8004202b10:	48 89 e5             	mov    %rsp,%rbp
  8004202b13:	48 83 ec 10          	sub    $0x10,%rsp
  8004202b17:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref != 0 || pp->pp_link)
  8004202b1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b1f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202b23:	66 85 c0             	test   %ax,%ax
  8004202b26:	75 0c                	jne    8004202b34 <page_free+0x25>
  8004202b28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b2c:	48 8b 00             	mov    (%rax),%rax
  8004202b2f:	48 85 c0             	test   %rax,%rax
  8004202b32:	74 2a                	je     8004202b5e <page_free+0x4f>
		panic("'the page could not be free");
  8004202b34:	48 ba 8c 67 21 04 80 	movabs $0x800421678c,%rdx
  8004202b3b:	00 00 00 
  8004202b3e:	be f0 01 00 00       	mov    $0x1f0,%esi
  8004202b43:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004202b4a:	00 00 00 
  8004202b4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b52:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004202b59:	00 00 00 
  8004202b5c:	ff d1                	callq  *%rcx

	pp->pp_link = page_free_list;
  8004202b5e:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004202b65:	00 00 00 
  8004202b68:	48 8b 10             	mov    (%rax),%rdx
  8004202b6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b6f:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  8004202b72:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004202b79:	00 00 00 
  8004202b7c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202b80:	48 89 10             	mov    %rdx,(%rax)
}
  8004202b83:	c9                   	leaveq 
  8004202b84:	c3                   	retq   

0000008004202b85 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004202b85:	55                   	push   %rbp
  8004202b86:	48 89 e5             	mov    %rsp,%rbp
  8004202b89:	48 83 ec 10          	sub    $0x10,%rsp
  8004202b8d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004202b91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b95:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202b99:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202b9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ba0:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004202ba4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ba8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202bac:	66 85 c0             	test   %ax,%ax
  8004202baf:	75 13                	jne    8004202bc4 <page_decref+0x3f>
		page_free(pp);
  8004202bb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bb5:	48 89 c7             	mov    %rax,%rdi
  8004202bb8:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  8004202bbf:	00 00 00 
  8004202bc2:	ff d0                	callq  *%rax
}
  8004202bc4:	c9                   	leaveq 
  8004202bc5:	c3                   	retq   

0000008004202bc6 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004202bc6:	55                   	push   %rbp
  8004202bc7:	48 89 e5             	mov    %rsp,%rbp
  8004202bca:	48 83 ec 50          	sub    $0x50,%rsp
  8004202bce:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202bd2:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202bd6:	89 55 bc             	mov    %edx,-0x44(%rbp)
	pdpe_t *pdpe;
 	struct PageInfo *page = NULL;
  8004202bd9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202be0:	00 
 	pml4e_t *current_pml4e = &pml4e[PML4(va)];
  8004202be1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202be5:	48 c1 e8 27          	shr    $0x27,%rax
  8004202be9:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202bee:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202bf5:	00 
  8004202bf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202bfa:	48 01 d0             	add    %rdx,%rax
  8004202bfd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

 	if(create && !(*current_pml4e & PTE_P)) {
  8004202c01:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004202c05:	74 69                	je     8004202c70 <pml4e_walk+0xaa>
  8004202c07:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c0b:	48 8b 00             	mov    (%rax),%rax
  8004202c0e:	83 e0 01             	and    $0x1,%eax
  8004202c11:	48 85 c0             	test   %rax,%rax
  8004202c14:	75 5a                	jne    8004202c70 <pml4e_walk+0xaa>
 		page = page_alloc(ALLOC_ZERO);
  8004202c16:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202c1b:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004202c22:	00 00 00 
  8004202c25:	ff d0                	callq  *%rax
  8004202c27:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 		if (!page)
  8004202c2b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202c30:	75 0a                	jne    8004202c3c <pml4e_walk+0x76>
			return NULL;
  8004202c32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c37:	e9 fd 00 00 00       	jmpq   8004202d39 <pml4e_walk+0x173>

		page->pp_ref++;
  8004202c3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c40:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202c44:	8d 50 01             	lea    0x1(%rax),%edx
  8004202c47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c4b:	66 89 50 08          	mov    %dx,0x8(%rax)


		*current_pml4e = (pml4e_t) page2pa(page)| PTE_P | PTE_W | PTE_U;
  8004202c4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c53:	48 89 c7             	mov    %rax,%rdi
  8004202c56:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004202c5d:	00 00 00 
  8004202c60:	ff d0                	callq  *%rax
  8004202c62:	48 83 c8 07          	or     $0x7,%rax
  8004202c66:	48 89 c2             	mov    %rax,%rdx
  8004202c69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c6d:	48 89 10             	mov    %rdx,(%rax)
	}

	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*current_pml4e));
  8004202c70:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c74:	48 8b 00             	mov    (%rax),%rax
  8004202c77:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202c7d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202c81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c85:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202c89:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004202c8c:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004202c8f:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004202c96:	00 00 00 
  8004202c99:	48 8b 00             	mov    (%rax),%rax
  8004202c9c:	48 39 c2             	cmp    %rax,%rdx
  8004202c9f:	72 32                	jb     8004202cd3 <pml4e_walk+0x10d>
  8004202ca1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202ca5:	48 89 c1             	mov    %rax,%rcx
  8004202ca8:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004202caf:	00 00 00 
  8004202cb2:	be 2c 02 00 00       	mov    $0x22c,%esi
  8004202cb7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004202cbe:	00 00 00 
  8004202cc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202cc6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202ccd:	00 00 00 
  8004202cd0:	41 ff d0             	callq  *%r8
  8004202cd3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202cda:	00 00 00 
  8004202cdd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202ce1:	48 01 d0             	add    %rdx,%rax
  8004202ce4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	pte_t *pte = pdpe_walk(pdpe, va, create);
  8004202ce8:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202ceb:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202cef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202cf3:	48 89 ce             	mov    %rcx,%rsi
  8004202cf6:	48 89 c7             	mov    %rax,%rdi
  8004202cf9:	48 b8 3b 2d 20 04 80 	movabs $0x8004202d3b,%rax
  8004202d00:	00 00 00 
  8004202d03:	ff d0                	callq  *%rax
  8004202d05:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	if (!pte && page) {
  8004202d09:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004202d0e:	75 25                	jne    8004202d35 <pml4e_walk+0x16f>
  8004202d10:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202d15:	74 1e                	je     8004202d35 <pml4e_walk+0x16f>
		*current_pml4e = 0x0;
  8004202d17:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202d1b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(page);
  8004202d22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d26:	48 89 c7             	mov    %rax,%rdi
  8004202d29:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004202d30:	00 00 00 
  8004202d33:	ff d0                	callq  *%rax
	}

	return pte;
  8004202d35:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8004202d39:	c9                   	leaveq 
  8004202d3a:	c3                   	retq   

0000008004202d3b <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  8004202d3b:	55                   	push   %rbp
  8004202d3c:	48 89 e5             	mov    %rsp,%rbp
  8004202d3f:	48 83 ec 50          	sub    $0x50,%rsp
  8004202d43:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202d47:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202d4b:	89 55 bc             	mov    %edx,-0x44(%rbp)
	pde_t *pde;
		struct PageInfo *page = NULL;
  8004202d4e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202d55:	00 
		pdpe_t *current_pdpe = &pdpe[PDPE(va)];
  8004202d56:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202d5a:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202d5e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202d63:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202d6a:	00 
  8004202d6b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d6f:	48 01 d0             	add    %rdx,%rax
  8004202d72:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		if(create && !(*current_pdpe & PTE_P)) {
  8004202d76:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004202d7a:	74 69                	je     8004202de5 <pdpe_walk+0xaa>
  8004202d7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202d80:	48 8b 00             	mov    (%rax),%rax
  8004202d83:	83 e0 01             	and    $0x1,%eax
  8004202d86:	48 85 c0             	test   %rax,%rax
  8004202d89:	75 5a                	jne    8004202de5 <pdpe_walk+0xaa>
			page = page_alloc(ALLOC_ZERO);
  8004202d8b:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202d90:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004202d97:	00 00 00 
  8004202d9a:	ff d0                	callq  *%rax
  8004202d9c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			if (!page)
  8004202da0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202da5:	75 0a                	jne    8004202db1 <pdpe_walk+0x76>
				return NULL;
  8004202da7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dac:	e9 fd 00 00 00       	jmpq   8004202eae <pdpe_walk+0x173>
			page->pp_ref++;
  8004202db1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202db5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202db9:	8d 50 01             	lea    0x1(%rax),%edx
  8004202dbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202dc0:	66 89 50 08          	mov    %dx,0x8(%rax)
			*current_pdpe = (pdpe_t) page2pa(page) | PTE_P | PTE_W | PTE_U;
  8004202dc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202dc8:	48 89 c7             	mov    %rax,%rdi
  8004202dcb:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004202dd2:	00 00 00 
  8004202dd5:	ff d0                	callq  *%rax
  8004202dd7:	48 83 c8 07          	or     $0x7,%rax
  8004202ddb:	48 89 c2             	mov    %rax,%rdx
  8004202dde:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202de2:	48 89 10             	mov    %rdx,(%rax)
		}

		pde = (pde_t *) KADDR(PTE_ADDR(*current_pdpe));
  8004202de5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202de9:	48 8b 00             	mov    (%rax),%rax
  8004202dec:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202df2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202df6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202dfa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202dfe:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004202e01:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004202e04:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004202e0b:	00 00 00 
  8004202e0e:	48 8b 00             	mov    (%rax),%rax
  8004202e11:	48 39 c2             	cmp    %rax,%rdx
  8004202e14:	72 32                	jb     8004202e48 <pdpe_walk+0x10d>
  8004202e16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e1a:	48 89 c1             	mov    %rax,%rcx
  8004202e1d:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004202e24:	00 00 00 
  8004202e27:	be 4b 02 00 00       	mov    $0x24b,%esi
  8004202e2c:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004202e33:	00 00 00 
  8004202e36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e3b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202e42:	00 00 00 
  8004202e45:	41 ff d0             	callq  *%r8
  8004202e48:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202e4f:	00 00 00 
  8004202e52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e56:	48 01 d0             	add    %rdx,%rax
  8004202e59:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		pte_t *pte = pgdir_walk(pde, va, create);
  8004202e5d:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202e60:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202e64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202e68:	48 89 ce             	mov    %rcx,%rsi
  8004202e6b:	48 89 c7             	mov    %rax,%rdi
  8004202e6e:	48 b8 b0 2e 20 04 80 	movabs $0x8004202eb0,%rax
  8004202e75:	00 00 00 
  8004202e78:	ff d0                	callq  *%rax
  8004202e7a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

		if (!pte && page) {
  8004202e7e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004202e83:	75 25                	jne    8004202eaa <pdpe_walk+0x16f>
  8004202e85:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202e8a:	74 1e                	je     8004202eaa <pdpe_walk+0x16f>
			*current_pdpe = 0x0;
  8004202e8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e90:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(page);
  8004202e97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e9b:	48 89 c7             	mov    %rax,%rdi
  8004202e9e:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004202ea5:	00 00 00 
  8004202ea8:	ff d0                	callq  *%rax
		}

		return pte;
  8004202eaa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8004202eae:	c9                   	leaveq 
  8004202eaf:	c3                   	retq   

0000008004202eb0 <pgdir_walk>:
// The logic here is slightly different, in that it needs to look
// not just at the page directory, but also get the last-level page table entry.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004202eb0:	55                   	push   %rbp
  8004202eb1:	48 89 e5             	mov    %rsp,%rbp
  8004202eb4:	48 83 ec 50          	sub    $0x50,%rsp
  8004202eb8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202ebc:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202ec0:	89 55 bc             	mov    %edx,-0x44(%rbp)
	// Fill this function in
	pde_t *current_pde = &pgdir[PDX(va)];
  8004202ec3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202ec7:	48 c1 e8 15          	shr    $0x15,%rax
  8004202ecb:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202ed0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202ed7:	00 
  8004202ed8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202edc:	48 01 d0             	add    %rdx,%rax
  8004202edf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte_t *pte;

	if(create && !(*current_pde & PTE_P)) {
  8004202ee3:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004202ee7:	74 69                	je     8004202f52 <pgdir_walk+0xa2>
  8004202ee9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202eed:	48 8b 00             	mov    (%rax),%rax
  8004202ef0:	83 e0 01             	and    $0x1,%eax
  8004202ef3:	48 85 c0             	test   %rax,%rax
  8004202ef6:	75 5a                	jne    8004202f52 <pgdir_walk+0xa2>
		struct PageInfo *page = page_alloc(ALLOC_ZERO);
  8004202ef8:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202efd:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004202f04:	00 00 00 
  8004202f07:	ff d0                	callq  *%rax
  8004202f09:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (!page)
  8004202f0d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202f12:	75 0a                	jne    8004202f1e <pgdir_walk+0x6e>
			return NULL;
  8004202f14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f19:	e9 d6 00 00 00       	jmpq   8004202ff4 <pgdir_walk+0x144>

		page->pp_ref++;
  8004202f1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f22:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202f26:	8d 50 01             	lea    0x1(%rax),%edx
  8004202f29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f2d:	66 89 50 08          	mov    %dx,0x8(%rax)
		*current_pde = (pde_t) page2pa(page) | PTE_P | PTE_W | PTE_U;
  8004202f31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f35:	48 89 c7             	mov    %rax,%rdi
  8004202f38:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004202f3f:	00 00 00 
  8004202f42:	ff d0                	callq  *%rax
  8004202f44:	48 83 c8 07          	or     $0x7,%rax
  8004202f48:	48 89 c2             	mov    %rax,%rdx
  8004202f4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f4f:	48 89 10             	mov    %rdx,(%rax)
	}

	pte = (pte_t *) KADDR(PTE_ADDR(*current_pde));
  8004202f52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f56:	48 8b 00             	mov    (%rax),%rax
  8004202f59:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202f5f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202f63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f67:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202f6b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004202f6e:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004202f71:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004202f78:	00 00 00 
  8004202f7b:	48 8b 00             	mov    (%rax),%rax
  8004202f7e:	48 39 c2             	cmp    %rax,%rdx
  8004202f81:	72 32                	jb     8004202fb5 <pgdir_walk+0x105>
  8004202f83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f87:	48 89 c1             	mov    %rax,%rcx
  8004202f8a:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004202f91:	00 00 00 
  8004202f94:	be 6e 02 00 00       	mov    $0x26e,%esi
  8004202f99:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004202fa0:	00 00 00 
  8004202fa3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202fa8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202faf:	00 00 00 
  8004202fb2:	41 ff d0             	callq  *%r8
  8004202fb5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202fbc:	00 00 00 
  8004202fbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202fc3:	48 01 d0             	add    %rdx,%rax
  8004202fc6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	if(!pte)
  8004202fca:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004202fcf:	75 07                	jne    8004202fd8 <pgdir_walk+0x128>
		return NULL;
  8004202fd1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202fd6:	eb 1c                	jmp    8004202ff4 <pgdir_walk+0x144>

	return &pte[PTX(va)];
  8004202fd8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202fdc:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202fe0:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202fe5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202fec:	00 
  8004202fed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202ff1:	48 01 d0             	add    %rdx,%rax
}
  8004202ff4:	c9                   	leaveq 
  8004202ff5:	c3                   	retq   

0000008004202ff6 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004202ff6:	55                   	push   %rbp
  8004202ff7:	48 89 e5             	mov    %rsp,%rbp
  8004202ffa:	48 83 ec 40          	sub    $0x40,%rsp
  8004202ffe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203002:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203006:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420300a:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420300e:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
	// Fill this function in
	pte_t *pte;
	int i;
 	for(i = 0; i < size; i += PGSIZE) {
  8004203012:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004203019:	e9 8a 00 00 00       	jmpq   80042030a8 <boot_map_region+0xb2>
 		pte = pml4e_walk(pml4e, (void *)la + i, true);
  800420301e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203021:	48 63 d0             	movslq %eax,%rdx
  8004203024:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203028:	48 01 d0             	add    %rdx,%rax
  800420302b:	48 89 c1             	mov    %rax,%rcx
  800420302e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203032:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203037:	48 89 ce             	mov    %rcx,%rsi
  800420303a:	48 89 c7             	mov    %rax,%rdi
  800420303d:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  8004203044:	00 00 00 
  8004203047:	ff d0                	callq  *%rax
  8004203049:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
 		if (!pte)
  800420304d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203052:	75 2a                	jne    800420307e <boot_map_region+0x88>
 			panic("failed to find the physical memory");
  8004203054:	48 ba a8 67 21 04 80 	movabs $0x80042167a8,%rdx
  800420305b:	00 00 00 
  800420305e:	be 89 02 00 00       	mov    $0x289,%esi
  8004203063:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420306a:	00 00 00 
  800420306d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203072:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004203079:	00 00 00 
  800420307c:	ff d1                	callq  *%rcx
 		*pte = (pa + i) | perm | PTE_P;
  800420307e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203081:	48 63 d0             	movslq %eax,%rdx
  8004203084:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203088:	48 01 c2             	add    %rax,%rdx
  800420308b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420308e:	48 98                	cltq   
  8004203090:	48 09 d0             	or     %rdx,%rax
  8004203093:	48 83 c8 01          	or     $0x1,%rax
  8004203097:	48 89 c2             	mov    %rax,%rdx
  800420309a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420309e:	48 89 10             	mov    %rdx,(%rax)
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t *pte;
	int i;
 	for(i = 0; i < size; i += PGSIZE) {
  80042030a1:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  80042030a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042030ab:	48 98                	cltq   
  80042030ad:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042030b1:	0f 82 67 ff ff ff    	jb     800420301e <boot_map_region+0x28>
 		pte = pml4e_walk(pml4e, (void *)la + i, true);
 		if (!pte)
 			panic("failed to find the physical memory");
 		*pte = (pa + i) | perm | PTE_P;
 	}
}
  80042030b7:	c9                   	leaveq 
  80042030b8:	c3                   	retq   

00000080042030b9 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  80042030b9:	55                   	push   %rbp
  80042030ba:	48 89 e5             	mov    %rsp,%rbp
  80042030bd:	48 83 ec 30          	sub    $0x30,%rsp
  80042030c1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042030c5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042030c9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042030cd:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in
	pte_t *pte = pml4e_walk(pml4e, va, true);
  80042030d0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042030d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042030d8:	ba 01 00 00 00       	mov    $0x1,%edx
  80042030dd:	48 89 ce             	mov    %rcx,%rsi
  80042030e0:	48 89 c7             	mov    %rax,%rdi
  80042030e3:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  80042030ea:	00 00 00 
  80042030ed:	ff d0                	callq  *%rax
  80042030ef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!pte)
  80042030f3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042030f8:	75 07                	jne    8004203101 <page_insert+0x48>
		return -E_NO_MEM;
  80042030fa:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042030ff:	eb 6b                	jmp    800420316c <page_insert+0xb3>

	pp->pp_ref++;
  8004203101:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203105:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203109:	8d 50 01             	lea    0x1(%rax),%edx
  800420310c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203110:	66 89 50 08          	mov    %dx,0x8(%rax)
	if (*pte & PTE_P)
  8004203114:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203118:	48 8b 00             	mov    (%rax),%rax
  800420311b:	83 e0 01             	and    $0x1,%eax
  800420311e:	48 85 c0             	test   %rax,%rax
  8004203121:	74 1a                	je     800420313d <page_insert+0x84>
		page_remove(pml4e, va);
  8004203123:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203127:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420312b:	48 89 d6             	mov    %rdx,%rsi
  800420312e:	48 89 c7             	mov    %rax,%rdi
  8004203131:	48 b8 e5 31 20 04 80 	movabs $0x80042031e5,%rax
  8004203138:	00 00 00 
  800420313b:	ff d0                	callq  *%rax
	*pte = page2pa(pp) | perm | PTE_P;
  800420313d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203141:	48 89 c7             	mov    %rax,%rdi
  8004203144:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  800420314b:	00 00 00 
  800420314e:	ff d0                	callq  *%rax
  8004203150:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203153:	48 63 d2             	movslq %edx,%rdx
  8004203156:	48 09 d0             	or     %rdx,%rax
  8004203159:	48 83 c8 01          	or     $0x1,%rax
  800420315d:	48 89 c2             	mov    %rax,%rdx
  8004203160:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203164:	48 89 10             	mov    %rdx,(%rax)

	return 0;
  8004203167:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420316c:	c9                   	leaveq 
  800420316d:	c3                   	retq   

000000800420316e <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  800420316e:	55                   	push   %rbp
  800420316f:	48 89 e5             	mov    %rsp,%rbp
  8004203172:	48 83 ec 30          	sub    $0x30,%rsp
  8004203176:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420317a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420317e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t *pte = pml4e_walk(pml4e, va, true);
  8004203182:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203186:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420318a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420318f:	48 89 ce             	mov    %rcx,%rsi
  8004203192:	48 89 c7             	mov    %rax,%rdi
  8004203195:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  800420319c:	00 00 00 
  800420319f:	ff d0                	callq  *%rax
  80042031a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!pte)
  80042031a5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042031aa:	75 07                	jne    80042031b3 <page_lookup+0x45>
		return NULL;
  80042031ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031b1:	eb 30                	jmp    80042031e3 <page_lookup+0x75>

	physaddr_t pa = (physaddr_t) *pte;
  80042031b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031b7:	48 8b 00             	mov    (%rax),%rax
  80042031ba:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	if (pte_store)
  80042031be:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042031c3:	74 0b                	je     80042031d0 <page_lookup+0x62>
		*pte_store = pte;
  80042031c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042031c9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042031cd:	48 89 10             	mov    %rdx,(%rax)

	return pa2page(pa);
  80042031d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031d4:	48 89 c7             	mov    %rax,%rdi
  80042031d7:	48 b8 69 17 20 04 80 	movabs $0x8004201769,%rax
  80042031de:	00 00 00 
  80042031e1:	ff d0                	callq  *%rax
}
  80042031e3:	c9                   	leaveq 
  80042031e4:	c3                   	retq   

00000080042031e5 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  80042031e5:	55                   	push   %rbp
  80042031e6:	48 89 e5             	mov    %rsp,%rbp
  80042031e9:	48 83 ec 20          	sub    $0x20,%rsp
  80042031ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042031f1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	pte_t *pte = NULL;
  80042031f5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042031fc:	00 
	struct PageInfo *page = page_lookup(pml4e, va, &pte);
  80042031fd:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203201:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203205:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203209:	48 89 ce             	mov    %rcx,%rsi
  800420320c:	48 89 c7             	mov    %rax,%rdi
  800420320f:	48 b8 6e 31 20 04 80 	movabs $0x800420316e,%rax
  8004203216:	00 00 00 
  8004203219:	ff d0                	callq  *%rax
  800420321b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (page) {
  800420321f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203224:	74 41                	je     8004203267 <page_remove+0x82>
		page_decref(page);
  8004203226:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420322a:	48 89 c7             	mov    %rax,%rdi
  800420322d:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004203234:	00 00 00 
  8004203237:	ff d0                	callq  *%rax
		if (pte) {
  8004203239:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420323d:	48 85 c0             	test   %rax,%rax
  8004203240:	74 25                	je     8004203267 <page_remove+0x82>
			*pte = 0;
  8004203242:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203246:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			tlb_invalidate(pml4e, va);
  800420324d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203251:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203255:	48 89 d6             	mov    %rdx,%rsi
  8004203258:	48 89 c7             	mov    %rax,%rdi
  800420325b:	48 b8 69 32 20 04 80 	movabs $0x8004203269,%rax
  8004203262:	00 00 00 
  8004203265:	ff d0                	callq  *%rax
		}
	}
}
  8004203267:	c9                   	leaveq 
  8004203268:	c3                   	retq   

0000008004203269 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203269:	55                   	push   %rbp
  800420326a:	48 89 e5             	mov    %rsp,%rbp
  800420326d:	48 83 ec 20          	sub    $0x20,%rsp
  8004203271:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203275:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203279:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420327e:	75 35                	jne    80042032b5 <tlb_invalidate+0x4c>
  8004203280:	48 b9 cb 67 21 04 80 	movabs $0x80042167cb,%rcx
  8004203287:	00 00 00 
  800420328a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203291:	00 00 00 
  8004203294:	be f8 02 00 00       	mov    $0x2f8,%esi
  8004203299:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042032a0:	00 00 00 
  80042032a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032a8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042032af:	00 00 00 
  80042032b2:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  80042032b5:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042032bc:	00 00 00 
  80042032bf:	ff d0                	callq  *%rax
  80042032c1:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  80042032c8:	00 00 00 
  80042032cb:	48 98                	cltq   
  80042032cd:	48 c1 e0 03          	shl    $0x3,%rax
  80042032d1:	48 89 c2             	mov    %rax,%rdx
  80042032d4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042032d8:	48 29 c2             	sub    %rax,%rdx
  80042032db:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042032df:	48 83 c0 08          	add    $0x8,%rax
  80042032e3:	48 8b 00             	mov    (%rax),%rax
  80042032e6:	48 85 c0             	test   %rax,%rax
  80042032e9:	74 3e                	je     8004203329 <tlb_invalidate+0xc0>
  80042032eb:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042032f2:	00 00 00 
  80042032f5:	ff d0                	callq  *%rax
  80042032f7:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  80042032fe:	00 00 00 
  8004203301:	48 98                	cltq   
  8004203303:	48 c1 e0 03          	shl    $0x3,%rax
  8004203307:	48 89 c2             	mov    %rax,%rdx
  800420330a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420330e:	48 29 c2             	sub    %rax,%rdx
  8004203311:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203315:	48 83 c0 08          	add    $0x8,%rax
  8004203319:	48 8b 00             	mov    (%rax),%rax
  800420331c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203323:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203327:	75 0f                	jne    8004203338 <tlb_invalidate+0xcf>
  8004203329:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420332d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203331:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203335:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004203338:	c9                   	leaveq 
  8004203339:	c3                   	retq   

000000800420333a <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  800420333a:	55                   	push   %rbp
  800420333b:	48 89 e5             	mov    %rsp,%rbp
  800420333e:	48 83 ec 30          	sub    $0x30,%rsp
  8004203342:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203346:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// okay to simply panic if this happens).
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	uint64_t s_size = (size_t)ROUNDUP(pa + size, PGSIZE);
  800420334a:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004203351:	00 
  8004203352:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203356:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420335a:	48 01 c2             	add    %rax,%rdx
  800420335d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203361:	48 01 d0             	add    %rdx,%rax
  8004203364:	48 83 e8 01          	sub    $0x1,%rax
  8004203368:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420336c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203370:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203375:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004203379:	48 89 d0             	mov    %rdx,%rax
  800420337c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203380:	48 29 c2             	sub    %rax,%rdx
  8004203383:	48 89 d0             	mov    %rdx,%rax
  8004203386:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	pa = (physaddr_t)ROUNDDOWN(pa, PGSIZE);
  800420338a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420338e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203392:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203396:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420339c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	s_size = s_size - pa;
  80042033a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042033a4:	48 29 45 e8          	sub    %rax,-0x18(%rbp)
	if(base + s_size >= MMIOLIM)
  80042033a8:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  80042033af:	00 00 00 
  80042033b2:	48 8b 10             	mov    (%rax),%rdx
  80042033b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042033b9:	48 01 c2             	add    %rax,%rdx
  80042033bc:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042033c3:	00 00 00 
  80042033c6:	48 39 c2             	cmp    %rax,%rdx
  80042033c9:	76 2a                	jbe    80042033f5 <mmio_map_region+0xbb>
		panic("cant assign memory to mmio\n");
  80042033cb:	48 ba d7 67 21 04 80 	movabs $0x80042167d7,%rdx
  80042033d2:	00 00 00 
  80042033d5:	be 21 03 00 00       	mov    $0x321,%esi
  80042033da:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042033e1:	00 00 00 
  80042033e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033e9:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042033f0:	00 00 00 
  80042033f3:	ff d1                	callq  *%rcx
	boot_map_region(boot_pml4e, base, s_size, pa, PTE_PCD | PTE_PWT | PTE_W);
  80042033f5:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  80042033fc:	00 00 00 
  80042033ff:	48 8b 30             	mov    (%rax),%rsi
  8004203402:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004203409:	00 00 00 
  800420340c:	48 8b 00             	mov    (%rax),%rax
  800420340f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203413:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203417:	41 b8 1a 00 00 00    	mov    $0x1a,%r8d
  800420341d:	48 89 c7             	mov    %rax,%rdi
  8004203420:	48 b8 f6 2f 20 04 80 	movabs $0x8004202ff6,%rax
  8004203427:	00 00 00 
  800420342a:	ff d0                	callq  *%rax
	base += s_size;
  800420342c:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  8004203433:	00 00 00 
  8004203436:	48 8b 10             	mov    (%rax),%rdx
  8004203439:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420343d:	48 01 c2             	add    %rax,%rdx
  8004203440:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  8004203447:	00 00 00 
  800420344a:	48 89 10             	mov    %rdx,(%rax)
	return (void *)(base - s_size);
  800420344d:	48 b8 b0 b5 22 04 80 	movabs $0x800422b5b0,%rax
  8004203454:	00 00 00 
  8004203457:	48 8b 00             	mov    (%rax),%rax
  800420345a:	48 2b 45 e8          	sub    -0x18(%rbp),%rax
	//panic("mmio_map_region not implemented");
}
  800420345e:	c9                   	leaveq 
  800420345f:	c3                   	retq   

0000008004203460 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203460:	55                   	push   %rbp
  8004203461:	48 89 e5             	mov    %rsp,%rbp
  8004203464:	48 83 ec 50          	sub    $0x50,%rsp
  8004203468:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420346c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203470:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004203474:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	uint64_t end = ROUNDUP((uint64_t)va+len,PGSIZE),start = ROUNDDOWN((uint64_t)va, PGSIZE);
  8004203477:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  800420347e:	00 
  800420347f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004203483:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203487:	48 01 c2             	add    %rax,%rdx
  800420348a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420348e:	48 01 d0             	add    %rdx,%rax
  8004203491:	48 83 e8 01          	sub    $0x1,%rax
  8004203495:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203499:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420349d:	ba 00 00 00 00       	mov    $0x0,%edx
  80042034a2:	48 f7 75 f0          	divq   -0x10(%rbp)
  80042034a6:	48 89 d0             	mov    %rdx,%rax
  80042034a9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042034ad:	48 29 c2             	sub    %rax,%rdx
  80042034b0:	48 89 d0             	mov    %rdx,%rax
  80042034b3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042034b7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034bb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042034bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034c3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042034c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	for (; start < end; start += PGSIZE)
  80042034cd:	e9 99 00 00 00       	jmpq   800420356b <user_mem_check+0x10b>
	{
		pte_t *pte = pml4e_walk(env->env_pml4e, (const void *)start, false);
  80042034d2:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042034d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042034da:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042034e1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042034e6:	48 89 ce             	mov    %rcx,%rsi
  80042034e9:	48 89 c7             	mov    %rax,%rdi
  80042034ec:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  80042034f3:	00 00 00 
  80042034f6:	ff d0                	callq  *%rax
  80042034f8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (start >= ULIM || pte == NULL || ((*pte & perm) != perm) || ((*pte & PTE_P) == 0))
  80042034fc:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004203503:	00 00 00 
  8004203506:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420350a:	77 2f                	ja     800420353b <user_mem_check+0xdb>
  800420350c:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203511:	74 28                	je     800420353b <user_mem_check+0xdb>
  8004203513:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203517:	48 8b 10             	mov    (%rax),%rdx
  800420351a:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420351d:	48 98                	cltq   
  800420351f:	48 21 c2             	and    %rax,%rdx
  8004203522:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004203525:	48 98                	cltq   
  8004203527:	48 39 c2             	cmp    %rax,%rdx
  800420352a:	75 0f                	jne    800420353b <user_mem_check+0xdb>
  800420352c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203530:	48 8b 00             	mov    (%rax),%rax
  8004203533:	83 e0 01             	and    $0x1,%eax
  8004203536:	48 85 c0             	test   %rax,%rax
  8004203539:	75 28                	jne    8004203563 <user_mem_check+0x103>
		{
			user_mem_check_addr = start < (uintptr_t)va ? (uintptr_t)va : start;
  800420353b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420353f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203543:	76 06                	jbe    800420354b <user_mem_check+0xeb>
  8004203545:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203549:	eb 04                	jmp    800420354f <user_mem_check+0xef>
  800420354b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420354f:	48 ba 40 e2 6b 04 80 	movabs $0x80046be240,%rdx
  8004203556:	00 00 00 
  8004203559:	48 89 02             	mov    %rax,(%rdx)
			return -E_FAULT;
  800420355c:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203561:	eb 1b                	jmp    800420357e <user_mem_check+0x11e>
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
	// LAB 3: Your code here.
	uint64_t end = ROUNDUP((uint64_t)va+len,PGSIZE),start = ROUNDDOWN((uint64_t)va, PGSIZE);

	for (; start < end; start += PGSIZE)
  8004203563:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420356a:	00 
  800420356b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420356f:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203573:	0f 82 59 ff ff ff    	jb     80042034d2 <user_mem_check+0x72>
		{
			user_mem_check_addr = start < (uintptr_t)va ? (uintptr_t)va : start;
			return -E_FAULT;
		}
	}
	return 0;
  8004203579:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420357e:	c9                   	leaveq 
  800420357f:	c3                   	retq   

0000008004203580 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203580:	55                   	push   %rbp
  8004203581:	48 89 e5             	mov    %rsp,%rbp
  8004203584:	48 83 ec 20          	sub    $0x20,%rsp
  8004203588:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420358c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203590:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203594:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203597:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420359a:	83 c8 04             	or     $0x4,%eax
  800420359d:	89 c1                	mov    %eax,%ecx
  800420359f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042035a3:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042035a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035ab:	48 89 c7             	mov    %rax,%rdi
  80042035ae:	48 b8 60 34 20 04 80 	movabs $0x8004203460,%rax
  80042035b5:	00 00 00 
  80042035b8:	ff d0                	callq  *%rax
  80042035ba:	85 c0                	test   %eax,%eax
  80042035bc:	79 47                	jns    8004203605 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  80042035be:	48 b8 40 e2 6b 04 80 	movabs $0x80046be240,%rax
  80042035c5:	00 00 00 
  80042035c8:	48 8b 10             	mov    (%rax),%rdx
  80042035cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035cf:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042035d5:	89 c6                	mov    %eax,%esi
  80042035d7:	48 bf f8 67 21 04 80 	movabs $0x80042167f8,%rdi
  80042035de:	00 00 00 
  80042035e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035e6:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  80042035ed:	00 00 00 
  80042035f0:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  80042035f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035f6:	48 89 c7             	mov    %rax,%rdi
  80042035f9:	48 b8 d7 7f 20 04 80 	movabs $0x8004207fd7,%rax
  8004203600:	00 00 00 
  8004203603:	ff d0                	callq  *%rax
	}
}
  8004203605:	c9                   	leaveq 
  8004203606:	c3                   	retq   

0000008004203607 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203607:	55                   	push   %rbp
  8004203608:	48 89 e5             	mov    %rsp,%rbp
  800420360b:	48 83 ec 60          	sub    $0x60,%rsp
  800420360f:	89 f8                	mov    %edi,%eax
  8004203611:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203614:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203618:	74 07                	je     8004203621 <check_page_free_list+0x1a>
  800420361a:	b8 01 00 00 00       	mov    $0x1,%eax
  800420361f:	eb 05                	jmp    8004203626 <check_page_free_list+0x1f>
  8004203621:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203626:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203629:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203630:	00 
  8004203631:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203638:	00 
	void *first_free_page;

	if (!page_free_list)
  8004203639:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004203640:	00 00 00 
  8004203643:	48 8b 00             	mov    (%rax),%rax
  8004203646:	48 85 c0             	test   %rax,%rax
  8004203649:	75 2a                	jne    8004203675 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  800420364b:	48 ba 30 68 21 04 80 	movabs $0x8004216830,%rdx
  8004203652:	00 00 00 
  8004203655:	be 71 03 00 00       	mov    $0x371,%esi
  800420365a:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203661:	00 00 00 
  8004203664:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203669:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004203670:	00 00 00 
  8004203673:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203675:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203679:	0f 84 a9 00 00 00    	je     8004203728 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  800420367f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203683:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203687:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  800420368b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420368f:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004203696:	00 00 00 
  8004203699:	48 8b 00             	mov    (%rax),%rax
  800420369c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042036a0:	eb 58                	jmp    80042036fa <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  80042036a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036a6:	48 89 c7             	mov    %rax,%rdi
  80042036a9:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  80042036b0:	00 00 00 
  80042036b3:	ff d0                	callq  *%rax
  80042036b5:	48 c1 e8 15          	shr    $0x15,%rax
  80042036b9:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036be:	48 89 c2             	mov    %rax,%rdx
  80042036c1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042036c4:	48 39 c2             	cmp    %rax,%rdx
  80042036c7:	0f 93 c0             	setae  %al
  80042036ca:	0f b6 c0             	movzbl %al,%eax
  80042036cd:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  80042036d0:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042036d3:	48 98                	cltq   
  80042036d5:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  80042036da:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042036de:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  80042036e1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042036e5:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042036e8:	48 98                	cltq   
  80042036ea:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042036ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036f3:	48 8b 00             	mov    (%rax),%rax
  80042036f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042036fa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042036ff:	75 a1                	jne    80042036a2 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203701:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203705:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  800420370c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203710:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203714:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203717:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420371b:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004203722:	00 00 00 
  8004203725:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203728:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  800420372f:	00 00 00 
  8004203732:	48 8b 00             	mov    (%rax),%rax
  8004203735:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203739:	eb 5e                	jmp    8004203799 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  800420373b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420373f:	48 89 c7             	mov    %rax,%rdi
  8004203742:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203749:	00 00 00 
  800420374c:	ff d0                	callq  *%rax
  800420374e:	48 c1 e8 15          	shr    $0x15,%rax
  8004203752:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203757:	48 89 c2             	mov    %rax,%rdx
  800420375a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420375d:	48 39 c2             	cmp    %rax,%rdx
  8004203760:	73 2c                	jae    800420378e <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203762:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203766:	48 89 c7             	mov    %rax,%rdi
  8004203769:	48 b8 da 17 20 04 80 	movabs $0x80042017da,%rax
  8004203770:	00 00 00 
  8004203773:	ff d0                	callq  *%rax
  8004203775:	ba 80 00 00 00       	mov    $0x80,%edx
  800420377a:	be 97 00 00 00       	mov    $0x97,%esi
  800420377f:	48 89 c7             	mov    %rax,%rdi
  8004203782:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004203789:	00 00 00 
  800420378c:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  800420378e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203792:	48 8b 00             	mov    (%rax),%rax
  8004203795:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203799:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420379e:	75 9b                	jne    800420373b <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = boot_alloc(0);
  80042037a0:	bf 00 00 00 00       	mov    $0x0,%edi
  80042037a5:	48 b8 03 21 20 04 80 	movabs $0x8004202103,%rax
  80042037ac:	00 00 00 
  80042037af:	ff d0                	callq  *%rax
  80042037b1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042037b5:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  80042037bc:	00 00 00 
  80042037bf:	48 8b 00             	mov    (%rax),%rax
  80042037c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042037c6:	e9 20 03 00 00       	jmpq   8004203aeb <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  80042037cb:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  80042037d2:	00 00 00 
  80042037d5:	48 8b 00             	mov    (%rax),%rax
  80042037d8:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042037dc:	73 35                	jae    8004203813 <check_page_free_list+0x20c>
  80042037de:	48 b9 54 68 21 04 80 	movabs $0x8004216854,%rcx
  80042037e5:	00 00 00 
  80042037e8:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042037ef:	00 00 00 
  80042037f2:	be 8b 03 00 00       	mov    $0x38b,%esi
  80042037f7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042037fe:	00 00 00 
  8004203801:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203806:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420380d:	00 00 00 
  8004203810:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203813:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  800420381a:	00 00 00 
  800420381d:	48 8b 10             	mov    (%rax),%rdx
  8004203820:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004203827:	00 00 00 
  800420382a:	48 8b 00             	mov    (%rax),%rax
  800420382d:	48 c1 e0 04          	shl    $0x4,%rax
  8004203831:	48 01 d0             	add    %rdx,%rax
  8004203834:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203838:	77 35                	ja     800420386f <check_page_free_list+0x268>
  800420383a:	48 b9 60 68 21 04 80 	movabs $0x8004216860,%rcx
  8004203841:	00 00 00 
  8004203844:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420384b:	00 00 00 
  800420384e:	be 8c 03 00 00       	mov    $0x38c,%esi
  8004203853:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420385a:	00 00 00 
  800420385d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203862:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203869:	00 00 00 
  800420386c:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  800420386f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203873:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  800420387a:	00 00 00 
  800420387d:	48 8b 00             	mov    (%rax),%rax
  8004203880:	48 29 c2             	sub    %rax,%rdx
  8004203883:	48 89 d0             	mov    %rdx,%rax
  8004203886:	83 e0 0f             	and    $0xf,%eax
  8004203889:	48 85 c0             	test   %rax,%rax
  800420388c:	74 35                	je     80042038c3 <check_page_free_list+0x2bc>
  800420388e:	48 b9 78 68 21 04 80 	movabs $0x8004216878,%rcx
  8004203895:	00 00 00 
  8004203898:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420389f:	00 00 00 
  80042038a2:	be 8d 03 00 00       	mov    $0x38d,%esi
  80042038a7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042038ae:	00 00 00 
  80042038b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038b6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042038bd:	00 00 00 
  80042038c0:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  80042038c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038c7:	48 89 c7             	mov    %rax,%rdi
  80042038ca:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  80042038d1:	00 00 00 
  80042038d4:	ff d0                	callq  *%rax
  80042038d6:	48 85 c0             	test   %rax,%rax
  80042038d9:	75 35                	jne    8004203910 <check_page_free_list+0x309>
  80042038db:	48 b9 aa 68 21 04 80 	movabs $0x80042168aa,%rcx
  80042038e2:	00 00 00 
  80042038e5:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042038ec:	00 00 00 
  80042038ef:	be 90 03 00 00       	mov    $0x390,%esi
  80042038f4:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042038fb:	00 00 00 
  80042038fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203903:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420390a:	00 00 00 
  800420390d:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  8004203910:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203914:	48 89 c7             	mov    %rax,%rdi
  8004203917:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  800420391e:	00 00 00 
  8004203921:	ff d0                	callq  *%rax
  8004203923:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203929:	75 35                	jne    8004203960 <check_page_free_list+0x359>
  800420392b:	48 b9 bb 68 21 04 80 	movabs $0x80042168bb,%rcx
  8004203932:	00 00 00 
  8004203935:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420393c:	00 00 00 
  800420393f:	be 91 03 00 00       	mov    $0x391,%esi
  8004203944:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420394b:	00 00 00 
  800420394e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203953:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420395a:	00 00 00 
  800420395d:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004203960:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203964:	48 89 c7             	mov    %rax,%rdi
  8004203967:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  800420396e:	00 00 00 
  8004203971:	ff d0                	callq  *%rax
  8004203973:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203979:	75 35                	jne    80042039b0 <check_page_free_list+0x3a9>
  800420397b:	48 b9 d8 68 21 04 80 	movabs $0x80042168d8,%rcx
  8004203982:	00 00 00 
  8004203985:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420398c:	00 00 00 
  800420398f:	be 92 03 00 00       	mov    $0x392,%esi
  8004203994:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420399b:	00 00 00 
  800420399e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042039a3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042039aa:	00 00 00 
  80042039ad:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  80042039b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039b4:	48 89 c7             	mov    %rax,%rdi
  80042039b7:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  80042039be:	00 00 00 
  80042039c1:	ff d0                	callq  *%rax
  80042039c3:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042039c9:	75 35                	jne    8004203a00 <check_page_free_list+0x3f9>
  80042039cb:	48 b9 fb 68 21 04 80 	movabs $0x80042168fb,%rcx
  80042039d2:	00 00 00 
  80042039d5:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042039dc:	00 00 00 
  80042039df:	be 93 03 00 00       	mov    $0x393,%esi
  80042039e4:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042039eb:	00 00 00 
  80042039ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042039f3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042039fa:	00 00 00 
  80042039fd:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || page2kva(pp) >= first_free_page);
  8004203a00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a04:	48 89 c7             	mov    %rax,%rdi
  8004203a07:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203a0e:	00 00 00 
  8004203a11:	ff d0                	callq  *%rax
  8004203a13:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203a19:	76 4e                	jbe    8004203a69 <check_page_free_list+0x462>
  8004203a1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a1f:	48 89 c7             	mov    %rax,%rdi
  8004203a22:	48 b8 da 17 20 04 80 	movabs $0x80042017da,%rax
  8004203a29:	00 00 00 
  8004203a2c:	ff d0                	callq  *%rax
  8004203a2e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203a32:	73 35                	jae    8004203a69 <check_page_free_list+0x462>
  8004203a34:	48 b9 18 69 21 04 80 	movabs $0x8004216918,%rcx
  8004203a3b:	00 00 00 
  8004203a3e:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203a45:	00 00 00 
  8004203a48:	be 94 03 00 00       	mov    $0x394,%esi
  8004203a4d:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203a54:	00 00 00 
  8004203a57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a5c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203a63:	00 00 00 
  8004203a66:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004203a69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a6d:	48 89 c7             	mov    %rax,%rdi
  8004203a70:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203a77:	00 00 00 
  8004203a7a:	ff d0                	callq  *%rax
  8004203a7c:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004203a82:	75 35                	jne    8004203ab9 <check_page_free_list+0x4b2>
  8004203a84:	48 b9 54 69 21 04 80 	movabs $0x8004216954,%rcx
  8004203a8b:	00 00 00 
  8004203a8e:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203a95:	00 00 00 
  8004203a98:	be 96 03 00 00       	mov    $0x396,%esi
  8004203a9d:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203aa4:	00 00 00 
  8004203aa7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203aac:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203ab3:	00 00 00 
  8004203ab6:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004203ab9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203abd:	48 89 c7             	mov    %rax,%rdi
  8004203ac0:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203ac7:	00 00 00 
  8004203aca:	ff d0                	callq  *%rax
  8004203acc:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203ad2:	77 07                	ja     8004203adb <check_page_free_list+0x4d4>
			++nfree_basemem;
  8004203ad4:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004203ad9:	eb 05                	jmp    8004203ae0 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  8004203adb:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203ae0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ae4:	48 8b 00             	mov    (%rax),%rax
  8004203ae7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203aeb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203af0:	0f 85 d5 fc ff ff    	jne    80042037cb <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  8004203af6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203afb:	75 35                	jne    8004203b32 <check_page_free_list+0x52b>
  8004203afd:	48 b9 71 69 21 04 80 	movabs $0x8004216971,%rcx
  8004203b04:	00 00 00 
  8004203b07:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203b0e:	00 00 00 
  8004203b11:	be 9e 03 00 00       	mov    $0x39e,%esi
  8004203b16:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203b1d:	00 00 00 
  8004203b20:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b25:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203b2c:	00 00 00 
  8004203b2f:	41 ff d0             	callq  *%r8
}
  8004203b32:	c9                   	leaveq 
  8004203b33:	c3                   	retq   

0000008004203b34 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  8004203b34:	55                   	push   %rbp
  8004203b35:	48 89 e5             	mov    %rsp,%rbp
  8004203b38:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203b3c:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004203b43:	00 00 00 
  8004203b46:	48 8b 00             	mov    (%rax),%rax
  8004203b49:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203b4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203b54:	eb 37                	jmp    8004203b8d <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004203b56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b5a:	48 89 c7             	mov    %rax,%rdi
  8004203b5d:	48 b8 da 17 20 04 80 	movabs $0x80042017da,%rax
  8004203b64:	00 00 00 
  8004203b67:	ff d0                	callq  *%rax
  8004203b69:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004203b6e:	be 97 00 00 00       	mov    $0x97,%esi
  8004203b73:	48 89 c7             	mov    %rax,%rdi
  8004203b76:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004203b7d:	00 00 00 
  8004203b80:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203b82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b86:	48 8b 00             	mov    (%rax),%rax
  8004203b89:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203b8d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203b92:	75 c2                	jne    8004203b56 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203b94:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004203b9b:	00 00 00 
  8004203b9e:	48 8b 00             	mov    (%rax),%rax
  8004203ba1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203ba5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203bac:	e9 ec 01 00 00       	jmpq   8004203d9d <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004203bb1:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  8004203bb8:	00 00 00 
  8004203bbb:	48 8b 00             	mov    (%rax),%rax
  8004203bbe:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203bc2:	73 35                	jae    8004203bf9 <check_page_alloc+0xc5>
  8004203bc4:	48 b9 82 69 21 04 80 	movabs $0x8004216982,%rcx
  8004203bcb:	00 00 00 
  8004203bce:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203bd5:	00 00 00 
  8004203bd8:	be b8 03 00 00       	mov    $0x3b8,%esi
  8004203bdd:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203be4:	00 00 00 
  8004203be7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203bec:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203bf3:	00 00 00 
  8004203bf6:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004203bf9:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  8004203c00:	00 00 00 
  8004203c03:	48 8b 10             	mov    (%rax),%rdx
  8004203c06:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004203c0d:	00 00 00 
  8004203c10:	48 8b 00             	mov    (%rax),%rax
  8004203c13:	48 c1 e0 04          	shl    $0x4,%rax
  8004203c17:	48 01 d0             	add    %rdx,%rax
  8004203c1a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203c1e:	77 35                	ja     8004203c55 <check_page_alloc+0x121>
  8004203c20:	48 b9 8f 69 21 04 80 	movabs $0x800421698f,%rcx
  8004203c27:	00 00 00 
  8004203c2a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203c31:	00 00 00 
  8004203c34:	be b9 03 00 00       	mov    $0x3b9,%esi
  8004203c39:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203c40:	00 00 00 
  8004203c43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c48:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203c4f:	00 00 00 
  8004203c52:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004203c55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c59:	48 89 c7             	mov    %rax,%rdi
  8004203c5c:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203c63:	00 00 00 
  8004203c66:	ff d0                	callq  *%rax
  8004203c68:	48 85 c0             	test   %rax,%rax
  8004203c6b:	75 35                	jne    8004203ca2 <check_page_alloc+0x16e>
  8004203c6d:	48 b9 a4 69 21 04 80 	movabs $0x80042169a4,%rcx
  8004203c74:	00 00 00 
  8004203c77:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203c7e:	00 00 00 
  8004203c81:	be bc 03 00 00       	mov    $0x3bc,%esi
  8004203c86:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203c8d:	00 00 00 
  8004203c90:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c95:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203c9c:	00 00 00 
  8004203c9f:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004203ca2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ca6:	48 89 c7             	mov    %rax,%rdi
  8004203ca9:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203cb0:	00 00 00 
  8004203cb3:	ff d0                	callq  *%rax
  8004203cb5:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203cbb:	75 35                	jne    8004203cf2 <check_page_alloc+0x1be>
  8004203cbd:	48 b9 b6 69 21 04 80 	movabs $0x80042169b6,%rcx
  8004203cc4:	00 00 00 
  8004203cc7:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203cce:	00 00 00 
  8004203cd1:	be bd 03 00 00       	mov    $0x3bd,%esi
  8004203cd6:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203cdd:	00 00 00 
  8004203ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ce5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203cec:	00 00 00 
  8004203cef:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  8004203cf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cf6:	48 89 c7             	mov    %rax,%rdi
  8004203cf9:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203d00:	00 00 00 
  8004203d03:	ff d0                	callq  *%rax
  8004203d05:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203d0b:	75 35                	jne    8004203d42 <check_page_alloc+0x20e>
  8004203d0d:	48 b9 d0 69 21 04 80 	movabs $0x80042169d0,%rcx
  8004203d14:	00 00 00 
  8004203d17:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203d1e:	00 00 00 
  8004203d21:	be be 03 00 00       	mov    $0x3be,%esi
  8004203d26:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203d2d:	00 00 00 
  8004203d30:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d35:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203d3c:	00 00 00 
  8004203d3f:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004203d42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d46:	48 89 c7             	mov    %rax,%rdi
  8004203d49:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203d50:	00 00 00 
  8004203d53:	ff d0                	callq  *%rax
  8004203d55:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004203d5b:	75 35                	jne    8004203d92 <check_page_alloc+0x25e>
  8004203d5d:	48 b9 f4 69 21 04 80 	movabs $0x80042169f4,%rcx
  8004203d64:	00 00 00 
  8004203d67:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203d6e:	00 00 00 
  8004203d71:	be bf 03 00 00       	mov    $0x3bf,%esi
  8004203d76:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203d7d:	00 00 00 
  8004203d80:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d85:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203d8c:	00 00 00 
  8004203d8f:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203d92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d96:	48 8b 00             	mov    (%rax),%rax
  8004203d99:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203d9d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203da2:	0f 85 09 fe ff ff    	jne    8004203bb1 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004203da8:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203daf:	00 
  8004203db0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203db4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203db8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203dbc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004203dc0:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203dc5:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004203dcc:	00 00 00 
  8004203dcf:	ff d0                	callq  *%rax
  8004203dd1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203dd5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203dda:	75 35                	jne    8004203e11 <check_page_alloc+0x2dd>
  8004203ddc:	48 b9 0f 6a 21 04 80 	movabs $0x8004216a0f,%rcx
  8004203de3:	00 00 00 
  8004203de6:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203ded:	00 00 00 
  8004203df0:	be c3 03 00 00       	mov    $0x3c3,%esi
  8004203df5:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203dfc:	00 00 00 
  8004203dff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e04:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203e0b:	00 00 00 
  8004203e0e:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004203e11:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203e16:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004203e1d:	00 00 00 
  8004203e20:	ff d0                	callq  *%rax
  8004203e22:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203e26:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203e2b:	75 35                	jne    8004203e62 <check_page_alloc+0x32e>
  8004203e2d:	48 b9 25 6a 21 04 80 	movabs $0x8004216a25,%rcx
  8004203e34:	00 00 00 
  8004203e37:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203e3e:	00 00 00 
  8004203e41:	be c4 03 00 00       	mov    $0x3c4,%esi
  8004203e46:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203e4d:	00 00 00 
  8004203e50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e55:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203e5c:	00 00 00 
  8004203e5f:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004203e62:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203e67:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004203e6e:	00 00 00 
  8004203e71:	ff d0                	callq  *%rax
  8004203e73:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203e77:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203e7c:	75 35                	jne    8004203eb3 <check_page_alloc+0x37f>
  8004203e7e:	48 b9 3b 6a 21 04 80 	movabs $0x8004216a3b,%rcx
  8004203e85:	00 00 00 
  8004203e88:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203e8f:	00 00 00 
  8004203e92:	be c5 03 00 00       	mov    $0x3c5,%esi
  8004203e97:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203e9e:	00 00 00 
  8004203ea1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ea6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203ead:	00 00 00 
  8004203eb0:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004203eb3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203eb8:	75 35                	jne    8004203eef <check_page_alloc+0x3bb>
  8004203eba:	48 b9 51 6a 21 04 80 	movabs $0x8004216a51,%rcx
  8004203ec1:	00 00 00 
  8004203ec4:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203ecb:	00 00 00 
  8004203ece:	be c6 03 00 00       	mov    $0x3c6,%esi
  8004203ed3:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203eda:	00 00 00 
  8004203edd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ee2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203ee9:	00 00 00 
  8004203eec:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004203eef:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203ef4:	74 0a                	je     8004203f00 <check_page_alloc+0x3cc>
  8004203ef6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203efa:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203efe:	75 35                	jne    8004203f35 <check_page_alloc+0x401>
  8004203f00:	48 b9 55 6a 21 04 80 	movabs $0x8004216a55,%rcx
  8004203f07:	00 00 00 
  8004203f0a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203f11:	00 00 00 
  8004203f14:	be c7 03 00 00       	mov    $0x3c7,%esi
  8004203f19:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203f20:	00 00 00 
  8004203f23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f28:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203f2f:	00 00 00 
  8004203f32:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004203f35:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203f3a:	74 14                	je     8004203f50 <check_page_alloc+0x41c>
  8004203f3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f40:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203f44:	74 0a                	je     8004203f50 <check_page_alloc+0x41c>
  8004203f46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f4a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203f4e:	75 35                	jne    8004203f85 <check_page_alloc+0x451>
  8004203f50:	48 b9 68 6a 21 04 80 	movabs $0x8004216a68,%rcx
  8004203f57:	00 00 00 
  8004203f5a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203f61:	00 00 00 
  8004203f64:	be c8 03 00 00       	mov    $0x3c8,%esi
  8004203f69:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203f70:	00 00 00 
  8004203f73:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f78:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203f7f:	00 00 00 
  8004203f82:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004203f85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f89:	48 89 c7             	mov    %rax,%rdi
  8004203f8c:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203f93:	00 00 00 
  8004203f96:	ff d0                	callq  *%rax
  8004203f98:	48 ba 30 f7 6b 04 80 	movabs $0x80046bf730,%rdx
  8004203f9f:	00 00 00 
  8004203fa2:	48 8b 12             	mov    (%rdx),%rdx
  8004203fa5:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004203fa9:	48 39 d0             	cmp    %rdx,%rax
  8004203fac:	72 35                	jb     8004203fe3 <check_page_alloc+0x4af>
  8004203fae:	48 b9 88 6a 21 04 80 	movabs $0x8004216a88,%rcx
  8004203fb5:	00 00 00 
  8004203fb8:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004203fbf:	00 00 00 
  8004203fc2:	be c9 03 00 00       	mov    $0x3c9,%esi
  8004203fc7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004203fce:	00 00 00 
  8004203fd1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fd6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203fdd:	00 00 00 
  8004203fe0:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004203fe3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203fe7:	48 89 c7             	mov    %rax,%rdi
  8004203fea:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004203ff1:	00 00 00 
  8004203ff4:	ff d0                	callq  *%rax
  8004203ff6:	48 ba 30 f7 6b 04 80 	movabs $0x80046bf730,%rdx
  8004203ffd:	00 00 00 
  8004204000:	48 8b 12             	mov    (%rdx),%rdx
  8004204003:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204007:	48 39 d0             	cmp    %rdx,%rax
  800420400a:	72 35                	jb     8004204041 <check_page_alloc+0x50d>
  800420400c:	48 b9 a5 6a 21 04 80 	movabs $0x8004216aa5,%rcx
  8004204013:	00 00 00 
  8004204016:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420401d:	00 00 00 
  8004204020:	be ca 03 00 00       	mov    $0x3ca,%esi
  8004204025:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420402c:	00 00 00 
  800420402f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204034:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420403b:	00 00 00 
  800420403e:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204041:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204045:	48 89 c7             	mov    %rax,%rdi
  8004204048:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  800420404f:	00 00 00 
  8004204052:	ff d0                	callq  *%rax
  8004204054:	48 ba 30 f7 6b 04 80 	movabs $0x80046bf730,%rdx
  800420405b:	00 00 00 
  800420405e:	48 8b 12             	mov    (%rdx),%rdx
  8004204061:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204065:	48 39 d0             	cmp    %rdx,%rax
  8004204068:	72 35                	jb     800420409f <check_page_alloc+0x56b>
  800420406a:	48 b9 c2 6a 21 04 80 	movabs $0x8004216ac2,%rcx
  8004204071:	00 00 00 
  8004204074:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420407b:	00 00 00 
  800420407e:	be cb 03 00 00       	mov    $0x3cb,%esi
  8004204083:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420408a:	00 00 00 
  800420408d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204092:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204099:	00 00 00 
  800420409c:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  800420409f:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  80042040a6:	00 00 00 
  80042040a9:	48 8b 00             	mov    (%rax),%rax
  80042040ac:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  80042040b0:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  80042040b7:	00 00 00 
  80042040ba:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  80042040c1:	bf 00 00 00 00       	mov    $0x0,%edi
  80042040c6:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  80042040cd:	00 00 00 
  80042040d0:	ff d0                	callq  *%rax
  80042040d2:	48 85 c0             	test   %rax,%rax
  80042040d5:	74 35                	je     800420410c <check_page_alloc+0x5d8>
  80042040d7:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  80042040de:	00 00 00 
  80042040e1:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042040e8:	00 00 00 
  80042040eb:	be d2 03 00 00       	mov    $0x3d2,%esi
  80042040f0:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042040f7:	00 00 00 
  80042040fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040ff:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204106:	00 00 00 
  8004204109:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  800420410c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204110:	48 89 c7             	mov    %rax,%rdi
  8004204113:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  800420411a:	00 00 00 
  800420411d:	ff d0                	callq  *%rax
	page_free(pp1);
  800420411f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204123:	48 89 c7             	mov    %rax,%rdi
  8004204126:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  800420412d:	00 00 00 
  8004204130:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204132:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204136:	48 89 c7             	mov    %rax,%rdi
  8004204139:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  8004204140:	00 00 00 
  8004204143:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204145:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420414c:	00 
  800420414d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204151:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204155:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204159:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  800420415d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204162:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004204169:	00 00 00 
  800420416c:	ff d0                	callq  *%rax
  800420416e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204172:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204177:	75 35                	jne    80042041ae <check_page_alloc+0x67a>
  8004204179:	48 b9 0f 6a 21 04 80 	movabs $0x8004216a0f,%rcx
  8004204180:	00 00 00 
  8004204183:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420418a:	00 00 00 
  800420418d:	be d9 03 00 00       	mov    $0x3d9,%esi
  8004204192:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204199:	00 00 00 
  800420419c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041a1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042041a8:	00 00 00 
  80042041ab:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042041ae:	bf 00 00 00 00       	mov    $0x0,%edi
  80042041b3:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  80042041ba:	00 00 00 
  80042041bd:	ff d0                	callq  *%rax
  80042041bf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042041c3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042041c8:	75 35                	jne    80042041ff <check_page_alloc+0x6cb>
  80042041ca:	48 b9 25 6a 21 04 80 	movabs $0x8004216a25,%rcx
  80042041d1:	00 00 00 
  80042041d4:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042041db:	00 00 00 
  80042041de:	be da 03 00 00       	mov    $0x3da,%esi
  80042041e3:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042041ea:	00 00 00 
  80042041ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041f2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042041f9:	00 00 00 
  80042041fc:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042041ff:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204204:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  800420420b:	00 00 00 
  800420420e:	ff d0                	callq  *%rax
  8004204210:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204214:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204219:	75 35                	jne    8004204250 <check_page_alloc+0x71c>
  800420421b:	48 b9 3b 6a 21 04 80 	movabs $0x8004216a3b,%rcx
  8004204222:	00 00 00 
  8004204225:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420422c:	00 00 00 
  800420422f:	be db 03 00 00       	mov    $0x3db,%esi
  8004204234:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420423b:	00 00 00 
  800420423e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204243:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420424a:	00 00 00 
  800420424d:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204250:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204255:	75 35                	jne    800420428c <check_page_alloc+0x758>
  8004204257:	48 b9 51 6a 21 04 80 	movabs $0x8004216a51,%rcx
  800420425e:	00 00 00 
  8004204261:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204268:	00 00 00 
  800420426b:	be dc 03 00 00       	mov    $0x3dc,%esi
  8004204270:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204277:	00 00 00 
  800420427a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420427f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204286:	00 00 00 
  8004204289:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  800420428c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204291:	74 0a                	je     800420429d <check_page_alloc+0x769>
  8004204293:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204297:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420429b:	75 35                	jne    80042042d2 <check_page_alloc+0x79e>
  800420429d:	48 b9 55 6a 21 04 80 	movabs $0x8004216a55,%rcx
  80042042a4:	00 00 00 
  80042042a7:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042042ae:	00 00 00 
  80042042b1:	be dd 03 00 00       	mov    $0x3dd,%esi
  80042042b6:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042042bd:	00 00 00 
  80042042c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042c5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042042cc:	00 00 00 
  80042042cf:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042042d2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042042d7:	74 14                	je     80042042ed <check_page_alloc+0x7b9>
  80042042d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042042dd:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042042e1:	74 0a                	je     80042042ed <check_page_alloc+0x7b9>
  80042042e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042042e7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042042eb:	75 35                	jne    8004204322 <check_page_alloc+0x7ee>
  80042042ed:	48 b9 68 6a 21 04 80 	movabs $0x8004216a68,%rcx
  80042042f4:	00 00 00 
  80042042f7:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042042fe:	00 00 00 
  8004204301:	be de 03 00 00       	mov    $0x3de,%esi
  8004204306:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420430d:	00 00 00 
  8004204310:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204315:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420431c:	00 00 00 
  800420431f:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204322:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204327:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  800420432e:	00 00 00 
  8004204331:	ff d0                	callq  *%rax
  8004204333:	48 85 c0             	test   %rax,%rax
  8004204336:	74 35                	je     800420436d <check_page_alloc+0x839>
  8004204338:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  800420433f:	00 00 00 
  8004204342:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204349:	00 00 00 
  800420434c:	be df 03 00 00       	mov    $0x3df,%esi
  8004204351:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204358:	00 00 00 
  800420435b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204360:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204367:	00 00 00 
  800420436a:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  800420436d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204371:	48 89 c7             	mov    %rax,%rdi
  8004204374:	48 b8 da 17 20 04 80 	movabs $0x80042017da,%rax
  800420437b:	00 00 00 
  800420437e:	ff d0                	callq  *%rax
  8004204380:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204385:	be 01 00 00 00       	mov    $0x1,%esi
  800420438a:	48 89 c7             	mov    %rax,%rdi
  800420438d:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004204394:	00 00 00 
  8004204397:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204399:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420439d:	48 89 c7             	mov    %rax,%rdi
  80042043a0:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  80042043a7:	00 00 00 
  80042043aa:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  80042043ac:	bf 01 00 00 00       	mov    $0x1,%edi
  80042043b1:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  80042043b8:	00 00 00 
  80042043bb:	ff d0                	callq  *%rax
  80042043bd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042043c1:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042043c6:	75 35                	jne    80042043fd <check_page_alloc+0x8c9>
  80042043c8:	48 b9 ee 6a 21 04 80 	movabs $0x8004216aee,%rcx
  80042043cf:	00 00 00 
  80042043d2:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042043d9:	00 00 00 
  80042043dc:	be e4 03 00 00       	mov    $0x3e4,%esi
  80042043e1:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042043e8:	00 00 00 
  80042043eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043f0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042043f7:	00 00 00 
  80042043fa:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  80042043fd:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204402:	74 0a                	je     800420440e <check_page_alloc+0x8da>
  8004204404:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204408:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420440c:	74 35                	je     8004204443 <check_page_alloc+0x90f>
  800420440e:	48 b9 0c 6b 21 04 80 	movabs $0x8004216b0c,%rcx
  8004204415:	00 00 00 
  8004204418:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420441f:	00 00 00 
  8004204422:	be e5 03 00 00       	mov    $0x3e5,%esi
  8004204427:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420442e:	00 00 00 
  8004204431:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204436:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420443d:	00 00 00 
  8004204440:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204443:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204447:	48 89 c7             	mov    %rax,%rdi
  800420444a:	48 b8 da 17 20 04 80 	movabs $0x80042017da,%rax
  8004204451:	00 00 00 
  8004204454:	ff d0                	callq  *%rax
  8004204456:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  800420445a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204461:	eb 4d                	jmp    80042044b0 <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204463:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204466:	48 63 d0             	movslq %eax,%rdx
  8004204469:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420446d:	48 01 d0             	add    %rdx,%rax
  8004204470:	0f b6 00             	movzbl (%rax),%eax
  8004204473:	84 c0                	test   %al,%al
  8004204475:	74 35                	je     80042044ac <check_page_alloc+0x978>
  8004204477:	48 b9 1c 6b 21 04 80 	movabs $0x8004216b1c,%rcx
  800420447e:	00 00 00 
  8004204481:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204488:	00 00 00 
  800420448b:	be e8 03 00 00       	mov    $0x3e8,%esi
  8004204490:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204497:	00 00 00 
  800420449a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420449f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042044a6:	00 00 00 
  80042044a9:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  80042044ac:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042044b0:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  80042044b7:	7e aa                	jle    8004204463 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  80042044b9:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  80042044c0:	00 00 00 
  80042044c3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042044c7:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  80042044ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044ce:	48 89 c7             	mov    %rax,%rdi
  80042044d1:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  80042044d8:	00 00 00 
  80042044db:	ff d0                	callq  *%rax
	page_free(pp1);
  80042044dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042044e1:	48 89 c7             	mov    %rax,%rdi
  80042044e4:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  80042044eb:	00 00 00 
  80042044ee:	ff d0                	callq  *%rax
	page_free(pp2);
  80042044f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042044f4:	48 89 c7             	mov    %rax,%rdi
  80042044f7:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  80042044fe:	00 00 00 
  8004204501:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004204503:	48 bf 28 6b 21 04 80 	movabs $0x8004216b28,%rdi
  800420450a:	00 00 00 
  800420450d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204512:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004204519:	00 00 00 
  800420451c:	ff d2                	callq  *%rdx
}
  800420451e:	c9                   	leaveq 
  800420451f:	c3                   	retq   

0000008004204520 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204520:	55                   	push   %rbp
  8004204521:	48 89 e5             	mov    %rsp,%rbp
  8004204524:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  800420452b:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204532:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004204539:	00 00 00 
  800420453c:	48 8b 00             	mov    (%rax),%rax
  800420453f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204543:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420454a:	00 
  800420454b:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004204552:	00 00 00 
  8004204555:	48 8b 00             	mov    (%rax),%rax
  8004204558:	48 c1 e0 04          	shl    $0x4,%rax
  800420455c:	48 89 c2             	mov    %rax,%rdx
  800420455f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204563:	48 01 d0             	add    %rdx,%rax
  8004204566:	48 83 e8 01          	sub    $0x1,%rax
  800420456a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420456e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204572:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204577:	48 f7 75 e0          	divq   -0x20(%rbp)
  800420457b:	48 89 d0             	mov    %rdx,%rax
  800420457e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204582:	48 29 c2             	sub    %rax,%rdx
  8004204585:	48 89 d0             	mov    %rdx,%rax
  8004204588:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  800420458c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204593:	00 
  8004204594:	e9 d4 00 00 00       	jmpq   800420466d <check_boot_pml4e+0x14d>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204599:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  80042045a0:	00 00 00 
  80042045a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045a7:	48 01 c2             	add    %rax,%rdx
  80042045aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042045ae:	48 89 d6             	mov    %rdx,%rsi
  80042045b1:	48 89 c7             	mov    %rax,%rdi
  80042045b4:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  80042045bb:	00 00 00 
  80042045be:	ff d0                	callq  *%rax
  80042045c0:	48 ba 38 f7 6b 04 80 	movabs $0x80046bf738,%rdx
  80042045c7:	00 00 00 
  80042045ca:	48 8b 12             	mov    (%rdx),%rdx
  80042045cd:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80042045d1:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042045d8:	00 00 00 
  80042045db:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  80042045df:	77 32                	ja     8004204613 <check_boot_pml4e+0xf3>
  80042045e1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042045e5:	48 89 c1             	mov    %rax,%rcx
  80042045e8:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042045ef:	00 00 00 
  80042045f2:	be 08 04 00 00       	mov    $0x408,%esi
  80042045f7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042045fe:	00 00 00 
  8004204601:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204606:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420460d:	00 00 00 
  8004204610:	41 ff d0             	callq  *%r8
  8004204613:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800420461a:	ff ff ff 
  800420461d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204621:	48 01 d1             	add    %rdx,%rcx
  8004204624:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204628:	48 01 ca             	add    %rcx,%rdx
  800420462b:	48 39 d0             	cmp    %rdx,%rax
  800420462e:	74 35                	je     8004204665 <check_boot_pml4e+0x145>
  8004204630:	48 b9 48 6b 21 04 80 	movabs $0x8004216b48,%rcx
  8004204637:	00 00 00 
  800420463a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204641:	00 00 00 
  8004204644:	be 08 04 00 00       	mov    $0x408,%esi
  8004204649:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204650:	00 00 00 
  8004204653:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204658:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420465f:	00 00 00 
  8004204662:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204665:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420466c:	00 
  800420466d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204671:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204675:	0f 82 1e ff ff ff    	jb     8004204599 <check_boot_pml4e+0x79>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  800420467b:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  8004204682:	00 
  8004204683:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204687:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  800420468d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204691:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204695:	ba 00 00 00 00       	mov    $0x0,%edx
  800420469a:	48 f7 75 c8          	divq   -0x38(%rbp)
  800420469e:	48 89 d0             	mov    %rdx,%rax
  80042046a1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042046a5:	48 29 c2             	sub    %rax,%rdx
  80042046a8:	48 89 d0             	mov    %rdx,%rax
  80042046ab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  80042046af:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042046b6:	00 
  80042046b7:	e9 d4 00 00 00       	jmpq   8004204790 <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  80042046bc:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80042046c3:	00 00 00 
  80042046c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046ca:	48 01 c2             	add    %rax,%rdx
  80042046cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046d1:	48 89 d6             	mov    %rdx,%rsi
  80042046d4:	48 89 c7             	mov    %rax,%rdi
  80042046d7:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  80042046de:	00 00 00 
  80042046e1:	ff d0                	callq  *%rax
  80042046e3:	48 ba 50 e2 6b 04 80 	movabs $0x80046be250,%rdx
  80042046ea:	00 00 00 
  80042046ed:	48 8b 12             	mov    (%rdx),%rdx
  80042046f0:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042046f4:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042046fb:	00 00 00 
  80042046fe:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8004204702:	77 32                	ja     8004204736 <check_boot_pml4e+0x216>
  8004204704:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204708:	48 89 c1             	mov    %rax,%rcx
  800420470b:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  8004204712:	00 00 00 
  8004204715:	be 0e 04 00 00       	mov    $0x40e,%esi
  800420471a:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204721:	00 00 00 
  8004204724:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204729:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204730:	00 00 00 
  8004204733:	41 ff d0             	callq  *%r8
  8004204736:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800420473d:	ff ff ff 
  8004204740:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004204744:	48 01 d1             	add    %rdx,%rcx
  8004204747:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420474b:	48 01 ca             	add    %rcx,%rdx
  800420474e:	48 39 d0             	cmp    %rdx,%rax
  8004204751:	74 35                	je     8004204788 <check_boot_pml4e+0x268>
  8004204753:	48 b9 80 6b 21 04 80 	movabs $0x8004216b80,%rcx
  800420475a:	00 00 00 
  800420475d:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204764:	00 00 00 
  8004204767:	be 0e 04 00 00       	mov    $0x40e,%esi
  800420476c:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204773:	00 00 00 
  8004204776:	b8 00 00 00 00       	mov    $0x0,%eax
  800420477b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204782:	00 00 00 
  8004204785:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204788:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420478f:	00 
  8004204790:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204794:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204798:	0f 82 1e ff ff ff    	jb     80042046bc <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  800420479e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042047a5:	00 
  80042047a6:	eb 6a                	jmp    8004204812 <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  80042047a8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042047af:	00 00 00 
  80042047b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047b6:	48 01 c2             	add    %rax,%rdx
  80042047b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042047bd:	48 89 d6             	mov    %rdx,%rsi
  80042047c0:	48 89 c7             	mov    %rax,%rdi
  80042047c3:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  80042047ca:	00 00 00 
  80042047cd:	ff d0                	callq  *%rax
  80042047cf:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042047d3:	74 35                	je     800420480a <check_boot_pml4e+0x2ea>
  80042047d5:	48 b9 b8 6b 21 04 80 	movabs $0x8004216bb8,%rcx
  80042047dc:	00 00 00 
  80042047df:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042047e6:	00 00 00 
  80042047e9:	be 12 04 00 00       	mov    $0x412,%esi
  80042047ee:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042047f5:	00 00 00 
  80042047f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047fd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204804:	00 00 00 
  8004204807:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  800420480a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204811:	00 
  8004204812:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004204819:	00 00 00 
  800420481c:	48 8b 00             	mov    (%rax),%rax
  800420481f:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204823:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204827:	0f 87 7b ff ff ff    	ja     80042047a8 <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  800420482d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204834:	00 
  8004204835:	e9 a1 01 00 00       	jmpq   80042049db <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  800420483a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420483e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004204842:	48 89 d0             	mov    %rdx,%rax
  8004204845:	48 01 c0             	add    %rax,%rax
  8004204848:	48 01 d0             	add    %rdx,%rax
  800420484b:	48 c1 e0 0f          	shl    $0xf,%rax
  800420484f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204856:	00 00 00 
  8004204859:	48 29 c2             	sub    %rax,%rdx
  800420485c:	48 89 d0             	mov    %rdx,%rax
  800420485f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204863:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420486a:	00 
  800420486b:	e9 e0 00 00 00       	jmpq   8004204950 <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004204870:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204874:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204878:	48 01 d0             	add    %rdx,%rax
  800420487b:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004204882:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204886:	48 89 d6             	mov    %rdx,%rsi
  8004204889:	48 89 c7             	mov    %rax,%rdi
  800420488c:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004204893:	00 00 00 
  8004204896:	ff d0                	callq  *%rax
  8004204898:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420489c:	48 89 d1             	mov    %rdx,%rcx
  800420489f:	48 c1 e1 10          	shl    $0x10,%rcx
  80042048a3:	48 ba 00 20 6c 04 80 	movabs $0x80046c2000,%rdx
  80042048aa:	00 00 00 
  80042048ad:	48 01 ca             	add    %rcx,%rdx
  80042048b0:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042048b4:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042048bb:	00 00 00 
  80042048be:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  80042048c2:	77 32                	ja     80042048f6 <check_boot_pml4e+0x3d6>
  80042048c4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042048c8:	48 89 c1             	mov    %rax,%rcx
  80042048cb:	48 ba 68 67 21 04 80 	movabs $0x8004216768,%rdx
  80042048d2:	00 00 00 
  80042048d5:	be 1a 04 00 00       	mov    $0x41a,%esi
  80042048da:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042048e1:	00 00 00 
  80042048e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048e9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042048f0:	00 00 00 
  80042048f3:	41 ff d0             	callq  *%r8
  80042048f6:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042048fd:	ff ff ff 
  8004204900:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004204904:	48 01 d1             	add    %rdx,%rcx
  8004204907:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420490b:	48 01 ca             	add    %rcx,%rdx
  800420490e:	48 39 d0             	cmp    %rdx,%rax
  8004204911:	74 35                	je     8004204948 <check_boot_pml4e+0x428>
  8004204913:	48 b9 e0 6b 21 04 80 	movabs $0x8004216be0,%rcx
  800420491a:	00 00 00 
  800420491d:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204924:	00 00 00 
  8004204927:	be 1a 04 00 00       	mov    $0x41a,%esi
  800420492c:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204933:	00 00 00 
  8004204936:	b8 00 00 00 00       	mov    $0x0,%eax
  800420493b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204942:	00 00 00 
  8004204945:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204948:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420494f:	00 
  8004204950:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  8004204957:	00 
  8004204958:	0f 86 12 ff ff ff    	jbe    8004204870 <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  800420495e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204965:	00 
  8004204966:	eb 64                	jmp    80042049cc <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004204968:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420496c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204970:	48 01 c2             	add    %rax,%rdx
  8004204973:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204977:	48 89 d6             	mov    %rdx,%rsi
  800420497a:	48 89 c7             	mov    %rax,%rdi
  800420497d:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004204984:	00 00 00 
  8004204987:	ff d0                	callq  *%rax
  8004204989:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420498d:	74 35                	je     80042049c4 <check_boot_pml4e+0x4a4>
  800420498f:	48 b9 28 6c 21 04 80 	movabs $0x8004216c28,%rcx
  8004204996:	00 00 00 
  8004204999:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042049a0:	00 00 00 
  80042049a3:	be 1c 04 00 00       	mov    $0x41c,%esi
  80042049a8:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042049af:	00 00 00 
  80042049b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049b7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042049be:	00 00 00 
  80042049c1:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  80042049c4:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042049cb:	00 
  80042049cc:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  80042049d3:	00 
  80042049d4:	76 92                	jbe    8004204968 <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  80042049d6:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042049db:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  80042049e0:	0f 86 54 fe ff ff    	jbe    800420483a <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  80042049e6:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042049ed:	00 00 00 
  80042049f0:	48 8b 00             	mov    (%rax),%rax
  80042049f3:	48 83 c0 08          	add    $0x8,%rax
  80042049f7:	48 8b 00             	mov    (%rax),%rax
  80042049fa:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204a00:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004204a04:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204a08:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204a0c:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004204a0f:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004204a12:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004204a19:	00 00 00 
  8004204a1c:	48 8b 00             	mov    (%rax),%rax
  8004204a1f:	48 39 c2             	cmp    %rax,%rdx
  8004204a22:	72 32                	jb     8004204a56 <check_boot_pml4e+0x536>
  8004204a24:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204a28:	48 89 c1             	mov    %rax,%rcx
  8004204a2b:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004204a32:	00 00 00 
  8004204a35:	be 1f 04 00 00       	mov    $0x41f,%esi
  8004204a3a:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204a41:	00 00 00 
  8004204a44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a49:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204a50:	00 00 00 
  8004204a53:	41 ff d0             	callq  *%r8
  8004204a56:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204a5d:	00 00 00 
  8004204a60:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204a64:	48 01 d0             	add    %rdx,%rax
  8004204a67:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004204a6b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204a6f:	48 8b 00             	mov    (%rax),%rax
  8004204a72:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204a78:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004204a7c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204a80:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204a84:	89 45 84             	mov    %eax,-0x7c(%rbp)
  8004204a87:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004204a8a:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004204a91:	00 00 00 
  8004204a94:	48 8b 00             	mov    (%rax),%rax
  8004204a97:	48 39 c2             	cmp    %rax,%rdx
  8004204a9a:	72 32                	jb     8004204ace <check_boot_pml4e+0x5ae>
  8004204a9c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204aa0:	48 89 c1             	mov    %rax,%rcx
  8004204aa3:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004204aaa:	00 00 00 
  8004204aad:	be 20 04 00 00       	mov    $0x420,%esi
  8004204ab2:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204ab9:	00 00 00 
  8004204abc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ac1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204ac8:	00 00 00 
  8004204acb:	41 ff d0             	callq  *%r8
  8004204ace:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204ad5:	00 00 00 
  8004204ad8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004204adc:	48 01 d0             	add    %rdx,%rax
  8004204adf:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204ae6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204aed:	00 
  8004204aee:	e9 50 01 00 00       	jmpq   8004204c43 <check_boot_pml4e+0x723>
		switch (i) {
  8004204af3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204af7:	48 83 f8 04          	cmp    $0x4,%rax
  8004204afb:	72 67                	jb     8004204b64 <check_boot_pml4e+0x644>
  8004204afd:	48 83 f8 05          	cmp    $0x5,%rax
  8004204b01:	76 06                	jbe    8004204b09 <check_boot_pml4e+0x5e9>
  8004204b03:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004204b07:	75 5b                	jne    8004204b64 <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  8004204b09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b0d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204b14:	00 
  8004204b15:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204b1c:	48 01 d0             	add    %rdx,%rax
  8004204b1f:	48 8b 00             	mov    (%rax),%rax
  8004204b22:	83 e0 01             	and    $0x1,%eax
  8004204b25:	48 85 c0             	test   %rax,%rax
  8004204b28:	75 35                	jne    8004204b5f <check_boot_pml4e+0x63f>
  8004204b2a:	48 b9 4b 6c 21 04 80 	movabs $0x8004216c4b,%rcx
  8004204b31:	00 00 00 
  8004204b34:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204b3b:	00 00 00 
  8004204b3e:	be 28 04 00 00       	mov    $0x428,%esi
  8004204b43:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204b4a:	00 00 00 
  8004204b4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b52:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204b59:	00 00 00 
  8004204b5c:	41 ff d0             	callq  *%r8
			break;
  8004204b5f:	e9 da 00 00 00       	jmpq   8004204c3e <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  8004204b64:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004204b69:	0f 86 ce 00 00 00    	jbe    8004204c3d <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  8004204b6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b73:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204b7a:	00 
  8004204b7b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204b82:	48 01 d0             	add    %rdx,%rax
  8004204b85:	48 8b 00             	mov    (%rax),%rax
  8004204b88:	83 e0 01             	and    $0x1,%eax
  8004204b8b:	48 85 c0             	test   %rax,%rax
  8004204b8e:	74 5a                	je     8004204bea <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  8004204b90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b94:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204b9b:	00 
  8004204b9c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204ba3:	48 01 d0             	add    %rdx,%rax
  8004204ba6:	48 8b 00             	mov    (%rax),%rax
  8004204ba9:	83 e0 02             	and    $0x2,%eax
  8004204bac:	48 85 c0             	test   %rax,%rax
  8004204baf:	0f 85 88 00 00 00    	jne    8004204c3d <check_boot_pml4e+0x71d>
  8004204bb5:	48 b9 5c 6c 21 04 80 	movabs $0x8004216c5c,%rcx
  8004204bbc:	00 00 00 
  8004204bbf:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204bc6:	00 00 00 
  8004204bc9:	be 2d 04 00 00       	mov    $0x42d,%esi
  8004204bce:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204bd5:	00 00 00 
  8004204bd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bdd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204be4:	00 00 00 
  8004204be7:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  8004204bea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204bee:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204bf5:	00 
  8004204bf6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204bfd:	48 01 d0             	add    %rdx,%rax
  8004204c00:	48 8b 00             	mov    (%rax),%rax
  8004204c03:	48 85 c0             	test   %rax,%rax
  8004204c06:	74 35                	je     8004204c3d <check_boot_pml4e+0x71d>
  8004204c08:	48 b9 6d 6c 21 04 80 	movabs $0x8004216c6d,%rcx
  8004204c0f:	00 00 00 
  8004204c12:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204c19:	00 00 00 
  8004204c1c:	be 2f 04 00 00       	mov    $0x42f,%esi
  8004204c21:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204c28:	00 00 00 
  8004204c2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c30:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204c37:	00 00 00 
  8004204c3a:	41 ff d0             	callq  *%r8
			}
			break;
  8004204c3d:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204c3e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004204c43:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004204c4a:	00 
  8004204c4b:	0f 86 a2 fe ff ff    	jbe    8004204af3 <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			}
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004204c51:	48 bf 80 6c 21 04 80 	movabs $0x8004216c80,%rdi
  8004204c58:	00 00 00 
  8004204c5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c60:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004204c67:	00 00 00 
  8004204c6a:	ff d2                	callq  *%rdx
}
  8004204c6c:	c9                   	leaveq 
  8004204c6d:	c3                   	retq   

0000008004204c6e <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004204c6e:	55                   	push   %rbp
  8004204c6f:	48 89 e5             	mov    %rsp,%rbp
  8004204c72:	48 83 ec 60          	sub    $0x60,%rsp
  8004204c76:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004204c7a:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  8004204c7e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204c82:	48 c1 e8 27          	shr    $0x27,%rax
  8004204c86:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204c8b:	48 c1 e0 03          	shl    $0x3,%rax
  8004204c8f:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  8004204c93:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204c97:	48 8b 00             	mov    (%rax),%rax
  8004204c9a:	83 e0 01             	and    $0x1,%eax
  8004204c9d:	48 85 c0             	test   %rax,%rax
  8004204ca0:	75 0c                	jne    8004204cae <check_va2pa+0x40>
		return ~0;
  8004204ca2:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204ca9:	e9 38 02 00 00       	jmpq   8004204ee6 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004204cae:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204cb2:	48 8b 00             	mov    (%rax),%rax
  8004204cb5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204cbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204cbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204cc3:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204cc7:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004204cca:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004204ccd:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004204cd4:	00 00 00 
  8004204cd7:	48 8b 00             	mov    (%rax),%rax
  8004204cda:	48 39 c2             	cmp    %rax,%rdx
  8004204cdd:	72 32                	jb     8004204d11 <check_va2pa+0xa3>
  8004204cdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ce3:	48 89 c1             	mov    %rax,%rcx
  8004204ce6:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004204ced:	00 00 00 
  8004204cf0:	be 47 04 00 00       	mov    $0x447,%esi
  8004204cf5:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204cfc:	00 00 00 
  8004204cff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d04:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204d0b:	00 00 00 
  8004204d0e:	41 ff d0             	callq  *%r8
  8004204d11:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204d18:	00 00 00 
  8004204d1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d1f:	48 01 d0             	add    %rdx,%rax
  8004204d22:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004204d26:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204d2a:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004204d2e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204d33:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204d3a:	00 
  8004204d3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d3f:	48 01 d0             	add    %rdx,%rax
  8004204d42:	48 8b 00             	mov    (%rax),%rax
  8004204d45:	83 e0 01             	and    $0x1,%eax
  8004204d48:	48 85 c0             	test   %rax,%rax
  8004204d4b:	75 0c                	jne    8004204d59 <check_va2pa+0xeb>
		return ~0;
  8004204d4d:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204d54:	e9 8d 01 00 00       	jmpq   8004204ee6 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004204d59:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204d5d:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004204d61:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204d66:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204d6d:	00 
  8004204d6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d72:	48 01 d0             	add    %rdx,%rax
  8004204d75:	48 8b 00             	mov    (%rax),%rax
  8004204d78:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204d7e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204d82:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d86:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204d8a:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004204d8d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004204d90:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004204d97:	00 00 00 
  8004204d9a:	48 8b 00             	mov    (%rax),%rax
  8004204d9d:	48 39 c2             	cmp    %rax,%rdx
  8004204da0:	72 32                	jb     8004204dd4 <check_va2pa+0x166>
  8004204da2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204da6:	48 89 c1             	mov    %rax,%rcx
  8004204da9:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004204db0:	00 00 00 
  8004204db3:	be 4b 04 00 00       	mov    $0x44b,%esi
  8004204db8:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204dbf:	00 00 00 
  8004204dc2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204dc7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204dce:	00 00 00 
  8004204dd1:	41 ff d0             	callq  *%r8
  8004204dd4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204ddb:	00 00 00 
  8004204dde:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204de2:	48 01 d0             	add    %rdx,%rax
  8004204de5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004204de9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204ded:	48 c1 e8 15          	shr    $0x15,%rax
  8004204df1:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204df6:	48 c1 e0 03          	shl    $0x3,%rax
  8004204dfa:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004204dfe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204e02:	48 8b 00             	mov    (%rax),%rax
  8004204e05:	83 e0 01             	and    $0x1,%eax
  8004204e08:	48 85 c0             	test   %rax,%rax
  8004204e0b:	75 0c                	jne    8004204e19 <check_va2pa+0x1ab>
		return ~0;
  8004204e0d:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204e14:	e9 cd 00 00 00       	jmpq   8004204ee6 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004204e19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204e1d:	48 8b 00             	mov    (%rax),%rax
  8004204e20:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204e26:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204e2a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204e2e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204e32:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004204e35:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004204e38:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004204e3f:	00 00 00 
  8004204e42:	48 8b 00             	mov    (%rax),%rax
  8004204e45:	48 39 c2             	cmp    %rax,%rdx
  8004204e48:	72 32                	jb     8004204e7c <check_va2pa+0x20e>
  8004204e4a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204e4e:	48 89 c1             	mov    %rax,%rcx
  8004204e51:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004204e58:	00 00 00 
  8004204e5b:	be 50 04 00 00       	mov    $0x450,%esi
  8004204e60:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204e67:	00 00 00 
  8004204e6a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e6f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204e76:	00 00 00 
  8004204e79:	41 ff d0             	callq  *%r8
  8004204e7c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204e83:	00 00 00 
  8004204e86:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204e8a:	48 01 d0             	add    %rdx,%rax
  8004204e8d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004204e91:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204e95:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204e99:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204e9e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204ea5:	00 
  8004204ea6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204eaa:	48 01 d0             	add    %rdx,%rax
  8004204ead:	48 8b 00             	mov    (%rax),%rax
  8004204eb0:	83 e0 01             	and    $0x1,%eax
  8004204eb3:	48 85 c0             	test   %rax,%rax
  8004204eb6:	75 09                	jne    8004204ec1 <check_va2pa+0x253>
		return ~0;
  8004204eb8:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204ebf:	eb 25                	jmp    8004204ee6 <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004204ec1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204ec5:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204ec9:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204ece:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204ed5:	00 
  8004204ed6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204eda:	48 01 d0             	add    %rdx,%rax
  8004204edd:	48 8b 00             	mov    (%rax),%rax
  8004204ee0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004204ee6:	c9                   	leaveq 
  8004204ee7:	c3                   	retq   

0000008004204ee8 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004204ee8:	55                   	push   %rbp
  8004204ee9:	48 89 e5             	mov    %rsp,%rbp
  8004204eec:	53                   	push   %rbx
  8004204eed:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004204ef4:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004204efb:	00 
  8004204efc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204f00:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204f04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204f08:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204f0c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204f10:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204f14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204f18:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204f1c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204f20:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004204f24:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204f29:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004204f30:	00 00 00 
  8004204f33:	ff d0                	callq  *%rax
  8004204f35:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004204f39:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004204f3e:	75 35                	jne    8004204f75 <page_check+0x8d>
  8004204f40:	48 b9 9f 6c 21 04 80 	movabs $0x8004216c9f,%rcx
  8004204f47:	00 00 00 
  8004204f4a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204f51:	00 00 00 
  8004204f54:	be 66 04 00 00       	mov    $0x466,%esi
  8004204f59:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204f60:	00 00 00 
  8004204f63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f68:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204f6f:	00 00 00 
  8004204f72:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004204f75:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204f7a:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004204f81:	00 00 00 
  8004204f84:	ff d0                	callq  *%rax
  8004204f86:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204f8a:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004204f8f:	75 35                	jne    8004204fc6 <page_check+0xde>
  8004204f91:	48 b9 b3 6c 21 04 80 	movabs $0x8004216cb3,%rcx
  8004204f98:	00 00 00 
  8004204f9b:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204fa2:	00 00 00 
  8004204fa5:	be 67 04 00 00       	mov    $0x467,%esi
  8004204faa:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004204fb1:	00 00 00 
  8004204fb4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fb9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204fc0:	00 00 00 
  8004204fc3:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004204fc6:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204fcb:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004204fd2:	00 00 00 
  8004204fd5:	ff d0                	callq  *%rax
  8004204fd7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204fdb:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004204fe0:	75 35                	jne    8004205017 <page_check+0x12f>
  8004204fe2:	48 b9 c7 6c 21 04 80 	movabs $0x8004216cc7,%rcx
  8004204fe9:	00 00 00 
  8004204fec:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004204ff3:	00 00 00 
  8004204ff6:	be 68 04 00 00       	mov    $0x468,%esi
  8004204ffb:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205002:	00 00 00 
  8004205005:	b8 00 00 00 00       	mov    $0x0,%eax
  800420500a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205011:	00 00 00 
  8004205014:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004205017:	bf 00 00 00 00       	mov    $0x0,%edi
  800420501c:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004205023:	00 00 00 
  8004205026:	ff d0                	callq  *%rax
  8004205028:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420502c:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205031:	75 35                	jne    8004205068 <page_check+0x180>
  8004205033:	48 b9 db 6c 21 04 80 	movabs $0x8004216cdb,%rcx
  800420503a:	00 00 00 
  800420503d:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205044:	00 00 00 
  8004205047:	be 69 04 00 00       	mov    $0x469,%esi
  800420504c:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205053:	00 00 00 
  8004205056:	b8 00 00 00 00       	mov    $0x0,%eax
  800420505b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205062:	00 00 00 
  8004205065:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205068:	bf 00 00 00 00       	mov    $0x0,%edi
  800420506d:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004205074:	00 00 00 
  8004205077:	ff d0                	callq  *%rax
  8004205079:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420507d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205082:	75 35                	jne    80042050b9 <page_check+0x1d1>
  8004205084:	48 b9 ef 6c 21 04 80 	movabs $0x8004216cef,%rcx
  800420508b:	00 00 00 
  800420508e:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205095:	00 00 00 
  8004205098:	be 6a 04 00 00       	mov    $0x46a,%esi
  800420509d:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042050a4:	00 00 00 
  80042050a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050ac:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042050b3:	00 00 00 
  80042050b6:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  80042050b9:	bf 00 00 00 00       	mov    $0x0,%edi
  80042050be:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  80042050c5:	00 00 00 
  80042050c8:	ff d0                	callq  *%rax
  80042050ca:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042050ce:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042050d3:	75 35                	jne    800420510a <page_check+0x222>
  80042050d5:	48 b9 03 6d 21 04 80 	movabs $0x8004216d03,%rcx
  80042050dc:	00 00 00 
  80042050df:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042050e6:	00 00 00 
  80042050e9:	be 6b 04 00 00       	mov    $0x46b,%esi
  80042050ee:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042050f5:	00 00 00 
  80042050f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050fd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205104:	00 00 00 
  8004205107:	41 ff d0             	callq  *%r8

	assert(pp0);
  800420510a:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800420510f:	75 35                	jne    8004205146 <page_check+0x25e>
  8004205111:	48 b9 51 6a 21 04 80 	movabs $0x8004216a51,%rcx
  8004205118:	00 00 00 
  800420511b:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205122:	00 00 00 
  8004205125:	be 6d 04 00 00       	mov    $0x46d,%esi
  800420512a:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205131:	00 00 00 
  8004205134:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205139:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205140:	00 00 00 
  8004205143:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205146:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420514b:	74 0a                	je     8004205157 <page_check+0x26f>
  800420514d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205151:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205155:	75 35                	jne    800420518c <page_check+0x2a4>
  8004205157:	48 b9 55 6a 21 04 80 	movabs $0x8004216a55,%rcx
  800420515e:	00 00 00 
  8004205161:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205168:	00 00 00 
  800420516b:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004205170:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205177:	00 00 00 
  800420517a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420517f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205186:	00 00 00 
  8004205189:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420518c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205191:	74 14                	je     80042051a7 <page_check+0x2bf>
  8004205193:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205197:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420519b:	74 0a                	je     80042051a7 <page_check+0x2bf>
  800420519d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042051a1:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042051a5:	75 35                	jne    80042051dc <page_check+0x2f4>
  80042051a7:	48 b9 68 6a 21 04 80 	movabs $0x8004216a68,%rcx
  80042051ae:	00 00 00 
  80042051b1:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042051b8:	00 00 00 
  80042051bb:	be 6f 04 00 00       	mov    $0x46f,%esi
  80042051c0:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042051c7:	00 00 00 
  80042051ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051cf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042051d6:	00 00 00 
  80042051d9:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  80042051dc:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042051e1:	74 1e                	je     8004205201 <page_check+0x319>
  80042051e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042051e7:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042051eb:	74 14                	je     8004205201 <page_check+0x319>
  80042051ed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042051f1:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042051f5:	74 0a                	je     8004205201 <page_check+0x319>
  80042051f7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042051fb:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042051ff:	75 35                	jne    8004205236 <page_check+0x34e>
  8004205201:	48 b9 18 6d 21 04 80 	movabs $0x8004216d18,%rcx
  8004205208:	00 00 00 
  800420520b:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205212:	00 00 00 
  8004205215:	be 70 04 00 00       	mov    $0x470,%esi
  800420521a:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205221:	00 00 00 
  8004205224:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205229:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205230:	00 00 00 
  8004205233:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205236:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420523b:	74 28                	je     8004205265 <page_check+0x37d>
  800420523d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205241:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205245:	74 1e                	je     8004205265 <page_check+0x37d>
  8004205247:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420524b:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420524f:	74 14                	je     8004205265 <page_check+0x37d>
  8004205251:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205255:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205259:	74 0a                	je     8004205265 <page_check+0x37d>
  800420525b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420525f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205263:	75 35                	jne    800420529a <page_check+0x3b2>
  8004205265:	48 b9 48 6d 21 04 80 	movabs $0x8004216d48,%rcx
  800420526c:	00 00 00 
  800420526f:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205276:	00 00 00 
  8004205279:	be 71 04 00 00       	mov    $0x471,%esi
  800420527e:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205285:	00 00 00 
  8004205288:	b8 00 00 00 00       	mov    $0x0,%eax
  800420528d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205294:	00 00 00 
  8004205297:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  800420529a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420529f:	74 32                	je     80042052d3 <page_check+0x3eb>
  80042052a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042052a5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042052a9:	74 28                	je     80042052d3 <page_check+0x3eb>
  80042052ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042052af:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042052b3:	74 1e                	je     80042052d3 <page_check+0x3eb>
  80042052b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042052b9:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042052bd:	74 14                	je     80042052d3 <page_check+0x3eb>
  80042052bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042052c3:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042052c7:	74 0a                	je     80042052d3 <page_check+0x3eb>
  80042052c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042052cd:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042052d1:	75 35                	jne    8004205308 <page_check+0x420>
  80042052d3:	48 b9 88 6d 21 04 80 	movabs $0x8004216d88,%rcx
  80042052da:	00 00 00 
  80042052dd:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042052e4:	00 00 00 
  80042052e7:	be 72 04 00 00       	mov    $0x472,%esi
  80042052ec:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042052f3:	00 00 00 
  80042052f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052fb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205302:	00 00 00 
  8004205305:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205308:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  800420530f:	00 00 00 
  8004205312:	48 8b 00             	mov    (%rax),%rax
  8004205315:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205319:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004205320:	00 00 00 
  8004205323:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  800420532a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420532f:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004205336:	00 00 00 
  8004205339:	ff d0                	callq  *%rax
  800420533b:	48 85 c0             	test   %rax,%rax
  800420533e:	74 35                	je     8004205375 <page_check+0x48d>
  8004205340:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  8004205347:	00 00 00 
  800420534a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205351:	00 00 00 
  8004205354:	be 79 04 00 00       	mov    $0x479,%esi
  8004205359:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205360:	00 00 00 
  8004205363:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205368:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420536f:	00 00 00 
  8004205372:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205375:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  800420537c:	00 00 00 
  800420537f:	48 8b 00             	mov    (%rax),%rax
  8004205382:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  8004205389:	be 00 00 00 00       	mov    $0x0,%esi
  800420538e:	48 89 c7             	mov    %rax,%rdi
  8004205391:	48 b8 6e 31 20 04 80 	movabs $0x800420316e,%rax
  8004205398:	00 00 00 
  800420539b:	ff d0                	callq  *%rax
  800420539d:	48 85 c0             	test   %rax,%rax
  80042053a0:	74 35                	je     80042053d7 <page_check+0x4ef>
  80042053a2:	48 b9 d8 6d 21 04 80 	movabs $0x8004216dd8,%rcx
  80042053a9:	00 00 00 
  80042053ac:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042053b3:	00 00 00 
  80042053b6:	be 7c 04 00 00       	mov    $0x47c,%esi
  80042053bb:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042053c2:	00 00 00 
  80042053c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053ca:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042053d1:	00 00 00 
  80042053d4:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042053d7:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042053de:	00 00 00 
  80042053e1:	48 8b 00             	mov    (%rax),%rax
  80042053e4:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042053e8:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042053ed:	ba 00 00 00 00       	mov    $0x0,%edx
  80042053f2:	48 89 c7             	mov    %rax,%rdi
  80042053f5:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  80042053fc:	00 00 00 
  80042053ff:	ff d0                	callq  *%rax
  8004205401:	85 c0                	test   %eax,%eax
  8004205403:	78 35                	js     800420543a <page_check+0x552>
  8004205405:	48 b9 10 6e 21 04 80 	movabs $0x8004216e10,%rcx
  800420540c:	00 00 00 
  800420540f:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205416:	00 00 00 
  8004205419:	be 7f 04 00 00       	mov    $0x47f,%esi
  800420541e:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205425:	00 00 00 
  8004205428:	b8 00 00 00 00       	mov    $0x0,%eax
  800420542d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205434:	00 00 00 
  8004205437:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  800420543a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420543e:	48 89 c7             	mov    %rax,%rdi
  8004205441:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  8004205448:	00 00 00 
  800420544b:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420544d:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205454:	00 00 00 
  8004205457:	48 8b 00             	mov    (%rax),%rax
  800420545a:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420545e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205463:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205468:	48 89 c7             	mov    %rax,%rdi
  800420546b:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  8004205472:	00 00 00 
  8004205475:	ff d0                	callq  *%rax
  8004205477:	85 c0                	test   %eax,%eax
  8004205479:	78 35                	js     80042054b0 <page_check+0x5c8>
  800420547b:	48 b9 10 6e 21 04 80 	movabs $0x8004216e10,%rcx
  8004205482:	00 00 00 
  8004205485:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420548c:	00 00 00 
  800420548f:	be 83 04 00 00       	mov    $0x483,%esi
  8004205494:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420549b:	00 00 00 
  800420549e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054a3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042054aa:	00 00 00 
  80042054ad:	41 ff d0             	callq  *%r8
	page_free(pp2);
  80042054b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042054b4:	48 89 c7             	mov    %rax,%rdi
  80042054b7:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  80042054be:	00 00 00 
  80042054c1:	ff d0                	callq  *%rax
	page_free(pp3);
  80042054c3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042054c7:	48 89 c7             	mov    %rax,%rdi
  80042054ca:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  80042054d1:	00 00 00 
  80042054d4:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  80042054d6:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042054dd:	00 00 00 
  80042054e0:	48 8b 00             	mov    (%rax),%rax
  80042054e3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042054e7:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042054ec:	ba 00 00 00 00       	mov    $0x0,%edx
  80042054f1:	48 89 c7             	mov    %rax,%rdi
  80042054f4:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  80042054fb:	00 00 00 
  80042054fe:	ff d0                	callq  *%rax
  8004205500:	85 c0                	test   %eax,%eax
  8004205502:	74 35                	je     8004205539 <page_check+0x651>
  8004205504:	48 b9 40 6e 21 04 80 	movabs $0x8004216e40,%rcx
  800420550b:	00 00 00 
  800420550e:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205515:	00 00 00 
  8004205518:	be 89 04 00 00       	mov    $0x489,%esi
  800420551d:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205524:	00 00 00 
  8004205527:	b8 00 00 00 00       	mov    $0x0,%eax
  800420552c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205533:	00 00 00 
  8004205536:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205539:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205540:	00 00 00 
  8004205543:	48 8b 00             	mov    (%rax),%rax
  8004205546:	48 8b 00             	mov    (%rax),%rax
  8004205549:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420554f:	48 89 c3             	mov    %rax,%rbx
  8004205552:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205556:	48 89 c7             	mov    %rax,%rdi
  8004205559:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004205560:	00 00 00 
  8004205563:	ff d0                	callq  *%rax
  8004205565:	48 39 c3             	cmp    %rax,%rbx
  8004205568:	0f 84 97 00 00 00    	je     8004205605 <page_check+0x71d>
  800420556e:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205575:	00 00 00 
  8004205578:	48 8b 00             	mov    (%rax),%rax
  800420557b:	48 8b 00             	mov    (%rax),%rax
  800420557e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205584:	48 89 c3             	mov    %rax,%rbx
  8004205587:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420558b:	48 89 c7             	mov    %rax,%rdi
  800420558e:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004205595:	00 00 00 
  8004205598:	ff d0                	callq  *%rax
  800420559a:	48 39 c3             	cmp    %rax,%rbx
  800420559d:	74 66                	je     8004205605 <page_check+0x71d>
  800420559f:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042055a6:	00 00 00 
  80042055a9:	48 8b 00             	mov    (%rax),%rax
  80042055ac:	48 8b 00             	mov    (%rax),%rax
  80042055af:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042055b5:	48 89 c3             	mov    %rax,%rbx
  80042055b8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055bc:	48 89 c7             	mov    %rax,%rdi
  80042055bf:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  80042055c6:	00 00 00 
  80042055c9:	ff d0                	callq  *%rax
  80042055cb:	48 39 c3             	cmp    %rax,%rbx
  80042055ce:	74 35                	je     8004205605 <page_check+0x71d>
  80042055d0:	48 b9 70 6e 21 04 80 	movabs $0x8004216e70,%rcx
  80042055d7:	00 00 00 
  80042055da:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042055e1:	00 00 00 
  80042055e4:	be 8a 04 00 00       	mov    $0x48a,%esi
  80042055e9:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042055f0:	00 00 00 
  80042055f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055f8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042055ff:	00 00 00 
  8004205602:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004205605:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  800420560c:	00 00 00 
  800420560f:	48 8b 00             	mov    (%rax),%rax
  8004205612:	be 00 00 00 00       	mov    $0x0,%esi
  8004205617:	48 89 c7             	mov    %rax,%rdi
  800420561a:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004205621:	00 00 00 
  8004205624:	ff d0                	callq  *%rax
  8004205626:	48 89 c3             	mov    %rax,%rbx
  8004205629:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420562d:	48 89 c7             	mov    %rax,%rdi
  8004205630:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004205637:	00 00 00 
  800420563a:	ff d0                	callq  *%rax
  800420563c:	48 39 c3             	cmp    %rax,%rbx
  800420563f:	74 35                	je     8004205676 <page_check+0x78e>
  8004205641:	48 b9 f8 6e 21 04 80 	movabs $0x8004216ef8,%rcx
  8004205648:	00 00 00 
  800420564b:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205652:	00 00 00 
  8004205655:	be 8b 04 00 00       	mov    $0x48b,%esi
  800420565a:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205661:	00 00 00 
  8004205664:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205669:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205670:	00 00 00 
  8004205673:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205676:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420567a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420567e:	66 83 f8 01          	cmp    $0x1,%ax
  8004205682:	74 35                	je     80042056b9 <page_check+0x7d1>
  8004205684:	48 b9 25 6f 21 04 80 	movabs $0x8004216f25,%rcx
  800420568b:	00 00 00 
  800420568e:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205695:	00 00 00 
  8004205698:	be 8c 04 00 00       	mov    $0x48c,%esi
  800420569d:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042056a4:	00 00 00 
  80042056a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056ac:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042056b3:	00 00 00 
  80042056b6:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  80042056b9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042056bd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042056c1:	66 83 f8 01          	cmp    $0x1,%ax
  80042056c5:	74 35                	je     80042056fc <page_check+0x814>
  80042056c7:	48 b9 36 6f 21 04 80 	movabs $0x8004216f36,%rcx
  80042056ce:	00 00 00 
  80042056d1:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042056d8:	00 00 00 
  80042056db:	be 8d 04 00 00       	mov    $0x48d,%esi
  80042056e0:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042056e7:	00 00 00 
  80042056ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056ef:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042056f6:	00 00 00 
  80042056f9:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  80042056fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205700:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205704:	66 83 f8 01          	cmp    $0x1,%ax
  8004205708:	74 35                	je     800420573f <page_check+0x857>
  800420570a:	48 b9 47 6f 21 04 80 	movabs $0x8004216f47,%rcx
  8004205711:	00 00 00 
  8004205714:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420571b:	00 00 00 
  800420571e:	be 8e 04 00 00       	mov    $0x48e,%esi
  8004205723:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420572a:	00 00 00 
  800420572d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205732:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205739:	00 00 00 
  800420573c:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  800420573f:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205746:	00 00 00 
  8004205749:	48 8b 00             	mov    (%rax),%rax
  800420574c:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205750:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205755:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420575a:	48 89 c7             	mov    %rax,%rdi
  800420575d:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  8004205764:	00 00 00 
  8004205767:	ff d0                	callq  *%rax
  8004205769:	85 c0                	test   %eax,%eax
  800420576b:	74 35                	je     80042057a2 <page_check+0x8ba>
  800420576d:	48 b9 58 6f 21 04 80 	movabs $0x8004216f58,%rcx
  8004205774:	00 00 00 
  8004205777:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420577e:	00 00 00 
  8004205781:	be 90 04 00 00       	mov    $0x490,%esi
  8004205786:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420578d:	00 00 00 
  8004205790:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205795:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420579c:	00 00 00 
  800420579f:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042057a2:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042057a9:	00 00 00 
  80042057ac:	48 8b 00             	mov    (%rax),%rax
  80042057af:	be 00 10 00 00       	mov    $0x1000,%esi
  80042057b4:	48 89 c7             	mov    %rax,%rdi
  80042057b7:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  80042057be:	00 00 00 
  80042057c1:	ff d0                	callq  *%rax
  80042057c3:	48 89 c3             	mov    %rax,%rbx
  80042057c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042057ca:	48 89 c7             	mov    %rax,%rdi
  80042057cd:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  80042057d4:	00 00 00 
  80042057d7:	ff d0                	callq  *%rax
  80042057d9:	48 39 c3             	cmp    %rax,%rbx
  80042057dc:	74 35                	je     8004205813 <page_check+0x92b>
  80042057de:	48 b9 90 6f 21 04 80 	movabs $0x8004216f90,%rcx
  80042057e5:	00 00 00 
  80042057e8:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042057ef:	00 00 00 
  80042057f2:	be 91 04 00 00       	mov    $0x491,%esi
  80042057f7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042057fe:	00 00 00 
  8004205801:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205806:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420580d:	00 00 00 
  8004205810:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205813:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205817:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420581b:	66 83 f8 02          	cmp    $0x2,%ax
  800420581f:	74 35                	je     8004205856 <page_check+0x96e>
  8004205821:	48 b9 c0 6f 21 04 80 	movabs $0x8004216fc0,%rcx
  8004205828:	00 00 00 
  800420582b:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205832:	00 00 00 
  8004205835:	be 92 04 00 00       	mov    $0x492,%esi
  800420583a:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205841:	00 00 00 
  8004205844:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205849:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205850:	00 00 00 
  8004205853:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004205856:	bf 00 00 00 00       	mov    $0x0,%edi
  800420585b:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004205862:	00 00 00 
  8004205865:	ff d0                	callq  *%rax
  8004205867:	48 85 c0             	test   %rax,%rax
  800420586a:	74 35                	je     80042058a1 <page_check+0x9b9>
  800420586c:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  8004205873:	00 00 00 
  8004205876:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420587d:	00 00 00 
  8004205880:	be 95 04 00 00       	mov    $0x495,%esi
  8004205885:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420588c:	00 00 00 
  800420588f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205894:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420589b:	00 00 00 
  800420589e:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042058a1:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042058a8:	00 00 00 
  80042058ab:	48 8b 00             	mov    (%rax),%rax
  80042058ae:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042058b2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042058b7:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042058bc:	48 89 c7             	mov    %rax,%rdi
  80042058bf:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  80042058c6:	00 00 00 
  80042058c9:	ff d0                	callq  *%rax
  80042058cb:	85 c0                	test   %eax,%eax
  80042058cd:	74 35                	je     8004205904 <page_check+0xa1c>
  80042058cf:	48 b9 58 6f 21 04 80 	movabs $0x8004216f58,%rcx
  80042058d6:	00 00 00 
  80042058d9:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042058e0:	00 00 00 
  80042058e3:	be 98 04 00 00       	mov    $0x498,%esi
  80042058e8:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042058ef:	00 00 00 
  80042058f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058f7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042058fe:	00 00 00 
  8004205901:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205904:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  800420590b:	00 00 00 
  800420590e:	48 8b 00             	mov    (%rax),%rax
  8004205911:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205916:	48 89 c7             	mov    %rax,%rdi
  8004205919:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004205920:	00 00 00 
  8004205923:	ff d0                	callq  *%rax
  8004205925:	48 89 c3             	mov    %rax,%rbx
  8004205928:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420592c:	48 89 c7             	mov    %rax,%rdi
  800420592f:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004205936:	00 00 00 
  8004205939:	ff d0                	callq  *%rax
  800420593b:	48 39 c3             	cmp    %rax,%rbx
  800420593e:	74 35                	je     8004205975 <page_check+0xa8d>
  8004205940:	48 b9 90 6f 21 04 80 	movabs $0x8004216f90,%rcx
  8004205947:	00 00 00 
  800420594a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205951:	00 00 00 
  8004205954:	be 99 04 00 00       	mov    $0x499,%esi
  8004205959:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205960:	00 00 00 
  8004205963:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205968:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420596f:	00 00 00 
  8004205972:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205975:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205979:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420597d:	66 83 f8 02          	cmp    $0x2,%ax
  8004205981:	74 35                	je     80042059b8 <page_check+0xad0>
  8004205983:	48 b9 c0 6f 21 04 80 	movabs $0x8004216fc0,%rcx
  800420598a:	00 00 00 
  800420598d:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205994:	00 00 00 
  8004205997:	be 9a 04 00 00       	mov    $0x49a,%esi
  800420599c:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042059a3:	00 00 00 
  80042059a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059ab:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042059b2:	00 00 00 
  80042059b5:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  80042059b8:	bf 00 00 00 00       	mov    $0x0,%edi
  80042059bd:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  80042059c4:	00 00 00 
  80042059c7:	ff d0                	callq  *%rax
  80042059c9:	48 85 c0             	test   %rax,%rax
  80042059cc:	74 35                	je     8004205a03 <page_check+0xb1b>
  80042059ce:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  80042059d5:	00 00 00 
  80042059d8:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042059df:	00 00 00 
  80042059e2:	be 9e 04 00 00       	mov    $0x49e,%esi
  80042059e7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042059ee:	00 00 00 
  80042059f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059f6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042059fd:	00 00 00 
  8004205a00:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004205a03:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205a0a:	00 00 00 
  8004205a0d:	48 8b 00             	mov    (%rax),%rax
  8004205a10:	48 8b 00             	mov    (%rax),%rax
  8004205a13:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a19:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004205a1d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205a21:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205a25:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205a28:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004205a2b:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004205a32:	00 00 00 
  8004205a35:	48 8b 00             	mov    (%rax),%rax
  8004205a38:	48 39 c2             	cmp    %rax,%rdx
  8004205a3b:	72 32                	jb     8004205a6f <page_check+0xb87>
  8004205a3d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205a41:	48 89 c1             	mov    %rax,%rcx
  8004205a44:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004205a4b:	00 00 00 
  8004205a4e:	be a0 04 00 00       	mov    $0x4a0,%esi
  8004205a53:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205a5a:	00 00 00 
  8004205a5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a62:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205a69:	00 00 00 
  8004205a6c:	41 ff d0             	callq  *%r8
  8004205a6f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205a76:	00 00 00 
  8004205a79:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205a7d:	48 01 d0             	add    %rdx,%rax
  8004205a80:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004205a84:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004205a88:	48 8b 00             	mov    (%rax),%rax
  8004205a8b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a91:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004205a95:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205a99:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205a9d:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004205aa0:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004205aa3:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004205aaa:	00 00 00 
  8004205aad:	48 8b 00             	mov    (%rax),%rax
  8004205ab0:	48 39 c2             	cmp    %rax,%rdx
  8004205ab3:	72 32                	jb     8004205ae7 <page_check+0xbff>
  8004205ab5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205ab9:	48 89 c1             	mov    %rax,%rcx
  8004205abc:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004205ac3:	00 00 00 
  8004205ac6:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004205acb:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205ad2:	00 00 00 
  8004205ad5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ada:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205ae1:	00 00 00 
  8004205ae4:	41 ff d0             	callq  *%r8
  8004205ae7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205aee:	00 00 00 
  8004205af1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205af5:	48 01 d0             	add    %rdx,%rax
  8004205af8:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004205afc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205b00:	48 8b 00             	mov    (%rax),%rax
  8004205b03:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205b09:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004205b10:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205b17:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205b1b:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004205b21:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004205b27:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004205b2e:	00 00 00 
  8004205b31:	48 8b 00             	mov    (%rax),%rax
  8004205b34:	48 39 c2             	cmp    %rax,%rdx
  8004205b37:	72 35                	jb     8004205b6e <page_check+0xc86>
  8004205b39:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205b40:	48 89 c1             	mov    %rax,%rcx
  8004205b43:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004205b4a:	00 00 00 
  8004205b4d:	be a2 04 00 00       	mov    $0x4a2,%esi
  8004205b52:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205b59:	00 00 00 
  8004205b5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b61:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205b68:	00 00 00 
  8004205b6b:	41 ff d0             	callq  *%r8
  8004205b6e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205b75:	00 00 00 
  8004205b78:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205b7f:	48 01 d0             	add    %rdx,%rax
  8004205b82:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004205b89:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205b90:	00 00 00 
  8004205b93:	48 8b 00             	mov    (%rax),%rax
  8004205b96:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205b9b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205ba0:	48 89 c7             	mov    %rax,%rdi
  8004205ba3:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  8004205baa:	00 00 00 
  8004205bad:	ff d0                	callq  *%rax
  8004205baf:	48 8b 95 e0 fe ff ff 	mov    -0x120(%rbp),%rdx
  8004205bb6:	48 83 c2 08          	add    $0x8,%rdx
  8004205bba:	48 39 d0             	cmp    %rdx,%rax
  8004205bbd:	74 35                	je     8004205bf4 <page_check+0xd0c>
  8004205bbf:	48 b9 d8 6f 21 04 80 	movabs $0x8004216fd8,%rcx
  8004205bc6:	00 00 00 
  8004205bc9:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205bd0:	00 00 00 
  8004205bd3:	be a3 04 00 00       	mov    $0x4a3,%esi
  8004205bd8:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205bdf:	00 00 00 
  8004205be2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205be7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205bee:	00 00 00 
  8004205bf1:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  8004205bf4:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205bfb:	00 00 00 
  8004205bfe:	48 8b 00             	mov    (%rax),%rax
  8004205c01:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205c05:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004205c0a:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205c0f:	48 89 c7             	mov    %rax,%rdi
  8004205c12:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  8004205c19:	00 00 00 
  8004205c1c:	ff d0                	callq  *%rax
  8004205c1e:	85 c0                	test   %eax,%eax
  8004205c20:	74 35                	je     8004205c57 <page_check+0xd6f>
  8004205c22:	48 b9 18 70 21 04 80 	movabs $0x8004217018,%rcx
  8004205c29:	00 00 00 
  8004205c2c:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205c33:	00 00 00 
  8004205c36:	be a6 04 00 00       	mov    $0x4a6,%esi
  8004205c3b:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205c42:	00 00 00 
  8004205c45:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c4a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205c51:	00 00 00 
  8004205c54:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205c57:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205c5e:	00 00 00 
  8004205c61:	48 8b 00             	mov    (%rax),%rax
  8004205c64:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205c69:	48 89 c7             	mov    %rax,%rdi
  8004205c6c:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004205c73:	00 00 00 
  8004205c76:	ff d0                	callq  *%rax
  8004205c78:	48 89 c3             	mov    %rax,%rbx
  8004205c7b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c7f:	48 89 c7             	mov    %rax,%rdi
  8004205c82:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004205c89:	00 00 00 
  8004205c8c:	ff d0                	callq  *%rax
  8004205c8e:	48 39 c3             	cmp    %rax,%rbx
  8004205c91:	74 35                	je     8004205cc8 <page_check+0xde0>
  8004205c93:	48 b9 90 6f 21 04 80 	movabs $0x8004216f90,%rcx
  8004205c9a:	00 00 00 
  8004205c9d:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205ca4:	00 00 00 
  8004205ca7:	be a7 04 00 00       	mov    $0x4a7,%esi
  8004205cac:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205cb3:	00 00 00 
  8004205cb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cbb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205cc2:	00 00 00 
  8004205cc5:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205cc8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205ccc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205cd0:	66 83 f8 02          	cmp    $0x2,%ax
  8004205cd4:	74 35                	je     8004205d0b <page_check+0xe23>
  8004205cd6:	48 b9 c0 6f 21 04 80 	movabs $0x8004216fc0,%rcx
  8004205cdd:	00 00 00 
  8004205ce0:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205ce7:	00 00 00 
  8004205cea:	be a8 04 00 00       	mov    $0x4a8,%esi
  8004205cef:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205cf6:	00 00 00 
  8004205cf9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cfe:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205d05:	00 00 00 
  8004205d08:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004205d0b:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205d12:	00 00 00 
  8004205d15:	48 8b 00             	mov    (%rax),%rax
  8004205d18:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205d1d:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205d22:	48 89 c7             	mov    %rax,%rdi
  8004205d25:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  8004205d2c:	00 00 00 
  8004205d2f:	ff d0                	callq  *%rax
  8004205d31:	48 8b 00             	mov    (%rax),%rax
  8004205d34:	83 e0 04             	and    $0x4,%eax
  8004205d37:	48 85 c0             	test   %rax,%rax
  8004205d3a:	75 35                	jne    8004205d71 <page_check+0xe89>
  8004205d3c:	48 b9 58 70 21 04 80 	movabs $0x8004217058,%rcx
  8004205d43:	00 00 00 
  8004205d46:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205d4d:	00 00 00 
  8004205d50:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004205d55:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205d5c:	00 00 00 
  8004205d5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d64:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205d6b:	00 00 00 
  8004205d6e:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004205d71:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205d78:	00 00 00 
  8004205d7b:	48 8b 00             	mov    (%rax),%rax
  8004205d7e:	48 8b 00             	mov    (%rax),%rax
  8004205d81:	83 e0 04             	and    $0x4,%eax
  8004205d84:	48 85 c0             	test   %rax,%rax
  8004205d87:	75 35                	jne    8004205dbe <page_check+0xed6>
  8004205d89:	48 b9 8b 70 21 04 80 	movabs $0x800421708b,%rcx
  8004205d90:	00 00 00 
  8004205d93:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205d9a:	00 00 00 
  8004205d9d:	be aa 04 00 00       	mov    $0x4aa,%esi
  8004205da2:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205da9:	00 00 00 
  8004205dac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205db1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205db8:	00 00 00 
  8004205dbb:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004205dbe:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205dc5:	00 00 00 
  8004205dc8:	48 8b 00             	mov    (%rax),%rax
  8004205dcb:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004205dcf:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205dd4:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004205dd9:	48 89 c7             	mov    %rax,%rdi
  8004205ddc:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  8004205de3:	00 00 00 
  8004205de6:	ff d0                	callq  *%rax
  8004205de8:	85 c0                	test   %eax,%eax
  8004205dea:	78 35                	js     8004205e21 <page_check+0xf39>
  8004205dec:	48 b9 a8 70 21 04 80 	movabs $0x80042170a8,%rcx
  8004205df3:	00 00 00 
  8004205df6:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205dfd:	00 00 00 
  8004205e00:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004205e05:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205e0c:	00 00 00 
  8004205e0f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e14:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205e1b:	00 00 00 
  8004205e1e:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004205e21:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205e28:	00 00 00 
  8004205e2b:	48 8b 00             	mov    (%rax),%rax
  8004205e2e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205e32:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205e37:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205e3c:	48 89 c7             	mov    %rax,%rdi
  8004205e3f:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  8004205e46:	00 00 00 
  8004205e49:	ff d0                	callq  *%rax
  8004205e4b:	85 c0                	test   %eax,%eax
  8004205e4d:	74 35                	je     8004205e84 <page_check+0xf9c>
  8004205e4f:	48 b9 e0 70 21 04 80 	movabs $0x80042170e0,%rcx
  8004205e56:	00 00 00 
  8004205e59:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205e60:	00 00 00 
  8004205e63:	be b1 04 00 00       	mov    $0x4b1,%esi
  8004205e68:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205e6f:	00 00 00 
  8004205e72:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e77:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205e7e:	00 00 00 
  8004205e81:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004205e84:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205e8b:	00 00 00 
  8004205e8e:	48 8b 00             	mov    (%rax),%rax
  8004205e91:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205e96:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205e9b:	48 89 c7             	mov    %rax,%rdi
  8004205e9e:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  8004205ea5:	00 00 00 
  8004205ea8:	ff d0                	callq  *%rax
  8004205eaa:	48 8b 00             	mov    (%rax),%rax
  8004205ead:	83 e0 04             	and    $0x4,%eax
  8004205eb0:	48 85 c0             	test   %rax,%rax
  8004205eb3:	74 35                	je     8004205eea <page_check+0x1002>
  8004205eb5:	48 b9 18 71 21 04 80 	movabs $0x8004217118,%rcx
  8004205ebc:	00 00 00 
  8004205ebf:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205ec6:	00 00 00 
  8004205ec9:	be b2 04 00 00       	mov    $0x4b2,%esi
  8004205ece:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205ed5:	00 00 00 
  8004205ed8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205edd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205ee4:	00 00 00 
  8004205ee7:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004205eea:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205ef1:	00 00 00 
  8004205ef4:	48 8b 00             	mov    (%rax),%rax
  8004205ef7:	be 00 00 00 00       	mov    $0x0,%esi
  8004205efc:	48 89 c7             	mov    %rax,%rdi
  8004205eff:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004205f06:	00 00 00 
  8004205f09:	ff d0                	callq  *%rax
  8004205f0b:	48 89 c3             	mov    %rax,%rbx
  8004205f0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205f12:	48 89 c7             	mov    %rax,%rdi
  8004205f15:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004205f1c:	00 00 00 
  8004205f1f:	ff d0                	callq  *%rax
  8004205f21:	48 39 c3             	cmp    %rax,%rbx
  8004205f24:	74 35                	je     8004205f5b <page_check+0x1073>
  8004205f26:	48 b9 50 71 21 04 80 	movabs $0x8004217150,%rcx
  8004205f2d:	00 00 00 
  8004205f30:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205f37:	00 00 00 
  8004205f3a:	be b5 04 00 00       	mov    $0x4b5,%esi
  8004205f3f:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205f46:	00 00 00 
  8004205f49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f4e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205f55:	00 00 00 
  8004205f58:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004205f5b:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004205f62:	00 00 00 
  8004205f65:	48 8b 00             	mov    (%rax),%rax
  8004205f68:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205f6d:	48 89 c7             	mov    %rax,%rdi
  8004205f70:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004205f77:	00 00 00 
  8004205f7a:	ff d0                	callq  *%rax
  8004205f7c:	48 89 c3             	mov    %rax,%rbx
  8004205f7f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205f83:	48 89 c7             	mov    %rax,%rdi
  8004205f86:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004205f8d:	00 00 00 
  8004205f90:	ff d0                	callq  *%rax
  8004205f92:	48 39 c3             	cmp    %rax,%rbx
  8004205f95:	74 35                	je     8004205fcc <page_check+0x10e4>
  8004205f97:	48 b9 80 71 21 04 80 	movabs $0x8004217180,%rcx
  8004205f9e:	00 00 00 
  8004205fa1:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205fa8:	00 00 00 
  8004205fab:	be b6 04 00 00       	mov    $0x4b6,%esi
  8004205fb0:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205fb7:	00 00 00 
  8004205fba:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fbf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205fc6:	00 00 00 
  8004205fc9:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004205fcc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205fd0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205fd4:	66 83 f8 02          	cmp    $0x2,%ax
  8004205fd8:	74 35                	je     800420600f <page_check+0x1127>
  8004205fda:	48 b9 b0 71 21 04 80 	movabs $0x80042171b0,%rcx
  8004205fe1:	00 00 00 
  8004205fe4:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004205feb:	00 00 00 
  8004205fee:	be b8 04 00 00       	mov    $0x4b8,%esi
  8004205ff3:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004205ffa:	00 00 00 
  8004205ffd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206002:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206009:	00 00 00 
  800420600c:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  800420600f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206013:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206017:	66 83 f8 01          	cmp    $0x1,%ax
  800420601b:	74 35                	je     8004206052 <page_check+0x116a>
  800420601d:	48 b9 c1 71 21 04 80 	movabs $0x80042171c1,%rcx
  8004206024:	00 00 00 
  8004206027:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420602e:	00 00 00 
  8004206031:	be b9 04 00 00       	mov    $0x4b9,%esi
  8004206036:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420603d:	00 00 00 
  8004206040:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206045:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420604c:	00 00 00 
  800420604f:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206052:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206059:	00 00 00 
  800420605c:	48 8b 00             	mov    (%rax),%rax
  800420605f:	be 00 00 00 00       	mov    $0x0,%esi
  8004206064:	48 89 c7             	mov    %rax,%rdi
  8004206067:	48 b8 e5 31 20 04 80 	movabs $0x80042031e5,%rax
  800420606e:	00 00 00 
  8004206071:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206073:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  800420607a:	00 00 00 
  800420607d:	48 8b 00             	mov    (%rax),%rax
  8004206080:	be 00 00 00 00       	mov    $0x0,%esi
  8004206085:	48 89 c7             	mov    %rax,%rdi
  8004206088:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  800420608f:	00 00 00 
  8004206092:	ff d0                	callq  *%rax
  8004206094:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206098:	74 35                	je     80042060cf <page_check+0x11e7>
  800420609a:	48 b9 d8 71 21 04 80 	movabs $0x80042171d8,%rcx
  80042060a1:	00 00 00 
  80042060a4:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042060ab:	00 00 00 
  80042060ae:	be be 04 00 00       	mov    $0x4be,%esi
  80042060b3:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042060ba:	00 00 00 
  80042060bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060c2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042060c9:	00 00 00 
  80042060cc:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  80042060cf:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042060d6:	00 00 00 
  80042060d9:	48 8b 00             	mov    (%rax),%rax
  80042060dc:	be 00 10 00 00       	mov    $0x1000,%esi
  80042060e1:	48 89 c7             	mov    %rax,%rdi
  80042060e4:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  80042060eb:	00 00 00 
  80042060ee:	ff d0                	callq  *%rax
  80042060f0:	48 89 c3             	mov    %rax,%rbx
  80042060f3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042060f7:	48 89 c7             	mov    %rax,%rdi
  80042060fa:	48 b8 44 17 20 04 80 	movabs $0x8004201744,%rax
  8004206101:	00 00 00 
  8004206104:	ff d0                	callq  *%rax
  8004206106:	48 39 c3             	cmp    %rax,%rbx
  8004206109:	74 35                	je     8004206140 <page_check+0x1258>
  800420610b:	48 b9 80 71 21 04 80 	movabs $0x8004217180,%rcx
  8004206112:	00 00 00 
  8004206115:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420611c:	00 00 00 
  800420611f:	be bf 04 00 00       	mov    $0x4bf,%esi
  8004206124:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420612b:	00 00 00 
  800420612e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206133:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420613a:	00 00 00 
  800420613d:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206140:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206144:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206148:	66 83 f8 01          	cmp    $0x1,%ax
  800420614c:	74 35                	je     8004206183 <page_check+0x129b>
  800420614e:	48 b9 25 6f 21 04 80 	movabs $0x8004216f25,%rcx
  8004206155:	00 00 00 
  8004206158:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  800420615f:	00 00 00 
  8004206162:	be c0 04 00 00       	mov    $0x4c0,%esi
  8004206167:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  800420616e:	00 00 00 
  8004206171:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206176:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420617d:	00 00 00 
  8004206180:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206183:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206187:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420618b:	66 83 f8 01          	cmp    $0x1,%ax
  800420618f:	74 35                	je     80042061c6 <page_check+0x12de>
  8004206191:	48 b9 c1 71 21 04 80 	movabs $0x80042171c1,%rcx
  8004206198:	00 00 00 
  800420619b:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042061a2:	00 00 00 
  80042061a5:	be c1 04 00 00       	mov    $0x4c1,%esi
  80042061aa:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042061b1:	00 00 00 
  80042061b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061b9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042061c0:	00 00 00 
  80042061c3:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042061c6:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042061cd:	00 00 00 
  80042061d0:	48 8b 00             	mov    (%rax),%rax
  80042061d3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042061d7:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042061dc:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042061e1:	48 89 c7             	mov    %rax,%rdi
  80042061e4:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  80042061eb:	00 00 00 
  80042061ee:	ff d0                	callq  *%rax
  80042061f0:	85 c0                	test   %eax,%eax
  80042061f2:	74 35                	je     8004206229 <page_check+0x1341>
  80042061f4:	48 b9 e0 70 21 04 80 	movabs $0x80042170e0,%rcx
  80042061fb:	00 00 00 
  80042061fe:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206205:	00 00 00 
  8004206208:	be c5 04 00 00       	mov    $0x4c5,%esi
  800420620d:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206214:	00 00 00 
  8004206217:	b8 00 00 00 00       	mov    $0x0,%eax
  800420621c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206223:	00 00 00 
  8004206226:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206229:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420622d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206231:	66 85 c0             	test   %ax,%ax
  8004206234:	75 35                	jne    800420626b <page_check+0x1383>
  8004206236:	48 b9 fb 71 21 04 80 	movabs $0x80042171fb,%rcx
  800420623d:	00 00 00 
  8004206240:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206247:	00 00 00 
  800420624a:	be c6 04 00 00       	mov    $0x4c6,%esi
  800420624f:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206256:	00 00 00 
  8004206259:	b8 00 00 00 00       	mov    $0x0,%eax
  800420625e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206265:	00 00 00 
  8004206268:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  800420626b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420626f:	48 8b 00             	mov    (%rax),%rax
  8004206272:	48 85 c0             	test   %rax,%rax
  8004206275:	74 35                	je     80042062ac <page_check+0x13c4>
  8004206277:	48 b9 07 72 21 04 80 	movabs $0x8004217207,%rcx
  800420627e:	00 00 00 
  8004206281:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206288:	00 00 00 
  800420628b:	be c7 04 00 00       	mov    $0x4c7,%esi
  8004206290:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206297:	00 00 00 
  800420629a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420629f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042062a6:	00 00 00 
  80042062a9:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  80042062ac:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042062b3:	00 00 00 
  80042062b6:	48 8b 00             	mov    (%rax),%rax
  80042062b9:	be 00 10 00 00       	mov    $0x1000,%esi
  80042062be:	48 89 c7             	mov    %rax,%rdi
  80042062c1:	48 b8 e5 31 20 04 80 	movabs $0x80042031e5,%rax
  80042062c8:	00 00 00 
  80042062cb:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  80042062cd:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042062d4:	00 00 00 
  80042062d7:	48 8b 00             	mov    (%rax),%rax
  80042062da:	be 00 00 00 00       	mov    $0x0,%esi
  80042062df:	48 89 c7             	mov    %rax,%rdi
  80042062e2:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  80042062e9:	00 00 00 
  80042062ec:	ff d0                	callq  *%rax
  80042062ee:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042062f2:	74 35                	je     8004206329 <page_check+0x1441>
  80042062f4:	48 b9 d8 71 21 04 80 	movabs $0x80042171d8,%rcx
  80042062fb:	00 00 00 
  80042062fe:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206305:	00 00 00 
  8004206308:	be cb 04 00 00       	mov    $0x4cb,%esi
  800420630d:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206314:	00 00 00 
  8004206317:	b8 00 00 00 00       	mov    $0x0,%eax
  800420631c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206323:	00 00 00 
  8004206326:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206329:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206330:	00 00 00 
  8004206333:	48 8b 00             	mov    (%rax),%rax
  8004206336:	be 00 10 00 00       	mov    $0x1000,%esi
  800420633b:	48 89 c7             	mov    %rax,%rdi
  800420633e:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004206345:	00 00 00 
  8004206348:	ff d0                	callq  *%rax
  800420634a:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420634e:	74 35                	je     8004206385 <page_check+0x149d>
  8004206350:	48 b9 20 72 21 04 80 	movabs $0x8004217220,%rcx
  8004206357:	00 00 00 
  800420635a:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206361:	00 00 00 
  8004206364:	be cc 04 00 00       	mov    $0x4cc,%esi
  8004206369:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206370:	00 00 00 
  8004206373:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206378:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420637f:	00 00 00 
  8004206382:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206385:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206389:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420638d:	66 85 c0             	test   %ax,%ax
  8004206390:	74 35                	je     80042063c7 <page_check+0x14df>
  8004206392:	48 b9 46 72 21 04 80 	movabs $0x8004217246,%rcx
  8004206399:	00 00 00 
  800420639c:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042063a3:	00 00 00 
  80042063a6:	be cd 04 00 00       	mov    $0x4cd,%esi
  80042063ab:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042063b2:	00 00 00 
  80042063b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063ba:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042063c1:	00 00 00 
  80042063c4:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042063c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042063cb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042063cf:	66 83 f8 01          	cmp    $0x1,%ax
  80042063d3:	74 35                	je     800420640a <page_check+0x1522>
  80042063d5:	48 b9 c1 71 21 04 80 	movabs $0x80042171c1,%rcx
  80042063dc:	00 00 00 
  80042063df:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042063e6:	00 00 00 
  80042063e9:	be ce 04 00 00       	mov    $0x4ce,%esi
  80042063ee:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042063f5:	00 00 00 
  80042063f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063fd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206404:	00 00 00 
  8004206407:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  800420640a:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206411:	00 00 00 
  8004206414:	48 8b 00             	mov    (%rax),%rax
  8004206417:	48 8b 00             	mov    (%rax),%rax
  800420641a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206420:	48 89 c7             	mov    %rax,%rdi
  8004206423:	48 b8 69 17 20 04 80 	movabs $0x8004201769,%rax
  800420642a:	00 00 00 
  800420642d:	ff d0                	callq  *%rax
  800420642f:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  8004206436:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  800420643d:	00 00 00 
  8004206440:	48 8b 00             	mov    (%rax),%rax
  8004206443:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  800420644a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420644e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206452:	66 83 f8 01          	cmp    $0x1,%ax
  8004206456:	74 35                	je     800420648d <page_check+0x15a5>
  8004206458:	48 b9 c1 71 21 04 80 	movabs $0x80042171c1,%rcx
  800420645f:	00 00 00 
  8004206462:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206469:	00 00 00 
  800420646c:	be e4 04 00 00       	mov    $0x4e4,%esi
  8004206471:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206478:	00 00 00 
  800420647b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206480:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206487:	00 00 00 
  800420648a:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  800420648d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206494:	48 89 c7             	mov    %rax,%rdi
  8004206497:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  800420649e:	00 00 00 
  80042064a1:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  80042064a3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042064aa:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042064ae:	74 13                	je     80042064c3 <page_check+0x15db>
  80042064b0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042064b4:	48 89 c7             	mov    %rax,%rdi
  80042064b7:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  80042064be:	00 00 00 
  80042064c1:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  80042064c3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042064ca:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042064ce:	74 13                	je     80042064e3 <page_check+0x15fb>
  80042064d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042064d4:	48 89 c7             	mov    %rax,%rdi
  80042064d7:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  80042064de:	00 00 00 
  80042064e1:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  80042064e3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042064ea:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042064ee:	74 13                	je     8004206503 <page_check+0x161b>
  80042064f0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042064f4:	48 89 c7             	mov    %rax,%rdi
  80042064f7:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  80042064fe:	00 00 00 
  8004206501:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004206503:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  800420650a:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  800420650e:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206515:	00 00 00 
  8004206518:	48 8b 00             	mov    (%rax),%rax
  800420651b:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004206522:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206527:	48 89 ce             	mov    %rcx,%rsi
  800420652a:	48 89 c7             	mov    %rax,%rdi
  800420652d:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  8004206534:	00 00 00 
  8004206537:	ff d0                	callq  *%rax
  8004206539:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206540:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206547:	00 00 00 
  800420654a:	48 8b 00             	mov    (%rax),%rax
  800420654d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004206554:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206558:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  800420655e:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206562:	48 01 d0             	add    %rdx,%rax
  8004206565:	48 8b 00             	mov    (%rax),%rax
  8004206568:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420656e:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004206575:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420657c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206580:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  8004206586:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  800420658c:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004206593:	00 00 00 
  8004206596:	48 8b 00             	mov    (%rax),%rax
  8004206599:	48 39 c2             	cmp    %rax,%rdx
  800420659c:	72 35                	jb     80042065d3 <page_check+0x16eb>
  800420659e:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042065a5:	48 89 c1             	mov    %rax,%rcx
  80042065a8:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  80042065af:	00 00 00 
  80042065b2:	be ec 04 00 00       	mov    $0x4ec,%esi
  80042065b7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042065be:	00 00 00 
  80042065c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065c6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042065cd:	00 00 00 
  80042065d0:	41 ff d0             	callq  *%r8
  80042065d3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042065da:	00 00 00 
  80042065dd:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042065e4:	48 01 d0             	add    %rdx,%rax
  80042065e7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042065eb:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042065f2:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042065f6:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042065fb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206602:	00 
  8004206603:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206607:	48 01 d0             	add    %rdx,%rax
  800420660a:	48 8b 00             	mov    (%rax),%rax
  800420660d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206613:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  800420661a:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004206621:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206625:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  800420662b:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  8004206631:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004206638:	00 00 00 
  800420663b:	48 8b 00             	mov    (%rax),%rax
  800420663e:	48 39 c2             	cmp    %rax,%rdx
  8004206641:	72 35                	jb     8004206678 <page_check+0x1790>
  8004206643:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420664a:	48 89 c1             	mov    %rax,%rcx
  800420664d:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004206654:	00 00 00 
  8004206657:	be ed 04 00 00       	mov    $0x4ed,%esi
  800420665c:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206663:	00 00 00 
  8004206666:	b8 00 00 00 00       	mov    $0x0,%eax
  800420666b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206672:	00 00 00 
  8004206675:	41 ff d0             	callq  *%r8
  8004206678:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420667f:	00 00 00 
  8004206682:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004206689:	48 01 d0             	add    %rdx,%rax
  800420668c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206690:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206697:	48 c1 e8 15          	shr    $0x15,%rax
  800420669b:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042066a0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042066a7:	00 
  80042066a8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042066ac:	48 01 d0             	add    %rdx,%rax
  80042066af:	48 8b 00             	mov    (%rax),%rax
  80042066b2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042066b8:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042066bf:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042066c6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042066ca:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  80042066d0:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  80042066d6:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  80042066dd:	00 00 00 
  80042066e0:	48 8b 00             	mov    (%rax),%rax
  80042066e3:	48 39 c2             	cmp    %rax,%rdx
  80042066e6:	72 35                	jb     800420671d <page_check+0x1835>
  80042066e8:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042066ef:	48 89 c1             	mov    %rax,%rcx
  80042066f2:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  80042066f9:	00 00 00 
  80042066fc:	be ee 04 00 00       	mov    $0x4ee,%esi
  8004206701:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206708:	00 00 00 
  800420670b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206710:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206717:	00 00 00 
  800420671a:	41 ff d0             	callq  *%r8
  800420671d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206724:	00 00 00 
  8004206727:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800420672e:	48 01 d0             	add    %rdx,%rax
  8004206731:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206738:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420673f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206743:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206748:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420674f:	00 
  8004206750:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206757:	48 01 c2             	add    %rax,%rdx
  800420675a:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004206761:	48 39 c2             	cmp    %rax,%rdx
  8004206764:	74 35                	je     800420679b <page_check+0x18b3>
  8004206766:	48 b9 57 72 21 04 80 	movabs $0x8004217257,%rcx
  800420676d:	00 00 00 
  8004206770:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206777:	00 00 00 
  800420677a:	be ef 04 00 00       	mov    $0x4ef,%esi
  800420677f:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206786:	00 00 00 
  8004206789:	b8 00 00 00 00       	mov    $0x0,%eax
  800420678e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206795:	00 00 00 
  8004206798:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  800420679b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420679f:	48 89 c7             	mov    %rax,%rdi
  80042067a2:	48 b8 da 17 20 04 80 	movabs $0x80042017da,%rax
  80042067a9:	00 00 00 
  80042067ac:	ff d0                	callq  *%rax
  80042067ae:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042067b3:	be ff 00 00 00       	mov    $0xff,%esi
  80042067b8:	48 89 c7             	mov    %rax,%rdi
  80042067bb:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  80042067c2:	00 00 00 
  80042067c5:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  80042067c7:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042067ce:	00 00 00 
  80042067d1:	48 8b 00             	mov    (%rax),%rax
  80042067d4:	ba 01 00 00 00       	mov    $0x1,%edx
  80042067d9:	be 00 00 00 00       	mov    $0x0,%esi
  80042067de:	48 89 c7             	mov    %rax,%rdi
  80042067e1:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  80042067e8:	00 00 00 
  80042067eb:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  80042067ed:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042067f4:	00 00 00 
  80042067f7:	48 8b 00             	mov    (%rax),%rax
  80042067fa:	48 8b 00             	mov    (%rax),%rax
  80042067fd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206803:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  800420680a:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004206811:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206815:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  800420681b:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  8004206821:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004206828:	00 00 00 
  800420682b:	48 8b 00             	mov    (%rax),%rax
  800420682e:	48 39 c2             	cmp    %rax,%rdx
  8004206831:	72 35                	jb     8004206868 <page_check+0x1980>
  8004206833:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420683a:	48 89 c1             	mov    %rax,%rcx
  800420683d:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004206844:	00 00 00 
  8004206847:	be f4 04 00 00       	mov    $0x4f4,%esi
  800420684c:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206853:	00 00 00 
  8004206856:	b8 00 00 00 00       	mov    $0x0,%eax
  800420685b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206862:	00 00 00 
  8004206865:	41 ff d0             	callq  *%r8
  8004206868:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420686f:	00 00 00 
  8004206872:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004206879:	48 01 d0             	add    %rdx,%rax
  800420687c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004206880:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206884:	48 8b 00             	mov    (%rax),%rax
  8004206887:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420688d:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004206894:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800420689b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420689f:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  80042068a5:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  80042068ab:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  80042068b2:	00 00 00 
  80042068b5:	48 8b 00             	mov    (%rax),%rax
  80042068b8:	48 39 c2             	cmp    %rax,%rdx
  80042068bb:	72 35                	jb     80042068f2 <page_check+0x1a0a>
  80042068bd:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042068c4:	48 89 c1             	mov    %rax,%rcx
  80042068c7:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  80042068ce:	00 00 00 
  80042068d1:	be f5 04 00 00       	mov    $0x4f5,%esi
  80042068d6:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042068dd:	00 00 00 
  80042068e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068e5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042068ec:	00 00 00 
  80042068ef:	41 ff d0             	callq  *%r8
  80042068f2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042068f9:	00 00 00 
  80042068fc:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004206903:	48 01 d0             	add    %rdx,%rax
  8004206906:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  800420690a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420690e:	48 8b 00             	mov    (%rax),%rax
  8004206911:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206917:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  800420691e:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004206925:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206929:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  800420692f:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  8004206935:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  800420693c:	00 00 00 
  800420693f:	48 8b 00             	mov    (%rax),%rax
  8004206942:	48 39 c2             	cmp    %rax,%rdx
  8004206945:	72 35                	jb     800420697c <page_check+0x1a94>
  8004206947:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800420694e:	48 89 c1             	mov    %rax,%rcx
  8004206951:	48 ba c8 65 21 04 80 	movabs $0x80042165c8,%rdx
  8004206958:	00 00 00 
  800420695b:	be f6 04 00 00       	mov    $0x4f6,%esi
  8004206960:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206967:	00 00 00 
  800420696a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420696f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206976:	00 00 00 
  8004206979:	41 ff d0             	callq  *%r8
  800420697c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206983:	00 00 00 
  8004206986:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800420698d:	48 01 d0             	add    %rdx,%rax
  8004206990:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  8004206997:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420699e:	eb 58                	jmp    80042069f8 <page_check+0x1b10>
		assert((ptep[i] & PTE_P) == 0);
  80042069a0:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  80042069a7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042069aa:	48 63 d2             	movslq %edx,%rdx
  80042069ad:	48 c1 e2 03          	shl    $0x3,%rdx
  80042069b1:	48 01 d0             	add    %rdx,%rax
  80042069b4:	48 8b 00             	mov    (%rax),%rax
  80042069b7:	83 e0 01             	and    $0x1,%eax
  80042069ba:	48 85 c0             	test   %rax,%rax
  80042069bd:	74 35                	je     80042069f4 <page_check+0x1b0c>
  80042069bf:	48 b9 6f 72 21 04 80 	movabs $0x800421726f,%rcx
  80042069c6:	00 00 00 
  80042069c9:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  80042069d0:	00 00 00 
  80042069d3:	be f8 04 00 00       	mov    $0x4f8,%esi
  80042069d8:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  80042069df:	00 00 00 
  80042069e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069e7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042069ee:	00 00 00 
  80042069f1:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  80042069f4:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042069f8:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  80042069ff:	7e 9f                	jle    80042069a0 <page_check+0x1ab8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004206a01:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206a08:	00 00 00 
  8004206a0b:	48 8b 00             	mov    (%rax),%rax
  8004206a0e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004206a15:	48 b8 38 e2 6b 04 80 	movabs $0x80046be238,%rax
  8004206a1c:	00 00 00 
  8004206a1f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004206a23:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004206a26:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206a2a:	48 89 c7             	mov    %rax,%rdi
  8004206a2d:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004206a34:	00 00 00 
  8004206a37:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206a39:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206a3d:	48 89 c7             	mov    %rax,%rdi
  8004206a40:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004206a47:	00 00 00 
  8004206a4a:	ff d0                	callq  *%rax
	page_decref(pp3);
  8004206a4c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206a50:	48 89 c7             	mov    %rax,%rdi
  8004206a53:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004206a5a:	00 00 00 
  8004206a5d:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  8004206a5f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206a63:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206a67:	66 85 c0             	test   %ax,%ax
  8004206a6a:	74 35                	je     8004206aa1 <page_check+0x1bb9>
  8004206a6c:	48 b9 86 72 21 04 80 	movabs $0x8004217286,%rcx
  8004206a73:	00 00 00 
  8004206a76:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206a7d:	00 00 00 
  8004206a80:	be 04 05 00 00       	mov    $0x504,%esi
  8004206a85:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206a8c:	00 00 00 
  8004206a8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a94:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206a9b:	00 00 00 
  8004206a9e:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206aa1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206aa5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206aa9:	66 85 c0             	test   %ax,%ax
  8004206aac:	74 35                	je     8004206ae3 <page_check+0x1bfb>
  8004206aae:	48 b9 46 72 21 04 80 	movabs $0x8004217246,%rcx
  8004206ab5:	00 00 00 
  8004206ab8:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206abf:	00 00 00 
  8004206ac2:	be 05 05 00 00       	mov    $0x505,%esi
  8004206ac7:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206ace:	00 00 00 
  8004206ad1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ad6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206add:	00 00 00 
  8004206ae0:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  8004206ae3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206ae7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206aeb:	66 85 c0             	test   %ax,%ax
  8004206aee:	74 35                	je     8004206b25 <page_check+0x1c3d>
  8004206af0:	48 b9 97 72 21 04 80 	movabs $0x8004217297,%rcx
  8004206af7:	00 00 00 
  8004206afa:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206b01:	00 00 00 
  8004206b04:	be 06 05 00 00       	mov    $0x506,%esi
  8004206b09:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206b10:	00 00 00 
  8004206b13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b18:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206b1f:	00 00 00 
  8004206b22:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  8004206b25:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206b29:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b2d:	66 85 c0             	test   %ax,%ax
  8004206b30:	74 35                	je     8004206b67 <page_check+0x1c7f>
  8004206b32:	48 b9 a8 72 21 04 80 	movabs $0x80042172a8,%rcx
  8004206b39:	00 00 00 
  8004206b3c:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206b43:	00 00 00 
  8004206b46:	be 07 05 00 00       	mov    $0x507,%esi
  8004206b4b:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206b52:	00 00 00 
  8004206b55:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b5a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206b61:	00 00 00 
  8004206b64:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  8004206b67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206b6b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b6f:	66 85 c0             	test   %ax,%ax
  8004206b72:	74 35                	je     8004206ba9 <page_check+0x1cc1>
  8004206b74:	48 b9 b9 72 21 04 80 	movabs $0x80042172b9,%rcx
  8004206b7b:	00 00 00 
  8004206b7e:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206b85:	00 00 00 
  8004206b88:	be 08 05 00 00       	mov    $0x508,%esi
  8004206b8d:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206b94:	00 00 00 
  8004206b97:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b9c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206ba3:	00 00 00 
  8004206ba6:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  8004206ba9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206bad:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206bb1:	66 85 c0             	test   %ax,%ax
  8004206bb4:	74 35                	je     8004206beb <page_check+0x1d03>
  8004206bb6:	48 b9 ca 72 21 04 80 	movabs $0x80042172ca,%rcx
  8004206bbd:	00 00 00 
  8004206bc0:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206bc7:	00 00 00 
  8004206bca:	be 09 05 00 00       	mov    $0x509,%esi
  8004206bcf:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206bd6:	00 00 00 
  8004206bd9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bde:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206be5:	00 00 00 
  8004206be8:	41 ff d0             	callq  *%r8

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004206beb:	be 01 10 00 00       	mov    $0x1001,%esi
  8004206bf0:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206bf5:	48 b8 3a 33 20 04 80 	movabs $0x800420333a,%rax
  8004206bfc:	00 00 00 
  8004206bff:	ff d0                	callq  *%rax
  8004206c01:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004206c08:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206c0d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206c12:	48 b8 3a 33 20 04 80 	movabs $0x800420333a,%rax
  8004206c19:	00 00 00 
  8004206c1c:	ff d0                	callq  *%rax
  8004206c1e:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004206c25:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206c2c:	00 00 00 
  8004206c2f:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004206c36:	76 1d                	jbe    8004206c55 <page_check+0x1d6d>
  8004206c38:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206c3f:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206c46:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004206c4d:	00 00 00 
  8004206c50:	48 39 c2             	cmp    %rax,%rdx
  8004206c53:	76 35                	jbe    8004206c8a <page_check+0x1da2>
  8004206c55:	48 b9 e0 72 21 04 80 	movabs $0x80042172e0,%rcx
  8004206c5c:	00 00 00 
  8004206c5f:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206c66:	00 00 00 
  8004206c69:	be 0f 05 00 00       	mov    $0x50f,%esi
  8004206c6e:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206c75:	00 00 00 
  8004206c78:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c7d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206c84:	00 00 00 
  8004206c87:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  8004206c8a:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206c91:	00 00 00 
  8004206c94:	48 39 85 e8 fe ff ff 	cmp    %rax,-0x118(%rbp)
  8004206c9b:	76 1d                	jbe    8004206cba <page_check+0x1dd2>
  8004206c9d:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206ca4:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206cab:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004206cb2:	00 00 00 
  8004206cb5:	48 39 c2             	cmp    %rax,%rdx
  8004206cb8:	76 35                	jbe    8004206cef <page_check+0x1e07>
  8004206cba:	48 b9 08 73 21 04 80 	movabs $0x8004217308,%rcx
  8004206cc1:	00 00 00 
  8004206cc4:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206ccb:	00 00 00 
  8004206cce:	be 10 05 00 00       	mov    $0x510,%esi
  8004206cd3:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206cda:	00 00 00 
  8004206cdd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ce2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206ce9:	00 00 00 
  8004206cec:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004206cef:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206cf6:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004206cfb:	48 85 c0             	test   %rax,%rax
  8004206cfe:	75 11                	jne    8004206d11 <page_check+0x1e29>
  8004206d00:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206d07:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004206d0c:	48 85 c0             	test   %rax,%rax
  8004206d0f:	74 35                	je     8004206d46 <page_check+0x1e5e>
  8004206d11:	48 b9 30 73 21 04 80 	movabs $0x8004217330,%rcx
  8004206d18:	00 00 00 
  8004206d1b:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206d22:	00 00 00 
  8004206d25:	be 12 05 00 00       	mov    $0x512,%esi
  8004206d2a:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206d31:	00 00 00 
  8004206d34:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d39:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206d40:	00 00 00 
  8004206d43:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004206d46:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206d4d:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004206d53:	48 3b 85 e8 fe ff ff 	cmp    -0x118(%rbp),%rax
  8004206d5a:	76 35                	jbe    8004206d91 <page_check+0x1ea9>
  8004206d5c:	48 b9 57 73 21 04 80 	movabs $0x8004217357,%rcx
  8004206d63:	00 00 00 
  8004206d66:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206d6d:	00 00 00 
  8004206d70:	be 14 05 00 00       	mov    $0x514,%esi
  8004206d75:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206d7c:	00 00 00 
  8004206d7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d84:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206d8b:	00 00 00 
  8004206d8e:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004206d91:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206d98:	00 00 00 
  8004206d9b:	48 8b 00             	mov    (%rax),%rax
  8004206d9e:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004206da5:	48 89 d6             	mov    %rdx,%rsi
  8004206da8:	48 89 c7             	mov    %rax,%rdi
  8004206dab:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004206db2:	00 00 00 
  8004206db5:	ff d0                	callq  *%rax
  8004206db7:	48 85 c0             	test   %rax,%rax
  8004206dba:	74 35                	je     8004206df1 <page_check+0x1f09>
  8004206dbc:	48 b9 70 73 21 04 80 	movabs $0x8004217370,%rcx
  8004206dc3:	00 00 00 
  8004206dc6:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206dcd:	00 00 00 
  8004206dd0:	be 17 05 00 00       	mov    $0x517,%esi
  8004206dd5:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206ddc:	00 00 00 
  8004206ddf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206de4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206deb:	00 00 00 
  8004206dee:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004206df1:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206df8:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004206dff:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206e06:	00 00 00 
  8004206e09:	48 8b 00             	mov    (%rax),%rax
  8004206e0c:	48 89 d6             	mov    %rdx,%rsi
  8004206e0f:	48 89 c7             	mov    %rax,%rdi
  8004206e12:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004206e19:	00 00 00 
  8004206e1c:	ff d0                	callq  *%rax
  8004206e1e:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004206e24:	74 35                	je     8004206e5b <page_check+0x1f73>
  8004206e26:	48 b9 98 73 21 04 80 	movabs $0x8004217398,%rcx
  8004206e2d:	00 00 00 
  8004206e30:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206e37:	00 00 00 
  8004206e3a:	be 18 05 00 00       	mov    $0x518,%esi
  8004206e3f:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206e46:	00 00 00 
  8004206e49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e4e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206e55:	00 00 00 
  8004206e58:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004206e5b:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206e62:	00 00 00 
  8004206e65:	48 8b 00             	mov    (%rax),%rax
  8004206e68:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004206e6f:	48 89 d6             	mov    %rdx,%rsi
  8004206e72:	48 89 c7             	mov    %rax,%rdi
  8004206e75:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004206e7c:	00 00 00 
  8004206e7f:	ff d0                	callq  *%rax
  8004206e81:	48 85 c0             	test   %rax,%rax
  8004206e84:	74 35                	je     8004206ebb <page_check+0x1fd3>
  8004206e86:	48 b9 c8 73 21 04 80 	movabs $0x80042173c8,%rcx
  8004206e8d:	00 00 00 
  8004206e90:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206e97:	00 00 00 
  8004206e9a:	be 19 05 00 00       	mov    $0x519,%esi
  8004206e9f:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206ea6:	00 00 00 
  8004206ea9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206eae:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206eb5:	00 00 00 
  8004206eb8:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004206ebb:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206ec2:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004206ec9:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206ed0:	00 00 00 
  8004206ed3:	48 8b 00             	mov    (%rax),%rax
  8004206ed6:	48 89 d6             	mov    %rdx,%rsi
  8004206ed9:	48 89 c7             	mov    %rax,%rdi
  8004206edc:	48 b8 6e 4c 20 04 80 	movabs $0x8004204c6e,%rax
  8004206ee3:	00 00 00 
  8004206ee6:	ff d0                	callq  *%rax
  8004206ee8:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206eec:	74 35                	je     8004206f23 <page_check+0x203b>
  8004206eee:	48 b9 f0 73 21 04 80 	movabs $0x80042173f0,%rcx
  8004206ef5:	00 00 00 
  8004206ef8:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206eff:	00 00 00 
  8004206f02:	be 1a 05 00 00       	mov    $0x51a,%esi
  8004206f07:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206f0e:	00 00 00 
  8004206f11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f16:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206f1d:	00 00 00 
  8004206f20:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004206f23:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004206f2a:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206f31:	00 00 00 
  8004206f34:	48 8b 00             	mov    (%rax),%rax
  8004206f37:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206f3c:	48 89 ce             	mov    %rcx,%rsi
  8004206f3f:	48 89 c7             	mov    %rax,%rdi
  8004206f42:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  8004206f49:	00 00 00 
  8004206f4c:	ff d0                	callq  *%rax
  8004206f4e:	48 8b 00             	mov    (%rax),%rax
  8004206f51:	83 e0 1a             	and    $0x1a,%eax
  8004206f54:	48 85 c0             	test   %rax,%rax
  8004206f57:	75 35                	jne    8004206f8e <page_check+0x20a6>
  8004206f59:	48 b9 20 74 21 04 80 	movabs $0x8004217420,%rcx
  8004206f60:	00 00 00 
  8004206f63:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206f6a:	00 00 00 
  8004206f6d:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004206f72:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206f79:	00 00 00 
  8004206f7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f81:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206f88:	00 00 00 
  8004206f8b:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004206f8e:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004206f95:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004206f9c:	00 00 00 
  8004206f9f:	48 8b 00             	mov    (%rax),%rax
  8004206fa2:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206fa7:	48 89 ce             	mov    %rcx,%rsi
  8004206faa:	48 89 c7             	mov    %rax,%rdi
  8004206fad:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  8004206fb4:	00 00 00 
  8004206fb7:	ff d0                	callq  *%rax
  8004206fb9:	48 8b 00             	mov    (%rax),%rax
  8004206fbc:	83 e0 04             	and    $0x4,%eax
  8004206fbf:	48 85 c0             	test   %rax,%rax
  8004206fc2:	74 35                	je     8004206ff9 <page_check+0x2111>
  8004206fc4:	48 b9 68 74 21 04 80 	movabs $0x8004217468,%rcx
  8004206fcb:	00 00 00 
  8004206fce:	48 ba 41 66 21 04 80 	movabs $0x8004216641,%rdx
  8004206fd5:	00 00 00 
  8004206fd8:	be 1d 05 00 00       	mov    $0x51d,%esi
  8004206fdd:	48 bf 56 66 21 04 80 	movabs $0x8004216656,%rdi
  8004206fe4:	00 00 00 
  8004206fe7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fec:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206ff3:	00 00 00 
  8004206ff6:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004206ff9:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207000:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004207007:	00 00 00 
  800420700a:	48 8b 00             	mov    (%rax),%rax
  800420700d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207012:	48 89 ce             	mov    %rcx,%rsi
  8004207015:	48 89 c7             	mov    %rax,%rdi
  8004207018:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  800420701f:	00 00 00 
  8004207022:	ff d0                	callq  *%rax
  8004207024:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  800420702b:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207032:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207038:	48 89 c1             	mov    %rax,%rcx
  800420703b:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004207042:	00 00 00 
  8004207045:	48 8b 00             	mov    (%rax),%rax
  8004207048:	ba 00 00 00 00       	mov    $0x0,%edx
  800420704d:	48 89 ce             	mov    %rcx,%rsi
  8004207050:	48 89 c7             	mov    %rax,%rdi
  8004207053:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  800420705a:	00 00 00 
  800420705d:	ff d0                	callq  *%rax
  800420705f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  8004207066:	48 8b 8d e8 fe ff ff 	mov    -0x118(%rbp),%rcx
  800420706d:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  8004207074:	00 00 00 
  8004207077:	48 8b 00             	mov    (%rax),%rax
  800420707a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420707f:	48 89 ce             	mov    %rcx,%rsi
  8004207082:	48 89 c7             	mov    %rax,%rdi
  8004207085:	48 b8 c6 2b 20 04 80 	movabs $0x8004202bc6,%rax
  800420708c:	00 00 00 
  800420708f:	ff d0                	callq  *%rax
  8004207091:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  8004207098:	48 bf 9b 74 21 04 80 	movabs $0x800421749b,%rdi
  800420709f:	00 00 00 
  80042070a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070a7:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042070ae:	00 00 00 
  80042070b1:	ff d2                	callq  *%rdx
}
  80042070b3:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  80042070ba:	5b                   	pop    %rbx
  80042070bb:	5d                   	pop    %rbp
  80042070bc:	c3                   	retq   

00000080042070bd <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042070bd:	55                   	push   %rbp
  80042070be:	48 89 e5             	mov    %rsp,%rbp
  80042070c1:	48 83 ec 08          	sub    $0x8,%rsp
  80042070c5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042070c9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042070cd:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  80042070d4:	00 00 00 
  80042070d7:	48 8b 00             	mov    (%rax),%rax
  80042070da:	48 29 c2             	sub    %rax,%rdx
  80042070dd:	48 89 d0             	mov    %rdx,%rax
  80042070e0:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042070e4:	c9                   	leaveq 
  80042070e5:	c3                   	retq   

00000080042070e6 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042070e6:	55                   	push   %rbp
  80042070e7:	48 89 e5             	mov    %rsp,%rbp
  80042070ea:	48 83 ec 08          	sub    $0x8,%rsp
  80042070ee:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042070f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042070f6:	48 89 c7             	mov    %rax,%rdi
  80042070f9:	48 b8 bd 70 20 04 80 	movabs $0x80042070bd,%rax
  8004207100:	00 00 00 
  8004207103:	ff d0                	callq  *%rax
  8004207105:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207109:	c9                   	leaveq 
  800420710a:	c3                   	retq   

000000800420710b <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420710b:	55                   	push   %rbp
  800420710c:	48 89 e5             	mov    %rsp,%rbp
  800420710f:	48 83 ec 10          	sub    $0x10,%rsp
  8004207113:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207117:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420711b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420711f:	48 89 c2             	mov    %rax,%rdx
  8004207122:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004207129:	00 00 00 
  800420712c:	48 8b 00             	mov    (%rax),%rax
  800420712f:	48 39 c2             	cmp    %rax,%rdx
  8004207132:	72 2a                	jb     800420715e <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207134:	48 ba b8 74 21 04 80 	movabs $0x80042174b8,%rdx
  800420713b:	00 00 00 
  800420713e:	be 54 00 00 00       	mov    $0x54,%esi
  8004207143:	48 bf d7 74 21 04 80 	movabs $0x80042174d7,%rdi
  800420714a:	00 00 00 
  800420714d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207152:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004207159:	00 00 00 
  800420715c:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800420715e:	48 b8 38 f7 6b 04 80 	movabs $0x80046bf738,%rax
  8004207165:	00 00 00 
  8004207168:	48 8b 00             	mov    (%rax),%rax
  800420716b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420716f:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207173:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207177:	48 01 d0             	add    %rdx,%rax
}
  800420717a:	c9                   	leaveq 
  800420717b:	c3                   	retq   

000000800420717c <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800420717c:	55                   	push   %rbp
  800420717d:	48 89 e5             	mov    %rsp,%rbp
  8004207180:	48 83 ec 20          	sub    $0x20,%rsp
  8004207184:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207188:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420718c:	48 89 c7             	mov    %rax,%rdi
  800420718f:	48 b8 e6 70 20 04 80 	movabs $0x80042070e6,%rax
  8004207196:	00 00 00 
  8004207199:	ff d0                	callq  *%rax
  800420719b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420719f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042071a3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042071a7:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042071aa:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042071ad:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  80042071b4:	00 00 00 
  80042071b7:	48 8b 00             	mov    (%rax),%rax
  80042071ba:	48 39 c2             	cmp    %rax,%rdx
  80042071bd:	72 32                	jb     80042071f1 <page2kva+0x75>
  80042071bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042071c3:	48 89 c1             	mov    %rax,%rcx
  80042071c6:	48 ba e8 74 21 04 80 	movabs $0x80042174e8,%rdx
  80042071cd:	00 00 00 
  80042071d0:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042071d5:	48 bf d7 74 21 04 80 	movabs $0x80042174d7,%rdi
  80042071dc:	00 00 00 
  80042071df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071e4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042071eb:	00 00 00 
  80042071ee:	41 ff d0             	callq  *%r8
  80042071f1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042071f8:	00 00 00 
  80042071fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042071ff:	48 01 d0             	add    %rdx,%rax
}
  8004207202:	c9                   	leaveq 
  8004207203:	c3                   	retq   

0000008004207204 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207204:	55                   	push   %rbp
  8004207205:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207208:	48 bf 60 b7 22 04 80 	movabs $0x800422b760,%rdi
  800420720f:	00 00 00 
  8004207212:	48 b8 4b 60 21 04 80 	movabs $0x800421604b,%rax
  8004207219:	00 00 00 
  800420721c:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420721e:	f3 90                	pause  
}
  8004207220:	5d                   	pop    %rbp
  8004207221:	c3                   	retq   

0000008004207222 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207222:	55                   	push   %rbp
  8004207223:	48 89 e5             	mov    %rsp,%rbp
  8004207226:	53                   	push   %rbx
  8004207227:	48 83 ec 28          	sub    $0x28,%rsp
  800420722b:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420722e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207232:	89 d0                	mov    %edx,%eax
  8004207234:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207237:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420723b:	75 42                	jne    800420727f <envid2env+0x5d>
		*env_store = curenv;
  800420723d:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004207244:	00 00 00 
  8004207247:	ff d0                	callq  *%rax
  8004207249:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  8004207250:	00 00 00 
  8004207253:	48 98                	cltq   
  8004207255:	48 c1 e0 03          	shl    $0x3,%rax
  8004207259:	48 89 c2             	mov    %rax,%rdx
  800420725c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207260:	48 29 c2             	sub    %rax,%rdx
  8004207263:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207267:	48 83 c0 08          	add    $0x8,%rax
  800420726b:	48 8b 10             	mov    (%rax),%rdx
  800420726e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207272:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207275:	b8 00 00 00 00       	mov    $0x0,%eax
  800420727a:	e9 09 01 00 00       	jmpq   8004207388 <envid2env+0x166>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  800420727f:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  8004207286:	00 00 00 
  8004207289:	48 8b 08             	mov    (%rax),%rcx
  800420728c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420728f:	48 98                	cltq   
  8004207291:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207296:	48 89 c2             	mov    %rax,%rdx
  8004207299:	48 89 d0             	mov    %rdx,%rax
  800420729c:	48 c1 e0 03          	shl    $0x3,%rax
  80042072a0:	48 01 d0             	add    %rdx,%rax
  80042072a3:	48 c1 e0 05          	shl    $0x5,%rax
  80042072a7:	48 01 c8             	add    %rcx,%rax
  80042072aa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  80042072ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042072b2:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042072b8:	85 c0                	test   %eax,%eax
  80042072ba:	74 0f                	je     80042072cb <envid2env+0xa9>
  80042072bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042072c0:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042072c6:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  80042072c9:	74 15                	je     80042072e0 <envid2env+0xbe>
		*env_store = 0;
  80042072cb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042072cf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  80042072d6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80042072db:	e9 a8 00 00 00       	jmpq   8004207388 <envid2env+0x166>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  80042072e0:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  80042072e4:	0f 84 8e 00 00 00    	je     8004207378 <envid2env+0x156>
  80042072ea:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042072f1:	00 00 00 
  80042072f4:	ff d0                	callq  *%rax
  80042072f6:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  80042072fd:	00 00 00 
  8004207300:	48 98                	cltq   
  8004207302:	48 c1 e0 03          	shl    $0x3,%rax
  8004207306:	48 89 c2             	mov    %rax,%rdx
  8004207309:	48 c1 e2 04          	shl    $0x4,%rdx
  800420730d:	48 29 c2             	sub    %rax,%rdx
  8004207310:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207314:	48 83 c0 08          	add    $0x8,%rax
  8004207318:	48 8b 00             	mov    (%rax),%rax
  800420731b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420731f:	74 57                	je     8004207378 <envid2env+0x156>
  8004207321:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207325:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  800420732b:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004207332:	00 00 00 
  8004207335:	ff d0                	callq  *%rax
  8004207337:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420733e:	00 00 00 
  8004207341:	48 98                	cltq   
  8004207343:	48 c1 e0 03          	shl    $0x3,%rax
  8004207347:	48 89 c2             	mov    %rax,%rdx
  800420734a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420734e:	48 29 c2             	sub    %rax,%rdx
  8004207351:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207355:	48 83 c0 08          	add    $0x8,%rax
  8004207359:	48 8b 00             	mov    (%rax),%rax
  800420735c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207362:	39 c3                	cmp    %eax,%ebx
  8004207364:	74 12                	je     8004207378 <envid2env+0x156>
		*env_store = 0;
  8004207366:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420736a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207371:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207376:	eb 10                	jmp    8004207388 <envid2env+0x166>
	}

	*env_store = e;
  8004207378:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420737c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207380:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207383:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207388:	48 83 c4 28          	add    $0x28,%rsp
  800420738c:	5b                   	pop    %rbx
  800420738d:	5d                   	pop    %rbp
  800420738e:	c3                   	retq   

000000800420738f <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  800420738f:	55                   	push   %rbp
  8004207390:	48 89 e5             	mov    %rsp,%rbp
  8004207393:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.

	env_free_list = &envs[0];
  8004207397:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  800420739e:	00 00 00 
  80042073a1:	48 8b 10             	mov    (%rax),%rdx
  80042073a4:	48 b8 58 e2 6b 04 80 	movabs $0x80046be258,%rax
  80042073ab:	00 00 00 
  80042073ae:	48 89 10             	mov    %rdx,(%rax)
	struct Env *last = NULL;
  80042073b1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042073b8:	00 
	int i;
	for(i=0; i< NENV; i++){
  80042073b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042073c0:	e9 ff 00 00 00       	jmpq   80042074c4 <env_init+0x135>
		envs[i].env_id = 0;
  80042073c5:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  80042073cc:	00 00 00 
  80042073cf:	48 8b 08             	mov    (%rax),%rcx
  80042073d2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042073d5:	48 63 d0             	movslq %eax,%rdx
  80042073d8:	48 89 d0             	mov    %rdx,%rax
  80042073db:	48 c1 e0 03          	shl    $0x3,%rax
  80042073df:	48 01 d0             	add    %rdx,%rax
  80042073e2:	48 c1 e0 05          	shl    $0x5,%rax
  80042073e6:	48 01 c8             	add    %rcx,%rax
  80042073e9:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  80042073f0:	00 00 00 
		envs[i].env_status = ENV_FREE;
  80042073f3:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  80042073fa:	00 00 00 
  80042073fd:	48 8b 08             	mov    (%rax),%rcx
  8004207400:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207403:	48 63 d0             	movslq %eax,%rdx
  8004207406:	48 89 d0             	mov    %rdx,%rax
  8004207409:	48 c1 e0 03          	shl    $0x3,%rax
  800420740d:	48 01 d0             	add    %rdx,%rax
  8004207410:	48 c1 e0 05          	shl    $0x5,%rax
  8004207414:	48 01 c8             	add    %rcx,%rax
  8004207417:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  800420741e:	00 00 00 
		envs[i].env_link = NULL;
  8004207421:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  8004207428:	00 00 00 
  800420742b:	48 8b 08             	mov    (%rax),%rcx
  800420742e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207431:	48 63 d0             	movslq %eax,%rdx
  8004207434:	48 89 d0             	mov    %rdx,%rax
  8004207437:	48 c1 e0 03          	shl    $0x3,%rax
  800420743b:	48 01 d0             	add    %rdx,%rax
  800420743e:	48 c1 e0 05          	shl    $0x5,%rax
  8004207442:	48 01 c8             	add    %rcx,%rax
  8004207445:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  800420744c:	00 00 00 00 
		if(last == NULL){
  8004207450:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207455:	75 2a                	jne    8004207481 <env_init+0xf2>
			last = &envs[i];
  8004207457:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  800420745e:	00 00 00 
  8004207461:	48 8b 08             	mov    (%rax),%rcx
  8004207464:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207467:	48 63 d0             	movslq %eax,%rdx
  800420746a:	48 89 d0             	mov    %rdx,%rax
  800420746d:	48 c1 e0 03          	shl    $0x3,%rax
  8004207471:	48 01 d0             	add    %rdx,%rax
  8004207474:	48 c1 e0 05          	shl    $0x5,%rax
  8004207478:	48 01 c8             	add    %rcx,%rax
  800420747b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420747f:	eb 3f                	jmp    80042074c0 <env_init+0x131>
		} else {
			last->env_link = &envs[i];
  8004207481:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  8004207488:	00 00 00 
  800420748b:	48 8b 08             	mov    (%rax),%rcx
  800420748e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207491:	48 63 d0             	movslq %eax,%rdx
  8004207494:	48 89 d0             	mov    %rdx,%rax
  8004207497:	48 c1 e0 03          	shl    $0x3,%rax
  800420749b:	48 01 d0             	add    %rdx,%rax
  800420749e:	48 c1 e0 05          	shl    $0x5,%rax
  80042074a2:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042074a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042074aa:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
			last = last->env_link;
  80042074b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042074b5:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  80042074bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	// LAB 3: Your code here.

	env_free_list = &envs[0];
	struct Env *last = NULL;
	int i;
	for(i=0; i< NENV; i++){
  80042074c0:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042074c4:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%rbp)
  80042074cb:	0f 8e f4 fe ff ff    	jle    80042073c5 <env_init+0x36>
			last = last->env_link;
		}
	}

	// Per-CPU part of the initialization
	env_init_percpu();
  80042074d1:	48 b8 df 74 20 04 80 	movabs $0x80042074df,%rax
  80042074d8:	00 00 00 
  80042074db:	ff d0                	callq  *%rax
}
  80042074dd:	c9                   	leaveq 
  80042074de:	c3                   	retq   

00000080042074df <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  80042074df:	55                   	push   %rbp
  80042074e0:	48 89 e5             	mov    %rsp,%rbp
  80042074e3:	53                   	push   %rbx
  80042074e4:	48 83 ec 10          	sub    $0x10,%rsp
  80042074e8:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  80042074ef:	00 00 00 
  80042074f2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  80042074f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042074fa:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  80042074fd:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207502:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207504:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207509:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  800420750b:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207510:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207512:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207517:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004207519:	b8 10 00 00 00       	mov    $0x10,%eax
  800420751e:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207520:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207525:	89 c3                	mov    %eax,%ebx
  8004207527:	53                   	push   %rbx
  8004207528:	48 b8 35 75 20 04 80 	movabs $0x8004207535,%rax
  800420752f:	00 00 00 
  8004207532:	50                   	push   %rax
  8004207533:	48 cb                	lretq  
  8004207535:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  800420753b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420753f:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  8004207542:	48 83 c4 10          	add    $0x10,%rsp
  8004207546:	5b                   	pop    %rbx
  8004207547:	5d                   	pop    %rbp
  8004207548:	c3                   	retq   

0000008004207549 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004207549:	55                   	push   %rbp
  800420754a:	48 89 e5             	mov    %rsp,%rbp
  800420754d:	48 83 ec 20          	sub    $0x20,%rsp
  8004207551:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004207555:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420755c:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  800420755d:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207562:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004207569:	00 00 00 
  800420756c:	ff d0                	callq  *%rax
  800420756e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207572:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207577:	75 0a                	jne    8004207583 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004207579:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420757e:	e9 98 00 00 00       	jmpq   800420761b <env_setup_vm+0xd2>
	//	is an exception -- you need to increment env_pml4e's
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.
	e->env_pml4e = page2kva(p);
  8004207583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207587:	48 89 c7             	mov    %rax,%rdi
  800420758a:	48 b8 7c 71 20 04 80 	movabs $0x800420717c,%rax
  8004207591:	00 00 00 
  8004207594:	ff d0                	callq  *%rax
  8004207596:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420759a:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3 = page2pa(p);
  80042075a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042075a5:	48 89 c7             	mov    %rax,%rdi
  80042075a8:	48 b8 e6 70 20 04 80 	movabs $0x80042070e6,%rax
  80042075af:	00 00 00 
  80042075b2:	ff d0                	callq  *%rax
  80042075b4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042075b8:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)
	p->pp_ref++;
  80042075bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042075c3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042075c7:	8d 50 01             	lea    0x1(%rax),%edx
  80042075ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042075ce:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e[1] = boot_pml4e[1];
  80042075d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042075d6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042075dd:	48 8d 50 08          	lea    0x8(%rax),%rdx
  80042075e1:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  80042075e8:	00 00 00 
  80042075eb:	48 8b 00             	mov    (%rax),%rax
  80042075ee:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042075f2:	48 89 02             	mov    %rax,(%rdx)
	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  80042075f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042075f9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207600:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004207604:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207608:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420760f:	48 83 c8 05          	or     $0x5,%rax
  8004207613:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  8004207616:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420761b:	c9                   	leaveq 
  800420761c:	c3                   	retq   

000000800420761d <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  800420761d:	55                   	push   %rbp
  800420761e:	48 89 e5             	mov    %rsp,%rbp
  8004207621:	48 83 ec 30          	sub    $0x30,%rsp
  8004207625:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207629:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  800420762c:	48 b8 58 e2 6b 04 80 	movabs $0x80046be258,%rax
  8004207633:	00 00 00 
  8004207636:	48 8b 00             	mov    (%rax),%rax
  8004207639:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420763d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207642:	75 0a                	jne    800420764e <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004207644:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004207649:	e9 76 01 00 00       	jmpq   80042077c4 <env_alloc+0x1a7>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  800420764e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207652:	48 89 c7             	mov    %rax,%rdi
  8004207655:	48 b8 49 75 20 04 80 	movabs $0x8004207549,%rax
  800420765c:	00 00 00 
  800420765f:	ff d0                	callq  *%rax
  8004207661:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004207664:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004207668:	79 08                	jns    8004207672 <env_alloc+0x55>
		return r;
  800420766a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420766d:	e9 52 01 00 00       	jmpq   80042077c4 <env_alloc+0x1a7>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207672:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207676:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420767c:	05 00 10 00 00       	add    $0x1000,%eax
  8004207681:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207686:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207689:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420768d:	7f 07                	jg     8004207696 <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  800420768f:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004207696:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420769a:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  80042076a1:	00 00 00 
  80042076a4:	48 8b 00             	mov    (%rax),%rax
  80042076a7:	48 29 c2             	sub    %rax,%rdx
  80042076aa:	48 89 d0             	mov    %rdx,%rax
  80042076ad:	48 c1 f8 05          	sar    $0x5,%rax
  80042076b1:	48 89 c2             	mov    %rax,%rdx
  80042076b4:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  80042076bb:	e3 38 8e 
  80042076be:	48 0f af c2          	imul   %rdx,%rax
  80042076c2:	0b 45 fc             	or     -0x4(%rbp),%eax
  80042076c5:	89 c2                	mov    %eax,%edx
  80042076c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042076cb:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  80042076d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042076d5:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042076d8:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  80042076de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042076e2:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  80042076e9:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  80042076ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042076f0:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  80042076f7:	00 00 00 
	e->env_runs = 0;
  80042076fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042076fe:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207705:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207708:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420770c:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004207711:	be 00 00 00 00       	mov    $0x0,%esi
  8004207716:	48 89 c7             	mov    %rax,%rdi
  8004207719:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004207720:	00 00 00 
  8004207723:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004207725:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207729:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004207730:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004207732:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207736:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  800420773c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207740:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004207747:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004207749:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420774d:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  8004207752:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004207759:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420775d:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004207764:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags |= FL_IF;
  8004207766:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420776a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207771:	80 cc 02             	or     $0x2,%ah
  8004207774:	48 89 c2             	mov    %rax,%rdx
  8004207777:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420777b:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207782:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207786:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  800420778d:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207791:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207795:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  800420779c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042077a0:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  80042077a7:	48 b8 58 e2 6b 04 80 	movabs $0x80046be258,%rax
  80042077ae:	00 00 00 
  80042077b1:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  80042077b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042077b8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042077bc:	48 89 10             	mov    %rdx,(%rax)

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  80042077bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042077c4:	c9                   	leaveq 
  80042077c5:	c3                   	retq   

00000080042077c6 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  80042077c6:	55                   	push   %rbp
  80042077c7:	48 89 e5             	mov    %rsp,%rbp
  80042077ca:	48 83 ec 60          	sub    $0x60,%rsp
  80042077ce:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042077d2:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042077d6:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
	// LAB 3: Your code here.
	void *start = ROUNDDOWN(va, PGSIZE);
  80042077da:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042077de:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042077e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042077e6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042077ec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  void *end = ROUNDUP(va + len, PGSIZE);
  80042077f0:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  80042077f7:	00 
  80042077f8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042077fc:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207800:	48 01 d0             	add    %rdx,%rax
  8004207803:	48 89 c2             	mov    %rax,%rdx
  8004207806:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420780a:	48 01 d0             	add    %rdx,%rax
  800420780d:	48 83 e8 01          	sub    $0x1,%rax
  8004207811:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004207815:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207819:	ba 00 00 00 00       	mov    $0x0,%edx
  800420781e:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004207822:	48 89 d0             	mov    %rdx,%rax
  8004207825:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004207829:	48 29 c2             	sub    %rax,%rdx
  800420782c:	48 89 d0             	mov    %rdx,%rax
  800420782f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  for(; start < end; start += PGSIZE) {
  8004207833:	e9 c3 00 00 00       	jmpq   80042078fb <region_alloc+0x135>
      struct PageInfo *pp = page_alloc(0);
  8004207838:	bf 00 00 00 00       	mov    $0x0,%edi
  800420783d:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  8004207844:	00 00 00 
  8004207847:	ff d0                	callq  *%rax
  8004207849:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
      if (pp) {
  800420784d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004207852:	74 7d                	je     80042078d1 <region_alloc+0x10b>
          pp->pp_ref++;
  8004207854:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207858:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420785c:	8d 50 01             	lea    0x1(%rax),%edx
  800420785f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207863:	66 89 50 08          	mov    %dx,0x8(%rax)
          int ret = page_insert(e->env_pml4e, pp, start, PTE_W | PTE_U);
  8004207867:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420786b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207872:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207876:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420787a:	b9 06 00 00 00       	mov    $0x6,%ecx
  800420787f:	48 89 c7             	mov    %rax,%rdi
  8004207882:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  8004207889:	00 00 00 
  800420788c:	ff d0                	callq  *%rax
  800420788e:	89 45 cc             	mov    %eax,-0x34(%rbp)
          if (ret < 0) {
  8004207891:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004207895:	79 30                	jns    80042078c7 <region_alloc+0x101>
              panic("region_alloc: %e \n", ret);
  8004207897:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420789a:	89 c1                	mov    %eax,%ecx
  800420789c:	48 ba 0b 75 21 04 80 	movabs $0x800421750b,%rdx
  80042078a3:	00 00 00 
  80042078a6:	be 37 01 00 00       	mov    $0x137,%esi
  80042078ab:	48 bf 1e 75 21 04 80 	movabs $0x800421751e,%rdi
  80042078b2:	00 00 00 
  80042078b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078ba:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042078c1:	00 00 00 
  80042078c4:	41 ff d0             	callq  *%r8
region_alloc(struct Env *e, void *va, size_t len)
{
	// LAB 3: Your code here.
	void *start = ROUNDDOWN(va, PGSIZE);
  void *end = ROUNDUP(va + len, PGSIZE);
  for(; start < end; start += PGSIZE) {
  80042078c7:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042078ce:	00 
  80042078cf:	eb 2a                	jmp    80042078fb <region_alloc+0x135>
          int ret = page_insert(e->env_pml4e, pp, start, PTE_W | PTE_U);
          if (ret < 0) {
              panic("region_alloc: %e \n", ret);
          }
      } else {
          panic("region_alloc: page allocation failed!! \n");
  80042078d1:	48 ba 30 75 21 04 80 	movabs $0x8004217530,%rdx
  80042078d8:	00 00 00 
  80042078db:	be 3a 01 00 00       	mov    $0x13a,%esi
  80042078e0:	48 bf 1e 75 21 04 80 	movabs $0x800421751e,%rdi
  80042078e7:	00 00 00 
  80042078ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078ef:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042078f6:	00 00 00 
  80042078f9:	ff d1                	callq  *%rcx
region_alloc(struct Env *e, void *va, size_t len)
{
	// LAB 3: Your code here.
	void *start = ROUNDDOWN(va, PGSIZE);
  void *end = ROUNDUP(va + len, PGSIZE);
  for(; start < end; start += PGSIZE) {
  80042078fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042078ff:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004207903:	0f 82 2f ff ff ff    	jb     8004207838 <region_alloc+0x72>
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
}
  8004207909:	c9                   	leaveq 
  800420790a:	c3                   	retq   

000000800420790b <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  800420790b:	55                   	push   %rbp
  800420790c:	48 89 e5             	mov    %rsp,%rbp
  800420790f:	48 83 ec 40          	sub    $0x40,%rsp
  8004207913:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207917:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	// LAB 3: Your code here
	// Now map one page for the program's initial stack
	// at virtual address USTACKTOP - PGSIZE.

	// LAB 3: Your code here.
	e->elf = binary;
  800420791b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420791f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004207923:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)


  struct Proghdr *program_header, *end_program_header;
  struct Elf *elf = (struct Elf *) binary;
  800420792a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420792e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  program_header = (struct Proghdr *) (binary + elf->e_phoff);
  8004207932:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207936:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800420793a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420793e:	48 01 d0             	add    %rdx,%rax
  8004207941:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  end_program_header = program_header + elf->e_phnum;
  8004207945:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207949:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  800420794d:	0f b7 c0             	movzwl %ax,%eax
  8004207950:	48 c1 e0 03          	shl    $0x3,%rax
  8004207954:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420795b:	00 
  800420795c:	48 29 c2             	sub    %rax,%rdx
  800420795f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207963:	48 01 d0             	add    %rdx,%rax
  8004207966:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  lcr3(e->env_cr3); // Important!
  800420796a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420796e:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207975:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004207979:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420797d:	0f 22 d8             	mov    %rax,%cr3

  for (; program_header < end_program_header; program_header++) {
  8004207980:	e9 a8 00 00 00       	jmpq   8004207a2d <load_icode+0x122>
      if (program_header->p_type == ELF_PROG_LOAD) {
  8004207985:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207989:	8b 00                	mov    (%rax),%eax
  800420798b:	83 f8 01             	cmp    $0x1,%eax
  800420798e:	0f 85 94 00 00 00    	jne    8004207a28 <load_icode+0x11d>
          region_alloc(e, (void *) program_header->p_va, program_header->p_memsz);
  8004207994:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207998:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420799c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079a0:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042079a4:	48 89 c1             	mov    %rax,%rcx
  80042079a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042079ab:	48 89 ce             	mov    %rcx,%rsi
  80042079ae:	48 89 c7             	mov    %rax,%rdi
  80042079b1:	48 b8 c6 77 20 04 80 	movabs $0x80042077c6,%rax
  80042079b8:	00 00 00 
  80042079bb:	ff d0                	callq  *%rax
          memmove((void *) program_header->p_va, (void *)binary + program_header->p_offset, program_header->p_filesz);
  80042079bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079c1:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042079c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079c9:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042079cd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042079d1:	48 01 c1             	add    %rax,%rcx
  80042079d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079d8:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042079dc:	48 89 ce             	mov    %rcx,%rsi
  80042079df:	48 89 c7             	mov    %rax,%rdi
  80042079e2:	48 b8 d6 ec 20 04 80 	movabs $0x800420ecd6,%rax
  80042079e9:	00 00 00 
  80042079ec:	ff d0                	callq  *%rax
          memset((void *)program_header->p_va + program_header->p_filesz, 0, program_header->p_memsz - program_header->p_filesz);
  80042079ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079f2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042079f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042079fa:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042079fe:	48 29 c2             	sub    %rax,%rdx
  8004207a01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a05:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004207a09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a0d:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207a11:	48 01 c8             	add    %rcx,%rax
  8004207a14:	be 00 00 00 00       	mov    $0x0,%esi
  8004207a19:	48 89 c7             	mov    %rax,%rdi
  8004207a1c:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004207a23:	00 00 00 
  8004207a26:	ff d0                	callq  *%rax
  program_header = (struct Proghdr *) (binary + elf->e_phoff);
  end_program_header = program_header + elf->e_phnum;

  lcr3(e->env_cr3); // Important!

  for (; program_header < end_program_header; program_header++) {
  8004207a28:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004207a2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a31:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207a35:	0f 82 4a ff ff ff    	jb     8004207985 <load_icode+0x7a>
          memmove((void *) program_header->p_va, (void *)binary + program_header->p_offset, program_header->p_filesz);
          memset((void *)program_header->p_va + program_header->p_filesz, 0, program_header->p_memsz - program_header->p_filesz);
      }
  }

  lcr3(boot_cr3);
  8004207a3b:	48 b8 20 f7 6b 04 80 	movabs $0x80046bf720,%rax
  8004207a42:	00 00 00 
  8004207a45:	48 8b 00             	mov    (%rax),%rax
  8004207a48:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004207a4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207a50:	0f 22 d8             	mov    %rax,%cr3

  region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE); // the stack for user space
  8004207a53:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207a57:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004207a5c:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004207a61:	48 89 c7             	mov    %rax,%rdi
  8004207a64:	48 b8 c6 77 20 04 80 	movabs $0x80042077c6,%rax
  8004207a6b:	00 00 00 
  8004207a6e:	ff d0                	callq  *%rax
  e->env_tf.tf_rip = elf->e_entry;
  8004207a70:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a74:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004207a78:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207a7c:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
}
  8004207a83:	c9                   	leaveq 
  8004207a84:	c3                   	retq   

0000008004207a85 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004207a85:	55                   	push   %rbp
  8004207a86:	48 89 e5             	mov    %rsp,%rbp
  8004207a89:	48 83 ec 20          	sub    $0x20,%rsp
  8004207a8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004207a91:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.
	struct Env *env;
	int ret = env_alloc(&env, 0);
  8004207a94:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004207a98:	be 00 00 00 00       	mov    $0x0,%esi
  8004207a9d:	48 89 c7             	mov    %rax,%rdi
  8004207aa0:	48 b8 1d 76 20 04 80 	movabs $0x800420761d,%rax
  8004207aa7:	00 00 00 
  8004207aaa:	ff d0                	callq  *%rax
  8004207aac:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (ret < 0) {
  8004207aaf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207ab3:	79 30                	jns    8004207ae5 <env_create+0x60>
			panic("env_alloc: %e", ret);
  8004207ab5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207ab8:	89 c1                	mov    %eax,%ecx
  8004207aba:	48 ba 59 75 21 04 80 	movabs $0x8004217559,%rdx
  8004207ac1:	00 00 00 
  8004207ac4:	be a6 01 00 00       	mov    $0x1a6,%esi
  8004207ac9:	48 bf 1e 75 21 04 80 	movabs $0x800421751e,%rdi
  8004207ad0:	00 00 00 
  8004207ad3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ad8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207adf:	00 00 00 
  8004207ae2:	41 ff d0             	callq  *%r8
	}
	load_icode(env, binary);
  8004207ae5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ae9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207aed:	48 89 d6             	mov    %rdx,%rsi
  8004207af0:	48 89 c7             	mov    %rax,%rdi
  8004207af3:	48 b8 0b 79 20 04 80 	movabs $0x800420790b,%rax
  8004207afa:	00 00 00 
  8004207afd:	ff d0                	callq  *%rax
	env->env_type = type;
  8004207aff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b03:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004207b06:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)

	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.
	if(type == ENV_TYPE_FS)
  8004207b0c:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8004207b10:	75 19                	jne    8004207b2b <env_create+0xa6>
		env->env_tf.tf_eflags |= FL_IOPL_3;
  8004207b12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b16:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207b1a:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004207b21:	80 ce 30             	or     $0x30,%dh
  8004207b24:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  8004207b2b:	c9                   	leaveq 
  8004207b2c:	c3                   	retq   

0000008004207b2d <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004207b2d:	55                   	push   %rbp
  8004207b2e:	48 89 e5             	mov    %rsp,%rbp
  8004207b31:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004207b38:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004207b3f:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004207b46:	00 00 00 
  8004207b49:	ff d0                	callq  *%rax
  8004207b4b:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  8004207b52:	00 00 00 
  8004207b55:	48 98                	cltq   
  8004207b57:	48 c1 e0 03          	shl    $0x3,%rax
  8004207b5b:	48 89 c2             	mov    %rax,%rdx
  8004207b5e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207b62:	48 29 c2             	sub    %rax,%rdx
  8004207b65:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207b69:	48 83 c0 08          	add    $0x8,%rax
  8004207b6d:	48 8b 00             	mov    (%rax),%rax
  8004207b70:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004207b77:	75 18                	jne    8004207b91 <env_free+0x64>
		lcr3(boot_cr3);
  8004207b79:	48 b8 20 f7 6b 04 80 	movabs $0x80046bf720,%rax
  8004207b80:	00 00 00 
  8004207b83:	48 8b 00             	mov    (%rax),%rax
  8004207b86:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004207b8a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004207b8e:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	if (e->env_pml4e[0] & PTE_P) {
  8004207b91:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207b98:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207b9f:	48 8b 00             	mov    (%rax),%rax
  8004207ba2:	83 e0 01             	and    $0x1,%eax
  8004207ba5:	48 85 c0             	test   %rax,%rax
  8004207ba8:	0f 84 7a 03 00 00    	je     8004207f28 <env_free+0x3fb>
		pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004207bae:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207bb5:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207bbc:	48 8b 00             	mov    (%rax),%rax
  8004207bbf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207bc5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004207bc9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207bcd:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207bd1:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004207bd4:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004207bd7:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004207bde:	00 00 00 
  8004207be1:	48 8b 00             	mov    (%rax),%rax
  8004207be4:	48 39 c2             	cmp    %rax,%rdx
  8004207be7:	72 32                	jb     8004207c1b <env_free+0xee>
  8004207be9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207bed:	48 89 c1             	mov    %rax,%rcx
  8004207bf0:	48 ba e8 74 21 04 80 	movabs $0x80042174e8,%rdx
  8004207bf7:	00 00 00 
  8004207bfa:	be c7 01 00 00       	mov    $0x1c7,%esi
  8004207bff:	48 bf 1e 75 21 04 80 	movabs $0x800421751e,%rdi
  8004207c06:	00 00 00 
  8004207c09:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c0e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207c15:	00 00 00 
  8004207c18:	41 ff d0             	callq  *%r8
  8004207c1b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207c22:	00 00 00 
  8004207c25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c29:	48 01 d0             	add    %rdx,%rax
  8004207c2c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		int pdeno_limit;
		uint64_t pdpe_index;
		// using 3 instead of NPDPENTRIES as we have only first three indices
		// set for 4GB of address space.
		for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004207c30:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004207c37:	00 
  8004207c38:	e9 ab 02 00 00       	jmpq   8004207ee8 <env_free+0x3bb>
			if(!(env_pdpe[pdpe_index] & PTE_P))
  8004207c3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207c41:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207c48:	00 
  8004207c49:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207c4d:	48 01 d0             	add    %rdx,%rax
  8004207c50:	48 8b 00             	mov    (%rax),%rax
  8004207c53:	83 e0 01             	and    $0x1,%eax
  8004207c56:	48 85 c0             	test   %rax,%rax
  8004207c59:	75 05                	jne    8004207c60 <env_free+0x133>
				continue;
  8004207c5b:	e9 83 02 00 00       	jmpq   8004207ee3 <env_free+0x3b6>
			pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004207c60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207c64:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207c6b:	00 
  8004207c6c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207c70:	48 01 d0             	add    %rdx,%rax
  8004207c73:	48 8b 00             	mov    (%rax),%rax
  8004207c76:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207c7c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004207c80:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207c84:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207c88:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004207c8b:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004207c8e:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004207c95:	00 00 00 
  8004207c98:	48 8b 00             	mov    (%rax),%rax
  8004207c9b:	48 39 c2             	cmp    %rax,%rdx
  8004207c9e:	72 32                	jb     8004207cd2 <env_free+0x1a5>
  8004207ca0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207ca4:	48 89 c1             	mov    %rax,%rcx
  8004207ca7:	48 ba e8 74 21 04 80 	movabs $0x80042174e8,%rdx
  8004207cae:	00 00 00 
  8004207cb1:	be cf 01 00 00       	mov    $0x1cf,%esi
  8004207cb6:	48 bf 1e 75 21 04 80 	movabs $0x800421751e,%rdi
  8004207cbd:	00 00 00 
  8004207cc0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207cc5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207ccc:	00 00 00 
  8004207ccf:	41 ff d0             	callq  *%r8
  8004207cd2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207cd9:	00 00 00 
  8004207cdc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207ce0:	48 01 d0             	add    %rdx,%rax
  8004207ce3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004207ce7:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004207cec:	75 07                	jne    8004207cf5 <env_free+0x1c8>
  8004207cee:	b8 04 00 00 00       	mov    $0x4,%eax
  8004207cf3:	eb 05                	jmp    8004207cfa <env_free+0x1cd>
  8004207cf5:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004207cfa:	89 45 b4             	mov    %eax,-0x4c(%rbp)
			static_assert(UTOP % PTSIZE == 0);
			for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004207cfd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207d04:	00 
  8004207d05:	e9 6e 01 00 00       	jmpq   8004207e78 <env_free+0x34b>

				// only look at mapped page tables
				if (!(env_pgdir[pdeno] & PTE_P))
  8004207d0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d0e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207d15:	00 
  8004207d16:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207d1a:	48 01 d0             	add    %rdx,%rax
  8004207d1d:	48 8b 00             	mov    (%rax),%rax
  8004207d20:	83 e0 01             	and    $0x1,%eax
  8004207d23:	48 85 c0             	test   %rax,%rax
  8004207d26:	75 05                	jne    8004207d2d <env_free+0x200>
					continue;
  8004207d28:	e9 46 01 00 00       	jmpq   8004207e73 <env_free+0x346>
				// find the pa and va of the page table
				pa = PTE_ADDR(env_pgdir[pdeno]);
  8004207d2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d31:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207d38:	00 
  8004207d39:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207d3d:	48 01 d0             	add    %rdx,%rax
  8004207d40:	48 8b 00             	mov    (%rax),%rax
  8004207d43:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207d49:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				pt = (pte_t*) KADDR(pa);
  8004207d4d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207d51:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004207d55:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004207d59:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207d5d:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004207d60:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004207d63:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004207d6a:	00 00 00 
  8004207d6d:	48 8b 00             	mov    (%rax),%rax
  8004207d70:	48 39 c2             	cmp    %rax,%rdx
  8004207d73:	72 32                	jb     8004207da7 <env_free+0x27a>
  8004207d75:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004207d79:	48 89 c1             	mov    %rax,%rcx
  8004207d7c:	48 ba e8 74 21 04 80 	movabs $0x80042174e8,%rdx
  8004207d83:	00 00 00 
  8004207d86:	be d9 01 00 00       	mov    $0x1d9,%esi
  8004207d8b:	48 bf 1e 75 21 04 80 	movabs $0x800421751e,%rdi
  8004207d92:	00 00 00 
  8004207d95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d9a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207da1:	00 00 00 
  8004207da4:	41 ff d0             	callq  *%r8
  8004207da7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207dae:	00 00 00 
  8004207db1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004207db5:	48 01 d0             	add    %rdx,%rax
  8004207db8:	48 89 45 90          	mov    %rax,-0x70(%rbp)

				// unmap all PTEs in this page table
				for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004207dbc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004207dc3:	00 
  8004207dc4:	eb 67                	jmp    8004207e2d <env_free+0x300>
					if (pt[pteno] & PTE_P){
  8004207dc6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207dca:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207dd1:	00 
  8004207dd2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004207dd6:	48 01 d0             	add    %rdx,%rax
  8004207dd9:	48 8b 00             	mov    (%rax),%rax
  8004207ddc:	83 e0 01             	and    $0x1,%eax
  8004207ddf:	48 85 c0             	test   %rax,%rax
  8004207de2:	74 44                	je     8004207e28 <env_free+0x2fb>
						page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004207de4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207de8:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004207dec:	48 89 c2             	mov    %rax,%rdx
  8004207def:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207df3:	48 c1 e0 15          	shl    $0x15,%rax
  8004207df7:	48 09 c2             	or     %rax,%rdx
  8004207dfa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207dfe:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207e02:	48 09 d0             	or     %rdx,%rax
  8004207e05:	48 89 c2             	mov    %rax,%rdx
  8004207e08:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207e0f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207e16:	48 89 d6             	mov    %rdx,%rsi
  8004207e19:	48 89 c7             	mov    %rax,%rdi
  8004207e1c:	48 b8 e5 31 20 04 80 	movabs $0x80042031e5,%rax
  8004207e23:	00 00 00 
  8004207e26:	ff d0                	callq  *%rax
				// find the pa and va of the page table
				pa = PTE_ADDR(env_pgdir[pdeno]);
				pt = (pte_t*) KADDR(pa);

				// unmap all PTEs in this page table
				for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004207e28:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004207e2d:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004207e34:	00 
  8004207e35:	76 8f                	jbe    8004207dc6 <env_free+0x299>
						page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
					}
				}

				// free the page table itself
				env_pgdir[pdeno] = 0;
  8004207e37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e3b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207e42:	00 
  8004207e43:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207e47:	48 01 d0             	add    %rdx,%rax
  8004207e4a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
				page_decref(pa2page(pa));
  8004207e51:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207e55:	48 89 c7             	mov    %rax,%rdi
  8004207e58:	48 b8 0b 71 20 04 80 	movabs $0x800420710b,%rax
  8004207e5f:	00 00 00 
  8004207e62:	ff d0                	callq  *%rax
  8004207e64:	48 89 c7             	mov    %rax,%rdi
  8004207e67:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004207e6e:	00 00 00 
  8004207e71:	ff d0                	callq  *%rax
			if(!(env_pdpe[pdpe_index] & PTE_P))
				continue;
			pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
			pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
			static_assert(UTOP % PTSIZE == 0);
			for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004207e73:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004207e78:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004207e7b:	48 98                	cltq   
  8004207e7d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004207e81:	0f 87 83 fe ff ff    	ja     8004207d0a <env_free+0x1dd>
				// free the page table itself
				env_pgdir[pdeno] = 0;
				page_decref(pa2page(pa));
			}
			// free the page directory
			pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004207e87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207e8b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207e92:	00 
  8004207e93:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e97:	48 01 d0             	add    %rdx,%rax
  8004207e9a:	48 8b 00             	mov    (%rax),%rax
  8004207e9d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207ea3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			env_pdpe[pdpe_index] = 0;
  8004207ea7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207eab:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207eb2:	00 
  8004207eb3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207eb7:	48 01 d0             	add    %rdx,%rax
  8004207eba:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004207ec1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207ec5:	48 89 c7             	mov    %rax,%rdi
  8004207ec8:	48 b8 0b 71 20 04 80 	movabs $0x800420710b,%rax
  8004207ecf:	00 00 00 
  8004207ed2:	ff d0                	callq  *%rax
  8004207ed4:	48 89 c7             	mov    %rax,%rdi
  8004207ed7:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004207ede:	00 00 00 
  8004207ee1:	ff d0                	callq  *%rax
		pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
		int pdeno_limit;
		uint64_t pdpe_index;
		// using 3 instead of NPDPENTRIES as we have only first three indices
		// set for 4GB of address space.
		for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004207ee3:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004207ee8:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004207eed:	0f 86 4a fd ff ff    	jbe    8004207c3d <env_free+0x110>
			pa = PTE_ADDR(env_pdpe[pdpe_index]);
			env_pdpe[pdpe_index] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory pointer
		page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004207ef3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207efa:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207f01:	48 8b 00             	mov    (%rax),%rax
  8004207f04:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207f0a:	48 89 c7             	mov    %rax,%rdi
  8004207f0d:	48 b8 0b 71 20 04 80 	movabs $0x800420710b,%rax
  8004207f14:	00 00 00 
  8004207f17:	ff d0                	callq  *%rax
  8004207f19:	48 89 c7             	mov    %rax,%rdi
  8004207f1c:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004207f23:	00 00 00 
  8004207f26:	ff d0                	callq  *%rax
	}
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004207f28:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207f2f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207f36:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004207f3d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207f44:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207f4b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004207f4f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207f56:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004207f5d:	00 00 00 00 
	e->env_cr3 = 0;
  8004207f61:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207f68:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004207f6f:	00 00 00 00 
	page_decref(pa2page(pa));
  8004207f73:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207f77:	48 89 c7             	mov    %rax,%rdi
  8004207f7a:	48 b8 0b 71 20 04 80 	movabs $0x800420710b,%rax
  8004207f81:	00 00 00 
  8004207f84:	ff d0                	callq  *%rax
  8004207f86:	48 89 c7             	mov    %rax,%rdi
  8004207f89:	48 b8 85 2b 20 04 80 	movabs $0x8004202b85,%rax
  8004207f90:	00 00 00 
  8004207f93:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004207f95:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207f9c:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004207fa3:	00 00 00 
	e->env_link = env_free_list;
  8004207fa6:	48 b8 58 e2 6b 04 80 	movabs $0x80046be258,%rax
  8004207fad:	00 00 00 
  8004207fb0:	48 8b 10             	mov    (%rax),%rdx
  8004207fb3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207fba:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004207fc1:	48 b8 58 e2 6b 04 80 	movabs $0x80046be258,%rax
  8004207fc8:	00 00 00 
  8004207fcb:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004207fd2:	48 89 10             	mov    %rdx,(%rax)
}
  8004207fd5:	c9                   	leaveq 
  8004207fd6:	c3                   	retq   

0000008004207fd7 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  8004207fd7:	55                   	push   %rbp
  8004207fd8:	48 89 e5             	mov    %rsp,%rbp
  8004207fdb:	48 83 ec 10          	sub    $0x10,%rsp
  8004207fdf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004207fe3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fe7:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207fed:	83 f8 03             	cmp    $0x3,%eax
  8004207ff0:	75 4a                	jne    800420803c <env_destroy+0x65>
  8004207ff2:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004207ff9:	00 00 00 
  8004207ffc:	ff d0                	callq  *%rax
  8004207ffe:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  8004208005:	00 00 00 
  8004208008:	48 98                	cltq   
  800420800a:	48 c1 e0 03          	shl    $0x3,%rax
  800420800e:	48 89 c2             	mov    %rax,%rdx
  8004208011:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208015:	48 29 c2             	sub    %rax,%rdx
  8004208018:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420801c:	48 83 c0 08          	add    $0x8,%rax
  8004208020:	48 8b 00             	mov    (%rax),%rax
  8004208023:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208027:	74 13                	je     800420803c <env_destroy+0x65>
		e->env_status = ENV_DYING;
  8004208029:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420802d:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  8004208034:	00 00 00 
		return;
  8004208037:	e9 8b 00 00 00       	jmpq   80042080c7 <env_destroy+0xf0>
	}

	env_free(e);
  800420803c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208040:	48 89 c7             	mov    %rax,%rdi
  8004208043:	48 b8 2d 7b 20 04 80 	movabs $0x8004207b2d,%rax
  800420804a:	00 00 00 
  800420804d:	ff d0                	callq  *%rax
	if (curenv == e) {
  800420804f:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004208056:	00 00 00 
  8004208059:	ff d0                	callq  *%rax
  800420805b:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  8004208062:	00 00 00 
  8004208065:	48 98                	cltq   
  8004208067:	48 c1 e0 03          	shl    $0x3,%rax
  800420806b:	48 89 c2             	mov    %rax,%rdx
  800420806e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208072:	48 29 c2             	sub    %rax,%rdx
  8004208075:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208079:	48 83 c0 08          	add    $0x8,%rax
  800420807d:	48 8b 00             	mov    (%rax),%rax
  8004208080:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208084:	75 41                	jne    80042080c7 <env_destroy+0xf0>
		curenv = NULL;
  8004208086:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420808d:	00 00 00 
  8004208090:	ff d0                	callq  *%rax
  8004208092:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  8004208099:	00 00 00 
  800420809c:	48 98                	cltq   
  800420809e:	48 c1 e0 03          	shl    $0x3,%rax
  80042080a2:	48 89 c2             	mov    %rax,%rdx
  80042080a5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042080a9:	48 29 c2             	sub    %rax,%rdx
  80042080ac:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042080b0:	48 83 c0 08          	add    $0x8,%rax
  80042080b4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  80042080bb:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  80042080c2:	00 00 00 
  80042080c5:	ff d0                	callq  *%rax
	}
}
  80042080c7:	c9                   	leaveq 
  80042080c8:	c3                   	retq   

00000080042080c9 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  80042080c9:	55                   	push   %rbp
  80042080ca:	48 89 e5             	mov    %rsp,%rbp
  80042080cd:	53                   	push   %rbx
  80042080ce:	48 83 ec 18          	sub    $0x18,%rsp
  80042080d2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  80042080d6:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042080dd:	00 00 00 
  80042080e0:	ff d0                	callq  *%rax
  80042080e2:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  80042080e9:	00 00 00 
  80042080ec:	48 98                	cltq   
  80042080ee:	48 c1 e0 03          	shl    $0x3,%rax
  80042080f2:	48 89 c2             	mov    %rax,%rdx
  80042080f5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042080f9:	48 29 c2             	sub    %rax,%rdx
  80042080fc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208100:	48 83 c0 08          	add    $0x8,%rax
  8004208104:	48 8b 18             	mov    (%rax),%rbx
  8004208107:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420810e:	00 00 00 
  8004208111:	ff d0                	callq  *%rax
  8004208113:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)
	__asm __volatile("movq %0,%%rsp\n"
  8004208119:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  800420811d:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208121:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208126:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420812b:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208130:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208135:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420813a:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420813f:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208144:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208149:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420814e:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208153:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208158:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420815d:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208162:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208167:	48 83 c4 78          	add    $0x78,%rsp
  800420816b:	8e 04 24             	mov    (%rsp),%es
  800420816e:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208172:	48 83 c4 10          	add    $0x10,%rsp
  8004208176:	48 83 c4 10          	add    $0x10,%rsp
  800420817a:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  800420817c:	48 ba 67 75 21 04 80 	movabs $0x8004217567,%rdx
  8004208183:	00 00 00 
  8004208186:	be 26 02 00 00       	mov    $0x226,%esi
  800420818b:	48 bf 1e 75 21 04 80 	movabs $0x800421751e,%rdi
  8004208192:	00 00 00 
  8004208195:	b8 00 00 00 00       	mov    $0x0,%eax
  800420819a:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042081a1:	00 00 00 
  80042081a4:	ff d1                	callq  *%rcx

00000080042081a6 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  80042081a6:	55                   	push   %rbp
  80042081a7:	48 89 e5             	mov    %rsp,%rbp
  80042081aa:	48 83 ec 20          	sub    $0x20,%rsp
  80042081ae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// LAB 3: Your code here.

	//f (e != curenv && e->env_status != ENV_RUNNABLE)
			//panic("the env could not run");

  if (curenv && curenv->env_status == ENV_RUNNING)
  80042081b2:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042081b9:	00 00 00 
  80042081bc:	ff d0                	callq  *%rax
  80042081be:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  80042081c5:	00 00 00 
  80042081c8:	48 98                	cltq   
  80042081ca:	48 c1 e0 03          	shl    $0x3,%rax
  80042081ce:	48 89 c2             	mov    %rax,%rdx
  80042081d1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042081d5:	48 29 c2             	sub    %rax,%rdx
  80042081d8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042081dc:	48 83 c0 08          	add    $0x8,%rax
  80042081e0:	48 8b 00             	mov    (%rax),%rax
  80042081e3:	48 85 c0             	test   %rax,%rax
  80042081e6:	74 77                	je     800420825f <env_run+0xb9>
  80042081e8:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042081ef:	00 00 00 
  80042081f2:	ff d0                	callq  *%rax
  80042081f4:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  80042081fb:	00 00 00 
  80042081fe:	48 98                	cltq   
  8004208200:	48 c1 e0 03          	shl    $0x3,%rax
  8004208204:	48 89 c2             	mov    %rax,%rdx
  8004208207:	48 c1 e2 04          	shl    $0x4,%rdx
  800420820b:	48 29 c2             	sub    %rax,%rdx
  800420820e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208212:	48 83 c0 08          	add    $0x8,%rax
  8004208216:	48 8b 00             	mov    (%rax),%rax
  8004208219:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420821f:	83 f8 03             	cmp    $0x3,%eax
  8004208222:	75 3b                	jne    800420825f <env_run+0xb9>
      curenv->env_status = ENV_RUNNABLE;
  8004208224:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420822b:	00 00 00 
  800420822e:	ff d0                	callq  *%rax
  8004208230:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  8004208237:	00 00 00 
  800420823a:	48 98                	cltq   
  800420823c:	48 c1 e0 03          	shl    $0x3,%rax
  8004208240:	48 89 c2             	mov    %rax,%rdx
  8004208243:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208247:	48 29 c2             	sub    %rax,%rdx
  800420824a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420824e:	48 83 c0 08          	add    $0x8,%rax
  8004208252:	48 8b 00             	mov    (%rax),%rax
  8004208255:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420825c:	00 00 00 

  curenv = e;
  800420825f:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004208266:	00 00 00 
  8004208269:	ff d0                	callq  *%rax
  800420826b:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  8004208272:	00 00 00 
  8004208275:	48 98                	cltq   
  8004208277:	48 c1 e0 03          	shl    $0x3,%rax
  800420827b:	48 89 c2             	mov    %rax,%rdx
  800420827e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208282:	48 29 c2             	sub    %rax,%rdx
  8004208285:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208289:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420828d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208291:	48 89 02             	mov    %rax,(%rdx)
  curenv->env_status = ENV_RUNNING;
  8004208294:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420829b:	00 00 00 
  800420829e:	ff d0                	callq  *%rax
  80042082a0:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  80042082a7:	00 00 00 
  80042082aa:	48 98                	cltq   
  80042082ac:	48 c1 e0 03          	shl    $0x3,%rax
  80042082b0:	48 89 c2             	mov    %rax,%rdx
  80042082b3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042082b7:	48 29 c2             	sub    %rax,%rdx
  80042082ba:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042082be:	48 83 c0 08          	add    $0x8,%rax
  80042082c2:	48 8b 00             	mov    (%rax),%rax
  80042082c5:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  80042082cc:	00 00 00 
  curenv->env_runs++;
  80042082cf:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042082d6:	00 00 00 
  80042082d9:	ff d0                	callq  *%rax
  80042082db:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  80042082e2:	00 00 00 
  80042082e5:	48 98                	cltq   
  80042082e7:	48 c1 e0 03          	shl    $0x3,%rax
  80042082eb:	48 89 c2             	mov    %rax,%rdx
  80042082ee:	48 c1 e2 04          	shl    $0x4,%rdx
  80042082f2:	48 29 c2             	sub    %rax,%rdx
  80042082f5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042082f9:	48 83 c0 08          	add    $0x8,%rax
  80042082fd:	48 8b 00             	mov    (%rax),%rax
  8004208300:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208306:	83 c2 01             	add    $0x1,%edx
  8004208309:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)

	unlock_kernel();
  800420830f:	48 b8 04 72 20 04 80 	movabs $0x8004207204,%rax
  8004208316:	00 00 00 
  8004208319:	ff d0                	callq  *%rax

  lcr3(curenv->env_cr3);
  800420831b:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004208322:	00 00 00 
  8004208325:	ff d0                	callq  *%rax
  8004208327:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420832e:	00 00 00 
  8004208331:	48 98                	cltq   
  8004208333:	48 c1 e0 03          	shl    $0x3,%rax
  8004208337:	48 89 c2             	mov    %rax,%rdx
  800420833a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420833e:	48 29 c2             	sub    %rax,%rdx
  8004208341:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208345:	48 83 c0 08          	add    $0x8,%rax
  8004208349:	48 8b 00             	mov    (%rax),%rax
  800420834c:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208353:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208357:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420835b:	0f 22 d8             	mov    %rax,%cr3
  env_pop_tf(&(curenv->env_tf));
  800420835e:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004208365:	00 00 00 
  8004208368:	ff d0                	callq  *%rax
  800420836a:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  8004208371:	00 00 00 
  8004208374:	48 98                	cltq   
  8004208376:	48 c1 e0 03          	shl    $0x3,%rax
  800420837a:	48 89 c2             	mov    %rax,%rdx
  800420837d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208381:	48 29 c2             	sub    %rax,%rdx
  8004208384:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208388:	48 83 c0 08          	add    $0x8,%rax
  800420838c:	48 8b 00             	mov    (%rax),%rax
  800420838f:	48 89 c7             	mov    %rax,%rdi
  8004208392:	48 b8 c9 80 20 04 80 	movabs $0x80042080c9,%rax
  8004208399:	00 00 00 
  800420839c:	ff d0                	callq  *%rax

000000800420839e <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  800420839e:	55                   	push   %rbp
  800420839f:	48 89 e5             	mov    %rsp,%rbp
  80042083a2:	48 83 ec 14          	sub    $0x14,%rsp
  80042083a6:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  80042083a9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042083ac:	0f b6 c0             	movzbl %al,%eax
  80042083af:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042083b6:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042083b9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042083bd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042083c0:	ee                   	out    %al,(%dx)
  80042083c1:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042083c8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042083cb:	89 c2                	mov    %eax,%edx
  80042083cd:	ec                   	in     (%dx),%al
  80042083ce:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042083d1:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  80042083d5:	0f b6 c0             	movzbl %al,%eax
}
  80042083d8:	c9                   	leaveq 
  80042083d9:	c3                   	retq   

00000080042083da <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  80042083da:	55                   	push   %rbp
  80042083db:	48 89 e5             	mov    %rsp,%rbp
  80042083de:	48 83 ec 18          	sub    $0x18,%rsp
  80042083e2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042083e5:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  80042083e8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042083eb:	0f b6 c0             	movzbl %al,%eax
  80042083ee:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042083f5:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042083f8:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042083fc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042083ff:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208400:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208403:	0f b6 c0             	movzbl %al,%eax
  8004208406:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  800420840d:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004208410:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208414:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208417:	ee                   	out    %al,(%dx)
}
  8004208418:	c9                   	leaveq 
  8004208419:	c3                   	retq   

000000800420841a <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  800420841a:	55                   	push   %rbp
  800420841b:	48 89 e5             	mov    %rsp,%rbp
  800420841e:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004208422:	48 b8 60 e2 6b 04 80 	movabs $0x80046be260,%rax
  8004208429:	00 00 00 
  800420842c:	c6 00 01             	movb   $0x1,(%rax)
  800420842f:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208436:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  800420843a:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420843e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208441:	ee                   	out    %al,(%dx)
  8004208442:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208449:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  800420844d:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208451:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208454:	ee                   	out    %al,(%dx)
  8004208455:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  800420845c:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208460:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004208464:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208467:	ee                   	out    %al,(%dx)
  8004208468:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  800420846f:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208473:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208477:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420847a:	ee                   	out    %al,(%dx)
  800420847b:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208482:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208486:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800420848a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420848d:	ee                   	out    %al,(%dx)
  800420848e:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208495:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208499:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800420849d:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042084a0:	ee                   	out    %al,(%dx)
  80042084a1:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  80042084a8:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  80042084ac:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042084b0:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042084b3:	ee                   	out    %al,(%dx)
  80042084b4:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  80042084bb:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  80042084bf:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  80042084c3:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042084c6:	ee                   	out    %al,(%dx)
  80042084c7:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  80042084ce:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  80042084d2:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042084d6:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042084d9:	ee                   	out    %al,(%dx)
  80042084da:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  80042084e1:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  80042084e5:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  80042084e9:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042084ec:	ee                   	out    %al,(%dx)
  80042084ed:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  80042084f4:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  80042084f8:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  80042084fc:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042084ff:	ee                   	out    %al,(%dx)
  8004208500:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004208507:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  800420850b:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  800420850f:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004208512:	ee                   	out    %al,(%dx)
  8004208513:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  800420851a:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  800420851e:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004208522:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208525:	ee                   	out    %al,(%dx)
  8004208526:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  800420852d:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004208531:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004208535:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004208538:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004208539:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  8004208540:	00 00 00 
  8004208543:	0f b7 00             	movzwl (%rax),%eax
  8004208546:	66 83 f8 ff          	cmp    $0xffff,%ax
  800420854a:	74 1e                	je     800420856a <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  800420854c:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  8004208553:	00 00 00 
  8004208556:	0f b7 00             	movzwl (%rax),%eax
  8004208559:	0f b7 c0             	movzwl %ax,%eax
  800420855c:	89 c7                	mov    %eax,%edi
  800420855e:	48 b8 6c 85 20 04 80 	movabs $0x800420856c,%rax
  8004208565:	00 00 00 
  8004208568:	ff d0                	callq  *%rax
}
  800420856a:	c9                   	leaveq 
  800420856b:	c3                   	retq   

000000800420856c <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  800420856c:	55                   	push   %rbp
  800420856d:	48 89 e5             	mov    %rsp,%rbp
  8004208570:	48 83 ec 30          	sub    $0x30,%rsp
  8004208574:	89 f8                	mov    %edi,%eax
  8004208576:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  800420857a:	48 b8 72 b6 22 04 80 	movabs $0x800422b672,%rax
  8004208581:	00 00 00 
  8004208584:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8004208588:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  800420858b:	48 b8 60 e2 6b 04 80 	movabs $0x80046be260,%rax
  8004208592:	00 00 00 
  8004208595:	0f b6 00             	movzbl (%rax),%eax
  8004208598:	83 f0 01             	xor    $0x1,%eax
  800420859b:	84 c0                	test   %al,%al
  800420859d:	74 05                	je     80042085a4 <irq_setmask_8259A+0x38>
		return;
  800420859f:	e9 b7 00 00 00       	jmpq   800420865b <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  80042085a4:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042085a8:	0f b6 c0             	movzbl %al,%eax
  80042085ab:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  80042085b2:	88 45 f7             	mov    %al,-0x9(%rbp)
  80042085b5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042085b9:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042085bc:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  80042085bd:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042085c1:	66 c1 e8 08          	shr    $0x8,%ax
  80042085c5:	0f b6 c0             	movzbl %al,%eax
  80042085c8:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  80042085cf:	88 45 ef             	mov    %al,-0x11(%rbp)
  80042085d2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042085d6:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042085d9:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  80042085da:	48 bf 73 75 21 04 80 	movabs $0x8004217573,%rdi
  80042085e1:	00 00 00 
  80042085e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042085e9:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042085f0:	00 00 00 
  80042085f3:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  80042085f5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042085fc:	eb 3c                	jmp    800420863a <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  80042085fe:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208602:	f7 d0                	not    %eax
  8004208604:	89 c2                	mov    %eax,%edx
  8004208606:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208609:	89 c1                	mov    %eax,%ecx
  800420860b:	d3 fa                	sar    %cl,%edx
  800420860d:	89 d0                	mov    %edx,%eax
  800420860f:	83 e0 01             	and    $0x1,%eax
  8004208612:	85 c0                	test   %eax,%eax
  8004208614:	74 20                	je     8004208636 <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  8004208616:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208619:	89 c6                	mov    %eax,%esi
  800420861b:	48 bf 87 75 21 04 80 	movabs $0x8004217587,%rdi
  8004208622:	00 00 00 
  8004208625:	b8 00 00 00 00       	mov    $0x0,%eax
  800420862a:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004208631:	00 00 00 
  8004208634:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004208636:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420863a:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  800420863e:	7e be                	jle    80042085fe <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208640:	48 bf 8b 75 21 04 80 	movabs $0x800421758b,%rdi
  8004208647:	00 00 00 
  800420864a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420864f:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004208656:	00 00 00 
  8004208659:	ff d2                	callq  *%rdx
}
  800420865b:	c9                   	leaveq 
  800420865c:	c3                   	retq   

000000800420865d <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  800420865d:	55                   	push   %rbp
  800420865e:	48 89 e5             	mov    %rsp,%rbp
  8004208661:	48 83 ec 10          	sub    $0x10,%rsp
  8004208665:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208668:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  800420866c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420866f:	89 c7                	mov    %eax,%edi
  8004208671:	48 b8 d8 11 20 04 80 	movabs $0x80042011d8,%rax
  8004208678:	00 00 00 
  800420867b:	ff d0                	callq  *%rax
	*cnt++;
  800420867d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208681:	48 83 c0 04          	add    $0x4,%rax
  8004208685:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004208689:	c9                   	leaveq 
  800420868a:	c3                   	retq   

000000800420868b <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  800420868b:	55                   	push   %rbp
  800420868c:	48 89 e5             	mov    %rsp,%rbp
  800420868f:	48 83 ec 30          	sub    $0x30,%rsp
  8004208693:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208697:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  800420869b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  80042086a2:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042086a6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042086aa:	48 8b 0a             	mov    (%rdx),%rcx
  80042086ad:	48 89 08             	mov    %rcx,(%rax)
  80042086b0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042086b4:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042086b8:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042086bc:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  80042086c0:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80042086c4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042086c8:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80042086cc:	48 89 c6             	mov    %rax,%rsi
  80042086cf:	48 bf 5d 86 20 04 80 	movabs $0x800420865d,%rdi
  80042086d6:	00 00 00 
  80042086d9:	48 b8 48 e0 20 04 80 	movabs $0x800420e048,%rax
  80042086e0:	00 00 00 
  80042086e3:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  80042086e5:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  80042086e8:	c9                   	leaveq 
  80042086e9:	c3                   	retq   

00000080042086ea <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80042086ea:	55                   	push   %rbp
  80042086eb:	48 89 e5             	mov    %rsp,%rbp
  80042086ee:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  80042086f5:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  80042086fc:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004208703:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420870a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004208711:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004208718:	84 c0                	test   %al,%al
  800420871a:	74 20                	je     800420873c <cprintf+0x52>
  800420871c:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004208720:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004208724:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208728:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420872c:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208730:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004208734:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208738:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420873c:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004208743:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  800420874a:	00 00 00 
  800420874d:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004208754:	00 00 00 
  8004208757:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420875b:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004208762:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208769:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208770:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004208777:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420877e:	48 8b 0a             	mov    (%rdx),%rcx
  8004208781:	48 89 08             	mov    %rcx,(%rax)
  8004208784:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208788:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420878c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208790:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004208794:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  800420879b:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042087a2:	48 89 d6             	mov    %rdx,%rsi
  80042087a5:	48 89 c7             	mov    %rax,%rdi
  80042087a8:	48 b8 8b 86 20 04 80 	movabs $0x800420868b,%rax
  80042087af:	00 00 00 
  80042087b2:	ff d0                	callq  *%rax
  80042087b4:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  80042087ba:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  80042087c0:	c9                   	leaveq 
  80042087c1:	c3                   	retq   

00000080042087c2 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042087c2:	55                   	push   %rbp
  80042087c3:	48 89 e5             	mov    %rsp,%rbp
  80042087c6:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042087ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042087ce:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042087d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042087d5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042087d8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042087dc:	f0 87 02             	lock xchg %eax,(%rdx)
  80042087df:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042087e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042087e5:	c9                   	leaveq 
  80042087e6:	c3                   	retq   

00000080042087e7 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  80042087e7:	55                   	push   %rbp
  80042087e8:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  80042087eb:	48 bf 60 b7 22 04 80 	movabs $0x800422b760,%rdi
  80042087f2:	00 00 00 
  80042087f5:	48 b8 74 5f 21 04 80 	movabs $0x8004215f74,%rax
  80042087fc:	00 00 00 
  80042087ff:	ff d0                	callq  *%rax
}
  8004208801:	5d                   	pop    %rbp
  8004208802:	c3                   	retq   

0000008004208803 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004208803:	55                   	push   %rbp
  8004208804:	48 89 e5             	mov    %rsp,%rbp
  8004208807:	48 83 ec 04          	sub    $0x4,%rsp
  800420880b:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  800420880e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208811:	83 f8 13             	cmp    $0x13,%eax
  8004208814:	77 16                	ja     800420882c <trapname+0x29>
		return excnames[trapno];
  8004208816:	48 b8 c0 79 21 04 80 	movabs $0x80042179c0,%rax
  800420881d:	00 00 00 
  8004208820:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208823:	48 63 d2             	movslq %edx,%rdx
  8004208826:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420882a:	eb 34                	jmp    8004208860 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  800420882c:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004208830:	75 0c                	jne    800420883e <trapname+0x3b>
		return "System call";
  8004208832:	48 b8 a0 75 21 04 80 	movabs $0x80042175a0,%rax
  8004208839:	00 00 00 
  800420883c:	eb 22                	jmp    8004208860 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  800420883e:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004208842:	7e 12                	jle    8004208856 <trapname+0x53>
  8004208844:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004208848:	7f 0c                	jg     8004208856 <trapname+0x53>
		return "Hardware Interrupt";
  800420884a:	48 b8 ac 75 21 04 80 	movabs $0x80042175ac,%rax
  8004208851:	00 00 00 
  8004208854:	eb 0a                	jmp    8004208860 <trapname+0x5d>
	return "(unknown trap)";
  8004208856:	48 b8 bf 75 21 04 80 	movabs $0x80042175bf,%rax
  800420885d:	00 00 00 
}
  8004208860:	c9                   	leaveq 
  8004208861:	c3                   	retq   

0000008004208862 <trap_init>:


void
trap_init(void)
{
  8004208862:	55                   	push   %rbp
  8004208863:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
	idt_pd.pd_lim = sizeof(idt)-1;
  8004208866:	48 b8 80 f2 6b 04 80 	movabs $0x80046bf280,%rax
  800420886d:	00 00 00 
  8004208870:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  8004208875:	48 ba 80 e2 6b 04 80 	movabs $0x80046be280,%rdx
  800420887c:	00 00 00 
  800420887f:	48 b8 80 f2 6b 04 80 	movabs $0x80046bf280,%rax
  8004208886:	00 00 00 
  8004208889:	48 89 50 02          	mov    %rdx,0x2(%rax)

	SETGATE(idt[T_DIVIDE], 0, GD_KT, DIVIDE_F, 0);
  800420888d:	48 b8 c4 c0 20 04 80 	movabs $0x800420c0c4,%rax
  8004208894:	00 00 00 
  8004208897:	89 c2                	mov    %eax,%edx
  8004208899:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042088a0:	00 00 00 
  80042088a3:	66 89 10             	mov    %dx,(%rax)
  80042088a6:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042088ad:	00 00 00 
  80042088b0:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  80042088b6:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042088bd:	00 00 00 
  80042088c0:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042088c4:	83 e2 f8             	and    $0xfffffff8,%edx
  80042088c7:	88 50 04             	mov    %dl,0x4(%rax)
  80042088ca:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042088d1:	00 00 00 
  80042088d4:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042088d8:	83 e2 07             	and    $0x7,%edx
  80042088db:	88 50 04             	mov    %dl,0x4(%rax)
  80042088de:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042088e5:	00 00 00 
  80042088e8:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042088ec:	83 e2 f0             	and    $0xfffffff0,%edx
  80042088ef:	83 ca 0e             	or     $0xe,%edx
  80042088f2:	88 50 05             	mov    %dl,0x5(%rax)
  80042088f5:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042088fc:	00 00 00 
  80042088ff:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208903:	83 e2 ef             	and    $0xffffffef,%edx
  8004208906:	88 50 05             	mov    %dl,0x5(%rax)
  8004208909:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208910:	00 00 00 
  8004208913:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208917:	83 e2 9f             	and    $0xffffff9f,%edx
  800420891a:	88 50 05             	mov    %dl,0x5(%rax)
  800420891d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208924:	00 00 00 
  8004208927:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420892b:	83 ca 80             	or     $0xffffff80,%edx
  800420892e:	88 50 05             	mov    %dl,0x5(%rax)
  8004208931:	48 b8 c4 c0 20 04 80 	movabs $0x800420c0c4,%rax
  8004208938:	00 00 00 
  800420893b:	48 c1 e8 10          	shr    $0x10,%rax
  800420893f:	89 c2                	mov    %eax,%edx
  8004208941:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208948:	00 00 00 
  800420894b:	66 89 50 06          	mov    %dx,0x6(%rax)
  800420894f:	48 b8 c4 c0 20 04 80 	movabs $0x800420c0c4,%rax
  8004208956:	00 00 00 
  8004208959:	48 c1 e8 20          	shr    $0x20,%rax
  800420895d:	89 c2                	mov    %eax,%edx
  800420895f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208966:	00 00 00 
  8004208969:	89 50 08             	mov    %edx,0x8(%rax)
  800420896c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208973:	00 00 00 
  8004208976:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_DEBUG], 0, GD_KT, DEBUG_F, 0);
  800420897d:	48 b8 ce c0 20 04 80 	movabs $0x800420c0ce,%rax
  8004208984:	00 00 00 
  8004208987:	89 c2                	mov    %eax,%edx
  8004208989:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208990:	00 00 00 
  8004208993:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004208997:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420899e:	00 00 00 
  80042089a1:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  80042089a7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042089ae:	00 00 00 
  80042089b1:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042089b5:	83 e2 f8             	and    $0xfffffff8,%edx
  80042089b8:	88 50 14             	mov    %dl,0x14(%rax)
  80042089bb:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042089c2:	00 00 00 
  80042089c5:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042089c9:	83 e2 07             	and    $0x7,%edx
  80042089cc:	88 50 14             	mov    %dl,0x14(%rax)
  80042089cf:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042089d6:	00 00 00 
  80042089d9:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042089dd:	83 e2 f0             	and    $0xfffffff0,%edx
  80042089e0:	83 ca 0e             	or     $0xe,%edx
  80042089e3:	88 50 15             	mov    %dl,0x15(%rax)
  80042089e6:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042089ed:	00 00 00 
  80042089f0:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042089f4:	83 e2 ef             	and    $0xffffffef,%edx
  80042089f7:	88 50 15             	mov    %dl,0x15(%rax)
  80042089fa:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208a01:	00 00 00 
  8004208a04:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208a08:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208a0b:	88 50 15             	mov    %dl,0x15(%rax)
  8004208a0e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208a15:	00 00 00 
  8004208a18:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208a1c:	83 ca 80             	or     $0xffffff80,%edx
  8004208a1f:	88 50 15             	mov    %dl,0x15(%rax)
  8004208a22:	48 b8 ce c0 20 04 80 	movabs $0x800420c0ce,%rax
  8004208a29:	00 00 00 
  8004208a2c:	48 c1 e8 10          	shr    $0x10,%rax
  8004208a30:	89 c2                	mov    %eax,%edx
  8004208a32:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208a39:	00 00 00 
  8004208a3c:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004208a40:	48 b8 ce c0 20 04 80 	movabs $0x800420c0ce,%rax
  8004208a47:	00 00 00 
  8004208a4a:	48 c1 e8 20          	shr    $0x20,%rax
  8004208a4e:	89 c2                	mov    %eax,%edx
  8004208a50:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208a57:	00 00 00 
  8004208a5a:	89 50 18             	mov    %edx,0x18(%rax)
  8004208a5d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208a64:	00 00 00 
  8004208a67:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[T_NMI], 0, GD_KT, NMI_F, 0);
  8004208a6e:	48 b8 d8 c0 20 04 80 	movabs $0x800420c0d8,%rax
  8004208a75:	00 00 00 
  8004208a78:	89 c2                	mov    %eax,%edx
  8004208a7a:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208a81:	00 00 00 
  8004208a84:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004208a88:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208a8f:	00 00 00 
  8004208a92:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004208a98:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208a9f:	00 00 00 
  8004208aa2:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004208aa6:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208aa9:	88 50 24             	mov    %dl,0x24(%rax)
  8004208aac:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208ab3:	00 00 00 
  8004208ab6:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004208aba:	83 e2 07             	and    $0x7,%edx
  8004208abd:	88 50 24             	mov    %dl,0x24(%rax)
  8004208ac0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208ac7:	00 00 00 
  8004208aca:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208ace:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208ad1:	83 ca 0e             	or     $0xe,%edx
  8004208ad4:	88 50 25             	mov    %dl,0x25(%rax)
  8004208ad7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208ade:	00 00 00 
  8004208ae1:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208ae5:	83 e2 ef             	and    $0xffffffef,%edx
  8004208ae8:	88 50 25             	mov    %dl,0x25(%rax)
  8004208aeb:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208af2:	00 00 00 
  8004208af5:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208af9:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208afc:	88 50 25             	mov    %dl,0x25(%rax)
  8004208aff:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208b06:	00 00 00 
  8004208b09:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208b0d:	83 ca 80             	or     $0xffffff80,%edx
  8004208b10:	88 50 25             	mov    %dl,0x25(%rax)
  8004208b13:	48 b8 d8 c0 20 04 80 	movabs $0x800420c0d8,%rax
  8004208b1a:	00 00 00 
  8004208b1d:	48 c1 e8 10          	shr    $0x10,%rax
  8004208b21:	89 c2                	mov    %eax,%edx
  8004208b23:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208b2a:	00 00 00 
  8004208b2d:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004208b31:	48 b8 d8 c0 20 04 80 	movabs $0x800420c0d8,%rax
  8004208b38:	00 00 00 
  8004208b3b:	48 c1 e8 20          	shr    $0x20,%rax
  8004208b3f:	89 c2                	mov    %eax,%edx
  8004208b41:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208b48:	00 00 00 
  8004208b4b:	89 50 28             	mov    %edx,0x28(%rax)
  8004208b4e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208b55:	00 00 00 
  8004208b58:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_BRKPT], 0, GD_KT, BRKPT_F, 3);
  8004208b5f:	48 b8 e2 c0 20 04 80 	movabs $0x800420c0e2,%rax
  8004208b66:	00 00 00 
  8004208b69:	89 c2                	mov    %eax,%edx
  8004208b6b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208b72:	00 00 00 
  8004208b75:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004208b79:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208b80:	00 00 00 
  8004208b83:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004208b89:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208b90:	00 00 00 
  8004208b93:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004208b97:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208b9a:	88 50 34             	mov    %dl,0x34(%rax)
  8004208b9d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208ba4:	00 00 00 
  8004208ba7:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004208bab:	83 e2 07             	and    $0x7,%edx
  8004208bae:	88 50 34             	mov    %dl,0x34(%rax)
  8004208bb1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208bb8:	00 00 00 
  8004208bbb:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208bbf:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208bc2:	83 ca 0e             	or     $0xe,%edx
  8004208bc5:	88 50 35             	mov    %dl,0x35(%rax)
  8004208bc8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208bcf:	00 00 00 
  8004208bd2:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208bd6:	83 e2 ef             	and    $0xffffffef,%edx
  8004208bd9:	88 50 35             	mov    %dl,0x35(%rax)
  8004208bdc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208be3:	00 00 00 
  8004208be6:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208bea:	83 ca 60             	or     $0x60,%edx
  8004208bed:	88 50 35             	mov    %dl,0x35(%rax)
  8004208bf0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208bf7:	00 00 00 
  8004208bfa:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208bfe:	83 ca 80             	or     $0xffffff80,%edx
  8004208c01:	88 50 35             	mov    %dl,0x35(%rax)
  8004208c04:	48 b8 e2 c0 20 04 80 	movabs $0x800420c0e2,%rax
  8004208c0b:	00 00 00 
  8004208c0e:	48 c1 e8 10          	shr    $0x10,%rax
  8004208c12:	89 c2                	mov    %eax,%edx
  8004208c14:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208c1b:	00 00 00 
  8004208c1e:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004208c22:	48 b8 e2 c0 20 04 80 	movabs $0x800420c0e2,%rax
  8004208c29:	00 00 00 
  8004208c2c:	48 c1 e8 20          	shr    $0x20,%rax
  8004208c30:	89 c2                	mov    %eax,%edx
  8004208c32:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208c39:	00 00 00 
  8004208c3c:	89 50 38             	mov    %edx,0x38(%rax)
  8004208c3f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208c46:	00 00 00 
  8004208c49:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[T_OFLOW], 0, GD_KT, OFLOW_F, 0);
  8004208c50:	48 b8 ec c0 20 04 80 	movabs $0x800420c0ec,%rax
  8004208c57:	00 00 00 
  8004208c5a:	89 c2                	mov    %eax,%edx
  8004208c5c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208c63:	00 00 00 
  8004208c66:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004208c6a:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208c71:	00 00 00 
  8004208c74:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004208c7a:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208c81:	00 00 00 
  8004208c84:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208c88:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208c8b:	88 50 44             	mov    %dl,0x44(%rax)
  8004208c8e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208c95:	00 00 00 
  8004208c98:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208c9c:	83 e2 07             	and    $0x7,%edx
  8004208c9f:	88 50 44             	mov    %dl,0x44(%rax)
  8004208ca2:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208ca9:	00 00 00 
  8004208cac:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208cb0:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208cb3:	83 ca 0e             	or     $0xe,%edx
  8004208cb6:	88 50 45             	mov    %dl,0x45(%rax)
  8004208cb9:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208cc0:	00 00 00 
  8004208cc3:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208cc7:	83 e2 ef             	and    $0xffffffef,%edx
  8004208cca:	88 50 45             	mov    %dl,0x45(%rax)
  8004208ccd:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208cd4:	00 00 00 
  8004208cd7:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208cdb:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208cde:	88 50 45             	mov    %dl,0x45(%rax)
  8004208ce1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208ce8:	00 00 00 
  8004208ceb:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208cef:	83 ca 80             	or     $0xffffff80,%edx
  8004208cf2:	88 50 45             	mov    %dl,0x45(%rax)
  8004208cf5:	48 b8 ec c0 20 04 80 	movabs $0x800420c0ec,%rax
  8004208cfc:	00 00 00 
  8004208cff:	48 c1 e8 10          	shr    $0x10,%rax
  8004208d03:	89 c2                	mov    %eax,%edx
  8004208d05:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208d0c:	00 00 00 
  8004208d0f:	66 89 50 46          	mov    %dx,0x46(%rax)
  8004208d13:	48 b8 ec c0 20 04 80 	movabs $0x800420c0ec,%rax
  8004208d1a:	00 00 00 
  8004208d1d:	48 c1 e8 20          	shr    $0x20,%rax
  8004208d21:	89 c2                	mov    %eax,%edx
  8004208d23:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208d2a:	00 00 00 
  8004208d2d:	89 50 48             	mov    %edx,0x48(%rax)
  8004208d30:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208d37:	00 00 00 
  8004208d3a:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[T_BOUND], 0, GD_KT, BOUND_F, 0);
  8004208d41:	48 b8 f6 c0 20 04 80 	movabs $0x800420c0f6,%rax
  8004208d48:	00 00 00 
  8004208d4b:	89 c2                	mov    %eax,%edx
  8004208d4d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208d54:	00 00 00 
  8004208d57:	66 89 50 50          	mov    %dx,0x50(%rax)
  8004208d5b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208d62:	00 00 00 
  8004208d65:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  8004208d6b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208d72:	00 00 00 
  8004208d75:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004208d79:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208d7c:	88 50 54             	mov    %dl,0x54(%rax)
  8004208d7f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208d86:	00 00 00 
  8004208d89:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004208d8d:	83 e2 07             	and    $0x7,%edx
  8004208d90:	88 50 54             	mov    %dl,0x54(%rax)
  8004208d93:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208d9a:	00 00 00 
  8004208d9d:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208da1:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208da4:	83 ca 0e             	or     $0xe,%edx
  8004208da7:	88 50 55             	mov    %dl,0x55(%rax)
  8004208daa:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208db1:	00 00 00 
  8004208db4:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208db8:	83 e2 ef             	and    $0xffffffef,%edx
  8004208dbb:	88 50 55             	mov    %dl,0x55(%rax)
  8004208dbe:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208dc5:	00 00 00 
  8004208dc8:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208dcc:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208dcf:	88 50 55             	mov    %dl,0x55(%rax)
  8004208dd2:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208dd9:	00 00 00 
  8004208ddc:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208de0:	83 ca 80             	or     $0xffffff80,%edx
  8004208de3:	88 50 55             	mov    %dl,0x55(%rax)
  8004208de6:	48 b8 f6 c0 20 04 80 	movabs $0x800420c0f6,%rax
  8004208ded:	00 00 00 
  8004208df0:	48 c1 e8 10          	shr    $0x10,%rax
  8004208df4:	89 c2                	mov    %eax,%edx
  8004208df6:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208dfd:	00 00 00 
  8004208e00:	66 89 50 56          	mov    %dx,0x56(%rax)
  8004208e04:	48 b8 f6 c0 20 04 80 	movabs $0x800420c0f6,%rax
  8004208e0b:	00 00 00 
  8004208e0e:	48 c1 e8 20          	shr    $0x20,%rax
  8004208e12:	89 c2                	mov    %eax,%edx
  8004208e14:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208e1b:	00 00 00 
  8004208e1e:	89 50 58             	mov    %edx,0x58(%rax)
  8004208e21:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208e28:	00 00 00 
  8004208e2b:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[T_ILLOP], 0, GD_KT, ILLOP_F, 0);
  8004208e32:	48 b8 00 c1 20 04 80 	movabs $0x800420c100,%rax
  8004208e39:	00 00 00 
  8004208e3c:	89 c2                	mov    %eax,%edx
  8004208e3e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208e45:	00 00 00 
  8004208e48:	66 89 50 60          	mov    %dx,0x60(%rax)
  8004208e4c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208e53:	00 00 00 
  8004208e56:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  8004208e5c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208e63:	00 00 00 
  8004208e66:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004208e6a:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208e6d:	88 50 64             	mov    %dl,0x64(%rax)
  8004208e70:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208e77:	00 00 00 
  8004208e7a:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004208e7e:	83 e2 07             	and    $0x7,%edx
  8004208e81:	88 50 64             	mov    %dl,0x64(%rax)
  8004208e84:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208e8b:	00 00 00 
  8004208e8e:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208e92:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208e95:	83 ca 0e             	or     $0xe,%edx
  8004208e98:	88 50 65             	mov    %dl,0x65(%rax)
  8004208e9b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208ea2:	00 00 00 
  8004208ea5:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208ea9:	83 e2 ef             	and    $0xffffffef,%edx
  8004208eac:	88 50 65             	mov    %dl,0x65(%rax)
  8004208eaf:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208eb6:	00 00 00 
  8004208eb9:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208ebd:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208ec0:	88 50 65             	mov    %dl,0x65(%rax)
  8004208ec3:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208eca:	00 00 00 
  8004208ecd:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208ed1:	83 ca 80             	or     $0xffffff80,%edx
  8004208ed4:	88 50 65             	mov    %dl,0x65(%rax)
  8004208ed7:	48 b8 00 c1 20 04 80 	movabs $0x800420c100,%rax
  8004208ede:	00 00 00 
  8004208ee1:	48 c1 e8 10          	shr    $0x10,%rax
  8004208ee5:	89 c2                	mov    %eax,%edx
  8004208ee7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208eee:	00 00 00 
  8004208ef1:	66 89 50 66          	mov    %dx,0x66(%rax)
  8004208ef5:	48 b8 00 c1 20 04 80 	movabs $0x800420c100,%rax
  8004208efc:	00 00 00 
  8004208eff:	48 c1 e8 20          	shr    $0x20,%rax
  8004208f03:	89 c2                	mov    %eax,%edx
  8004208f05:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208f0c:	00 00 00 
  8004208f0f:	89 50 68             	mov    %edx,0x68(%rax)
  8004208f12:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208f19:	00 00 00 
  8004208f1c:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[T_DEVICE], 0, GD_KT, DEVICE_F, 0);
  8004208f23:	48 b8 0a c1 20 04 80 	movabs $0x800420c10a,%rax
  8004208f2a:	00 00 00 
  8004208f2d:	89 c2                	mov    %eax,%edx
  8004208f2f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208f36:	00 00 00 
  8004208f39:	66 89 50 70          	mov    %dx,0x70(%rax)
  8004208f3d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208f44:	00 00 00 
  8004208f47:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  8004208f4d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208f54:	00 00 00 
  8004208f57:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004208f5b:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208f5e:	88 50 74             	mov    %dl,0x74(%rax)
  8004208f61:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208f68:	00 00 00 
  8004208f6b:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004208f6f:	83 e2 07             	and    $0x7,%edx
  8004208f72:	88 50 74             	mov    %dl,0x74(%rax)
  8004208f75:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208f7c:	00 00 00 
  8004208f7f:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004208f83:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208f86:	83 ca 0e             	or     $0xe,%edx
  8004208f89:	88 50 75             	mov    %dl,0x75(%rax)
  8004208f8c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208f93:	00 00 00 
  8004208f96:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004208f9a:	83 e2 ef             	and    $0xffffffef,%edx
  8004208f9d:	88 50 75             	mov    %dl,0x75(%rax)
  8004208fa0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208fa7:	00 00 00 
  8004208faa:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004208fae:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208fb1:	88 50 75             	mov    %dl,0x75(%rax)
  8004208fb4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208fbb:	00 00 00 
  8004208fbe:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004208fc2:	83 ca 80             	or     $0xffffff80,%edx
  8004208fc5:	88 50 75             	mov    %dl,0x75(%rax)
  8004208fc8:	48 b8 0a c1 20 04 80 	movabs $0x800420c10a,%rax
  8004208fcf:	00 00 00 
  8004208fd2:	48 c1 e8 10          	shr    $0x10,%rax
  8004208fd6:	89 c2                	mov    %eax,%edx
  8004208fd8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208fdf:	00 00 00 
  8004208fe2:	66 89 50 76          	mov    %dx,0x76(%rax)
  8004208fe6:	48 b8 0a c1 20 04 80 	movabs $0x800420c10a,%rax
  8004208fed:	00 00 00 
  8004208ff0:	48 c1 e8 20          	shr    $0x20,%rax
  8004208ff4:	89 c2                	mov    %eax,%edx
  8004208ff6:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004208ffd:	00 00 00 
  8004209000:	89 50 78             	mov    %edx,0x78(%rax)
  8004209003:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420900a:	00 00 00 
  800420900d:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[T_DBLFLT], 0, GD_KT, DBLFLT_F, 0);
  8004209014:	48 b8 14 c1 20 04 80 	movabs $0x800420c114,%rax
  800420901b:	00 00 00 
  800420901e:	89 c2                	mov    %eax,%edx
  8004209020:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209027:	00 00 00 
  800420902a:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  8004209031:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209038:	00 00 00 
  800420903b:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  8004209042:	08 00 
  8004209044:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420904b:	00 00 00 
  800420904e:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209055:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209058:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420905e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209065:	00 00 00 
  8004209068:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420906f:	83 e2 07             	and    $0x7,%edx
  8004209072:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209078:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420907f:	00 00 00 
  8004209082:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209089:	83 e2 f0             	and    $0xfffffff0,%edx
  800420908c:	83 ca 0e             	or     $0xe,%edx
  800420908f:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209095:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420909c:	00 00 00 
  800420909f:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042090a6:	83 e2 ef             	and    $0xffffffef,%edx
  80042090a9:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042090af:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042090b6:	00 00 00 
  80042090b9:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042090c0:	83 e2 9f             	and    $0xffffff9f,%edx
  80042090c3:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042090c9:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042090d0:	00 00 00 
  80042090d3:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042090da:	83 ca 80             	or     $0xffffff80,%edx
  80042090dd:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042090e3:	48 b8 14 c1 20 04 80 	movabs $0x800420c114,%rax
  80042090ea:	00 00 00 
  80042090ed:	48 c1 e8 10          	shr    $0x10,%rax
  80042090f1:	89 c2                	mov    %eax,%edx
  80042090f3:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042090fa:	00 00 00 
  80042090fd:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  8004209104:	48 b8 14 c1 20 04 80 	movabs $0x800420c114,%rax
  800420910b:	00 00 00 
  800420910e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209112:	89 c2                	mov    %eax,%edx
  8004209114:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420911b:	00 00 00 
  800420911e:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  8004209124:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420912b:	00 00 00 
  800420912e:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  8004209135:	00 00 00 
	SETGATE(idt[T_TSS], 0, GD_KT, TSS_F, 0);
  8004209138:	48 b8 1c c1 20 04 80 	movabs $0x800420c11c,%rax
  800420913f:	00 00 00 
  8004209142:	89 c2                	mov    %eax,%edx
  8004209144:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420914b:	00 00 00 
  800420914e:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  8004209155:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420915c:	00 00 00 
  800420915f:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  8004209166:	08 00 
  8004209168:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420916f:	00 00 00 
  8004209172:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209179:	83 e2 f8             	and    $0xfffffff8,%edx
  800420917c:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209182:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209189:	00 00 00 
  800420918c:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209193:	83 e2 07             	and    $0x7,%edx
  8004209196:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420919c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042091a3:	00 00 00 
  80042091a6:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042091ad:	83 e2 f0             	and    $0xfffffff0,%edx
  80042091b0:	83 ca 0e             	or     $0xe,%edx
  80042091b3:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042091b9:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042091c0:	00 00 00 
  80042091c3:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042091ca:	83 e2 ef             	and    $0xffffffef,%edx
  80042091cd:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042091d3:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042091da:	00 00 00 
  80042091dd:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042091e4:	83 e2 9f             	and    $0xffffff9f,%edx
  80042091e7:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042091ed:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042091f4:	00 00 00 
  80042091f7:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042091fe:	83 ca 80             	or     $0xffffff80,%edx
  8004209201:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209207:	48 b8 1c c1 20 04 80 	movabs $0x800420c11c,%rax
  800420920e:	00 00 00 
  8004209211:	48 c1 e8 10          	shr    $0x10,%rax
  8004209215:	89 c2                	mov    %eax,%edx
  8004209217:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420921e:	00 00 00 
  8004209221:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  8004209228:	48 b8 1c c1 20 04 80 	movabs $0x800420c11c,%rax
  800420922f:	00 00 00 
  8004209232:	48 c1 e8 20          	shr    $0x20,%rax
  8004209236:	89 c2                	mov    %eax,%edx
  8004209238:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420923f:	00 00 00 
  8004209242:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  8004209248:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420924f:	00 00 00 
  8004209252:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  8004209259:	00 00 00 
	SETGATE(idt[T_SEGNP], 0, GD_KT, SEGNP_F, 0);
  800420925c:	48 b8 24 c1 20 04 80 	movabs $0x800420c124,%rax
  8004209263:	00 00 00 
  8004209266:	89 c2                	mov    %eax,%edx
  8004209268:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420926f:	00 00 00 
  8004209272:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004209279:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209280:	00 00 00 
  8004209283:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  800420928a:	08 00 
  800420928c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209293:	00 00 00 
  8004209296:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420929d:	83 e2 f8             	and    $0xfffffff8,%edx
  80042092a0:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  80042092a6:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042092ad:	00 00 00 
  80042092b0:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  80042092b7:	83 e2 07             	and    $0x7,%edx
  80042092ba:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  80042092c0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042092c7:	00 00 00 
  80042092ca:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042092d1:	83 e2 f0             	and    $0xfffffff0,%edx
  80042092d4:	83 ca 0e             	or     $0xe,%edx
  80042092d7:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042092dd:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042092e4:	00 00 00 
  80042092e7:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042092ee:	83 e2 ef             	and    $0xffffffef,%edx
  80042092f1:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042092f7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042092fe:	00 00 00 
  8004209301:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209308:	83 e2 9f             	and    $0xffffff9f,%edx
  800420930b:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209311:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209318:	00 00 00 
  800420931b:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209322:	83 ca 80             	or     $0xffffff80,%edx
  8004209325:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420932b:	48 b8 24 c1 20 04 80 	movabs $0x800420c124,%rax
  8004209332:	00 00 00 
  8004209335:	48 c1 e8 10          	shr    $0x10,%rax
  8004209339:	89 c2                	mov    %eax,%edx
  800420933b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209342:	00 00 00 
  8004209345:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  800420934c:	48 b8 24 c1 20 04 80 	movabs $0x800420c124,%rax
  8004209353:	00 00 00 
  8004209356:	48 c1 e8 20          	shr    $0x20,%rax
  800420935a:	89 c2                	mov    %eax,%edx
  800420935c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209363:	00 00 00 
  8004209366:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  800420936c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209373:	00 00 00 
  8004209376:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  800420937d:	00 00 00 
	SETGATE(idt[T_STACK], 0, GD_KT, STACK_F, 0);
  8004209380:	48 b8 2c c1 20 04 80 	movabs $0x800420c12c,%rax
  8004209387:	00 00 00 
  800420938a:	89 c2                	mov    %eax,%edx
  800420938c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209393:	00 00 00 
  8004209396:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  800420939d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042093a4:	00 00 00 
  80042093a7:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  80042093ae:	08 00 
  80042093b0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042093b7:	00 00 00 
  80042093ba:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  80042093c1:	83 e2 f8             	and    $0xfffffff8,%edx
  80042093c4:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  80042093ca:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042093d1:	00 00 00 
  80042093d4:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  80042093db:	83 e2 07             	and    $0x7,%edx
  80042093de:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  80042093e4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042093eb:	00 00 00 
  80042093ee:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  80042093f5:	83 e2 f0             	and    $0xfffffff0,%edx
  80042093f8:	83 ca 0e             	or     $0xe,%edx
  80042093fb:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209401:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209408:	00 00 00 
  800420940b:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209412:	83 e2 ef             	and    $0xffffffef,%edx
  8004209415:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420941b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209422:	00 00 00 
  8004209425:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420942c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420942f:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209435:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420943c:	00 00 00 
  800420943f:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209446:	83 ca 80             	or     $0xffffff80,%edx
  8004209449:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420944f:	48 b8 2c c1 20 04 80 	movabs $0x800420c12c,%rax
  8004209456:	00 00 00 
  8004209459:	48 c1 e8 10          	shr    $0x10,%rax
  800420945d:	89 c2                	mov    %eax,%edx
  800420945f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209466:	00 00 00 
  8004209469:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  8004209470:	48 b8 2c c1 20 04 80 	movabs $0x800420c12c,%rax
  8004209477:	00 00 00 
  800420947a:	48 c1 e8 20          	shr    $0x20,%rax
  800420947e:	89 c2                	mov    %eax,%edx
  8004209480:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209487:	00 00 00 
  800420948a:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  8004209490:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209497:	00 00 00 
  800420949a:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  80042094a1:	00 00 00 
	SETGATE(idt[T_GPFLT], 0, GD_KT, GPFLT_F, 0);
  80042094a4:	48 b8 34 c1 20 04 80 	movabs $0x800420c134,%rax
  80042094ab:	00 00 00 
  80042094ae:	89 c2                	mov    %eax,%edx
  80042094b0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042094b7:	00 00 00 
  80042094ba:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  80042094c1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042094c8:	00 00 00 
  80042094cb:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  80042094d2:	08 00 
  80042094d4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042094db:	00 00 00 
  80042094de:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  80042094e5:	83 e2 f8             	and    $0xfffffff8,%edx
  80042094e8:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  80042094ee:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042094f5:	00 00 00 
  80042094f8:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  80042094ff:	83 e2 07             	and    $0x7,%edx
  8004209502:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209508:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420950f:	00 00 00 
  8004209512:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209519:	83 e2 f0             	and    $0xfffffff0,%edx
  800420951c:	83 ca 0e             	or     $0xe,%edx
  800420951f:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209525:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420952c:	00 00 00 
  800420952f:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209536:	83 e2 ef             	and    $0xffffffef,%edx
  8004209539:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420953f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209546:	00 00 00 
  8004209549:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209550:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209553:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209559:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209560:	00 00 00 
  8004209563:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420956a:	83 ca 80             	or     $0xffffff80,%edx
  800420956d:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209573:	48 b8 34 c1 20 04 80 	movabs $0x800420c134,%rax
  800420957a:	00 00 00 
  800420957d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209581:	89 c2                	mov    %eax,%edx
  8004209583:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420958a:	00 00 00 
  800420958d:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  8004209594:	48 b8 34 c1 20 04 80 	movabs $0x800420c134,%rax
  800420959b:	00 00 00 
  800420959e:	48 c1 e8 20          	shr    $0x20,%rax
  80042095a2:	89 c2                	mov    %eax,%edx
  80042095a4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042095ab:	00 00 00 
  80042095ae:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  80042095b4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042095bb:	00 00 00 
  80042095be:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  80042095c5:	00 00 00 
	SETGATE(idt[T_PGFLT], 0, GD_KT, PGFLT_F, 0);
  80042095c8:	48 b8 3c c1 20 04 80 	movabs $0x800420c13c,%rax
  80042095cf:	00 00 00 
  80042095d2:	89 c2                	mov    %eax,%edx
  80042095d4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042095db:	00 00 00 
  80042095de:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  80042095e5:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042095ec:	00 00 00 
  80042095ef:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  80042095f6:	08 00 
  80042095f8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042095ff:	00 00 00 
  8004209602:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209609:	83 e2 f8             	and    $0xfffffff8,%edx
  800420960c:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209612:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209619:	00 00 00 
  800420961c:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209623:	83 e2 07             	and    $0x7,%edx
  8004209626:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420962c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209633:	00 00 00 
  8004209636:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420963d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209640:	83 ca 0e             	or     $0xe,%edx
  8004209643:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209649:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209650:	00 00 00 
  8004209653:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420965a:	83 e2 ef             	and    $0xffffffef,%edx
  800420965d:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209663:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420966a:	00 00 00 
  800420966d:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209674:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209677:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420967d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209684:	00 00 00 
  8004209687:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420968e:	83 ca 80             	or     $0xffffff80,%edx
  8004209691:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209697:	48 b8 3c c1 20 04 80 	movabs $0x800420c13c,%rax
  800420969e:	00 00 00 
  80042096a1:	48 c1 e8 10          	shr    $0x10,%rax
  80042096a5:	89 c2                	mov    %eax,%edx
  80042096a7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042096ae:	00 00 00 
  80042096b1:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  80042096b8:	48 b8 3c c1 20 04 80 	movabs $0x800420c13c,%rax
  80042096bf:	00 00 00 
  80042096c2:	48 c1 e8 20          	shr    $0x20,%rax
  80042096c6:	89 c2                	mov    %eax,%edx
  80042096c8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042096cf:	00 00 00 
  80042096d2:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  80042096d8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042096df:	00 00 00 
  80042096e2:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  80042096e9:	00 00 00 
	SETGATE(idt[T_FPERR], 0, GD_KT, FPERR_F, 0);
  80042096ec:	48 b8 44 c1 20 04 80 	movabs $0x800420c144,%rax
  80042096f3:	00 00 00 
  80042096f6:	89 c2                	mov    %eax,%edx
  80042096f8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042096ff:	00 00 00 
  8004209702:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004209709:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209710:	00 00 00 
  8004209713:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  800420971a:	08 00 
  800420971c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209723:	00 00 00 
  8004209726:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420972d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209730:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209736:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420973d:	00 00 00 
  8004209740:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209747:	83 e2 07             	and    $0x7,%edx
  800420974a:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209750:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209757:	00 00 00 
  800420975a:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209761:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209764:	83 ca 0e             	or     $0xe,%edx
  8004209767:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420976d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209774:	00 00 00 
  8004209777:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420977e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209781:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209787:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420978e:	00 00 00 
  8004209791:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209798:	83 e2 9f             	and    $0xffffff9f,%edx
  800420979b:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  80042097a1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042097a8:	00 00 00 
  80042097ab:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  80042097b2:	83 ca 80             	or     $0xffffff80,%edx
  80042097b5:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  80042097bb:	48 b8 44 c1 20 04 80 	movabs $0x800420c144,%rax
  80042097c2:	00 00 00 
  80042097c5:	48 c1 e8 10          	shr    $0x10,%rax
  80042097c9:	89 c2                	mov    %eax,%edx
  80042097cb:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042097d2:	00 00 00 
  80042097d5:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  80042097dc:	48 b8 44 c1 20 04 80 	movabs $0x800420c144,%rax
  80042097e3:	00 00 00 
  80042097e6:	48 c1 e8 20          	shr    $0x20,%rax
  80042097ea:	89 c2                	mov    %eax,%edx
  80042097ec:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042097f3:	00 00 00 
  80042097f6:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  80042097fc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209803:	00 00 00 
  8004209806:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420980d:	00 00 00 
	SETGATE(idt[T_ALIGN], 0, GD_KT, ALIGN_F, 0);
  8004209810:	48 b8 4e c1 20 04 80 	movabs $0x800420c14e,%rax
  8004209817:	00 00 00 
  800420981a:	89 c2                	mov    %eax,%edx
  800420981c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209823:	00 00 00 
  8004209826:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  800420982d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209834:	00 00 00 
  8004209837:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  800420983e:	08 00 
  8004209840:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209847:	00 00 00 
  800420984a:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209851:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209854:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420985a:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209861:	00 00 00 
  8004209864:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420986b:	83 e2 07             	and    $0x7,%edx
  800420986e:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209874:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420987b:	00 00 00 
  800420987e:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209885:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209888:	83 ca 0e             	or     $0xe,%edx
  800420988b:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209891:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209898:	00 00 00 
  800420989b:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  80042098a2:	83 e2 ef             	and    $0xffffffef,%edx
  80042098a5:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  80042098ab:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042098b2:	00 00 00 
  80042098b5:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  80042098bc:	83 e2 9f             	and    $0xffffff9f,%edx
  80042098bf:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  80042098c5:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042098cc:	00 00 00 
  80042098cf:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  80042098d6:	83 ca 80             	or     $0xffffff80,%edx
  80042098d9:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  80042098df:	48 b8 4e c1 20 04 80 	movabs $0x800420c14e,%rax
  80042098e6:	00 00 00 
  80042098e9:	48 c1 e8 10          	shr    $0x10,%rax
  80042098ed:	89 c2                	mov    %eax,%edx
  80042098ef:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042098f6:	00 00 00 
  80042098f9:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  8004209900:	48 b8 4e c1 20 04 80 	movabs $0x800420c14e,%rax
  8004209907:	00 00 00 
  800420990a:	48 c1 e8 20          	shr    $0x20,%rax
  800420990e:	89 c2                	mov    %eax,%edx
  8004209910:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209917:	00 00 00 
  800420991a:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  8004209920:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209927:	00 00 00 
  800420992a:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  8004209931:	00 00 00 
	SETGATE(idt[T_MCHK], 0, GD_KT, MCHK_F, 0);
  8004209934:	48 b8 56 c1 20 04 80 	movabs $0x800420c156,%rax
  800420993b:	00 00 00 
  800420993e:	89 c2                	mov    %eax,%edx
  8004209940:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209947:	00 00 00 
  800420994a:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  8004209951:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209958:	00 00 00 
  800420995b:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  8004209962:	08 00 
  8004209964:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420996b:	00 00 00 
  800420996e:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004209975:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209978:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420997e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209985:	00 00 00 
  8004209988:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420998f:	83 e2 07             	and    $0x7,%edx
  8004209992:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004209998:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420999f:	00 00 00 
  80042099a2:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  80042099a9:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099ac:	83 ca 0e             	or     $0xe,%edx
  80042099af:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  80042099b5:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042099bc:	00 00 00 
  80042099bf:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  80042099c6:	83 e2 ef             	and    $0xffffffef,%edx
  80042099c9:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  80042099cf:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042099d6:	00 00 00 
  80042099d9:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  80042099e0:	83 e2 9f             	and    $0xffffff9f,%edx
  80042099e3:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  80042099e9:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  80042099f0:	00 00 00 
  80042099f3:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  80042099fa:	83 ca 80             	or     $0xffffff80,%edx
  80042099fd:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209a03:	48 b8 56 c1 20 04 80 	movabs $0x800420c156,%rax
  8004209a0a:	00 00 00 
  8004209a0d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a11:	89 c2                	mov    %eax,%edx
  8004209a13:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209a1a:	00 00 00 
  8004209a1d:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  8004209a24:	48 b8 56 c1 20 04 80 	movabs $0x800420c156,%rax
  8004209a2b:	00 00 00 
  8004209a2e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a32:	89 c2                	mov    %eax,%edx
  8004209a34:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209a3b:	00 00 00 
  8004209a3e:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  8004209a44:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209a4b:	00 00 00 
  8004209a4e:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  8004209a55:	00 00 00 
	SETGATE(idt[T_SIMDERR], 0, GD_KT, SIMDERR_F, 0);
  8004209a58:	48 b8 5c c1 20 04 80 	movabs $0x800420c15c,%rax
  8004209a5f:	00 00 00 
  8004209a62:	89 c2                	mov    %eax,%edx
  8004209a64:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209a6b:	00 00 00 
  8004209a6e:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  8004209a75:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209a7c:	00 00 00 
  8004209a7f:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  8004209a86:	08 00 
  8004209a88:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209a8f:	00 00 00 
  8004209a92:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004209a99:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a9c:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004209aa2:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209aa9:	00 00 00 
  8004209aac:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004209ab3:	83 e2 07             	and    $0x7,%edx
  8004209ab6:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004209abc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209ac3:	00 00 00 
  8004209ac6:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209acd:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ad0:	83 ca 0e             	or     $0xe,%edx
  8004209ad3:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209ad9:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209ae0:	00 00 00 
  8004209ae3:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209aea:	83 e2 ef             	and    $0xffffffef,%edx
  8004209aed:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209af3:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209afa:	00 00 00 
  8004209afd:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209b04:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209b07:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209b0d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209b14:	00 00 00 
  8004209b17:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209b1e:	83 ca 80             	or     $0xffffff80,%edx
  8004209b21:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209b27:	48 b8 5c c1 20 04 80 	movabs $0x800420c15c,%rax
  8004209b2e:	00 00 00 
  8004209b31:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b35:	89 c2                	mov    %eax,%edx
  8004209b37:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209b3e:	00 00 00 
  8004209b41:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  8004209b48:	48 b8 5c c1 20 04 80 	movabs $0x800420c15c,%rax
  8004209b4f:	00 00 00 
  8004209b52:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b56:	89 c2                	mov    %eax,%edx
  8004209b58:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209b5f:	00 00 00 
  8004209b62:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  8004209b68:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209b6f:	00 00 00 
  8004209b72:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  8004209b79:	00 00 00 
	SETGATE(idt[T_SYSCALL], 0, GD_KT, SYSCALL_F, 3);
  8004209b7c:	48 b8 62 c1 20 04 80 	movabs $0x800420c162,%rax
  8004209b83:	00 00 00 
  8004209b86:	89 c2                	mov    %eax,%edx
  8004209b88:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209b8f:	00 00 00 
  8004209b92:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  8004209b99:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209ba0:	00 00 00 
  8004209ba3:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  8004209baa:	08 00 
  8004209bac:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209bb3:	00 00 00 
  8004209bb6:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209bbd:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209bc0:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209bc6:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209bcd:	00 00 00 
  8004209bd0:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209bd7:	83 e2 07             	and    $0x7,%edx
  8004209bda:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209be0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209be7:	00 00 00 
  8004209bea:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209bf1:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209bf4:	83 ca 0e             	or     $0xe,%edx
  8004209bf7:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209bfd:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209c04:	00 00 00 
  8004209c07:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209c0e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209c11:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209c17:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209c1e:	00 00 00 
  8004209c21:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209c28:	83 ca 60             	or     $0x60,%edx
  8004209c2b:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209c31:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209c38:	00 00 00 
  8004209c3b:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209c42:	83 ca 80             	or     $0xffffff80,%edx
  8004209c45:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209c4b:	48 b8 62 c1 20 04 80 	movabs $0x800420c162,%rax
  8004209c52:	00 00 00 
  8004209c55:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c59:	89 c2                	mov    %eax,%edx
  8004209c5b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209c62:	00 00 00 
  8004209c65:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  8004209c6c:	48 b8 62 c1 20 04 80 	movabs $0x800420c162,%rax
  8004209c73:	00 00 00 
  8004209c76:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c7a:	89 c2                	mov    %eax,%edx
  8004209c7c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209c83:	00 00 00 
  8004209c86:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  8004209c8c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209c93:	00 00 00 
  8004209c96:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  8004209c9d:	00 00 00 

	// LAB 4
	SETGATE(idt[IRQ_OFFSET], 0, GD_KT, IRQ0_HANDLER, 0);
  8004209ca0:	48 b8 70 c1 20 04 80 	movabs $0x800420c170,%rax
  8004209ca7:	00 00 00 
  8004209caa:	89 c2                	mov    %eax,%edx
  8004209cac:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209cb3:	00 00 00 
  8004209cb6:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  8004209cbd:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209cc4:	00 00 00 
  8004209cc7:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  8004209cce:	08 00 
  8004209cd0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209cd7:	00 00 00 
  8004209cda:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  8004209ce1:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209ce4:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  8004209cea:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209cf1:	00 00 00 
  8004209cf4:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  8004209cfb:	83 e2 07             	and    $0x7,%edx
  8004209cfe:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  8004209d04:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209d0b:	00 00 00 
  8004209d0e:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209d15:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209d18:	83 ca 0e             	or     $0xe,%edx
  8004209d1b:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209d21:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209d28:	00 00 00 
  8004209d2b:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209d32:	83 e2 ef             	and    $0xffffffef,%edx
  8004209d35:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209d3b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209d42:	00 00 00 
  8004209d45:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209d4c:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209d4f:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209d55:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209d5c:	00 00 00 
  8004209d5f:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209d66:	83 ca 80             	or     $0xffffff80,%edx
  8004209d69:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209d6f:	48 b8 70 c1 20 04 80 	movabs $0x800420c170,%rax
  8004209d76:	00 00 00 
  8004209d79:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d7d:	89 c2                	mov    %eax,%edx
  8004209d7f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209d86:	00 00 00 
  8004209d89:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  8004209d90:	48 b8 70 c1 20 04 80 	movabs $0x800420c170,%rax
  8004209d97:	00 00 00 
  8004209d9a:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d9e:	89 c2                	mov    %eax,%edx
  8004209da0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209da7:	00 00 00 
  8004209daa:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  8004209db0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209db7:	00 00 00 
  8004209dba:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  8004209dc1:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 1], 0, GD_KT, IRQ1_HANDLER, 0);
  8004209dc4:	48 b8 76 c1 20 04 80 	movabs $0x800420c176,%rax
  8004209dcb:	00 00 00 
  8004209dce:	89 c2                	mov    %eax,%edx
  8004209dd0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209dd7:	00 00 00 
  8004209dda:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  8004209de1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209de8:	00 00 00 
  8004209deb:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  8004209df2:	08 00 
  8004209df4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209dfb:	00 00 00 
  8004209dfe:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  8004209e05:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209e08:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  8004209e0e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209e15:	00 00 00 
  8004209e18:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  8004209e1f:	83 e2 07             	and    $0x7,%edx
  8004209e22:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  8004209e28:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209e2f:	00 00 00 
  8004209e32:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209e39:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e3c:	83 ca 0e             	or     $0xe,%edx
  8004209e3f:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209e45:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209e4c:	00 00 00 
  8004209e4f:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209e56:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e59:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209e5f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209e66:	00 00 00 
  8004209e69:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209e70:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209e73:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209e79:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209e80:	00 00 00 
  8004209e83:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209e8a:	83 ca 80             	or     $0xffffff80,%edx
  8004209e8d:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209e93:	48 b8 76 c1 20 04 80 	movabs $0x800420c176,%rax
  8004209e9a:	00 00 00 
  8004209e9d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ea1:	89 c2                	mov    %eax,%edx
  8004209ea3:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209eaa:	00 00 00 
  8004209ead:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  8004209eb4:	48 b8 76 c1 20 04 80 	movabs $0x800420c176,%rax
  8004209ebb:	00 00 00 
  8004209ebe:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ec2:	89 c2                	mov    %eax,%edx
  8004209ec4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209ecb:	00 00 00 
  8004209ece:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  8004209ed4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209edb:	00 00 00 
  8004209ede:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  8004209ee5:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 2], 0, GD_KT, IRQ2_HANDLER, 0);
  8004209ee8:	48 b8 7c c1 20 04 80 	movabs $0x800420c17c,%rax
  8004209eef:	00 00 00 
  8004209ef2:	89 c2                	mov    %eax,%edx
  8004209ef4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209efb:	00 00 00 
  8004209efe:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  8004209f05:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209f0c:	00 00 00 
  8004209f0f:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  8004209f16:	08 00 
  8004209f18:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209f1f:	00 00 00 
  8004209f22:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  8004209f29:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f2c:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  8004209f32:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209f39:	00 00 00 
  8004209f3c:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  8004209f43:	83 e2 07             	and    $0x7,%edx
  8004209f46:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  8004209f4c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209f53:	00 00 00 
  8004209f56:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  8004209f5d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f60:	83 ca 0e             	or     $0xe,%edx
  8004209f63:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  8004209f69:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209f70:	00 00 00 
  8004209f73:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  8004209f7a:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f7d:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  8004209f83:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209f8a:	00 00 00 
  8004209f8d:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  8004209f94:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f97:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  8004209f9d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209fa4:	00 00 00 
  8004209fa7:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  8004209fae:	83 ca 80             	or     $0xffffff80,%edx
  8004209fb1:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  8004209fb7:	48 b8 7c c1 20 04 80 	movabs $0x800420c17c,%rax
  8004209fbe:	00 00 00 
  8004209fc1:	48 c1 e8 10          	shr    $0x10,%rax
  8004209fc5:	89 c2                	mov    %eax,%edx
  8004209fc7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209fce:	00 00 00 
  8004209fd1:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  8004209fd8:	48 b8 7c c1 20 04 80 	movabs $0x800420c17c,%rax
  8004209fdf:	00 00 00 
  8004209fe2:	48 c1 e8 20          	shr    $0x20,%rax
  8004209fe6:	89 c2                	mov    %eax,%edx
  8004209fe8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209fef:	00 00 00 
  8004209ff2:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  8004209ff8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  8004209fff:	00 00 00 
  800420a002:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420a009:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 3], 0, GD_KT, IRQ3_HANDLER, 0);
  800420a00c:	48 b8 82 c1 20 04 80 	movabs $0x800420c182,%rax
  800420a013:	00 00 00 
  800420a016:	89 c2                	mov    %eax,%edx
  800420a018:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a01f:	00 00 00 
  800420a022:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420a029:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a030:	00 00 00 
  800420a033:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420a03a:	08 00 
  800420a03c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a043:	00 00 00 
  800420a046:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a04d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a050:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a056:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a05d:	00 00 00 
  800420a060:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a067:	83 e2 07             	and    $0x7,%edx
  800420a06a:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a070:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a077:	00 00 00 
  800420a07a:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a081:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a084:	83 ca 0e             	or     $0xe,%edx
  800420a087:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a08d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a094:	00 00 00 
  800420a097:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a09e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a0a1:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a0a7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a0ae:	00 00 00 
  800420a0b1:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a0b8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0bb:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a0c1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a0c8:	00 00 00 
  800420a0cb:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a0d2:	83 ca 80             	or     $0xffffff80,%edx
  800420a0d5:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a0db:	48 b8 82 c1 20 04 80 	movabs $0x800420c182,%rax
  800420a0e2:	00 00 00 
  800420a0e5:	48 c1 e8 10          	shr    $0x10,%rax
  800420a0e9:	89 c2                	mov    %eax,%edx
  800420a0eb:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a0f2:	00 00 00 
  800420a0f5:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420a0fc:	48 b8 82 c1 20 04 80 	movabs $0x800420c182,%rax
  800420a103:	00 00 00 
  800420a106:	48 c1 e8 20          	shr    $0x20,%rax
  800420a10a:	89 c2                	mov    %eax,%edx
  800420a10c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a113:	00 00 00 
  800420a116:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420a11c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a123:	00 00 00 
  800420a126:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420a12d:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 4], 0, GD_KT, IRQ4_HANDLER, 0);
  800420a130:	48 b8 88 c1 20 04 80 	movabs $0x800420c188,%rax
  800420a137:	00 00 00 
  800420a13a:	89 c2                	mov    %eax,%edx
  800420a13c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a143:	00 00 00 
  800420a146:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a14d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a154:	00 00 00 
  800420a157:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a15e:	08 00 
  800420a160:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a167:	00 00 00 
  800420a16a:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a171:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a174:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a17a:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a181:	00 00 00 
  800420a184:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a18b:	83 e2 07             	and    $0x7,%edx
  800420a18e:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a194:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a19b:	00 00 00 
  800420a19e:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a1a5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a1a8:	83 ca 0e             	or     $0xe,%edx
  800420a1ab:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a1b1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a1b8:	00 00 00 
  800420a1bb:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a1c2:	83 e2 ef             	and    $0xffffffef,%edx
  800420a1c5:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a1cb:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a1d2:	00 00 00 
  800420a1d5:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a1dc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a1df:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a1e5:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a1ec:	00 00 00 
  800420a1ef:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a1f6:	83 ca 80             	or     $0xffffff80,%edx
  800420a1f9:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a1ff:	48 b8 88 c1 20 04 80 	movabs $0x800420c188,%rax
  800420a206:	00 00 00 
  800420a209:	48 c1 e8 10          	shr    $0x10,%rax
  800420a20d:	89 c2                	mov    %eax,%edx
  800420a20f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a216:	00 00 00 
  800420a219:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420a220:	48 b8 88 c1 20 04 80 	movabs $0x800420c188,%rax
  800420a227:	00 00 00 
  800420a22a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a22e:	89 c2                	mov    %eax,%edx
  800420a230:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a237:	00 00 00 
  800420a23a:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420a240:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a247:	00 00 00 
  800420a24a:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420a251:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 5], 0, GD_KT, IRQ5_HANDLER, 0);
  800420a254:	48 b8 8e c1 20 04 80 	movabs $0x800420c18e,%rax
  800420a25b:	00 00 00 
  800420a25e:	89 c2                	mov    %eax,%edx
  800420a260:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a267:	00 00 00 
  800420a26a:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420a271:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a278:	00 00 00 
  800420a27b:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420a282:	08 00 
  800420a284:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a28b:	00 00 00 
  800420a28e:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420a295:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a298:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420a29e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a2a5:	00 00 00 
  800420a2a8:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420a2af:	83 e2 07             	and    $0x7,%edx
  800420a2b2:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420a2b8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a2bf:	00 00 00 
  800420a2c2:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a2c9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a2cc:	83 ca 0e             	or     $0xe,%edx
  800420a2cf:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a2d5:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a2dc:	00 00 00 
  800420a2df:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a2e6:	83 e2 ef             	and    $0xffffffef,%edx
  800420a2e9:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a2ef:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a2f6:	00 00 00 
  800420a2f9:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a300:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a303:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a309:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a310:	00 00 00 
  800420a313:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a31a:	83 ca 80             	or     $0xffffff80,%edx
  800420a31d:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a323:	48 b8 8e c1 20 04 80 	movabs $0x800420c18e,%rax
  800420a32a:	00 00 00 
  800420a32d:	48 c1 e8 10          	shr    $0x10,%rax
  800420a331:	89 c2                	mov    %eax,%edx
  800420a333:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a33a:	00 00 00 
  800420a33d:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420a344:	48 b8 8e c1 20 04 80 	movabs $0x800420c18e,%rax
  800420a34b:	00 00 00 
  800420a34e:	48 c1 e8 20          	shr    $0x20,%rax
  800420a352:	89 c2                	mov    %eax,%edx
  800420a354:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a35b:	00 00 00 
  800420a35e:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420a364:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a36b:	00 00 00 
  800420a36e:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420a375:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 6], 0, GD_KT, IRQ6_HANDLER, 0);
  800420a378:	48 b8 94 c1 20 04 80 	movabs $0x800420c194,%rax
  800420a37f:	00 00 00 
  800420a382:	89 c2                	mov    %eax,%edx
  800420a384:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a38b:	00 00 00 
  800420a38e:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420a395:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a39c:	00 00 00 
  800420a39f:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420a3a6:	08 00 
  800420a3a8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a3af:	00 00 00 
  800420a3b2:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420a3b9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a3bc:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420a3c2:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a3c9:	00 00 00 
  800420a3cc:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420a3d3:	83 e2 07             	and    $0x7,%edx
  800420a3d6:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420a3dc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a3e3:	00 00 00 
  800420a3e6:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a3ed:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a3f0:	83 ca 0e             	or     $0xe,%edx
  800420a3f3:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a3f9:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a400:	00 00 00 
  800420a403:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a40a:	83 e2 ef             	and    $0xffffffef,%edx
  800420a40d:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a413:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a41a:	00 00 00 
  800420a41d:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a424:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a427:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a42d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a434:	00 00 00 
  800420a437:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a43e:	83 ca 80             	or     $0xffffff80,%edx
  800420a441:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a447:	48 b8 94 c1 20 04 80 	movabs $0x800420c194,%rax
  800420a44e:	00 00 00 
  800420a451:	48 c1 e8 10          	shr    $0x10,%rax
  800420a455:	89 c2                	mov    %eax,%edx
  800420a457:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a45e:	00 00 00 
  800420a461:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420a468:	48 b8 94 c1 20 04 80 	movabs $0x800420c194,%rax
  800420a46f:	00 00 00 
  800420a472:	48 c1 e8 20          	shr    $0x20,%rax
  800420a476:	89 c2                	mov    %eax,%edx
  800420a478:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a47f:	00 00 00 
  800420a482:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420a488:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a48f:	00 00 00 
  800420a492:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420a499:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 7], 0, GD_KT, IRQ7_HANDLER, 0);
  800420a49c:	48 b8 9a c1 20 04 80 	movabs $0x800420c19a,%rax
  800420a4a3:	00 00 00 
  800420a4a6:	89 c2                	mov    %eax,%edx
  800420a4a8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a4af:	00 00 00 
  800420a4b2:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420a4b9:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a4c0:	00 00 00 
  800420a4c3:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420a4ca:	08 00 
  800420a4cc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a4d3:	00 00 00 
  800420a4d6:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a4dd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a4e0:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a4e6:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a4ed:	00 00 00 
  800420a4f0:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a4f7:	83 e2 07             	and    $0x7,%edx
  800420a4fa:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a500:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a507:	00 00 00 
  800420a50a:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a511:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a514:	83 ca 0e             	or     $0xe,%edx
  800420a517:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a51d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a524:	00 00 00 
  800420a527:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a52e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a531:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a537:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a53e:	00 00 00 
  800420a541:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a548:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a54b:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a551:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a558:	00 00 00 
  800420a55b:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a562:	83 ca 80             	or     $0xffffff80,%edx
  800420a565:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a56b:	48 b8 9a c1 20 04 80 	movabs $0x800420c19a,%rax
  800420a572:	00 00 00 
  800420a575:	48 c1 e8 10          	shr    $0x10,%rax
  800420a579:	89 c2                	mov    %eax,%edx
  800420a57b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a582:	00 00 00 
  800420a585:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420a58c:	48 b8 9a c1 20 04 80 	movabs $0x800420c19a,%rax
  800420a593:	00 00 00 
  800420a596:	48 c1 e8 20          	shr    $0x20,%rax
  800420a59a:	89 c2                	mov    %eax,%edx
  800420a59c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a5a3:	00 00 00 
  800420a5a6:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420a5ac:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a5b3:	00 00 00 
  800420a5b6:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420a5bd:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 8], 0, GD_KT, IRQ8_HANDLER, 0);
  800420a5c0:	48 b8 a0 c1 20 04 80 	movabs $0x800420c1a0,%rax
  800420a5c7:	00 00 00 
  800420a5ca:	89 c2                	mov    %eax,%edx
  800420a5cc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a5d3:	00 00 00 
  800420a5d6:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420a5dd:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a5e4:	00 00 00 
  800420a5e7:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420a5ee:	08 00 
  800420a5f0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a5f7:	00 00 00 
  800420a5fa:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420a601:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a604:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420a60a:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a611:	00 00 00 
  800420a614:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420a61b:	83 e2 07             	and    $0x7,%edx
  800420a61e:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420a624:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a62b:	00 00 00 
  800420a62e:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a635:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a638:	83 ca 0e             	or     $0xe,%edx
  800420a63b:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a641:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a648:	00 00 00 
  800420a64b:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a652:	83 e2 ef             	and    $0xffffffef,%edx
  800420a655:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a65b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a662:	00 00 00 
  800420a665:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a66c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a66f:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a675:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a67c:	00 00 00 
  800420a67f:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a686:	83 ca 80             	or     $0xffffff80,%edx
  800420a689:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a68f:	48 b8 a0 c1 20 04 80 	movabs $0x800420c1a0,%rax
  800420a696:	00 00 00 
  800420a699:	48 c1 e8 10          	shr    $0x10,%rax
  800420a69d:	89 c2                	mov    %eax,%edx
  800420a69f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a6a6:	00 00 00 
  800420a6a9:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420a6b0:	48 b8 a0 c1 20 04 80 	movabs $0x800420c1a0,%rax
  800420a6b7:	00 00 00 
  800420a6ba:	48 c1 e8 20          	shr    $0x20,%rax
  800420a6be:	89 c2                	mov    %eax,%edx
  800420a6c0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a6c7:	00 00 00 
  800420a6ca:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420a6d0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a6d7:	00 00 00 
  800420a6da:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420a6e1:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 9], 0, GD_KT, IRQ9_HANDLER, 0);
  800420a6e4:	48 b8 a6 c1 20 04 80 	movabs $0x800420c1a6,%rax
  800420a6eb:	00 00 00 
  800420a6ee:	89 c2                	mov    %eax,%edx
  800420a6f0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a6f7:	00 00 00 
  800420a6fa:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420a701:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a708:	00 00 00 
  800420a70b:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420a712:	08 00 
  800420a714:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a71b:	00 00 00 
  800420a71e:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420a725:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a728:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420a72e:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a735:	00 00 00 
  800420a738:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420a73f:	83 e2 07             	and    $0x7,%edx
  800420a742:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420a748:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a74f:	00 00 00 
  800420a752:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a759:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a75c:	83 ca 0e             	or     $0xe,%edx
  800420a75f:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a765:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a76c:	00 00 00 
  800420a76f:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a776:	83 e2 ef             	and    $0xffffffef,%edx
  800420a779:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a77f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a786:	00 00 00 
  800420a789:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a790:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a793:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a799:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a7a0:	00 00 00 
  800420a7a3:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a7aa:	83 ca 80             	or     $0xffffff80,%edx
  800420a7ad:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a7b3:	48 b8 a6 c1 20 04 80 	movabs $0x800420c1a6,%rax
  800420a7ba:	00 00 00 
  800420a7bd:	48 c1 e8 10          	shr    $0x10,%rax
  800420a7c1:	89 c2                	mov    %eax,%edx
  800420a7c3:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a7ca:	00 00 00 
  800420a7cd:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420a7d4:	48 b8 a6 c1 20 04 80 	movabs $0x800420c1a6,%rax
  800420a7db:	00 00 00 
  800420a7de:	48 c1 e8 20          	shr    $0x20,%rax
  800420a7e2:	89 c2                	mov    %eax,%edx
  800420a7e4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a7eb:	00 00 00 
  800420a7ee:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420a7f4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a7fb:	00 00 00 
  800420a7fe:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420a805:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, IRQ10_HANDLER, 0);
  800420a808:	48 b8 ac c1 20 04 80 	movabs $0x800420c1ac,%rax
  800420a80f:	00 00 00 
  800420a812:	89 c2                	mov    %eax,%edx
  800420a814:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a81b:	00 00 00 
  800420a81e:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420a825:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a82c:	00 00 00 
  800420a82f:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420a836:	08 00 
  800420a838:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a83f:	00 00 00 
  800420a842:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420a849:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a84c:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420a852:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a859:	00 00 00 
  800420a85c:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420a863:	83 e2 07             	and    $0x7,%edx
  800420a866:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420a86c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a873:	00 00 00 
  800420a876:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a87d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a880:	83 ca 0e             	or     $0xe,%edx
  800420a883:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a889:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a890:	00 00 00 
  800420a893:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a89a:	83 e2 ef             	and    $0xffffffef,%edx
  800420a89d:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a8a3:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a8aa:	00 00 00 
  800420a8ad:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a8b4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a8b7:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a8bd:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a8c4:	00 00 00 
  800420a8c7:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a8ce:	83 ca 80             	or     $0xffffff80,%edx
  800420a8d1:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a8d7:	48 b8 ac c1 20 04 80 	movabs $0x800420c1ac,%rax
  800420a8de:	00 00 00 
  800420a8e1:	48 c1 e8 10          	shr    $0x10,%rax
  800420a8e5:	89 c2                	mov    %eax,%edx
  800420a8e7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a8ee:	00 00 00 
  800420a8f1:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420a8f8:	48 b8 ac c1 20 04 80 	movabs $0x800420c1ac,%rax
  800420a8ff:	00 00 00 
  800420a902:	48 c1 e8 20          	shr    $0x20,%rax
  800420a906:	89 c2                	mov    %eax,%edx
  800420a908:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a90f:	00 00 00 
  800420a912:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420a918:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a91f:	00 00 00 
  800420a922:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420a929:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, IRQ11_HANDLER, 0);
  800420a92c:	48 b8 b2 c1 20 04 80 	movabs $0x800420c1b2,%rax
  800420a933:	00 00 00 
  800420a936:	89 c2                	mov    %eax,%edx
  800420a938:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a93f:	00 00 00 
  800420a942:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420a949:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a950:	00 00 00 
  800420a953:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420a95a:	08 00 
  800420a95c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a963:	00 00 00 
  800420a966:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420a96d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a970:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420a976:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a97d:	00 00 00 
  800420a980:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420a987:	83 e2 07             	and    $0x7,%edx
  800420a98a:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420a990:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a997:	00 00 00 
  800420a99a:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420a9a1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a9a4:	83 ca 0e             	or     $0xe,%edx
  800420a9a7:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420a9ad:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a9b4:	00 00 00 
  800420a9b7:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420a9be:	83 e2 ef             	and    $0xffffffef,%edx
  800420a9c1:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420a9c7:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a9ce:	00 00 00 
  800420a9d1:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420a9d8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a9db:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420a9e1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420a9e8:	00 00 00 
  800420a9eb:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420a9f2:	83 ca 80             	or     $0xffffff80,%edx
  800420a9f5:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420a9fb:	48 b8 b2 c1 20 04 80 	movabs $0x800420c1b2,%rax
  800420aa02:	00 00 00 
  800420aa05:	48 c1 e8 10          	shr    $0x10,%rax
  800420aa09:	89 c2                	mov    %eax,%edx
  800420aa0b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aa12:	00 00 00 
  800420aa15:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420aa1c:	48 b8 b2 c1 20 04 80 	movabs $0x800420c1b2,%rax
  800420aa23:	00 00 00 
  800420aa26:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa2a:	89 c2                	mov    %eax,%edx
  800420aa2c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aa33:	00 00 00 
  800420aa36:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420aa3c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aa43:	00 00 00 
  800420aa46:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420aa4d:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, IRQ12_HANDLER, 0);
  800420aa50:	48 b8 b8 c1 20 04 80 	movabs $0x800420c1b8,%rax
  800420aa57:	00 00 00 
  800420aa5a:	89 c2                	mov    %eax,%edx
  800420aa5c:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aa63:	00 00 00 
  800420aa66:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420aa6d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aa74:	00 00 00 
  800420aa77:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420aa7e:	08 00 
  800420aa80:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aa87:	00 00 00 
  800420aa8a:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420aa91:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aa94:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420aa9a:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aaa1:	00 00 00 
  800420aaa4:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420aaab:	83 e2 07             	and    $0x7,%edx
  800420aaae:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420aab4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aabb:	00 00 00 
  800420aabe:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420aac5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aac8:	83 ca 0e             	or     $0xe,%edx
  800420aacb:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420aad1:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aad8:	00 00 00 
  800420aadb:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420aae2:	83 e2 ef             	and    $0xffffffef,%edx
  800420aae5:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420aaeb:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aaf2:	00 00 00 
  800420aaf5:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420aafc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aaff:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420ab05:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ab0c:	00 00 00 
  800420ab0f:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420ab16:	83 ca 80             	or     $0xffffff80,%edx
  800420ab19:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420ab1f:	48 b8 b8 c1 20 04 80 	movabs $0x800420c1b8,%rax
  800420ab26:	00 00 00 
  800420ab29:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab2d:	89 c2                	mov    %eax,%edx
  800420ab2f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ab36:	00 00 00 
  800420ab39:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420ab40:	48 b8 b8 c1 20 04 80 	movabs $0x800420c1b8,%rax
  800420ab47:	00 00 00 
  800420ab4a:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab4e:	89 c2                	mov    %eax,%edx
  800420ab50:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ab57:	00 00 00 
  800420ab5a:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420ab60:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ab67:	00 00 00 
  800420ab6a:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420ab71:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, IRQ13_HANDLER, 0);
  800420ab74:	48 b8 be c1 20 04 80 	movabs $0x800420c1be,%rax
  800420ab7b:	00 00 00 
  800420ab7e:	89 c2                	mov    %eax,%edx
  800420ab80:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ab87:	00 00 00 
  800420ab8a:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420ab91:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ab98:	00 00 00 
  800420ab9b:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420aba2:	08 00 
  800420aba4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420abab:	00 00 00 
  800420abae:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420abb5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420abb8:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420abbe:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420abc5:	00 00 00 
  800420abc8:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420abcf:	83 e2 07             	and    $0x7,%edx
  800420abd2:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420abd8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420abdf:	00 00 00 
  800420abe2:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420abe9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420abec:	83 ca 0e             	or     $0xe,%edx
  800420abef:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420abf5:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420abfc:	00 00 00 
  800420abff:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ac06:	83 e2 ef             	and    $0xffffffef,%edx
  800420ac09:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ac0f:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ac16:	00 00 00 
  800420ac19:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ac20:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ac23:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ac29:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ac30:	00 00 00 
  800420ac33:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ac3a:	83 ca 80             	or     $0xffffff80,%edx
  800420ac3d:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ac43:	48 b8 be c1 20 04 80 	movabs $0x800420c1be,%rax
  800420ac4a:	00 00 00 
  800420ac4d:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac51:	89 c2                	mov    %eax,%edx
  800420ac53:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ac5a:	00 00 00 
  800420ac5d:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420ac64:	48 b8 be c1 20 04 80 	movabs $0x800420c1be,%rax
  800420ac6b:	00 00 00 
  800420ac6e:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac72:	89 c2                	mov    %eax,%edx
  800420ac74:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ac7b:	00 00 00 
  800420ac7e:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420ac84:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ac8b:	00 00 00 
  800420ac8e:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420ac95:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, IRQ14_HANDLER, 0);
  800420ac98:	48 b8 c4 c1 20 04 80 	movabs $0x800420c1c4,%rax
  800420ac9f:	00 00 00 
  800420aca2:	89 c2                	mov    %eax,%edx
  800420aca4:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420acab:	00 00 00 
  800420acae:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420acb5:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420acbc:	00 00 00 
  800420acbf:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420acc6:	08 00 
  800420acc8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420accf:	00 00 00 
  800420acd2:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420acd9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420acdc:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420ace2:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ace9:	00 00 00 
  800420acec:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420acf3:	83 e2 07             	and    $0x7,%edx
  800420acf6:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420acfc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ad03:	00 00 00 
  800420ad06:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ad0d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad10:	83 ca 0e             	or     $0xe,%edx
  800420ad13:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ad19:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ad20:	00 00 00 
  800420ad23:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ad2a:	83 e2 ef             	and    $0xffffffef,%edx
  800420ad2d:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ad33:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ad3a:	00 00 00 
  800420ad3d:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ad44:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ad47:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ad4d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ad54:	00 00 00 
  800420ad57:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ad5e:	83 ca 80             	or     $0xffffff80,%edx
  800420ad61:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ad67:	48 b8 c4 c1 20 04 80 	movabs $0x800420c1c4,%rax
  800420ad6e:	00 00 00 
  800420ad71:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad75:	89 c2                	mov    %eax,%edx
  800420ad77:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ad7e:	00 00 00 
  800420ad81:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420ad88:	48 b8 c4 c1 20 04 80 	movabs $0x800420c1c4,%rax
  800420ad8f:	00 00 00 
  800420ad92:	48 c1 e8 20          	shr    $0x20,%rax
  800420ad96:	89 c2                	mov    %eax,%edx
  800420ad98:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ad9f:	00 00 00 
  800420ada2:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420ada8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420adaf:	00 00 00 
  800420adb2:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420adb9:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, IRQ15_HANDLER, 0);
  800420adbc:	48 b8 ca c1 20 04 80 	movabs $0x800420c1ca,%rax
  800420adc3:	00 00 00 
  800420adc6:	89 c2                	mov    %eax,%edx
  800420adc8:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420adcf:	00 00 00 
  800420add2:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420add9:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ade0:	00 00 00 
  800420ade3:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420adea:	08 00 
  800420adec:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420adf3:	00 00 00 
  800420adf6:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420adfd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ae00:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420ae06:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ae0d:	00 00 00 
  800420ae10:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420ae17:	83 e2 07             	and    $0x7,%edx
  800420ae1a:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420ae20:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ae27:	00 00 00 
  800420ae2a:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420ae31:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ae34:	83 ca 0e             	or     $0xe,%edx
  800420ae37:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420ae3d:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ae44:	00 00 00 
  800420ae47:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420ae4e:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae51:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420ae57:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ae5e:	00 00 00 
  800420ae61:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420ae68:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae6b:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420ae71:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420ae78:	00 00 00 
  800420ae7b:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420ae82:	83 ca 80             	or     $0xffffff80,%edx
  800420ae85:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420ae8b:	48 b8 ca c1 20 04 80 	movabs $0x800420c1ca,%rax
  800420ae92:	00 00 00 
  800420ae95:	48 c1 e8 10          	shr    $0x10,%rax
  800420ae99:	89 c2                	mov    %eax,%edx
  800420ae9b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aea2:	00 00 00 
  800420aea5:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420aeac:	48 b8 ca c1 20 04 80 	movabs $0x800420c1ca,%rax
  800420aeb3:	00 00 00 
  800420aeb6:	48 c1 e8 20          	shr    $0x20,%rax
  800420aeba:	89 c2                	mov    %eax,%edx
  800420aebc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aec3:	00 00 00 
  800420aec6:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420aecc:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aed3:	00 00 00 
  800420aed6:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420aedd:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], 0, GD_KT, IRQ_ERROR_HANDLER, 0);
  800420aee0:	48 b8 d0 c1 20 04 80 	movabs $0x800420c1d0,%rax
  800420aee7:	00 00 00 
  800420aeea:	89 c2                	mov    %eax,%edx
  800420aeec:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aef3:	00 00 00 
  800420aef6:	66 89 90 30 03 00 00 	mov    %dx,0x330(%rax)
  800420aefd:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420af04:	00 00 00 
  800420af07:	66 c7 80 32 03 00 00 	movw   $0x8,0x332(%rax)
  800420af0e:	08 00 
  800420af10:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420af17:	00 00 00 
  800420af1a:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420af21:	83 e2 f8             	and    $0xfffffff8,%edx
  800420af24:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420af2a:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420af31:	00 00 00 
  800420af34:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420af3b:	83 e2 07             	and    $0x7,%edx
  800420af3e:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420af44:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420af4b:	00 00 00 
  800420af4e:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420af55:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af58:	83 ca 0e             	or     $0xe,%edx
  800420af5b:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420af61:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420af68:	00 00 00 
  800420af6b:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420af72:	83 e2 ef             	and    $0xffffffef,%edx
  800420af75:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420af7b:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420af82:	00 00 00 
  800420af85:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420af8c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420af8f:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420af95:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420af9c:	00 00 00 
  800420af9f:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420afa6:	83 ca 80             	or     $0xffffff80,%edx
  800420afa9:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420afaf:	48 b8 d0 c1 20 04 80 	movabs $0x800420c1d0,%rax
  800420afb6:	00 00 00 
  800420afb9:	48 c1 e8 10          	shr    $0x10,%rax
  800420afbd:	89 c2                	mov    %eax,%edx
  800420afbf:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420afc6:	00 00 00 
  800420afc9:	66 89 90 36 03 00 00 	mov    %dx,0x336(%rax)
  800420afd0:	48 b8 d0 c1 20 04 80 	movabs $0x800420c1d0,%rax
  800420afd7:	00 00 00 
  800420afda:	48 c1 e8 20          	shr    $0x20,%rax
  800420afde:	89 c2                	mov    %eax,%edx
  800420afe0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420afe7:	00 00 00 
  800420afea:	89 90 38 03 00 00    	mov    %edx,0x338(%rax)
  800420aff0:	48 b8 80 e2 6b 04 80 	movabs $0x80046be280,%rax
  800420aff7:	00 00 00 
  800420affa:	c7 80 3c 03 00 00 00 	movl   $0x0,0x33c(%rax)
  800420b001:	00 00 00 
	// Per-CPU setup
	trap_init_percpu();
  800420b004:	48 b8 12 b0 20 04 80 	movabs $0x800420b012,%rax
  800420b00b:	00 00 00 
  800420b00e:	ff d0                	callq  *%rax
}
  800420b010:	5d                   	pop    %rbp
  800420b011:	c3                   	retq   

000000800420b012 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420b012:	55                   	push   %rbp
  800420b013:	48 89 e5             	mov    %rsp,%rbp
  800420b016:	48 83 ec 20          	sub    $0x20,%rsp
	// get a triple fault.  If you set up an individual CPU's TSS
	// wrong, you may not get a fault until you try to return from
	// user space on that CPU.
	//
	// LAB 4: Your code here:
	uint8_t id =  thiscpu->cpu_id;
  800420b01a:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b021:	00 00 00 
  800420b024:	ff d0                	callq  *%rax
  800420b026:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420b02d:	00 00 00 
  800420b030:	48 98                	cltq   
  800420b032:	48 c1 e0 03          	shl    $0x3,%rax
  800420b036:	48 89 c2             	mov    %rax,%rdx
  800420b039:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b03d:	48 29 c2             	sub    %rax,%rdx
  800420b040:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b044:	0f b6 00             	movzbl (%rax),%eax
  800420b047:	88 45 ff             	mov    %al,-0x1(%rbp)

	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - id * (KSTKSIZE + KSTKGAP);
  800420b04a:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b051:	00 00 00 
  800420b054:	ff d0                	callq  *%rax
  800420b056:	89 c6                	mov    %eax,%esi
  800420b058:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  800420b05c:	89 d0                	mov    %edx,%eax
  800420b05e:	01 c0                	add    %eax,%eax
  800420b060:	01 d0                	add    %edx,%eax
  800420b062:	c1 e0 0f             	shl    $0xf,%eax
  800420b065:	48 98                	cltq   
  800420b067:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420b06e:	00 00 00 
  800420b071:	48 29 c2             	sub    %rax,%rdx
  800420b074:	48 89 d0             	mov    %rdx,%rax
  800420b077:	48 89 c1             	mov    %rax,%rcx
  800420b07a:	48 bf 20 10 6c 04 80 	movabs $0x80046c1020,%rdi
  800420b081:	00 00 00 
  800420b084:	48 63 c6             	movslq %esi,%rax
  800420b087:	48 c1 e0 03          	shl    $0x3,%rax
  800420b08b:	48 89 c2             	mov    %rax,%rdx
  800420b08e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b092:	48 29 c2             	sub    %rax,%rdx
  800420b095:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
  800420b099:	48 83 c0 10          	add    $0x10,%rax
  800420b09d:	48 89 48 04          	mov    %rcx,0x4(%rax)
	struct Segdesc *seg = &gdt[(GD_TSS0 >> 3) + 2*id];
  800420b0a1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  800420b0a5:	01 c0                	add    %eax,%eax
  800420b0a7:	83 c0 05             	add    $0x5,%eax
  800420b0aa:	48 98                	cltq   
  800420b0ac:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b0b3:	00 
  800420b0b4:	48 b8 c0 b5 22 04 80 	movabs $0x800422b5c0,%rax
  800420b0bb:	00 00 00 
  800420b0be:	48 01 d0             	add    %rdx,%rax
  800420b0c1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	SETTSS((struct SystemSegdesc64 *)seg, STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420b0c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b0c9:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420b0ce:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b0d5:	00 00 00 
  800420b0d8:	ff d0                	callq  *%rax
  800420b0da:	48 98                	cltq   
  800420b0dc:	48 c1 e0 03          	shl    $0x3,%rax
  800420b0e0:	48 89 c2             	mov    %rax,%rdx
  800420b0e3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b0e7:	48 29 c2             	sub    %rax,%rdx
  800420b0ea:	48 83 c2 10          	add    $0x10,%rdx
  800420b0ee:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  800420b0f5:	00 00 00 
  800420b0f8:	48 01 d0             	add    %rdx,%rax
  800420b0fb:	89 c2                	mov    %eax,%edx
  800420b0fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b101:	66 89 50 02          	mov    %dx,0x2(%rax)
  800420b105:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b10c:	00 00 00 
  800420b10f:	ff d0                	callq  *%rax
  800420b111:	48 98                	cltq   
  800420b113:	48 c1 e0 03          	shl    $0x3,%rax
  800420b117:	48 89 c2             	mov    %rax,%rdx
  800420b11a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b11e:	48 29 c2             	sub    %rax,%rdx
  800420b121:	48 83 c2 10          	add    $0x10,%rdx
  800420b125:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  800420b12c:	00 00 00 
  800420b12f:	48 01 d0             	add    %rdx,%rax
  800420b132:	48 c1 e8 10          	shr    $0x10,%rax
  800420b136:	89 c2                	mov    %eax,%edx
  800420b138:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b13c:	88 50 04             	mov    %dl,0x4(%rax)
  800420b13f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b143:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b147:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b14a:	83 ca 09             	or     $0x9,%edx
  800420b14d:	88 50 05             	mov    %dl,0x5(%rax)
  800420b150:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b154:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b158:	83 e2 ef             	and    $0xffffffef,%edx
  800420b15b:	88 50 05             	mov    %dl,0x5(%rax)
  800420b15e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b162:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b166:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b169:	88 50 05             	mov    %dl,0x5(%rax)
  800420b16c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b170:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b174:	83 ca 80             	or     $0xffffff80,%edx
  800420b177:	88 50 05             	mov    %dl,0x5(%rax)
  800420b17a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b17e:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b182:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b185:	88 50 06             	mov    %dl,0x6(%rax)
  800420b188:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b18c:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b190:	83 e2 ef             	and    $0xffffffef,%edx
  800420b193:	88 50 06             	mov    %dl,0x6(%rax)
  800420b196:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b19a:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b19e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b1a1:	88 50 06             	mov    %dl,0x6(%rax)
  800420b1a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b1a8:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b1ac:	83 e2 7f             	and    $0x7f,%edx
  800420b1af:	88 50 06             	mov    %dl,0x6(%rax)
  800420b1b2:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b1b9:	00 00 00 
  800420b1bc:	ff d0                	callq  *%rax
  800420b1be:	48 98                	cltq   
  800420b1c0:	48 c1 e0 03          	shl    $0x3,%rax
  800420b1c4:	48 89 c2             	mov    %rax,%rdx
  800420b1c7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b1cb:	48 29 c2             	sub    %rax,%rdx
  800420b1ce:	48 83 c2 10          	add    $0x10,%rdx
  800420b1d2:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  800420b1d9:	00 00 00 
  800420b1dc:	48 01 d0             	add    %rdx,%rax
  800420b1df:	48 c1 e8 18          	shr    $0x18,%rax
  800420b1e3:	89 c2                	mov    %eax,%edx
  800420b1e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b1e9:	88 50 07             	mov    %dl,0x7(%rax)
  800420b1ec:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b1f3:	00 00 00 
  800420b1f6:	ff d0                	callq  *%rax
  800420b1f8:	48 98                	cltq   
  800420b1fa:	48 c1 e0 03          	shl    $0x3,%rax
  800420b1fe:	48 89 c2             	mov    %rax,%rdx
  800420b201:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b205:	48 29 c2             	sub    %rax,%rdx
  800420b208:	48 83 c2 10          	add    $0x10,%rdx
  800420b20c:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  800420b213:	00 00 00 
  800420b216:	48 01 d0             	add    %rdx,%rax
  800420b219:	48 c1 e8 20          	shr    $0x20,%rax
  800420b21d:	89 c2                	mov    %eax,%edx
  800420b21f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b223:	89 50 08             	mov    %edx,0x8(%rax)
  800420b226:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b22a:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420b22e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b232:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420b236:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b23a:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
	ltr(GD_TSS0 + 2 * (id << 3));
  800420b240:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  800420b244:	c1 e0 03             	shl    $0x3,%eax
  800420b247:	83 c0 14             	add    $0x14,%eax
  800420b24a:	01 c0                	add    %eax,%eax
  800420b24c:	0f b7 c0             	movzwl %ax,%eax
  800420b24f:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420b253:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420b257:	0f 00 d8             	ltr    %ax
  800420b25a:	48 b8 80 f2 6b 04 80 	movabs $0x80046bf280,%rax
  800420b261:	00 00 00 
  800420b264:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420b268:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b26c:	0f 01 18             	lidt   (%rax)
	// bottom three bits are special; we leave them 0)
	//ltr(GD_TSS0);

	// Load the IDT
	lidt(&idt_pd);
}
  800420b26f:	c9                   	leaveq 
  800420b270:	c3                   	retq   

000000800420b271 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420b271:	55                   	push   %rbp
  800420b272:	48 89 e5             	mov    %rsp,%rbp
  800420b275:	48 83 ec 20          	sub    $0x20,%rsp
  800420b279:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420b27d:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b284:	00 00 00 
  800420b287:	ff d0                	callq  *%rax
  800420b289:	89 c2                	mov    %eax,%edx
  800420b28b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b28f:	48 89 c6             	mov    %rax,%rsi
  800420b292:	48 bf ce 75 21 04 80 	movabs $0x80042175ce,%rdi
  800420b299:	00 00 00 
  800420b29c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b2a1:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  800420b2a8:	00 00 00 
  800420b2ab:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420b2ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2b1:	48 89 c7             	mov    %rax,%rdi
  800420b2b4:	48 b8 82 b5 20 04 80 	movabs $0x800420b582,%rax
  800420b2bb:	00 00 00 
  800420b2be:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420b2c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2c4:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420b2c8:	0f b7 c0             	movzwl %ax,%eax
  800420b2cb:	89 c6                	mov    %eax,%esi
  800420b2cd:	48 bf ec 75 21 04 80 	movabs $0x80042175ec,%rdi
  800420b2d4:	00 00 00 
  800420b2d7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b2dc:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b2e3:	00 00 00 
  800420b2e6:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420b2e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2ec:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420b2f3:	0f b7 c0             	movzwl %ax,%eax
  800420b2f6:	89 c6                	mov    %eax,%esi
  800420b2f8:	48 bf ff 75 21 04 80 	movabs $0x80042175ff,%rdi
  800420b2ff:	00 00 00 
  800420b302:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b307:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b30e:	00 00 00 
  800420b311:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420b313:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b317:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b31e:	89 c7                	mov    %eax,%edi
  800420b320:	48 b8 03 88 20 04 80 	movabs $0x8004208803,%rax
  800420b327:	00 00 00 
  800420b32a:	ff d0                	callq  *%rax
  800420b32c:	48 89 c2             	mov    %rax,%rdx
  800420b32f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b333:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b33a:	48 89 c6             	mov    %rax,%rsi
  800420b33d:	48 bf 12 76 21 04 80 	movabs $0x8004217612,%rdi
  800420b344:	00 00 00 
  800420b347:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b34c:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  800420b353:	00 00 00 
  800420b356:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420b358:	48 b8 90 f2 6b 04 80 	movabs $0x80046bf290,%rax
  800420b35f:	00 00 00 
  800420b362:	48 8b 00             	mov    (%rax),%rax
  800420b365:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420b369:	75 3a                	jne    800420b3a5 <print_trapframe+0x134>
  800420b36b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b36f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b376:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b37a:	75 29                	jne    800420b3a5 <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420b37c:	0f 20 d0             	mov    %cr2,%rax
  800420b37f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420b383:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420b387:	48 89 c6             	mov    %rax,%rsi
  800420b38a:	48 bf 24 76 21 04 80 	movabs $0x8004217624,%rdi
  800420b391:	00 00 00 
  800420b394:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b399:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b3a0:	00 00 00 
  800420b3a3:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420b3a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b3a9:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b3b0:	48 89 c6             	mov    %rax,%rsi
  800420b3b3:	48 bf 33 76 21 04 80 	movabs $0x8004217633,%rdi
  800420b3ba:	00 00 00 
  800420b3bd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b3c2:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b3c9:	00 00 00 
  800420b3cc:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420b3ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b3d2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b3d9:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b3dd:	0f 85 9c 00 00 00    	jne    800420b47f <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420b3e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b3e7:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b3ee:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b3f1:	48 85 c0             	test   %rax,%rax
  800420b3f4:	74 0c                	je     800420b402 <print_trapframe+0x191>
  800420b3f6:	48 b9 41 76 21 04 80 	movabs $0x8004217641,%rcx
  800420b3fd:	00 00 00 
  800420b400:	eb 0a                	jmp    800420b40c <print_trapframe+0x19b>
  800420b402:	48 b9 4c 76 21 04 80 	movabs $0x800421764c,%rcx
  800420b409:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420b40c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b410:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b417:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b41a:	48 85 c0             	test   %rax,%rax
  800420b41d:	74 0c                	je     800420b42b <print_trapframe+0x1ba>
  800420b41f:	48 ba 58 76 21 04 80 	movabs $0x8004217658,%rdx
  800420b426:	00 00 00 
  800420b429:	eb 0a                	jmp    800420b435 <print_trapframe+0x1c4>
  800420b42b:	48 ba 5e 76 21 04 80 	movabs $0x800421765e,%rdx
  800420b432:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420b435:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b439:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b440:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b443:	48 85 c0             	test   %rax,%rax
  800420b446:	74 0c                	je     800420b454 <print_trapframe+0x1e3>
  800420b448:	48 b8 63 76 21 04 80 	movabs $0x8004217663,%rax
  800420b44f:	00 00 00 
  800420b452:	eb 0a                	jmp    800420b45e <print_trapframe+0x1ed>
  800420b454:	48 b8 68 76 21 04 80 	movabs $0x8004217668,%rax
  800420b45b:	00 00 00 
  800420b45e:	48 89 c6             	mov    %rax,%rsi
  800420b461:	48 bf 6f 76 21 04 80 	movabs $0x800421766f,%rdi
  800420b468:	00 00 00 
  800420b46b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b470:	49 b8 ea 86 20 04 80 	movabs $0x80042086ea,%r8
  800420b477:	00 00 00 
  800420b47a:	41 ff d0             	callq  *%r8
  800420b47d:	eb 1b                	jmp    800420b49a <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420b47f:	48 bf 7e 76 21 04 80 	movabs $0x800421767e,%rdi
  800420b486:	00 00 00 
  800420b489:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b48e:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b495:	00 00 00 
  800420b498:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420b49a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b49e:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420b4a5:	48 89 c6             	mov    %rax,%rsi
  800420b4a8:	48 bf 80 76 21 04 80 	movabs $0x8004217680,%rdi
  800420b4af:	00 00 00 
  800420b4b2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b4b7:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b4be:	00 00 00 
  800420b4c1:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420b4c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b4c7:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b4ce:	0f b7 c0             	movzwl %ax,%eax
  800420b4d1:	89 c6                	mov    %eax,%esi
  800420b4d3:	48 bf 8f 76 21 04 80 	movabs $0x800421768f,%rdi
  800420b4da:	00 00 00 
  800420b4dd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b4e2:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b4e9:	00 00 00 
  800420b4ec:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420b4ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b4f2:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420b4f9:	48 89 c6             	mov    %rax,%rsi
  800420b4fc:	48 bf a2 76 21 04 80 	movabs $0x80042176a2,%rdi
  800420b503:	00 00 00 
  800420b506:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b50b:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b512:	00 00 00 
  800420b515:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420b517:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b51b:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b522:	0f b7 c0             	movzwl %ax,%eax
  800420b525:	83 e0 03             	and    $0x3,%eax
  800420b528:	85 c0                	test   %eax,%eax
  800420b52a:	74 54                	je     800420b580 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420b52c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b530:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420b537:	48 89 c6             	mov    %rax,%rsi
  800420b53a:	48 bf b1 76 21 04 80 	movabs $0x80042176b1,%rdi
  800420b541:	00 00 00 
  800420b544:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b549:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b550:	00 00 00 
  800420b553:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420b555:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b559:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420b560:	0f b7 c0             	movzwl %ax,%eax
  800420b563:	89 c6                	mov    %eax,%esi
  800420b565:	48 bf c0 76 21 04 80 	movabs $0x80042176c0,%rdi
  800420b56c:	00 00 00 
  800420b56f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b574:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b57b:	00 00 00 
  800420b57e:	ff d2                	callq  *%rdx
	}
}
  800420b580:	c9                   	leaveq 
  800420b581:	c3                   	retq   

000000800420b582 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420b582:	55                   	push   %rbp
  800420b583:	48 89 e5             	mov    %rsp,%rbp
  800420b586:	48 83 ec 10          	sub    $0x10,%rsp
  800420b58a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420b58e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b592:	48 8b 00             	mov    (%rax),%rax
  800420b595:	48 89 c6             	mov    %rax,%rsi
  800420b598:	48 bf d3 76 21 04 80 	movabs $0x80042176d3,%rdi
  800420b59f:	00 00 00 
  800420b5a2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b5a7:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b5ae:	00 00 00 
  800420b5b1:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420b5b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b5b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b5bb:	48 89 c6             	mov    %rax,%rsi
  800420b5be:	48 bf e2 76 21 04 80 	movabs $0x80042176e2,%rdi
  800420b5c5:	00 00 00 
  800420b5c8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b5cd:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b5d4:	00 00 00 
  800420b5d7:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420b5d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b5dd:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420b5e1:	48 89 c6             	mov    %rax,%rsi
  800420b5e4:	48 bf f1 76 21 04 80 	movabs $0x80042176f1,%rdi
  800420b5eb:	00 00 00 
  800420b5ee:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b5f3:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b5fa:	00 00 00 
  800420b5fd:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420b5ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b603:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420b607:	48 89 c6             	mov    %rax,%rsi
  800420b60a:	48 bf 00 77 21 04 80 	movabs $0x8004217700,%rdi
  800420b611:	00 00 00 
  800420b614:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b619:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b620:	00 00 00 
  800420b623:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420b625:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b629:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420b62d:	48 89 c6             	mov    %rax,%rsi
  800420b630:	48 bf 0f 77 21 04 80 	movabs $0x800421770f,%rdi
  800420b637:	00 00 00 
  800420b63a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b63f:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b646:	00 00 00 
  800420b649:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420b64b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b64f:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420b653:	48 89 c6             	mov    %rax,%rsi
  800420b656:	48 bf 1e 77 21 04 80 	movabs $0x800421771e,%rdi
  800420b65d:	00 00 00 
  800420b660:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b665:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b66c:	00 00 00 
  800420b66f:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420b671:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b675:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420b679:	48 89 c6             	mov    %rax,%rsi
  800420b67c:	48 bf 2d 77 21 04 80 	movabs $0x800421772d,%rdi
  800420b683:	00 00 00 
  800420b686:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b68b:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b692:	00 00 00 
  800420b695:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420b697:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b69b:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420b69f:	48 89 c6             	mov    %rax,%rsi
  800420b6a2:	48 bf 3b 77 21 04 80 	movabs $0x800421773b,%rdi
  800420b6a9:	00 00 00 
  800420b6ac:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6b1:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b6b8:	00 00 00 
  800420b6bb:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420b6bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b6c1:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420b6c5:	48 89 c6             	mov    %rax,%rsi
  800420b6c8:	48 bf 49 77 21 04 80 	movabs $0x8004217749,%rdi
  800420b6cf:	00 00 00 
  800420b6d2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6d7:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b6de:	00 00 00 
  800420b6e1:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420b6e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b6e7:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420b6eb:	48 89 c6             	mov    %rax,%rsi
  800420b6ee:	48 bf 58 77 21 04 80 	movabs $0x8004217758,%rdi
  800420b6f5:	00 00 00 
  800420b6f8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6fd:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b704:	00 00 00 
  800420b707:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420b709:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b70d:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420b711:	48 89 c6             	mov    %rax,%rsi
  800420b714:	48 bf 67 77 21 04 80 	movabs $0x8004217767,%rdi
  800420b71b:	00 00 00 
  800420b71e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b723:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b72a:	00 00 00 
  800420b72d:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420b72f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b733:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420b737:	48 89 c6             	mov    %rax,%rsi
  800420b73a:	48 bf 76 77 21 04 80 	movabs $0x8004217776,%rdi
  800420b741:	00 00 00 
  800420b744:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b749:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b750:	00 00 00 
  800420b753:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420b755:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b759:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420b75d:	48 89 c6             	mov    %rax,%rsi
  800420b760:	48 bf 85 77 21 04 80 	movabs $0x8004217785,%rdi
  800420b767:	00 00 00 
  800420b76a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b76f:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b776:	00 00 00 
  800420b779:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420b77b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b77f:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420b783:	48 89 c6             	mov    %rax,%rsi
  800420b786:	48 bf 94 77 21 04 80 	movabs $0x8004217794,%rdi
  800420b78d:	00 00 00 
  800420b790:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b795:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b79c:	00 00 00 
  800420b79f:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420b7a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b7a5:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b7a9:	48 89 c6             	mov    %rax,%rsi
  800420b7ac:	48 bf a3 77 21 04 80 	movabs $0x80042177a3,%rdi
  800420b7b3:	00 00 00 
  800420b7b6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b7bb:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b7c2:	00 00 00 
  800420b7c5:	ff d2                	callq  *%rdx
}
  800420b7c7:	c9                   	leaveq 
  800420b7c8:	c3                   	retq   

000000800420b7c9 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420b7c9:	55                   	push   %rbp
  800420b7ca:	48 89 e5             	mov    %rsp,%rbp
  800420b7cd:	48 83 ec 10          	sub    $0x10,%rsp
  800420b7d1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.


	if (tf->tf_trapno == T_PGFLT) {
  800420b7d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b7d9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b7e0:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b7e4:	75 18                	jne    800420b7fe <trap_dispatch+0x35>
		page_fault_handler(tf);
  800420b7e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b7ea:	48 89 c7             	mov    %rax,%rdi
  800420b7ed:	48 b8 f5 bc 20 04 80 	movabs $0x800420bcf5,%rax
  800420b7f4:	00 00 00 
  800420b7f7:	ff d0                	callq  *%rax
		return;
  800420b7f9:	e9 8b 01 00 00       	jmpq   800420b989 <trap_dispatch+0x1c0>
	}

	if (tf->tf_trapno == T_BRKPT) {
  800420b7fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b802:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b809:	48 83 f8 03          	cmp    $0x3,%rax
  800420b80d:	75 18                	jne    800420b827 <trap_dispatch+0x5e>
		monitor(tf);
  800420b80f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b813:	48 89 c7             	mov    %rax,%rdi
  800420b816:	48 b8 7a 16 20 04 80 	movabs $0x800420167a,%rax
  800420b81d:	00 00 00 
  800420b820:	ff d0                	callq  *%rax
		return;
  800420b822:	e9 62 01 00 00       	jmpq   800420b989 <trap_dispatch+0x1c0>
	}

	if (tf->tf_trapno == T_SYSCALL) {
  800420b827:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b82b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b832:	48 83 f8 30          	cmp    $0x30,%rax
  800420b836:	75 55                	jne    800420b88d <trap_dispatch+0xc4>
		tf->tf_regs.reg_rax = syscall(
  800420b838:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b83c:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420b840:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b844:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420b848:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b84c:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420b850:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b854:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420b858:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b85c:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420b860:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b864:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b868:	4d 89 c1             	mov    %r8,%r9
  800420b86b:	49 89 f8             	mov    %rdi,%r8
  800420b86e:	48 89 c7             	mov    %rax,%rdi
  800420b871:	48 b8 73 cf 20 04 80 	movabs $0x800420cf73,%rax
  800420b878:	00 00 00 
  800420b87b:	ff d0                	callq  *%rax
  800420b87d:	48 89 c2             	mov    %rax,%rdx
  800420b880:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b884:	48 89 50 70          	mov    %rdx,0x70(%rax)
			tf->tf_regs.reg_rcx,
			tf->tf_regs.reg_rbx,
			tf->tf_regs.reg_rdi,
			tf->tf_regs.reg_rsi
			);
		return;
  800420b888:	e9 fc 00 00 00       	jmpq   800420b989 <trap_dispatch+0x1c0>
	}
	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420b88d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b891:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b898:	48 83 f8 27          	cmp    $0x27,%rax
  800420b89c:	75 33                	jne    800420b8d1 <trap_dispatch+0x108>
		cprintf("Spurious interrupt on irq 7\n");
  800420b89e:	48 bf b2 77 21 04 80 	movabs $0x80042177b2,%rdi
  800420b8a5:	00 00 00 
  800420b8a8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b8ad:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420b8b4:	00 00 00 
  800420b8b7:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420b8b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8bd:	48 89 c7             	mov    %rax,%rdi
  800420b8c0:	48 b8 71 b2 20 04 80 	movabs $0x800420b271,%rax
  800420b8c7:	00 00 00 
  800420b8ca:	ff d0                	callq  *%rax
		return;
  800420b8cc:	e9 b8 00 00 00       	jmpq   800420b989 <trap_dispatch+0x1c0>
	}

	// Handle clock interrupts. Don't forget to acknowledge the
	// interrupt using lapic_eoi() before calling the scheduler!
	// LAB 4: Your code here.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
  800420b8d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8d5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b8dc:	48 83 f8 20          	cmp    $0x20,%rax
  800420b8e0:	75 18                	jne    800420b8fa <trap_dispatch+0x131>
    lapic_eoi();
  800420b8e2:	48 b8 1e 5c 21 04 80 	movabs $0x8004215c1e,%rax
  800420b8e9:	00 00 00 
  800420b8ec:	ff d0                	callq  *%rax
    sched_yield();
  800420b8ee:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  800420b8f5:	00 00 00 
  800420b8f8:	ff d0                	callq  *%rax

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.

	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420b8fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8fe:	48 89 c7             	mov    %rax,%rdi
  800420b901:	48 b8 71 b2 20 04 80 	movabs $0x800420b271,%rax
  800420b908:	00 00 00 
  800420b90b:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420b90d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b911:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b918:	66 83 f8 08          	cmp    $0x8,%ax
  800420b91c:	75 2a                	jne    800420b948 <trap_dispatch+0x17f>
		panic("unhandled trap in kernel");
  800420b91e:	48 ba cf 77 21 04 80 	movabs $0x80042177cf,%rdx
  800420b925:	00 00 00 
  800420b928:	be 3d 01 00 00       	mov    $0x13d,%esi
  800420b92d:	48 bf e8 77 21 04 80 	movabs $0x80042177e8,%rdi
  800420b934:	00 00 00 
  800420b937:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b93c:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420b943:	00 00 00 
  800420b946:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420b948:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b94f:	00 00 00 
  800420b952:	ff d0                	callq  *%rax
  800420b954:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420b95b:	00 00 00 
  800420b95e:	48 98                	cltq   
  800420b960:	48 c1 e0 03          	shl    $0x3,%rax
  800420b964:	48 89 c2             	mov    %rax,%rdx
  800420b967:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b96b:	48 29 c2             	sub    %rax,%rdx
  800420b96e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b972:	48 83 c0 08          	add    $0x8,%rax
  800420b976:	48 8b 00             	mov    (%rax),%rax
  800420b979:	48 89 c7             	mov    %rax,%rdi
  800420b97c:	48 b8 d7 7f 20 04 80 	movabs $0x8004207fd7,%rax
  800420b983:	00 00 00 
  800420b986:	ff d0                	callq  *%rax
		return;
  800420b988:	90                   	nop
	}
}
  800420b989:	c9                   	leaveq 
  800420b98a:	c3                   	retq   

000000800420b98b <trap>:

void
trap(struct Trapframe *tf)
{
  800420b98b:	55                   	push   %rbp
  800420b98c:	48 89 e5             	mov    %rsp,%rbp
  800420b98f:	48 83 ec 20          	sub    $0x20,%rsp
  800420b993:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420b997:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420b998:	48 b8 10 f7 6b 04 80 	movabs $0x80046bf710,%rax
  800420b99f:	00 00 00 
  800420b9a2:	48 8b 00             	mov    (%rax),%rax
  800420b9a5:	48 85 c0             	test   %rax,%rax
  800420b9a8:	74 01                	je     800420b9ab <trap+0x20>
		asm volatile("hlt");
  800420b9aa:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420b9ab:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420b9b2:	00 00 00 
  800420b9b5:	ff d0                	callq  *%rax
  800420b9b7:	48 98                	cltq   
  800420b9b9:	48 c1 e0 03          	shl    $0x3,%rax
  800420b9bd:	48 89 c2             	mov    %rax,%rdx
  800420b9c0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b9c4:	48 29 c2             	sub    %rax,%rdx
  800420b9c7:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  800420b9ce:	00 00 00 
  800420b9d1:	48 01 d0             	add    %rdx,%rax
  800420b9d4:	48 83 c0 04          	add    $0x4,%rax
  800420b9d8:	be 01 00 00 00       	mov    $0x1,%esi
  800420b9dd:	48 89 c7             	mov    %rax,%rdi
  800420b9e0:	48 b8 c2 87 20 04 80 	movabs $0x80042087c2,%rax
  800420b9e7:	00 00 00 
  800420b9ea:	ff d0                	callq  *%rax
  800420b9ec:	83 f8 02             	cmp    $0x2,%eax
  800420b9ef:	75 0c                	jne    800420b9fd <trap+0x72>
		lock_kernel();
  800420b9f1:	48 b8 e7 87 20 04 80 	movabs $0x80042087e7,%rax
  800420b9f8:	00 00 00 
  800420b9fb:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420b9fd:	9c                   	pushfq 
  800420b9fe:	58                   	pop    %rax
  800420b9ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420ba03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420ba07:	25 00 02 00 00       	and    $0x200,%eax
  800420ba0c:	48 85 c0             	test   %rax,%rax
  800420ba0f:	74 35                	je     800420ba46 <trap+0xbb>
  800420ba11:	48 b9 f4 77 21 04 80 	movabs $0x80042177f4,%rcx
  800420ba18:	00 00 00 
  800420ba1b:	48 ba 0d 78 21 04 80 	movabs $0x800421780d,%rdx
  800420ba22:	00 00 00 
  800420ba25:	be 58 01 00 00       	mov    $0x158,%esi
  800420ba2a:	48 bf e8 77 21 04 80 	movabs $0x80042177e8,%rdi
  800420ba31:	00 00 00 
  800420ba34:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ba39:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420ba40:	00 00 00 
  800420ba43:	41 ff d0             	callq  *%r8

	//cprintf("Incoming TRAP frame at %p\n", tf);
	if ((tf->tf_cs & 3) == 3) {
  800420ba46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ba4a:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420ba51:	0f b7 c0             	movzwl %ax,%eax
  800420ba54:	83 e0 03             	and    $0x3,%eax
  800420ba57:	83 f8 03             	cmp    $0x3,%eax
  800420ba5a:	0f 85 b3 01 00 00    	jne    800420bc13 <trap+0x288>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420ba60:	48 b8 e7 87 20 04 80 	movabs $0x80042087e7,%rax
  800420ba67:	00 00 00 
  800420ba6a:	ff d0                	callq  *%rax
		assert(curenv);
  800420ba6c:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420ba73:	00 00 00 
  800420ba76:	ff d0                	callq  *%rax
  800420ba78:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420ba7f:	00 00 00 
  800420ba82:	48 98                	cltq   
  800420ba84:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba88:	48 89 c2             	mov    %rax,%rdx
  800420ba8b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba8f:	48 29 c2             	sub    %rax,%rdx
  800420ba92:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ba96:	48 83 c0 08          	add    $0x8,%rax
  800420ba9a:	48 8b 00             	mov    (%rax),%rax
  800420ba9d:	48 85 c0             	test   %rax,%rax
  800420baa0:	75 35                	jne    800420bad7 <trap+0x14c>
  800420baa2:	48 b9 22 78 21 04 80 	movabs $0x8004217822,%rcx
  800420baa9:	00 00 00 
  800420baac:	48 ba 0d 78 21 04 80 	movabs $0x800421780d,%rdx
  800420bab3:	00 00 00 
  800420bab6:	be 61 01 00 00       	mov    $0x161,%esi
  800420babb:	48 bf e8 77 21 04 80 	movabs $0x80042177e8,%rdi
  800420bac2:	00 00 00 
  800420bac5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420baca:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420bad1:	00 00 00 
  800420bad4:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420bad7:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bade:	00 00 00 
  800420bae1:	ff d0                	callq  *%rax
  800420bae3:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420baea:	00 00 00 
  800420baed:	48 98                	cltq   
  800420baef:	48 c1 e0 03          	shl    $0x3,%rax
  800420baf3:	48 89 c2             	mov    %rax,%rdx
  800420baf6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bafa:	48 29 c2             	sub    %rax,%rdx
  800420bafd:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb01:	48 83 c0 08          	add    $0x8,%rax
  800420bb05:	48 8b 00             	mov    (%rax),%rax
  800420bb08:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bb0e:	83 f8 01             	cmp    $0x1,%eax
  800420bb11:	0f 85 81 00 00 00    	jne    800420bb98 <trap+0x20d>
			env_free(curenv);
  800420bb17:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bb1e:	00 00 00 
  800420bb21:	ff d0                	callq  *%rax
  800420bb23:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bb2a:	00 00 00 
  800420bb2d:	48 98                	cltq   
  800420bb2f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb33:	48 89 c2             	mov    %rax,%rdx
  800420bb36:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb3a:	48 29 c2             	sub    %rax,%rdx
  800420bb3d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb41:	48 83 c0 08          	add    $0x8,%rax
  800420bb45:	48 8b 00             	mov    (%rax),%rax
  800420bb48:	48 89 c7             	mov    %rax,%rdi
  800420bb4b:	48 b8 2d 7b 20 04 80 	movabs $0x8004207b2d,%rax
  800420bb52:	00 00 00 
  800420bb55:	ff d0                	callq  *%rax
			curenv = NULL;
  800420bb57:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bb5e:	00 00 00 
  800420bb61:	ff d0                	callq  *%rax
  800420bb63:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bb6a:	00 00 00 
  800420bb6d:	48 98                	cltq   
  800420bb6f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb73:	48 89 c2             	mov    %rax,%rdx
  800420bb76:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb7a:	48 29 c2             	sub    %rax,%rdx
  800420bb7d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb81:	48 83 c0 08          	add    $0x8,%rax
  800420bb85:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420bb8c:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  800420bb93:	00 00 00 
  800420bb96:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420bb98:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bb9f:	00 00 00 
  800420bba2:	ff d0                	callq  *%rax
  800420bba4:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bbab:	00 00 00 
  800420bbae:	48 98                	cltq   
  800420bbb0:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbb4:	48 89 c2             	mov    %rax,%rdx
  800420bbb7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bbbb:	48 29 c2             	sub    %rax,%rdx
  800420bbbe:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bbc2:	48 83 c0 08          	add    $0x8,%rax
  800420bbc6:	48 8b 10             	mov    (%rax),%rdx
  800420bbc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bbcd:	48 89 c6             	mov    %rax,%rsi
  800420bbd0:	b8 18 00 00 00       	mov    $0x18,%eax
  800420bbd5:	48 89 d7             	mov    %rdx,%rdi
  800420bbd8:	48 89 c1             	mov    %rax,%rcx
  800420bbdb:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420bbde:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bbe5:	00 00 00 
  800420bbe8:	ff d0                	callq  *%rax
  800420bbea:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bbf1:	00 00 00 
  800420bbf4:	48 98                	cltq   
  800420bbf6:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbfa:	48 89 c2             	mov    %rax,%rdx
  800420bbfd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc01:	48 29 c2             	sub    %rax,%rdx
  800420bc04:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc08:	48 83 c0 08          	add    $0x8,%rax
  800420bc0c:	48 8b 00             	mov    (%rax),%rax
  800420bc0f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420bc13:	48 b8 90 f2 6b 04 80 	movabs $0x80046bf290,%rax
  800420bc1a:	00 00 00 
  800420bc1d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bc21:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420bc24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bc28:	48 89 c7             	mov    %rax,%rdi
  800420bc2b:	48 b8 c9 b7 20 04 80 	movabs $0x800420b7c9,%rax
  800420bc32:	00 00 00 
  800420bc35:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420bc37:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bc3e:	00 00 00 
  800420bc41:	ff d0                	callq  *%rax
  800420bc43:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bc4a:	00 00 00 
  800420bc4d:	48 98                	cltq   
  800420bc4f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc53:	48 89 c2             	mov    %rax,%rdx
  800420bc56:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc5a:	48 29 c2             	sub    %rax,%rdx
  800420bc5d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc61:	48 83 c0 08          	add    $0x8,%rax
  800420bc65:	48 8b 00             	mov    (%rax),%rax
  800420bc68:	48 85 c0             	test   %rax,%rax
  800420bc6b:	74 7c                	je     800420bce9 <trap+0x35e>
  800420bc6d:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bc74:	00 00 00 
  800420bc77:	ff d0                	callq  *%rax
  800420bc79:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bc80:	00 00 00 
  800420bc83:	48 98                	cltq   
  800420bc85:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc89:	48 89 c2             	mov    %rax,%rdx
  800420bc8c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc90:	48 29 c2             	sub    %rax,%rdx
  800420bc93:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc97:	48 83 c0 08          	add    $0x8,%rax
  800420bc9b:	48 8b 00             	mov    (%rax),%rax
  800420bc9e:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bca4:	83 f8 03             	cmp    $0x3,%eax
  800420bca7:	75 40                	jne    800420bce9 <trap+0x35e>
		env_run(curenv);
  800420bca9:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bcb0:	00 00 00 
  800420bcb3:	ff d0                	callq  *%rax
  800420bcb5:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bcbc:	00 00 00 
  800420bcbf:	48 98                	cltq   
  800420bcc1:	48 c1 e0 03          	shl    $0x3,%rax
  800420bcc5:	48 89 c2             	mov    %rax,%rdx
  800420bcc8:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bccc:	48 29 c2             	sub    %rax,%rdx
  800420bccf:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bcd3:	48 83 c0 08          	add    $0x8,%rax
  800420bcd7:	48 8b 00             	mov    (%rax),%rax
  800420bcda:	48 89 c7             	mov    %rax,%rdi
  800420bcdd:	48 b8 a6 81 20 04 80 	movabs $0x80042081a6,%rax
  800420bce4:	00 00 00 
  800420bce7:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420bce9:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  800420bcf0:	00 00 00 
  800420bcf3:	ff d0                	callq  *%rax

000000800420bcf5 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420bcf5:	55                   	push   %rbp
  800420bcf6:	48 89 e5             	mov    %rsp,%rbp
  800420bcf9:	53                   	push   %rbx
  800420bcfa:	48 83 ec 38          	sub    $0x38,%rsp
  800420bcfe:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420bd02:	0f 20 d0             	mov    %cr2,%rax
  800420bd05:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	return val;
  800420bd09:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420bd0d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.

	if((tf->tf_cs & 3) != 3)
  800420bd11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bd15:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420bd1c:	0f b7 c0             	movzwl %ax,%eax
  800420bd1f:	83 e0 03             	and    $0x3,%eax
  800420bd22:	83 f8 03             	cmp    $0x3,%eax
  800420bd25:	74 2a                	je     800420bd51 <page_fault_handler+0x5c>
		panic("invalid page fault in kernel mode");
  800420bd27:	48 ba 30 78 21 04 80 	movabs $0x8004217830,%rdx
  800420bd2e:	00 00 00 
  800420bd31:	be 90 01 00 00       	mov    $0x190,%esi
  800420bd36:	48 bf e8 77 21 04 80 	movabs $0x80042177e8,%rdi
  800420bd3d:	00 00 00 
  800420bd40:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bd45:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420bd4c:	00 00 00 
  800420bd4f:	ff d1                	callq  *%rcx
	//   To change what the user environment runs, modify 'curenv->env_tf'
	//   (the 'tf' variable points at 'curenv->env_tf').

	// LAB 4: Your code here.

	if(curenv->env_pgfault_upcall)
  800420bd51:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bd58:	00 00 00 
  800420bd5b:	ff d0                	callq  *%rax
  800420bd5d:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bd64:	00 00 00 
  800420bd67:	48 98                	cltq   
  800420bd69:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd6d:	48 89 c2             	mov    %rax,%rdx
  800420bd70:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd74:	48 29 c2             	sub    %rax,%rdx
  800420bd77:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd7b:	48 83 c0 08          	add    $0x8,%rax
  800420bd7f:	48 8b 00             	mov    (%rax),%rax
  800420bd82:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420bd89:	48 85 c0             	test   %rax,%rax
  800420bd8c:	0f 84 71 02 00 00    	je     800420c003 <page_fault_handler+0x30e>
	{
		uintptr_t utf_addr;

		if(UXSTACKTOP-PGSIZE <= tf->tf_rsp && tf->tf_rsp <= UXSTACKTOP-1)
  800420bd92:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bd96:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bd9d:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420bda2:	48 39 c2             	cmp    %rax,%rdx
  800420bda5:	76 2c                	jbe    800420bdd3 <page_fault_handler+0xde>
  800420bda7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bdab:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bdb2:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420bdb7:	48 39 c2             	cmp    %rax,%rdx
  800420bdba:	77 17                	ja     800420bdd3 <page_fault_handler+0xde>
			utf_addr = tf->tf_rsp - sizeof(struct UTrapframe) - 4;
  800420bdbc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bdc0:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420bdc7:	48 2d a4 00 00 00    	sub    $0xa4,%rax
  800420bdcd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420bdd1:	eb 09                	jmp    800420bddc <page_fault_handler+0xe7>
		else
			utf_addr = UXSTACKTOP - sizeof(struct UTrapframe);
  800420bdd3:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420bdd8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)


		user_mem_assert(curenv, (void *)utf_addr, 1, PTE_W);
  800420bddc:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800420bde0:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bde7:	00 00 00 
  800420bdea:	ff d0                	callq  *%rax
  800420bdec:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bdf3:	00 00 00 
  800420bdf6:	48 98                	cltq   
  800420bdf8:	48 c1 e0 03          	shl    $0x3,%rax
  800420bdfc:	48 89 c2             	mov    %rax,%rdx
  800420bdff:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be03:	48 29 c2             	sub    %rax,%rdx
  800420be06:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420be0a:	48 83 c0 08          	add    $0x8,%rax
  800420be0e:	48 8b 00             	mov    (%rax),%rax
  800420be11:	b9 02 00 00 00       	mov    $0x2,%ecx
  800420be16:	ba 01 00 00 00       	mov    $0x1,%edx
  800420be1b:	48 89 de             	mov    %rbx,%rsi
  800420be1e:	48 89 c7             	mov    %rax,%rdi
  800420be21:	48 b8 80 35 20 04 80 	movabs $0x8004203580,%rax
  800420be28:	00 00 00 
  800420be2b:	ff d0                	callq  *%rax

		struct UTrapframe *utf = (struct UTrapframe *)utf_addr;
  800420be2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be31:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		utf->utf_fault_va = fault_va;
  800420be35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be39:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420be3d:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_err = tf->tf_err;
  800420be40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420be44:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420be4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be4f:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_regs = tf->tf_regs;
  800420be53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be57:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420be5b:	48 8b 0a             	mov    (%rdx),%rcx
  800420be5e:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420be62:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420be66:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420be6a:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420be6e:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420be72:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420be76:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420be7a:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420be7e:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420be82:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420be86:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420be8a:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420be8e:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420be92:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420be96:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420be9a:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420be9e:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420bea2:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420bea6:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420beaa:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420beae:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420beb2:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420beb6:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420beba:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420bebe:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420bec2:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420bec6:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420beca:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420bece:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420bed5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bed9:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420bee0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bee4:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_eflags = tf->tf_eflags;
  800420beeb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420beef:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420bef6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420befa:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420bf01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bf05:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bf0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bf10:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

		curenv->env_tf.tf_rip = (uintptr_t)curenv->env_pgfault_upcall;
  800420bf17:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bf1e:	00 00 00 
  800420bf21:	ff d0                	callq  *%rax
  800420bf23:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bf2a:	00 00 00 
  800420bf2d:	48 98                	cltq   
  800420bf2f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf33:	48 89 c2             	mov    %rax,%rdx
  800420bf36:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bf3a:	48 29 c2             	sub    %rax,%rdx
  800420bf3d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bf41:	48 83 c0 08          	add    $0x8,%rax
  800420bf45:	48 8b 18             	mov    (%rax),%rbx
  800420bf48:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bf4f:	00 00 00 
  800420bf52:	ff d0                	callq  *%rax
  800420bf54:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bf5b:	00 00 00 
  800420bf5e:	48 98                	cltq   
  800420bf60:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf64:	48 89 c2             	mov    %rax,%rdx
  800420bf67:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bf6b:	48 29 c2             	sub    %rax,%rdx
  800420bf6e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bf72:	48 83 c0 08          	add    $0x8,%rax
  800420bf76:	48 8b 00             	mov    (%rax),%rax
  800420bf79:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420bf80:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
		curenv->env_tf.tf_rsp = utf_addr;
  800420bf87:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bf8e:	00 00 00 
  800420bf91:	ff d0                	callq  *%rax
  800420bf93:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bf9a:	00 00 00 
  800420bf9d:	48 98                	cltq   
  800420bf9f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bfa3:	48 89 c2             	mov    %rax,%rdx
  800420bfa6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bfaa:	48 29 c2             	sub    %rax,%rdx
  800420bfad:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bfb1:	48 83 c0 08          	add    $0x8,%rax
  800420bfb5:	48 8b 00             	mov    (%rax),%rax
  800420bfb8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bfbc:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		env_run(curenv);
  800420bfc3:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420bfca:	00 00 00 
  800420bfcd:	ff d0                	callq  *%rax
  800420bfcf:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420bfd6:	00 00 00 
  800420bfd9:	48 98                	cltq   
  800420bfdb:	48 c1 e0 03          	shl    $0x3,%rax
  800420bfdf:	48 89 c2             	mov    %rax,%rdx
  800420bfe2:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bfe6:	48 29 c2             	sub    %rax,%rdx
  800420bfe9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bfed:	48 83 c0 08          	add    $0x8,%rax
  800420bff1:	48 8b 00             	mov    (%rax),%rax
  800420bff4:	48 89 c7             	mov    %rax,%rdi
  800420bff7:	48 b8 a6 81 20 04 80 	movabs $0x80042081a6,%rax
  800420bffe:	00 00 00 
  800420c001:	ff d0                	callq  *%rax
	}


	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420c003:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c007:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
		curenv->env_id, fault_va, tf->tf_rip);
  800420c00e:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c015:	00 00 00 
  800420c018:	ff d0                	callq  *%rax
  800420c01a:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c021:	00 00 00 
  800420c024:	48 98                	cltq   
  800420c026:	48 c1 e0 03          	shl    $0x3,%rax
  800420c02a:	48 89 c2             	mov    %rax,%rdx
  800420c02d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c031:	48 29 c2             	sub    %rax,%rdx
  800420c034:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c038:	48 83 c0 08          	add    $0x8,%rax
  800420c03c:	48 8b 00             	mov    (%rax),%rax
		env_run(curenv);
	}


	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420c03f:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c045:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c049:	48 89 d9             	mov    %rbx,%rcx
  800420c04c:	89 c6                	mov    %eax,%esi
  800420c04e:	48 bf 58 78 21 04 80 	movabs $0x8004217858,%rdi
  800420c055:	00 00 00 
  800420c058:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c05d:	49 b8 ea 86 20 04 80 	movabs $0x80042086ea,%r8
  800420c064:	00 00 00 
  800420c067:	41 ff d0             	callq  *%r8
		curenv->env_id, fault_va, tf->tf_rip);
	print_trapframe(tf);
  800420c06a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c06e:	48 89 c7             	mov    %rax,%rdi
  800420c071:	48 b8 71 b2 20 04 80 	movabs $0x800420b271,%rax
  800420c078:	00 00 00 
  800420c07b:	ff d0                	callq  *%rax
	env_destroy(curenv);
  800420c07d:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c084:	00 00 00 
  800420c087:	ff d0                	callq  *%rax
  800420c089:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c090:	00 00 00 
  800420c093:	48 98                	cltq   
  800420c095:	48 c1 e0 03          	shl    $0x3,%rax
  800420c099:	48 89 c2             	mov    %rax,%rdx
  800420c09c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c0a0:	48 29 c2             	sub    %rax,%rdx
  800420c0a3:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c0a7:	48 83 c0 08          	add    $0x8,%rax
  800420c0ab:	48 8b 00             	mov    (%rax),%rax
  800420c0ae:	48 89 c7             	mov    %rax,%rdi
  800420c0b1:	48 b8 d7 7f 20 04 80 	movabs $0x8004207fd7,%rax
  800420c0b8:	00 00 00 
  800420c0bb:	ff d0                	callq  *%rax
}
  800420c0bd:	48 83 c4 38          	add    $0x38,%rsp
  800420c0c1:	5b                   	pop    %rbx
  800420c0c2:	5d                   	pop    %rbp
  800420c0c3:	c3                   	retq   

000000800420c0c4 <DIVIDE_F>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

  TRAPHANDLER_NOEC(DIVIDE_F, T_DIVIDE)
  800420c0c4:	6a 00                	pushq  $0x0
  800420c0c6:	6a 00                	pushq  $0x0
  800420c0c8:	e9 09 01 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c0cd:	90                   	nop

000000800420c0ce <DEBUG_F>:
 	TRAPHANDLER_NOEC(DEBUG_F, T_DEBUG)
  800420c0ce:	6a 00                	pushq  $0x0
  800420c0d0:	6a 01                	pushq  $0x1
  800420c0d2:	e9 ff 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c0d7:	90                   	nop

000000800420c0d8 <NMI_F>:
 	TRAPHANDLER_NOEC(NMI_F, T_NMI)
  800420c0d8:	6a 00                	pushq  $0x0
  800420c0da:	6a 02                	pushq  $0x2
  800420c0dc:	e9 f5 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c0e1:	90                   	nop

000000800420c0e2 <BRKPT_F>:
 	TRAPHANDLER_NOEC(BRKPT_F, T_BRKPT)
  800420c0e2:	6a 00                	pushq  $0x0
  800420c0e4:	6a 03                	pushq  $0x3
  800420c0e6:	e9 eb 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c0eb:	90                   	nop

000000800420c0ec <OFLOW_F>:
 	TRAPHANDLER_NOEC(OFLOW_F, T_OFLOW)
  800420c0ec:	6a 00                	pushq  $0x0
  800420c0ee:	6a 04                	pushq  $0x4
  800420c0f0:	e9 e1 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c0f5:	90                   	nop

000000800420c0f6 <BOUND_F>:
 	TRAPHANDLER_NOEC(BOUND_F, T_BOUND)
  800420c0f6:	6a 00                	pushq  $0x0
  800420c0f8:	6a 05                	pushq  $0x5
  800420c0fa:	e9 d7 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c0ff:	90                   	nop

000000800420c100 <ILLOP_F>:
 	TRAPHANDLER_NOEC(ILLOP_F, T_ILLOP)
  800420c100:	6a 00                	pushq  $0x0
  800420c102:	6a 06                	pushq  $0x6
  800420c104:	e9 cd 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c109:	90                   	nop

000000800420c10a <DEVICE_F>:
 	TRAPHANDLER_NOEC(DEVICE_F, T_DEVICE)
  800420c10a:	6a 00                	pushq  $0x0
  800420c10c:	6a 07                	pushq  $0x7
  800420c10e:	e9 c3 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c113:	90                   	nop

000000800420c114 <DBLFLT_F>:
 	TRAPHANDLER(DBLFLT_F, T_DBLFLT)
  800420c114:	6a 08                	pushq  $0x8
  800420c116:	e9 bb 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c11b:	90                   	nop

000000800420c11c <TSS_F>:
 	TRAPHANDLER(TSS_F, T_TSS)
  800420c11c:	6a 0a                	pushq  $0xa
  800420c11e:	e9 b3 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c123:	90                   	nop

000000800420c124 <SEGNP_F>:
 	TRAPHANDLER(SEGNP_F, T_SEGNP)
  800420c124:	6a 0b                	pushq  $0xb
  800420c126:	e9 ab 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c12b:	90                   	nop

000000800420c12c <STACK_F>:
 	TRAPHANDLER(STACK_F, T_STACK)
  800420c12c:	6a 0c                	pushq  $0xc
  800420c12e:	e9 a3 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c133:	90                   	nop

000000800420c134 <GPFLT_F>:
 	TRAPHANDLER(GPFLT_F, T_GPFLT)
  800420c134:	6a 0d                	pushq  $0xd
  800420c136:	e9 9b 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c13b:	90                   	nop

000000800420c13c <PGFLT_F>:
 	TRAPHANDLER(PGFLT_F, T_PGFLT)
  800420c13c:	6a 0e                	pushq  $0xe
  800420c13e:	e9 93 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c143:	90                   	nop

000000800420c144 <FPERR_F>:
 	TRAPHANDLER_NOEC(FPERR_F, T_FPERR)
  800420c144:	6a 00                	pushq  $0x0
  800420c146:	6a 10                	pushq  $0x10
  800420c148:	e9 89 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c14d:	90                   	nop

000000800420c14e <ALIGN_F>:
 	TRAPHANDLER(ALIGN_F, T_ALIGN)
  800420c14e:	6a 11                	pushq  $0x11
  800420c150:	e9 81 00 00 00       	jmpq   800420c1d6 <_alltraps>
  800420c155:	90                   	nop

000000800420c156 <MCHK_F>:
 	TRAPHANDLER_NOEC(MCHK_F, T_MCHK)
  800420c156:	6a 00                	pushq  $0x0
  800420c158:	6a 12                	pushq  $0x12
  800420c15a:	eb 7a                	jmp    800420c1d6 <_alltraps>

000000800420c15c <SIMDERR_F>:
 	TRAPHANDLER_NOEC(SIMDERR_F, T_SIMDERR)
  800420c15c:	6a 00                	pushq  $0x0
  800420c15e:	6a 13                	pushq  $0x13
  800420c160:	eb 74                	jmp    800420c1d6 <_alltraps>

000000800420c162 <SYSCALL_F>:

 	TRAPHANDLER_NOEC(SYSCALL_F, T_SYSCALL)
  800420c162:	6a 00                	pushq  $0x0
  800420c164:	6a 30                	pushq  $0x30
  800420c166:	eb 6e                	jmp    800420c1d6 <_alltraps>

000000800420c168 <DEFAULT_F>:
 	TRAPHANDLER(DEFAULT_F, T_DEFAULT)
  800420c168:	68 f4 01 00 00       	pushq  $0x1f4
  800420c16d:	eb 67                	jmp    800420c1d6 <_alltraps>
  800420c16f:	90                   	nop

000000800420c170 <IRQ0_HANDLER>:

  /*  LAB 4 */
  TRAPHANDLER_NOEC(IRQ0_HANDLER, IRQ_OFFSET)
  800420c170:	6a 00                	pushq  $0x0
  800420c172:	6a 20                	pushq  $0x20
  800420c174:	eb 60                	jmp    800420c1d6 <_alltraps>

000000800420c176 <IRQ1_HANDLER>:
  TRAPHANDLER_NOEC(IRQ1_HANDLER, IRQ_OFFSET + 1)
  800420c176:	6a 00                	pushq  $0x0
  800420c178:	6a 21                	pushq  $0x21
  800420c17a:	eb 5a                	jmp    800420c1d6 <_alltraps>

000000800420c17c <IRQ2_HANDLER>:
  TRAPHANDLER_NOEC(IRQ2_HANDLER, IRQ_OFFSET + 2)
  800420c17c:	6a 00                	pushq  $0x0
  800420c17e:	6a 22                	pushq  $0x22
  800420c180:	eb 54                	jmp    800420c1d6 <_alltraps>

000000800420c182 <IRQ3_HANDLER>:
  TRAPHANDLER_NOEC(IRQ3_HANDLER, IRQ_OFFSET + 3)
  800420c182:	6a 00                	pushq  $0x0
  800420c184:	6a 23                	pushq  $0x23
  800420c186:	eb 4e                	jmp    800420c1d6 <_alltraps>

000000800420c188 <IRQ4_HANDLER>:
  TRAPHANDLER_NOEC(IRQ4_HANDLER, IRQ_OFFSET + 4)
  800420c188:	6a 00                	pushq  $0x0
  800420c18a:	6a 24                	pushq  $0x24
  800420c18c:	eb 48                	jmp    800420c1d6 <_alltraps>

000000800420c18e <IRQ5_HANDLER>:
  TRAPHANDLER_NOEC(IRQ5_HANDLER, IRQ_OFFSET + 5)
  800420c18e:	6a 00                	pushq  $0x0
  800420c190:	6a 25                	pushq  $0x25
  800420c192:	eb 42                	jmp    800420c1d6 <_alltraps>

000000800420c194 <IRQ6_HANDLER>:
  TRAPHANDLER_NOEC(IRQ6_HANDLER, IRQ_OFFSET + 6)
  800420c194:	6a 00                	pushq  $0x0
  800420c196:	6a 26                	pushq  $0x26
  800420c198:	eb 3c                	jmp    800420c1d6 <_alltraps>

000000800420c19a <IRQ7_HANDLER>:
  TRAPHANDLER_NOEC(IRQ7_HANDLER, IRQ_OFFSET + 7)
  800420c19a:	6a 00                	pushq  $0x0
  800420c19c:	6a 27                	pushq  $0x27
  800420c19e:	eb 36                	jmp    800420c1d6 <_alltraps>

000000800420c1a0 <IRQ8_HANDLER>:
  TRAPHANDLER_NOEC(IRQ8_HANDLER, IRQ_OFFSET + 8)
  800420c1a0:	6a 00                	pushq  $0x0
  800420c1a2:	6a 28                	pushq  $0x28
  800420c1a4:	eb 30                	jmp    800420c1d6 <_alltraps>

000000800420c1a6 <IRQ9_HANDLER>:
  TRAPHANDLER_NOEC(IRQ9_HANDLER, IRQ_OFFSET + 9)
  800420c1a6:	6a 00                	pushq  $0x0
  800420c1a8:	6a 29                	pushq  $0x29
  800420c1aa:	eb 2a                	jmp    800420c1d6 <_alltraps>

000000800420c1ac <IRQ10_HANDLER>:
  TRAPHANDLER_NOEC(IRQ10_HANDLER, IRQ_OFFSET + 10)
  800420c1ac:	6a 00                	pushq  $0x0
  800420c1ae:	6a 2a                	pushq  $0x2a
  800420c1b0:	eb 24                	jmp    800420c1d6 <_alltraps>

000000800420c1b2 <IRQ11_HANDLER>:
  TRAPHANDLER_NOEC(IRQ11_HANDLER, IRQ_OFFSET + 11)
  800420c1b2:	6a 00                	pushq  $0x0
  800420c1b4:	6a 2b                	pushq  $0x2b
  800420c1b6:	eb 1e                	jmp    800420c1d6 <_alltraps>

000000800420c1b8 <IRQ12_HANDLER>:
  TRAPHANDLER_NOEC(IRQ12_HANDLER, IRQ_OFFSET + 12)
  800420c1b8:	6a 00                	pushq  $0x0
  800420c1ba:	6a 2c                	pushq  $0x2c
  800420c1bc:	eb 18                	jmp    800420c1d6 <_alltraps>

000000800420c1be <IRQ13_HANDLER>:
  TRAPHANDLER_NOEC(IRQ13_HANDLER, IRQ_OFFSET + 13)
  800420c1be:	6a 00                	pushq  $0x0
  800420c1c0:	6a 2d                	pushq  $0x2d
  800420c1c2:	eb 12                	jmp    800420c1d6 <_alltraps>

000000800420c1c4 <IRQ14_HANDLER>:
  TRAPHANDLER_NOEC(IRQ14_HANDLER, IRQ_OFFSET + 14)
  800420c1c4:	6a 00                	pushq  $0x0
  800420c1c6:	6a 2e                	pushq  $0x2e
  800420c1c8:	eb 0c                	jmp    800420c1d6 <_alltraps>

000000800420c1ca <IRQ15_HANDLER>:
  TRAPHANDLER_NOEC(IRQ15_HANDLER, IRQ_OFFSET + 15)
  800420c1ca:	6a 00                	pushq  $0x0
  800420c1cc:	6a 2f                	pushq  $0x2f
  800420c1ce:	eb 06                	jmp    800420c1d6 <_alltraps>

000000800420c1d0 <IRQ_ERROR_HANDLER>:
  TRAPHANDLER_NOEC(IRQ_ERROR_HANDLER, IRQ_OFFSET + IRQ_ERROR)
  800420c1d0:	6a 00                	pushq  $0x0
  800420c1d2:	6a 33                	pushq  $0x33
  800420c1d4:	eb 00                	jmp    800420c1d6 <_alltraps>

000000800420c1d6 <_alltraps>:
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */

 _alltraps:
       	sub $16,%rsp
  800420c1d6:	48 83 ec 10          	sub    $0x10,%rsp
       	movw %ds,8(%rsp)
  800420c1da:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
       	movw %es,0(%rsp)
  800420c1de:	8c 04 24             	mov    %es,(%rsp)
       	PUSHA
  800420c1e1:	48 83 ec 78          	sub    $0x78,%rsp
  800420c1e5:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420c1ea:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420c1ef:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420c1f4:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420c1f9:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420c1fe:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420c203:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420c208:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420c20d:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420c212:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420c217:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420c21c:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420c221:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420c226:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420c22b:	4c 89 3c 24          	mov    %r15,(%rsp)
       	movq $GD_KD, %rax
  800420c22f:	48 c7 c0 10 00 00 00 	mov    $0x10,%rax
       	movq %rax, %es
  800420c236:	48 8e c0             	mov    %rax,%es
       	movq %rax, %ds
  800420c239:	48 8e d8             	mov    %rax,%ds
       	movq %rsp, %rdi
  800420c23c:	48 89 e7             	mov    %rsp,%rdi
       	call trap
  800420c23f:	e8 47 f7 ff ff       	callq  800420b98b <trap>

000000800420c244 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420c244:	55                   	push   %rbp
  800420c245:	48 89 e5             	mov    %rsp,%rbp
  800420c248:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420c24c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c250:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420c253:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c257:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c25a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420c25e:	f0 87 02             	lock xchg %eax,(%rdx)
  800420c261:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420c264:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420c267:	c9                   	leaveq 
  800420c268:	c3                   	retq   

000000800420c269 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420c269:	55                   	push   %rbp
  800420c26a:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420c26d:	48 bf 60 b7 22 04 80 	movabs $0x800422b760,%rdi
  800420c274:	00 00 00 
  800420c277:	48 b8 4b 60 21 04 80 	movabs $0x800421604b,%rax
  800420c27e:	00 00 00 
  800420c281:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420c283:	f3 90                	pause  
}
  800420c285:	5d                   	pop    %rbp
  800420c286:	c3                   	retq   

000000800420c287 <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420c287:	55                   	push   %rbp
  800420c288:	48 89 e5             	mov    %rsp,%rbp
  800420c28b:	48 83 ec 10          	sub    $0x10,%rsp
	// another CPU (env_status == ENV_RUNNING). If there are
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.

	// LAB 4: Your code here.
	int i, index = 0;
  800420c28f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	if (curenv)
  800420c296:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c29d:	00 00 00 
  800420c2a0:	ff d0                	callq  *%rax
  800420c2a2:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c2a9:	00 00 00 
  800420c2ac:	48 98                	cltq   
  800420c2ae:	48 c1 e0 03          	shl    $0x3,%rax
  800420c2b2:	48 89 c2             	mov    %rax,%rdx
  800420c2b5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c2b9:	48 29 c2             	sub    %rax,%rdx
  800420c2bc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c2c0:	48 83 c0 08          	add    $0x8,%rax
  800420c2c4:	48 8b 00             	mov    (%rax),%rax
  800420c2c7:	48 85 c0             	test   %rax,%rax
  800420c2ca:	74 41                	je     800420c30d <sched_yield+0x86>
		index = ENVX(curenv->env_id);
  800420c2cc:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c2d3:	00 00 00 
  800420c2d6:	ff d0                	callq  *%rax
  800420c2d8:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c2df:	00 00 00 
  800420c2e2:	48 98                	cltq   
  800420c2e4:	48 c1 e0 03          	shl    $0x3,%rax
  800420c2e8:	48 89 c2             	mov    %rax,%rdx
  800420c2eb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c2ef:	48 29 c2             	sub    %rax,%rdx
  800420c2f2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c2f6:	48 83 c0 08          	add    $0x8,%rax
  800420c2fa:	48 8b 00             	mov    (%rax),%rax
  800420c2fd:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c303:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c308:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800420c30b:	eb 07                	jmp    800420c314 <sched_yield+0x8d>
	else
		index = 0;
  800420c30d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)

	for(i = index; i != index + NENV ; i++) {
  800420c314:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420c317:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c31a:	e9 80 00 00 00       	jmpq   800420c39f <sched_yield+0x118>
		if (envs[i%NENV].env_status == ENV_RUNNABLE)
  800420c31f:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  800420c326:	00 00 00 
  800420c329:	48 8b 08             	mov    (%rax),%rcx
  800420c32c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c32f:	99                   	cltd   
  800420c330:	c1 ea 16             	shr    $0x16,%edx
  800420c333:	01 d0                	add    %edx,%eax
  800420c335:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c33a:	29 d0                	sub    %edx,%eax
  800420c33c:	48 63 d0             	movslq %eax,%rdx
  800420c33f:	48 89 d0             	mov    %rdx,%rax
  800420c342:	48 c1 e0 03          	shl    $0x3,%rax
  800420c346:	48 01 d0             	add    %rdx,%rax
  800420c349:	48 c1 e0 05          	shl    $0x5,%rax
  800420c34d:	48 01 c8             	add    %rcx,%rax
  800420c350:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c356:	83 f8 02             	cmp    $0x2,%eax
  800420c359:	75 40                	jne    800420c39b <sched_yield+0x114>
			env_run(&envs[i%NENV]);
  800420c35b:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  800420c362:	00 00 00 
  800420c365:	48 8b 08             	mov    (%rax),%rcx
  800420c368:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c36b:	99                   	cltd   
  800420c36c:	c1 ea 16             	shr    $0x16,%edx
  800420c36f:	01 d0                	add    %edx,%eax
  800420c371:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c376:	29 d0                	sub    %edx,%eax
  800420c378:	48 63 d0             	movslq %eax,%rdx
  800420c37b:	48 89 d0             	mov    %rdx,%rax
  800420c37e:	48 c1 e0 03          	shl    $0x3,%rax
  800420c382:	48 01 d0             	add    %rdx,%rax
  800420c385:	48 c1 e0 05          	shl    $0x5,%rax
  800420c389:	48 01 c8             	add    %rcx,%rax
  800420c38c:	48 89 c7             	mov    %rax,%rdi
  800420c38f:	48 b8 a6 81 20 04 80 	movabs $0x80042081a6,%rax
  800420c396:	00 00 00 
  800420c399:	ff d0                	callq  *%rax
	if (curenv)
		index = ENVX(curenv->env_id);
	else
		index = 0;

	for(i = index; i != index + NENV ; i++) {
  800420c39b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420c39f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420c3a2:	05 00 04 00 00       	add    $0x400,%eax
  800420c3a7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420c3aa:	0f 85 6f ff ff ff    	jne    800420c31f <sched_yield+0x98>
		if (envs[i%NENV].env_status == ENV_RUNNABLE)
			env_run(&envs[i%NENV]);
	}
	if(curenv && curenv->env_status == ENV_RUNNING) {
  800420c3b0:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c3b7:	00 00 00 
  800420c3ba:	ff d0                	callq  *%rax
  800420c3bc:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c3c3:	00 00 00 
  800420c3c6:	48 98                	cltq   
  800420c3c8:	48 c1 e0 03          	shl    $0x3,%rax
  800420c3cc:	48 89 c2             	mov    %rax,%rdx
  800420c3cf:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c3d3:	48 29 c2             	sub    %rax,%rdx
  800420c3d6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c3da:	48 83 c0 08          	add    $0x8,%rax
  800420c3de:	48 8b 00             	mov    (%rax),%rax
  800420c3e1:	48 85 c0             	test   %rax,%rax
  800420c3e4:	74 7c                	je     800420c462 <sched_yield+0x1db>
  800420c3e6:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c3ed:	00 00 00 
  800420c3f0:	ff d0                	callq  *%rax
  800420c3f2:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c3f9:	00 00 00 
  800420c3fc:	48 98                	cltq   
  800420c3fe:	48 c1 e0 03          	shl    $0x3,%rax
  800420c402:	48 89 c2             	mov    %rax,%rdx
  800420c405:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c409:	48 29 c2             	sub    %rax,%rdx
  800420c40c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c410:	48 83 c0 08          	add    $0x8,%rax
  800420c414:	48 8b 00             	mov    (%rax),%rax
  800420c417:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c41d:	83 f8 03             	cmp    $0x3,%eax
  800420c420:	75 40                	jne    800420c462 <sched_yield+0x1db>
		env_run(curenv);
  800420c422:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c429:	00 00 00 
  800420c42c:	ff d0                	callq  *%rax
  800420c42e:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c435:	00 00 00 
  800420c438:	48 98                	cltq   
  800420c43a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c43e:	48 89 c2             	mov    %rax,%rdx
  800420c441:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c445:	48 29 c2             	sub    %rax,%rdx
  800420c448:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c44c:	48 83 c0 08          	add    $0x8,%rax
  800420c450:	48 8b 00             	mov    (%rax),%rax
  800420c453:	48 89 c7             	mov    %rax,%rdi
  800420c456:	48 b8 a6 81 20 04 80 	movabs $0x80042081a6,%rax
  800420c45d:	00 00 00 
  800420c460:	ff d0                	callq  *%rax
	}

	// sched_halt never returns
	sched_halt();
  800420c462:	48 b8 70 c4 20 04 80 	movabs $0x800420c470,%rax
  800420c469:	00 00 00 
  800420c46c:	ff d0                	callq  *%rax
}
  800420c46e:	c9                   	leaveq 
  800420c46f:	c3                   	retq   

000000800420c470 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420c470:	55                   	push   %rbp
  800420c471:	48 89 e5             	mov    %rsp,%rbp
  800420c474:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420c478:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420c47f:	e9 91 00 00 00       	jmpq   800420c515 <sched_halt+0xa5>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420c484:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  800420c48b:	00 00 00 
  800420c48e:	48 8b 08             	mov    (%rax),%rcx
  800420c491:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c494:	48 63 d0             	movslq %eax,%rdx
  800420c497:	48 89 d0             	mov    %rdx,%rax
  800420c49a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c49e:	48 01 d0             	add    %rdx,%rax
  800420c4a1:	48 c1 e0 05          	shl    $0x5,%rax
  800420c4a5:	48 01 c8             	add    %rcx,%rax
  800420c4a8:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c4ae:	83 f8 02             	cmp    $0x2,%eax
  800420c4b1:	74 6f                	je     800420c522 <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
  800420c4b3:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  800420c4ba:	00 00 00 
  800420c4bd:	48 8b 08             	mov    (%rax),%rcx
  800420c4c0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c4c3:	48 63 d0             	movslq %eax,%rdx
  800420c4c6:	48 89 d0             	mov    %rdx,%rax
  800420c4c9:	48 c1 e0 03          	shl    $0x3,%rax
  800420c4cd:	48 01 d0             	add    %rdx,%rax
  800420c4d0:	48 c1 e0 05          	shl    $0x5,%rax
  800420c4d4:	48 01 c8             	add    %rcx,%rax
  800420c4d7:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420c4dd:	83 f8 03             	cmp    $0x3,%eax
  800420c4e0:	74 40                	je     800420c522 <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420c4e2:	48 b8 50 e2 6b 04 80 	movabs $0x80046be250,%rax
  800420c4e9:	00 00 00 
  800420c4ec:	48 8b 08             	mov    (%rax),%rcx
  800420c4ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c4f2:	48 63 d0             	movslq %eax,%rdx
  800420c4f5:	48 89 d0             	mov    %rdx,%rax
  800420c4f8:	48 c1 e0 03          	shl    $0x3,%rax
  800420c4fc:	48 01 d0             	add    %rdx,%rax
  800420c4ff:	48 c1 e0 05          	shl    $0x5,%rax
  800420c503:	48 01 c8             	add    %rcx,%rax
  800420c506:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420c50c:	83 f8 01             	cmp    $0x1,%eax
  800420c50f:	74 11                	je     800420c522 <sched_halt+0xb2>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420c511:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420c515:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420c51c:	0f 8e 62 ff ff ff    	jle    800420c484 <sched_halt+0x14>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420c522:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420c529:	75 2e                	jne    800420c559 <sched_halt+0xe9>
		cprintf("No runnable environments in the system!\n");
  800420c52b:	48 bf 60 7a 21 04 80 	movabs $0x8004217a60,%rdi
  800420c532:	00 00 00 
  800420c535:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c53a:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420c541:	00 00 00 
  800420c544:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420c546:	bf 00 00 00 00       	mov    $0x0,%edi
  800420c54b:	48 b8 7a 16 20 04 80 	movabs $0x800420167a,%rax
  800420c552:	00 00 00 
  800420c555:	ff d0                	callq  *%rax
  800420c557:	eb ed                	jmp    800420c546 <sched_halt+0xd6>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420c559:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c560:	00 00 00 
  800420c563:	ff d0                	callq  *%rax
  800420c565:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c56c:	00 00 00 
  800420c56f:	48 98                	cltq   
  800420c571:	48 c1 e0 03          	shl    $0x3,%rax
  800420c575:	48 89 c2             	mov    %rax,%rdx
  800420c578:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c57c:	48 29 c2             	sub    %rax,%rdx
  800420c57f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c583:	48 83 c0 08          	add    $0x8,%rax
  800420c587:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420c58e:	48 b8 28 f7 6b 04 80 	movabs $0x80046bf728,%rax
  800420c595:	00 00 00 
  800420c598:	48 8b 00             	mov    (%rax),%rax
  800420c59b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420c59f:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420c5a6:	00 00 00 
  800420c5a9:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420c5ad:	77 32                	ja     800420c5e1 <sched_halt+0x171>
  800420c5af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c5b3:	48 89 c1             	mov    %rax,%rcx
  800420c5b6:	48 ba 90 7a 21 04 80 	movabs $0x8004217a90,%rdx
  800420c5bd:	00 00 00 
  800420c5c0:	be 4d 00 00 00       	mov    $0x4d,%esi
  800420c5c5:	48 bf b4 7a 21 04 80 	movabs $0x8004217ab4,%rdi
  800420c5cc:	00 00 00 
  800420c5cf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5d4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420c5db:	00 00 00 
  800420c5de:	41 ff d0             	callq  *%r8
  800420c5e1:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420c5e8:	ff ff ff 
  800420c5eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c5ef:	48 01 d0             	add    %rdx,%rax
  800420c5f2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420c5f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c5fa:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420c5fd:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c604:	00 00 00 
  800420c607:	ff d0                	callq  *%rax
  800420c609:	48 98                	cltq   
  800420c60b:	48 c1 e0 03          	shl    $0x3,%rax
  800420c60f:	48 89 c2             	mov    %rax,%rdx
  800420c612:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c616:	48 29 c2             	sub    %rax,%rdx
  800420c619:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  800420c620:	00 00 00 
  800420c623:	48 01 d0             	add    %rdx,%rax
  800420c626:	48 83 c0 04          	add    $0x4,%rax
  800420c62a:	be 02 00 00 00       	mov    $0x2,%esi
  800420c62f:	48 89 c7             	mov    %rax,%rdi
  800420c632:	48 b8 44 c2 20 04 80 	movabs $0x800420c244,%rax
  800420c639:	00 00 00 
  800420c63c:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420c63e:	48 b8 69 c2 20 04 80 	movabs $0x800420c269,%rax
  800420c645:	00 00 00 
  800420c648:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420c64a:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c651:	00 00 00 
  800420c654:	ff d0                	callq  *%rax
  800420c656:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c65d:	00 00 00 
  800420c660:	48 98                	cltq   
  800420c662:	48 c1 e0 03          	shl    $0x3,%rax
  800420c666:	48 89 c2             	mov    %rax,%rdx
  800420c669:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c66d:	48 29 c2             	sub    %rax,%rdx
  800420c670:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c674:	48 83 c0 10          	add    $0x10,%rax
  800420c678:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420c67c:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420c683:	48 89 c4             	mov    %rax,%rsp
  800420c686:	6a 00                	pushq  $0x0
  800420c688:	6a 00                	pushq  $0x0
  800420c68a:	fb                   	sti    
  800420c68b:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420c68c:	c9                   	leaveq 
  800420c68d:	c3                   	retq   

000000800420c68e <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420c68e:	55                   	push   %rbp
  800420c68f:	48 89 e5             	mov    %rsp,%rbp
  800420c692:	48 83 ec 10          	sub    $0x10,%rsp
  800420c696:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c69a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, s, len, PTE_U);
  800420c69e:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c6a5:	00 00 00 
  800420c6a8:	ff d0                	callq  *%rax
  800420c6aa:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c6b1:	00 00 00 
  800420c6b4:	48 98                	cltq   
  800420c6b6:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6ba:	48 89 c2             	mov    %rax,%rdx
  800420c6bd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6c1:	48 29 c2             	sub    %rax,%rdx
  800420c6c4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c6c8:	48 83 c0 08          	add    $0x8,%rax
  800420c6cc:	48 8b 00             	mov    (%rax),%rax
  800420c6cf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c6d3:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420c6d7:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420c6dc:	48 89 c7             	mov    %rax,%rdi
  800420c6df:	48 b8 80 35 20 04 80 	movabs $0x8004203580,%rax
  800420c6e6:	00 00 00 
  800420c6e9:	ff d0                	callq  *%rax

	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420c6eb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c6ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c6f3:	48 89 c6             	mov    %rax,%rsi
  800420c6f6:	48 bf c8 7a 21 04 80 	movabs $0x8004217ac8,%rdi
  800420c6fd:	00 00 00 
  800420c700:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c705:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  800420c70c:	00 00 00 
  800420c70f:	ff d1                	callq  *%rcx
}
  800420c711:	c9                   	leaveq 
  800420c712:	c3                   	retq   

000000800420c713 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420c713:	55                   	push   %rbp
  800420c714:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420c717:	48 b8 8b 10 20 04 80 	movabs $0x800420108b,%rax
  800420c71e:	00 00 00 
  800420c721:	ff d0                	callq  *%rax
}
  800420c723:	5d                   	pop    %rbp
  800420c724:	c3                   	retq   

000000800420c725 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420c725:	55                   	push   %rbp
  800420c726:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420c729:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c730:	00 00 00 
  800420c733:	ff d0                	callq  *%rax
  800420c735:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c73c:	00 00 00 
  800420c73f:	48 98                	cltq   
  800420c741:	48 c1 e0 03          	shl    $0x3,%rax
  800420c745:	48 89 c2             	mov    %rax,%rdx
  800420c748:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c74c:	48 29 c2             	sub    %rax,%rdx
  800420c74f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c753:	48 83 c0 08          	add    $0x8,%rax
  800420c757:	48 8b 00             	mov    (%rax),%rax
  800420c75a:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420c760:	5d                   	pop    %rbp
  800420c761:	c3                   	retq   

000000800420c762 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420c762:	55                   	push   %rbp
  800420c763:	48 89 e5             	mov    %rsp,%rbp
  800420c766:	48 83 ec 20          	sub    $0x20,%rsp
  800420c76a:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420c76d:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c771:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c774:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c779:	48 89 ce             	mov    %rcx,%rsi
  800420c77c:	89 c7                	mov    %eax,%edi
  800420c77e:	48 b8 22 72 20 04 80 	movabs $0x8004207222,%rax
  800420c785:	00 00 00 
  800420c788:	ff d0                	callq  *%rax
  800420c78a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c78d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c791:	79 05                	jns    800420c798 <sys_env_destroy+0x36>
		return r;
  800420c793:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c796:	eb 18                	jmp    800420c7b0 <sys_env_destroy+0x4e>
	// if (e == curenv)
		// cprintf("[%08x] exiting gracefully\n", curenv->env_id);
	// else
		// cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
	env_destroy(e);
  800420c798:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c79c:	48 89 c7             	mov    %rax,%rdi
  800420c79f:	48 b8 d7 7f 20 04 80 	movabs $0x8004207fd7,%rax
  800420c7a6:	00 00 00 
  800420c7a9:	ff d0                	callq  *%rax
	return 0;
  800420c7ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c7b0:	c9                   	leaveq 
  800420c7b1:	c3                   	retq   

000000800420c7b2 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420c7b2:	55                   	push   %rbp
  800420c7b3:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420c7b6:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  800420c7bd:	00 00 00 
  800420c7c0:	ff d0                	callq  *%rax

000000800420c7c2 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420c7c2:	55                   	push   %rbp
  800420c7c3:	48 89 e5             	mov    %rsp,%rbp
  800420c7c6:	53                   	push   %rbx
  800420c7c7:	48 83 ec 18          	sub    $0x18,%rsp

	// LAB 4: Your code here.

	int result;
	struct Env *new_env;
	result = env_alloc(&new_env, curenv->env_id);
  800420c7cb:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c7d2:	00 00 00 
  800420c7d5:	ff d0                	callq  *%rax
  800420c7d7:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c7de:	00 00 00 
  800420c7e1:	48 98                	cltq   
  800420c7e3:	48 c1 e0 03          	shl    $0x3,%rax
  800420c7e7:	48 89 c2             	mov    %rax,%rdx
  800420c7ea:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c7ee:	48 29 c2             	sub    %rax,%rdx
  800420c7f1:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c7f5:	48 83 c0 08          	add    $0x8,%rax
  800420c7f9:	48 8b 00             	mov    (%rax),%rax
  800420c7fc:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420c802:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420c806:	89 d6                	mov    %edx,%esi
  800420c808:	48 89 c7             	mov    %rax,%rdi
  800420c80b:	48 b8 1d 76 20 04 80 	movabs $0x800420761d,%rax
  800420c812:	00 00 00 
  800420c815:	ff d0                	callq  *%rax
  800420c817:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (result < 0)
  800420c81a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c81e:	79 05                	jns    800420c825 <sys_exofork+0x63>
		return result;
  800420c820:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c823:	eb 6d                	jmp    800420c892 <sys_exofork+0xd0>

	new_env->env_status = ENV_NOT_RUNNABLE;
  800420c825:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c829:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420c830:	00 00 00 
	new_env->env_tf = curenv->env_tf;
  800420c833:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420c837:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420c83e:	00 00 00 
  800420c841:	ff d0                	callq  *%rax
  800420c843:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420c84a:	00 00 00 
  800420c84d:	48 98                	cltq   
  800420c84f:	48 c1 e0 03          	shl    $0x3,%rax
  800420c853:	48 89 c2             	mov    %rax,%rdx
  800420c856:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c85a:	48 29 c2             	sub    %rax,%rdx
  800420c85d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c861:	48 83 c0 08          	add    $0x8,%rax
  800420c865:	48 8b 00             	mov    (%rax),%rax
  800420c868:	48 89 da             	mov    %rbx,%rdx
  800420c86b:	48 89 c6             	mov    %rax,%rsi
  800420c86e:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c873:	48 89 d7             	mov    %rdx,%rdi
  800420c876:	48 89 c1             	mov    %rax,%rcx
  800420c879:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	new_env->env_tf.tf_regs.reg_rax = 0;
  800420c87c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c880:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420c887:	00 

	return new_env->env_id;
  800420c888:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c88c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

	//panic("sys_exofork not implemented");
}
  800420c892:	48 83 c4 18          	add    $0x18,%rsp
  800420c896:	5b                   	pop    %rbx
  800420c897:	5d                   	pop    %rbp
  800420c898:	c3                   	retq   

000000800420c899 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420c899:	55                   	push   %rbp
  800420c89a:	48 89 e5             	mov    %rsp,%rbp
  800420c89d:	48 83 ec 20          	sub    $0x20,%rsp
  800420c8a1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c8a4:	89 75 e8             	mov    %esi,-0x18(%rbp)

	// LAB 4: Your code here.

	int x;
	struct Env *e;
	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE)
  800420c8a7:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420c8ab:	74 0d                	je     800420c8ba <sys_env_set_status+0x21>
  800420c8ad:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420c8b1:	74 07                	je     800420c8ba <sys_env_set_status+0x21>
		return -E_INVAL;
  800420c8b3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c8b8:	eb 3d                	jmp    800420c8f7 <sys_env_set_status+0x5e>

	if ((x = envid2env(envid, &e, 1)) < 0)
  800420c8ba:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c8be:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c8c1:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c8c6:	48 89 ce             	mov    %rcx,%rsi
  800420c8c9:	89 c7                	mov    %eax,%edi
  800420c8cb:	48 b8 22 72 20 04 80 	movabs $0x8004207222,%rax
  800420c8d2:	00 00 00 
  800420c8d5:	ff d0                	callq  *%rax
  800420c8d7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c8da:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c8de:	79 05                	jns    800420c8e5 <sys_env_set_status+0x4c>
		return x;
  800420c8e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c8e3:	eb 12                	jmp    800420c8f7 <sys_env_set_status+0x5e>

	e->env_status = status;
  800420c8e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c8e9:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420c8ec:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420c8f2:	b8 00 00 00 00       	mov    $0x0,%eax


  //panic("sys_env_set_status not implemented");
	//panic("sys_env_set_status not implemented");
}
  800420c8f7:	c9                   	leaveq 
  800420c8f8:	c3                   	retq   

000000800420c8f9 <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420c8f9:	55                   	push   %rbp
  800420c8fa:	48 89 e5             	mov    %rsp,%rbp
  800420c8fd:	48 83 ec 10          	sub    $0x10,%rsp
  800420c901:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420c904:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// LAB 5: Your code here.
	// Remember to check whether the user has supplied us with a good
	// address!
	panic("sys_env_set_trapframe not implemented");
  800420c908:	48 ba d0 7a 21 04 80 	movabs $0x8004217ad0,%rdx
  800420c90f:	00 00 00 
  800420c912:	be 9b 00 00 00       	mov    $0x9b,%esi
  800420c917:	48 bf f6 7a 21 04 80 	movabs $0x8004217af6,%rdi
  800420c91e:	00 00 00 
  800420c921:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c926:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420c92d:	00 00 00 
  800420c930:	ff d1                	callq  *%rcx

000000800420c932 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420c932:	55                   	push   %rbp
  800420c933:	48 89 e5             	mov    %rsp,%rbp
  800420c936:	48 83 ec 20          	sub    $0x20,%rsp
  800420c93a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c93d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.

	int x;
	struct Env *e;

	if ((x = envid2env(envid, &e, 1)) < 0)
  800420c941:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c945:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c948:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c94d:	48 89 ce             	mov    %rcx,%rsi
  800420c950:	89 c7                	mov    %eax,%edi
  800420c952:	48 b8 22 72 20 04 80 	movabs $0x8004207222,%rax
  800420c959:	00 00 00 
  800420c95c:	ff d0                	callq  *%rax
  800420c95e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c961:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c965:	79 05                	jns    800420c96c <sys_env_set_pgfault_upcall+0x3a>
		return x;
  800420c967:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c96a:	eb 14                	jmp    800420c980 <sys_env_set_pgfault_upcall+0x4e>

	e->env_pgfault_upcall = func;
  800420c96c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c970:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c974:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420c97b:	b8 00 00 00 00       	mov    $0x0,%eax


	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420c980:	c9                   	leaveq 
  800420c981:	c3                   	retq   

000000800420c982 <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420c982:	55                   	push   %rbp
  800420c983:	48 89 e5             	mov    %rsp,%rbp
  800420c986:	48 83 ec 30          	sub    $0x30,%rsp
  800420c98a:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420c98d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420c991:	89 55 d8             	mov    %edx,-0x28(%rbp)

	int x;
	struct Env *e;
	struct PageInfo *pp;

	if ((uint64_t)va >= UTOP || (((uint64_t)va & 0xFFF) != 0))
  800420c994:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c998:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c99f:	00 00 00 
  800420c9a2:	48 39 c2             	cmp    %rax,%rdx
  800420c9a5:	77 0e                	ja     800420c9b5 <sys_page_alloc+0x33>
  800420c9a7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c9ab:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c9b0:	48 85 c0             	test   %rax,%rax
  800420c9b3:	74 0a                	je     800420c9bf <sys_page_alloc+0x3d>
		return -E_INVAL;
  800420c9b5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c9ba:	e9 b2 00 00 00       	jmpq   800420ca71 <sys_page_alloc+0xef>
	if ((perm | PTE_SYSCALL) != PTE_SYSCALL)
  800420c9bf:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420c9c2:	0d 07 0e 00 00       	or     $0xe07,%eax
  800420c9c7:	3d 07 0e 00 00       	cmp    $0xe07,%eax
  800420c9cc:	74 0a                	je     800420c9d8 <sys_page_alloc+0x56>
		return -E_INVAL;
  800420c9ce:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c9d3:	e9 99 00 00 00       	jmpq   800420ca71 <sys_page_alloc+0xef>

	if ((x = envid2env(envid, &e, 1)) < 0)
  800420c9d8:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420c9dc:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c9df:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c9e4:	48 89 ce             	mov    %rcx,%rsi
  800420c9e7:	89 c7                	mov    %eax,%edi
  800420c9e9:	48 b8 22 72 20 04 80 	movabs $0x8004207222,%rax
  800420c9f0:	00 00 00 
  800420c9f3:	ff d0                	callq  *%rax
  800420c9f5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c9f8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c9fc:	79 05                	jns    800420ca03 <sys_page_alloc+0x81>
		return x;
  800420c9fe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ca01:	eb 6e                	jmp    800420ca71 <sys_page_alloc+0xef>

	pp = page_alloc(ALLOC_ZERO);
  800420ca03:	bf 01 00 00 00       	mov    $0x1,%edi
  800420ca08:	48 b8 54 2a 20 04 80 	movabs $0x8004202a54,%rax
  800420ca0f:	00 00 00 
  800420ca12:	ff d0                	callq  *%rax
  800420ca14:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pp == NULL)
  800420ca18:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420ca1d:	75 07                	jne    800420ca26 <sys_page_alloc+0xa4>
		return -E_NO_MEM;
  800420ca1f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420ca24:	eb 4b                	jmp    800420ca71 <sys_page_alloc+0xef>

	if((x = page_insert(e->env_pml4e, pp, va, perm)) < 0)
  800420ca26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca2a:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ca31:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420ca34:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ca38:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420ca3c:	48 89 c7             	mov    %rax,%rdi
  800420ca3f:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  800420ca46:	00 00 00 
  800420ca49:	ff d0                	callq  *%rax
  800420ca4b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420ca4e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ca52:	79 18                	jns    800420ca6c <sys_page_alloc+0xea>
	{
		page_free(pp);
  800420ca54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca58:	48 89 c7             	mov    %rax,%rdi
  800420ca5b:	48 b8 0f 2b 20 04 80 	movabs $0x8004202b0f,%rax
  800420ca62:	00 00 00 
  800420ca65:	ff d0                	callq  *%rax
		return x;
  800420ca67:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ca6a:	eb 05                	jmp    800420ca71 <sys_page_alloc+0xef>
	}
	return 0;
  800420ca6c:	b8 00 00 00 00       	mov    $0x0,%eax

	//panic("sys_page_alloc not implemented");
}
  800420ca71:	c9                   	leaveq 
  800420ca72:	c3                   	retq   

000000800420ca73 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420ca73:	55                   	push   %rbp
  800420ca74:	48 89 e5             	mov    %rsp,%rbp
  800420ca77:	48 83 ec 50          	sub    $0x50,%rsp
  800420ca7b:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420ca7e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420ca82:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420ca85:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420ca89:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)

	int x;
	struct Env *src_env, *dst_env;
	struct PageInfo *pp;
	pte_t *ptep;
	if ((x = envid2env(srcenvid, &src_env, 1)) < 0)
  800420ca8d:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420ca91:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420ca94:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ca99:	48 89 ce             	mov    %rcx,%rsi
  800420ca9c:	89 c7                	mov    %eax,%edi
  800420ca9e:	48 b8 22 72 20 04 80 	movabs $0x8004207222,%rax
  800420caa5:	00 00 00 
  800420caa8:	ff d0                	callq  *%rax
  800420caaa:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420caad:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cab1:	79 08                	jns    800420cabb <sys_page_map+0x48>
		return x;
  800420cab3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cab6:	e9 2c 01 00 00       	jmpq   800420cbe7 <sys_page_map+0x174>
	if ((x = envid2env(dstenvid, &dst_env, 1)) < 0)
  800420cabb:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420cabf:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420cac2:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cac7:	48 89 ce             	mov    %rcx,%rsi
  800420caca:	89 c7                	mov    %eax,%edi
  800420cacc:	48 b8 22 72 20 04 80 	movabs $0x8004207222,%rax
  800420cad3:	00 00 00 
  800420cad6:	ff d0                	callq  *%rax
  800420cad8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cadb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cadf:	79 08                	jns    800420cae9 <sys_page_map+0x76>
		return x;
  800420cae1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cae4:	e9 fe 00 00 00       	jmpq   800420cbe7 <sys_page_map+0x174>
	if ((uint64_t)srcva >= UTOP || (((uint64_t)srcva & 0xFFF) != 0))
  800420cae9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420caed:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420caf4:	00 00 00 
  800420caf7:	48 39 c2             	cmp    %rax,%rdx
  800420cafa:	77 0e                	ja     800420cb0a <sys_page_map+0x97>
  800420cafc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420cb00:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cb05:	48 85 c0             	test   %rax,%rax
  800420cb08:	74 0a                	je     800420cb14 <sys_page_map+0xa1>
		return -E_INVAL;
  800420cb0a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb0f:	e9 d3 00 00 00       	jmpq   800420cbe7 <sys_page_map+0x174>
	if ((uint64_t)dstva >= UTOP || (((uint64_t)dstva & 0xFFF) != 0))
  800420cb14:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420cb18:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cb1f:	00 00 00 
  800420cb22:	48 39 c2             	cmp    %rax,%rdx
  800420cb25:	77 0e                	ja     800420cb35 <sys_page_map+0xc2>
  800420cb27:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420cb2b:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cb30:	48 85 c0             	test   %rax,%rax
  800420cb33:	74 0a                	je     800420cb3f <sys_page_map+0xcc>
		return -E_INVAL;
  800420cb35:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb3a:	e9 a8 00 00 00       	jmpq   800420cbe7 <sys_page_map+0x174>
	if ((perm | PTE_SYSCALL) != PTE_SYSCALL)
  800420cb3f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420cb42:	0d 07 0e 00 00       	or     $0xe07,%eax
  800420cb47:	3d 07 0e 00 00       	cmp    $0xe07,%eax
  800420cb4c:	74 0a                	je     800420cb58 <sys_page_map+0xe5>
		return -E_INVAL;
  800420cb4e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb53:	e9 8f 00 00 00       	jmpq   800420cbe7 <sys_page_map+0x174>

	pp = page_lookup(src_env->env_pml4e, srcva, &ptep);
  800420cb58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb5c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cb63:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420cb67:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420cb6b:	48 89 ce             	mov    %rcx,%rsi
  800420cb6e:	48 89 c7             	mov    %rax,%rdi
  800420cb71:	48 b8 6e 31 20 04 80 	movabs $0x800420316e,%rax
  800420cb78:	00 00 00 
  800420cb7b:	ff d0                	callq  *%rax
  800420cb7d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (pp == NULL)
  800420cb81:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420cb86:	75 07                	jne    800420cb8f <sys_page_map+0x11c>
		return -E_INVAL;
  800420cb88:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb8d:	eb 58                	jmp    800420cbe7 <sys_page_map+0x174>
	if (!((*ptep) & PTE_W) && (perm & PTE_W))
  800420cb8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cb93:	48 8b 00             	mov    (%rax),%rax
  800420cb96:	83 e0 02             	and    $0x2,%eax
  800420cb99:	48 85 c0             	test   %rax,%rax
  800420cb9c:	75 11                	jne    800420cbaf <sys_page_map+0x13c>
  800420cb9e:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420cba1:	83 e0 02             	and    $0x2,%eax
  800420cba4:	85 c0                	test   %eax,%eax
  800420cba6:	74 07                	je     800420cbaf <sys_page_map+0x13c>
		return -E_INVAL;
  800420cba8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cbad:	eb 38                	jmp    800420cbe7 <sys_page_map+0x174>
	if ((x = page_insert(dst_env->env_pml4e, pp, dstva, perm)) < 0)
  800420cbaf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cbb3:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cbba:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420cbbd:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420cbc1:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420cbc5:	48 89 c7             	mov    %rax,%rdi
  800420cbc8:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  800420cbcf:	00 00 00 
  800420cbd2:	ff d0                	callq  *%rax
  800420cbd4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cbd7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cbdb:	79 05                	jns    800420cbe2 <sys_page_map+0x16f>
		return x;
  800420cbdd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cbe0:	eb 05                	jmp    800420cbe7 <sys_page_map+0x174>
	return 0;
  800420cbe2:	b8 00 00 00 00       	mov    $0x0,%eax

	//panic("sys_page_map not implemented");
}
  800420cbe7:	c9                   	leaveq 
  800420cbe8:	c3                   	retq   

000000800420cbe9 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420cbe9:	55                   	push   %rbp
  800420cbea:	48 89 e5             	mov    %rsp,%rbp
  800420cbed:	48 83 ec 20          	sub    $0x20,%rsp
  800420cbf1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420cbf4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	// LAB 4: Your code here.
	int x;
	struct Env *e;

	if ((x = envid2env(envid, &e, 1)) < 0)
  800420cbf8:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420cbfc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420cbff:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cc04:	48 89 ce             	mov    %rcx,%rsi
  800420cc07:	89 c7                	mov    %eax,%edi
  800420cc09:	48 b8 22 72 20 04 80 	movabs $0x8004207222,%rax
  800420cc10:	00 00 00 
  800420cc13:	ff d0                	callq  *%rax
  800420cc15:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cc18:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cc1c:	79 05                	jns    800420cc23 <sys_page_unmap+0x3a>
		return x;
  800420cc1e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cc21:	eb 4e                	jmp    800420cc71 <sys_page_unmap+0x88>
	if ((uint64_t)va >= UTOP || (((uint64_t)va & 0xFFF) != 0))
  800420cc23:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cc27:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cc2e:	00 00 00 
  800420cc31:	48 39 c2             	cmp    %rax,%rdx
  800420cc34:	77 0e                	ja     800420cc44 <sys_page_unmap+0x5b>
  800420cc36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cc3a:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cc3f:	48 85 c0             	test   %rax,%rax
  800420cc42:	74 07                	je     800420cc4b <sys_page_unmap+0x62>
		return -E_INVAL;
  800420cc44:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cc49:	eb 26                	jmp    800420cc71 <sys_page_unmap+0x88>
	page_remove(e->env_pml4e, va);
  800420cc4b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc4f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cc56:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cc5a:	48 89 d6             	mov    %rdx,%rsi
  800420cc5d:	48 89 c7             	mov    %rax,%rdi
  800420cc60:	48 b8 e5 31 20 04 80 	movabs $0x80042031e5,%rax
  800420cc67:	00 00 00 
  800420cc6a:	ff d0                	callq  *%rax
	return 0;
  800420cc6c:	b8 00 00 00 00       	mov    $0x0,%eax

	//panic("sys_page_unmap not implemented");
}
  800420cc71:	c9                   	leaveq 
  800420cc72:	c3                   	retq   

000000800420cc73 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, unsigned perm)
{
  800420cc73:	55                   	push   %rbp
  800420cc74:	48 89 e5             	mov    %rsp,%rbp
  800420cc77:	53                   	push   %rbx
  800420cc78:	48 83 ec 48          	sub    $0x48,%rsp
  800420cc7c:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420cc7f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420cc83:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420cc87:	89 4d c8             	mov    %ecx,-0x38(%rbp)
		struct Env *e;
    struct PageInfo *pp;
    pte_t *pte;
    int r;

    if ((r = envid2env(envid, &e, 0)) != 0) {
  800420cc8a:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420cc8e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420cc91:	ba 00 00 00 00       	mov    $0x0,%edx
  800420cc96:	48 89 ce             	mov    %rcx,%rsi
  800420cc99:	89 c7                	mov    %eax,%edi
  800420cc9b:	48 b8 22 72 20 04 80 	movabs $0x8004207222,%rax
  800420cca2:	00 00 00 
  800420cca5:	ff d0                	callq  *%rax
  800420cca7:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420ccaa:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420ccae:	74 08                	je     800420ccb8 <sys_ipc_try_send+0x45>
        return r;
  800420ccb0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ccb3:	e9 c7 01 00 00       	jmpq   800420ce7f <sys_ipc_try_send+0x20c>
    }
    if (e->env_ipc_recving == 0) {
  800420ccb8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ccbc:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420ccc3:	83 f0 01             	xor    $0x1,%eax
  800420ccc6:	84 c0                	test   %al,%al
  800420ccc8:	74 0a                	je     800420ccd4 <sys_ipc_try_send+0x61>
        return -E_IPC_NOT_RECV;
  800420ccca:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420cccf:	e9 ab 01 00 00       	jmpq   800420ce7f <sys_ipc_try_send+0x20c>
    }
    if ((uint64_t)srcva < UTOP) {
  800420ccd4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420ccd8:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ccdf:	00 00 00 
  800420cce2:	48 39 c2             	cmp    %rax,%rdx
  800420cce5:	0f 87 19 01 00 00    	ja     800420ce04 <sys_ipc_try_send+0x191>
        if (PGOFF(srcva) != 0) {
  800420cceb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420ccef:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ccf4:	48 85 c0             	test   %rax,%rax
  800420ccf7:	74 0a                	je     800420cd03 <sys_ipc_try_send+0x90>
            return -E_INVAL;
  800420ccf9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ccfe:	e9 7c 01 00 00       	jmpq   800420ce7f <sys_ipc_try_send+0x20c>
        }
        if ((perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P)) {
  800420cd03:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420cd06:	83 e0 05             	and    $0x5,%eax
  800420cd09:	83 f8 05             	cmp    $0x5,%eax
  800420cd0c:	74 0a                	je     800420cd18 <sys_ipc_try_send+0xa5>
            return -E_INVAL;
  800420cd0e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd13:	e9 67 01 00 00       	jmpq   800420ce7f <sys_ipc_try_send+0x20c>
        }
        if ((perm & ~(PTE_SYSCALL)) != 0) {
  800420cd18:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420cd1b:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420cd20:	85 c0                	test   %eax,%eax
  800420cd22:	74 0a                	je     800420cd2e <sys_ipc_try_send+0xbb>
            return -E_INVAL;
  800420cd24:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd29:	e9 51 01 00 00       	jmpq   800420ce7f <sys_ipc_try_send+0x20c>
        }
        if ((pp = page_lookup(curenv->env_pml4e, srcva, &pte)) == NULL) {
  800420cd2e:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420cd35:	00 00 00 
  800420cd38:	ff d0                	callq  *%rax
  800420cd3a:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420cd41:	00 00 00 
  800420cd44:	48 98                	cltq   
  800420cd46:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd4a:	48 89 c2             	mov    %rax,%rdx
  800420cd4d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cd51:	48 29 c2             	sub    %rax,%rdx
  800420cd54:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cd58:	48 83 c0 08          	add    $0x8,%rax
  800420cd5c:	48 8b 00             	mov    (%rax),%rax
  800420cd5f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cd66:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420cd6a:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800420cd6e:	48 89 ce             	mov    %rcx,%rsi
  800420cd71:	48 89 c7             	mov    %rax,%rdi
  800420cd74:	48 b8 6e 31 20 04 80 	movabs $0x800420316e,%rax
  800420cd7b:	00 00 00 
  800420cd7e:	ff d0                	callq  *%rax
  800420cd80:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420cd84:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420cd89:	75 0a                	jne    800420cd95 <sys_ipc_try_send+0x122>
            return -E_INVAL;
  800420cd8b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd90:	e9 ea 00 00 00       	jmpq   800420ce7f <sys_ipc_try_send+0x20c>
        }
        if ((*pte & PTE_W) == 0 && (perm & PTE_W) == PTE_W) {
  800420cd95:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cd99:	48 8b 00             	mov    (%rax),%rax
  800420cd9c:	83 e0 02             	and    $0x2,%eax
  800420cd9f:	48 85 c0             	test   %rax,%rax
  800420cda2:	75 14                	jne    800420cdb8 <sys_ipc_try_send+0x145>
  800420cda4:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420cda7:	83 e0 02             	and    $0x2,%eax
  800420cdaa:	85 c0                	test   %eax,%eax
  800420cdac:	74 0a                	je     800420cdb8 <sys_ipc_try_send+0x145>
            return -E_INVAL;
  800420cdae:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cdb3:	e9 c7 00 00 00       	jmpq   800420ce7f <sys_ipc_try_send+0x20c>
        }
        if ((r = page_insert(e->env_pml4e, pp, e->env_ipc_dstva, perm)) != 0) {
  800420cdb8:	8b 4d c8             	mov    -0x38(%rbp),%ecx
  800420cdbb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cdbf:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420cdc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cdca:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cdd1:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420cdd5:	48 89 c7             	mov    %rax,%rdi
  800420cdd8:	48 b8 b9 30 20 04 80 	movabs $0x80042030b9,%rax
  800420cddf:	00 00 00 
  800420cde2:	ff d0                	callq  *%rax
  800420cde4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420cde7:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420cdeb:	74 08                	je     800420cdf5 <sys_ipc_try_send+0x182>
            return r;
  800420cded:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420cdf0:	e9 8a 00 00 00       	jmpq   800420ce7f <sys_ipc_try_send+0x20c>
        }
        e->env_ipc_perm = perm;
  800420cdf5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cdf9:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420cdfc:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420ce02:	eb 0e                	jmp    800420ce12 <sys_ipc_try_send+0x19f>
    } else {
        e->env_ipc_perm = 0;
  800420ce04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce08:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420ce0f:	00 00 00 
    }
    e->env_ipc_recving = 0;
  800420ce12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce16:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
    e->env_ipc_from = curenv->env_id;
  800420ce1d:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
  800420ce21:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420ce28:	00 00 00 
  800420ce2b:	ff d0                	callq  *%rax
  800420ce2d:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420ce34:	00 00 00 
  800420ce37:	48 98                	cltq   
  800420ce39:	48 c1 e0 03          	shl    $0x3,%rax
  800420ce3d:	48 89 c2             	mov    %rax,%rdx
  800420ce40:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ce44:	48 29 c2             	sub    %rax,%rdx
  800420ce47:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ce4b:	48 83 c0 08          	add    $0x8,%rax
  800420ce4f:	48 8b 00             	mov    (%rax),%rax
  800420ce52:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ce58:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
    e->env_ipc_value = value;
  800420ce5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce62:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ce66:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
    e->env_status = ENV_RUNNABLE;
  800420ce6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce70:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420ce77:	00 00 00 
    return 0;
  800420ce7a:	b8 00 00 00 00       	mov    $0x0,%eax
		//panic("sys_ipc_try_send not implemented");
	}
  800420ce7f:	48 83 c4 48          	add    $0x48,%rsp
  800420ce83:	5b                   	pop    %rbx
  800420ce84:	5d                   	pop    %rbp
  800420ce85:	c3                   	retq   

000000800420ce86 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420ce86:	55                   	push   %rbp
  800420ce87:	48 89 e5             	mov    %rsp,%rbp
  800420ce8a:	48 83 ec 10          	sub    $0x10,%rsp
  800420ce8e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 4: Your code here.
	if ((uint64_t)dstva < UTOP && PGOFF(dstva) != 0) {
  800420ce92:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ce96:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ce9d:	00 00 00 
  800420cea0:	48 39 c2             	cmp    %rax,%rdx
  800420cea3:	77 18                	ja     800420cebd <sys_ipc_recv+0x37>
  800420cea5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cea9:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ceae:	48 85 c0             	test   %rax,%rax
  800420ceb1:	74 0a                	je     800420cebd <sys_ipc_recv+0x37>
			return -E_INVAL;
  800420ceb3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ceb8:	e9 b4 00 00 00       	jmpq   800420cf71 <sys_ipc_recv+0xeb>
	}
	curenv->env_ipc_recving = 1;
  800420cebd:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420cec4:	00 00 00 
  800420cec7:	ff d0                	callq  *%rax
  800420cec9:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420ced0:	00 00 00 
  800420ced3:	48 98                	cltq   
  800420ced5:	48 c1 e0 03          	shl    $0x3,%rax
  800420ced9:	48 89 c2             	mov    %rax,%rdx
  800420cedc:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cee0:	48 29 c2             	sub    %rax,%rdx
  800420cee3:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cee7:	48 83 c0 08          	add    $0x8,%rax
  800420ceeb:	48 8b 00             	mov    (%rax),%rax
  800420ceee:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	curenv->env_ipc_dstva = dstva;
  800420cef5:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420cefc:	00 00 00 
  800420ceff:	ff d0                	callq  *%rax
  800420cf01:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420cf08:	00 00 00 
  800420cf0b:	48 98                	cltq   
  800420cf0d:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf11:	48 89 c2             	mov    %rax,%rdx
  800420cf14:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cf18:	48 29 c2             	sub    %rax,%rdx
  800420cf1b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cf1f:	48 83 c0 08          	add    $0x8,%rax
  800420cf23:	48 8b 00             	mov    (%rax),%rax
  800420cf26:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420cf2a:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420cf31:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420cf38:	00 00 00 
  800420cf3b:	ff d0                	callq  *%rax
  800420cf3d:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420cf44:	00 00 00 
  800420cf47:	48 98                	cltq   
  800420cf49:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf4d:	48 89 c2             	mov    %rax,%rdx
  800420cf50:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cf54:	48 29 c2             	sub    %rax,%rdx
  800420cf57:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cf5b:	48 83 c0 08          	add    $0x8,%rax
  800420cf5f:	48 8b 00             	mov    (%rax),%rax
  800420cf62:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420cf69:	00 00 00 

	//panic("sys_ipc_recv not implemented");
	return 0;
  800420cf6c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420cf71:	c9                   	leaveq 
  800420cf72:	c3                   	retq   

000000800420cf73 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420cf73:	55                   	push   %rbp
  800420cf74:	48 89 e5             	mov    %rsp,%rbp
  800420cf77:	48 83 ec 30          	sub    $0x30,%rsp
  800420cf7b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420cf7f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420cf83:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420cf87:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420cf8b:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420cf8f:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");

	switch (syscallno) {
  800420cf93:	48 83 7d f8 0d       	cmpq   $0xd,-0x8(%rbp)
  800420cf98:	0f 87 93 01 00 00    	ja     800420d131 <syscall+0x1be>
  800420cf9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfa2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420cfa9:	00 
  800420cfaa:	48 b8 08 7b 21 04 80 	movabs $0x8004217b08,%rax
  800420cfb1:	00 00 00 
  800420cfb4:	48 01 d0             	add    %rdx,%rax
  800420cfb7:	48 8b 00             	mov    (%rax),%rax
  800420cfba:	ff e0                	jmpq   *%rax
		case SYS_cputs:
			sys_cputs((const char *)a1, (size_t)a2);
  800420cfbc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cfc0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cfc4:	48 89 d6             	mov    %rdx,%rsi
  800420cfc7:	48 89 c7             	mov    %rax,%rdi
  800420cfca:	48 b8 8e c6 20 04 80 	movabs $0x800420c68e,%rax
  800420cfd1:	00 00 00 
  800420cfd4:	ff d0                	callq  *%rax
			return 0;
  800420cfd6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cfdb:	e9 58 01 00 00       	jmpq   800420d138 <syscall+0x1c5>
		case SYS_yield:
			sys_yield();
  800420cfe0:	48 b8 b2 c7 20 04 80 	movabs $0x800420c7b2,%rax
  800420cfe7:	00 00 00 
  800420cfea:	ff d0                	callq  *%rax
			return 0;
  800420cfec:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cff1:	e9 42 01 00 00       	jmpq   800420d138 <syscall+0x1c5>
		case SYS_cgetc:
			return sys_cgetc();
  800420cff6:	48 b8 13 c7 20 04 80 	movabs $0x800420c713,%rax
  800420cffd:	00 00 00 
  800420d000:	ff d0                	callq  *%rax
  800420d002:	48 98                	cltq   
  800420d004:	e9 2f 01 00 00       	jmpq   800420d138 <syscall+0x1c5>
		case SYS_getenvid:
			return sys_getenvid();
  800420d009:	48 b8 25 c7 20 04 80 	movabs $0x800420c725,%rax
  800420d010:	00 00 00 
  800420d013:	ff d0                	callq  *%rax
  800420d015:	48 98                	cltq   
  800420d017:	e9 1c 01 00 00       	jmpq   800420d138 <syscall+0x1c5>
		case SYS_env_destroy:
			return sys_env_destroy(a1);
  800420d01c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d020:	89 c7                	mov    %eax,%edi
  800420d022:	48 b8 62 c7 20 04 80 	movabs $0x800420c762,%rax
  800420d029:	00 00 00 
  800420d02c:	ff d0                	callq  *%rax
  800420d02e:	48 98                	cltq   
  800420d030:	e9 03 01 00 00       	jmpq   800420d138 <syscall+0x1c5>
		case SYS_exofork:
			return sys_exofork();
  800420d035:	48 b8 c2 c7 20 04 80 	movabs $0x800420c7c2,%rax
  800420d03c:	00 00 00 
  800420d03f:	ff d0                	callq  *%rax
  800420d041:	48 98                	cltq   
  800420d043:	e9 f0 00 00 00       	jmpq   800420d138 <syscall+0x1c5>
		case SYS_env_set_status:
			return sys_env_set_status(a1, a2);
  800420d048:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d04c:	89 c2                	mov    %eax,%edx
  800420d04e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d052:	89 d6                	mov    %edx,%esi
  800420d054:	89 c7                	mov    %eax,%edi
  800420d056:	48 b8 99 c8 20 04 80 	movabs $0x800420c899,%rax
  800420d05d:	00 00 00 
  800420d060:	ff d0                	callq  *%rax
  800420d062:	48 98                	cltq   
  800420d064:	e9 cf 00 00 00       	jmpq   800420d138 <syscall+0x1c5>
		case SYS_page_alloc:
			return sys_page_alloc((envid_t)a1, (void *)a2, (int)a3);
  800420d069:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d06d:	89 c2                	mov    %eax,%edx
  800420d06f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d073:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d077:	48 89 ce             	mov    %rcx,%rsi
  800420d07a:	89 c7                	mov    %eax,%edi
  800420d07c:	48 b8 82 c9 20 04 80 	movabs $0x800420c982,%rax
  800420d083:	00 00 00 
  800420d086:	ff d0                	callq  *%rax
  800420d088:	48 98                	cltq   
  800420d08a:	e9 a9 00 00 00       	jmpq   800420d138 <syscall+0x1c5>
		case SYS_page_map:
			return sys_page_map((envid_t)a1, (void *)a2, (envid_t)a3, (void *)a4, (int)a5);
  800420d08f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d093:	89 c7                	mov    %eax,%edi
  800420d095:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420d099:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d09d:	89 c2                	mov    %eax,%edx
  800420d09f:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420d0a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d0a7:	41 89 f8             	mov    %edi,%r8d
  800420d0aa:	89 c7                	mov    %eax,%edi
  800420d0ac:	48 b8 73 ca 20 04 80 	movabs $0x800420ca73,%rax
  800420d0b3:	00 00 00 
  800420d0b6:	ff d0                	callq  *%rax
  800420d0b8:	48 98                	cltq   
  800420d0ba:	eb 7c                	jmp    800420d138 <syscall+0x1c5>
		case SYS_page_unmap:
			return sys_page_unmap((envid_t)a1, (void *)a2);
  800420d0bc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d0c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d0c4:	48 89 d6             	mov    %rdx,%rsi
  800420d0c7:	89 c7                	mov    %eax,%edi
  800420d0c9:	48 b8 e9 cb 20 04 80 	movabs $0x800420cbe9,%rax
  800420d0d0:	00 00 00 
  800420d0d3:	ff d0                	callq  *%rax
  800420d0d5:	48 98                	cltq   
  800420d0d7:	eb 5f                	jmp    800420d138 <syscall+0x1c5>
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall((envid_t)a1, (void *)a2);
  800420d0d9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d0dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d0e1:	48 89 d6             	mov    %rdx,%rsi
  800420d0e4:	89 c7                	mov    %eax,%edi
  800420d0e6:	48 b8 32 c9 20 04 80 	movabs $0x800420c932,%rax
  800420d0ed:	00 00 00 
  800420d0f0:	ff d0                	callq  *%rax
  800420d0f2:	48 98                	cltq   
  800420d0f4:	eb 42                	jmp    800420d138 <syscall+0x1c5>
		case SYS_ipc_recv:
	    return sys_ipc_recv((void *)a1);
  800420d0f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d0fa:	48 89 c7             	mov    %rax,%rdi
  800420d0fd:	48 b8 86 ce 20 04 80 	movabs $0x800420ce86,%rax
  800420d104:	00 00 00 
  800420d107:	ff d0                	callq  *%rax
  800420d109:	48 98                	cltq   
  800420d10b:	eb 2b                	jmp    800420d138 <syscall+0x1c5>
		case SYS_ipc_try_send:
	    return sys_ipc_try_send(a1, a2, (void *)a3, a4);
  800420d10d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d111:	89 c1                	mov    %eax,%ecx
  800420d113:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d117:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d11b:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420d11f:	89 c7                	mov    %eax,%edi
  800420d121:	48 b8 73 cc 20 04 80 	movabs $0x800420cc73,%rax
  800420d128:	00 00 00 
  800420d12b:	ff d0                	callq  *%rax
  800420d12d:	48 98                	cltq   
  800420d12f:	eb 07                	jmp    800420d138 <syscall+0x1c5>
		default:
			return -E_INVAL;
  800420d131:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
	}
}
  800420d138:	c9                   	leaveq 
  800420d139:	c3                   	retq   

000000800420d13a <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420d13a:	55                   	push   %rbp
  800420d13b:	48 89 e5             	mov    %rsp,%rbp
  800420d13e:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420d145:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420d14c:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420d153:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420d15a:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d161:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420d168:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420d16c:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d173:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d17a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420d17e:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420d185:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d18c:	48 89 d1             	mov    %rdx,%rcx
  800420d18f:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d194:	48 89 ce             	mov    %rcx,%rsi
  800420d197:	48 89 c7             	mov    %rax,%rdi
  800420d19a:	48 b8 ed ed 20 04 80 	movabs $0x800420eded,%rax
  800420d1a1:	00 00 00 
  800420d1a4:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420d1a6:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420d1ad:	00 
	uint64_t ret_offset=0;
  800420d1ae:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d1b5:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420d1b6:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d1bd:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d1c1:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420d1c5:	74 0a                	je     800420d1d1 <list_func_die+0x97>
		return 0;
  800420d1c7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d1cc:	e9 cd 06 00 00       	jmpq   800420d89e <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420d1d1:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420d1d8:	ba 38 00 00 00       	mov    $0x38,%edx
  800420d1dd:	be 00 00 00 00       	mov    $0x0,%esi
  800420d1e2:	48 89 c7             	mov    %rax,%rdi
  800420d1e5:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  800420d1ec:	00 00 00 
  800420d1ef:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420d1f1:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d1f8:	be 11 00 00 00       	mov    $0x11,%esi
  800420d1fd:	48 89 c7             	mov    %rax,%rdi
  800420d200:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d207:	00 00 00 
  800420d20a:	ff d0                	callq  *%rax
  800420d20c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420d210:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d217:	be 12 00 00 00       	mov    $0x12,%esi
  800420d21c:	48 89 c7             	mov    %rax,%rdi
  800420d21f:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d226:	00 00 00 
  800420d229:	ff d0                	callq  *%rax
  800420d22b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420d22f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420d234:	0f 84 5f 06 00 00    	je     800420d899 <list_func_die+0x75f>
  800420d23a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d23e:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d242:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420d249:	0f 83 4a 06 00 00    	jae    800420d899 <list_func_die+0x75f>
  800420d24f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420d254:	0f 84 3f 06 00 00    	je     800420d899 <list_func_die+0x75f>
  800420d25a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d25e:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d262:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420d269:	0f 86 2a 06 00 00    	jbe    800420d899 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420d26f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d276:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d27d:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420d284:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d28b:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420d28e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d295:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420d29c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d2a3:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420d2a7:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d2ae:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420d2b5:	48 89 c7             	mov    %rax,%rdi
  800420d2b8:	48 b8 46 e9 20 04 80 	movabs $0x800420e946,%rax
  800420d2bf:	00 00 00 
  800420d2c2:	ff d0                	callq  *%rax
  800420d2c4:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420d2cb:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420d2ce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d2d2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420d2d6:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d2dd:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420d2e1:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d2e8:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d2ef:	48 85 c0             	test   %rax,%rax
  800420d2f2:	75 35                	jne    800420d329 <list_func_die+0x1ef>
  800420d2f4:	48 b9 a0 7e 21 04 80 	movabs $0x8004217ea0,%rcx
  800420d2fb:	00 00 00 
  800420d2fe:	48 ba ac 7e 21 04 80 	movabs $0x8004217eac,%rdx
  800420d305:	00 00 00 
  800420d308:	be 91 00 00 00       	mov    $0x91,%esi
  800420d30d:	48 bf c1 7e 21 04 80 	movabs $0x8004217ec1,%rdi
  800420d314:	00 00 00 
  800420d317:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d31c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420d323:	00 00 00 
  800420d326:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420d329:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d330:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d337:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420d33e:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420d345:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420d34a:	48 89 c7             	mov    %rax,%rdi
  800420d34d:	48 b8 a7 41 21 04 80 	movabs $0x80042141a7,%rax
  800420d354:	00 00 00 
  800420d357:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420d359:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d360:	89 c2                	mov    %eax,%edx
  800420d362:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d369:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420d36c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d373:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420d37a:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420d381:	00 00 00 
  800420d384:	48 8b 00             	mov    (%rax),%rax
  800420d387:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d38e:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d395:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420d399:	48 89 c7             	mov    %rax,%rdi
  800420d39c:	48 b8 57 0e 21 04 80 	movabs $0x8004210e57,%rax
  800420d3a3:	00 00 00 
  800420d3a6:	ff d0                	callq  *%rax
  800420d3a8:	83 f8 04             	cmp    $0x4,%eax
  800420d3ab:	0f 84 e1 04 00 00    	je     800420d892 <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420d3b1:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d3b8:	48 83 f8 05          	cmp    $0x5,%rax
  800420d3bc:	74 05                	je     800420d3c3 <list_func_die+0x289>
				goto last;
  800420d3be:	e9 cf 04 00 00       	jmpq   800420d892 <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d3c3:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d3ca:	be 49 00 00 00       	mov    $0x49,%esi
  800420d3cf:	48 89 c7             	mov    %rax,%rdi
  800420d3d2:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d3d9:	00 00 00 
  800420d3dc:	ff d0                	callq  *%rax
  800420d3de:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420d3e2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d3e7:	0f 84 d7 00 00 00    	je     800420d4c4 <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d3ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d3f1:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d3f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d3f9:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d3fd:	48 01 d0             	add    %rdx,%rax
  800420d400:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420d404:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420d40b:	00 00 00 
  800420d40e:	48 8b 08             	mov    (%rax),%rcx
  800420d411:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d418:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d41c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d420:	48 8b 38             	mov    (%rax),%rdi
  800420d423:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d427:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d42b:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d430:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d434:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d439:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d43d:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d442:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d446:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d44b:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d44f:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d454:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d458:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d45d:	48 89 cf             	mov    %rcx,%rdi
  800420d460:	48 b8 7d 0a 21 04 80 	movabs $0x8004210a7d,%rax
  800420d467:	00 00 00 
  800420d46a:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d46c:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d473:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d478:	48 89 c7             	mov    %rax,%rdi
  800420d47b:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d482:	00 00 00 
  800420d485:	ff d0                	callq  *%rax
  800420d487:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420d48b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d490:	74 0e                	je     800420d4a0 <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420d492:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d496:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d49a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d49e:	eb 24                	jmp    800420d4c4 <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420d4a0:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d4a7:	be 49 00 00 00       	mov    $0x49,%esi
  800420d4ac:	48 89 c7             	mov    %rax,%rdi
  800420d4af:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d4b6:	00 00 00 
  800420d4b9:	ff d0                	callq  *%rax
  800420d4bb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420d4bf:	e9 1e ff ff ff       	jmpq   800420d3e2 <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420d4c4:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d4cb:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d4cc:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d4d3:	be 02 00 00 00       	mov    $0x2,%esi
  800420d4d8:	48 89 c7             	mov    %rax,%rdi
  800420d4db:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d4e2:	00 00 00 
  800420d4e5:	ff d0                	callq  *%rax
  800420d4e7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420d4eb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d4f0:	0f 84 a2 00 00 00    	je     800420d598 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d4f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d4fa:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d4fe:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d502:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d506:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d50a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420d50e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d512:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d516:	48 83 f8 03          	cmp    $0x3,%rax
  800420d51a:	72 7c                	jb     800420d598 <list_func_die+0x45e>
  800420d51c:	48 83 f8 04          	cmp    $0x4,%rax
  800420d520:	76 06                	jbe    800420d528 <list_func_die+0x3ee>
  800420d522:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d526:	75 70                	jne    800420d598 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420d528:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d52f:	00 
						atom = *(loc_ptr++);
  800420d530:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d534:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d538:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420d53c:	0f b6 00             	movzbl (%rax),%eax
  800420d53f:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420d542:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420d547:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420d54b:	75 4a                	jne    800420d597 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420d54d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d551:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420d558:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420d55f:	48 89 c7             	mov    %rax,%rdi
  800420d562:	48 b8 dc f7 20 04 80 	movabs $0x800420f7dc,%rax
  800420d569:	00 00 00 
  800420d56c:	ff d0                	callq  *%rax
  800420d56e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420d572:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d579:	48 89 c2             	mov    %rax,%rdx
  800420d57c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d580:	48 29 c2             	sub    %rax,%rdx
  800420d583:	48 89 d0             	mov    %rdx,%rax
  800420d586:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420d58a:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d591:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420d595:	eb 00                	jmp    800420d597 <list_func_die+0x45d>
  800420d597:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420d598:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d59f:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d5a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d5a6:	89 c2                	mov    %eax,%edx
  800420d5a8:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d5af:	48 63 c9             	movslq %ecx,%rcx
  800420d5b2:	48 83 c1 08          	add    $0x8,%rcx
  800420d5b6:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420d5ba:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d5c1:	8b 50 28             	mov    0x28(%rax),%edx
  800420d5c4:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d5cb:	48 63 d2             	movslq %edx,%rdx
  800420d5ce:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d5d2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d5d6:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420d5db:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d5e2:	8b 40 28             	mov    0x28(%rax),%eax
  800420d5e5:	8d 50 01             	lea    0x1(%rax),%edx
  800420d5e8:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d5ef:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420d5f2:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d5f9:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d600:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d605:	48 89 ce             	mov    %rcx,%rsi
  800420d608:	48 89 c7             	mov    %rax,%rdi
  800420d60b:	48 b8 ed ed 20 04 80 	movabs $0x800420eded,%rax
  800420d612:	00 00 00 
  800420d615:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d617:	e9 40 02 00 00       	jmpq   800420d85c <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420d61c:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d623:	48 83 f8 05          	cmp    $0x5,%rax
  800420d627:	74 05                	je     800420d62e <list_func_die+0x4f4>
					break;
  800420d629:	e9 64 02 00 00       	jmpq   800420d892 <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d62e:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d635:	be 49 00 00 00       	mov    $0x49,%esi
  800420d63a:	48 89 c7             	mov    %rax,%rdi
  800420d63d:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d644:	00 00 00 
  800420d647:	ff d0                	callq  *%rax
  800420d649:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420d64d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d652:	0f 84 b1 00 00 00    	je     800420d709 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d658:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d65c:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d660:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d664:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d668:	48 01 d0             	add    %rdx,%rax
  800420d66b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420d66f:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420d676:	00 00 00 
  800420d679:	48 8b 08             	mov    (%rax),%rcx
  800420d67c:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d683:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d687:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d68b:	48 8b 38             	mov    (%rax),%rdi
  800420d68e:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d692:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d696:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d69b:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d69f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d6a4:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d6a8:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d6ad:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d6b1:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d6b6:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d6ba:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d6bf:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d6c3:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d6c8:	48 89 cf             	mov    %rcx,%rdi
  800420d6cb:	48 b8 7d 0a 21 04 80 	movabs $0x8004210a7d,%rax
  800420d6d2:	00 00 00 
  800420d6d5:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d6d7:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d6de:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d6e3:	48 89 c7             	mov    %rax,%rdi
  800420d6e6:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d6ed:	00 00 00 
  800420d6f0:	ff d0                	callq  *%rax
  800420d6f2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420d6f6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d6fb:	74 0c                	je     800420d709 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420d6fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d701:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d705:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420d709:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d710:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d711:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d718:	be 02 00 00 00       	mov    $0x2,%esi
  800420d71d:	48 89 c7             	mov    %rax,%rdi
  800420d720:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  800420d727:	00 00 00 
  800420d72a:	ff d0                	callq  *%rax
  800420d72c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420d730:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d735:	0f 84 a2 00 00 00    	je     800420d7dd <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d73b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d73f:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d743:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d747:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d74b:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d74f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420d753:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d757:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d75b:	48 83 f8 03          	cmp    $0x3,%rax
  800420d75f:	72 7c                	jb     800420d7dd <list_func_die+0x6a3>
  800420d761:	48 83 f8 04          	cmp    $0x4,%rax
  800420d765:	76 06                	jbe    800420d76d <list_func_die+0x633>
  800420d767:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d76b:	75 70                	jne    800420d7dd <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420d76d:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d774:	00 
							atom = *(loc_ptr++);
  800420d775:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d779:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d77d:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420d781:	0f b6 00             	movzbl (%rax),%eax
  800420d784:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420d787:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420d78c:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420d790:	75 4a                	jne    800420d7dc <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420d792:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d796:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420d79d:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420d7a4:	48 89 c7             	mov    %rax,%rdi
  800420d7a7:	48 b8 dc f7 20 04 80 	movabs $0x800420f7dc,%rax
  800420d7ae:	00 00 00 
  800420d7b1:	ff d0                	callq  *%rax
  800420d7b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420d7b7:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d7be:	48 89 c2             	mov    %rax,%rdx
  800420d7c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d7c5:	48 29 c2             	sub    %rax,%rdx
  800420d7c8:	48 89 d0             	mov    %rdx,%rax
  800420d7cb:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420d7cf:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d7d6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420d7da:	eb 00                	jmp    800420d7dc <list_func_die+0x6a2>
  800420d7dc:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420d7dd:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d7e4:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d7e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d7eb:	89 c2                	mov    %eax,%edx
  800420d7ed:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d7f4:	48 63 c9             	movslq %ecx,%rcx
  800420d7f7:	48 83 c1 08          	add    $0x8,%rcx
  800420d7fb:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420d7ff:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d806:	8b 50 28             	mov    0x28(%rax),%edx
  800420d809:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d810:	48 63 d2             	movslq %edx,%rdx
  800420d813:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d817:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d81b:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420d820:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d827:	8b 40 28             	mov    0x28(%rax),%eax
  800420d82a:	8d 50 01             	lea    0x1(%rax),%edx
  800420d82d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d834:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420d837:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d83e:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d845:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d84a:	48 89 ce             	mov    %rcx,%rsi
  800420d84d:	48 89 c7             	mov    %rax,%rdi
  800420d850:	48 b8 ed ed 20 04 80 	movabs $0x800420eded,%rax
  800420d857:	00 00 00 
  800420d85a:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d85c:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420d863:	00 00 00 
  800420d866:	48 8b 00             	mov    (%rax),%rax
  800420d869:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420d86d:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420d874:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420d87b:	48 89 c7             	mov    %rax,%rdi
  800420d87e:	48 b8 13 0c 21 04 80 	movabs $0x8004210c13,%rax
  800420d885:	00 00 00 
  800420d888:	ff d0                	callq  *%rax
  800420d88a:	85 c0                	test   %eax,%eax
  800420d88c:	0f 84 8a fd ff ff    	je     800420d61c <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420d892:	b8 01 00 00 00       	mov    $0x1,%eax
  800420d897:	eb 05                	jmp    800420d89e <list_func_die+0x764>
	}

	return 0;
  800420d899:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d89e:	c9                   	leaveq 
  800420d89f:	c3                   	retq   

000000800420d8a0 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420d8a0:	55                   	push   %rbp
  800420d8a1:	48 89 e5             	mov    %rsp,%rbp
  800420d8a4:	53                   	push   %rbx
  800420d8a5:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420d8ac:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420d8b3:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420d8ba:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420d8c1:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420d8c2:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420d8c9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420d8cd:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d8d4:	48 bb cf 7e 21 04 80 	movabs $0x8004217ecf,%rbx
  800420d8db:	00 00 00 
  800420d8de:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420d8e1:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d8e8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420d8ef:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d8f6:	48 bb cf 7e 21 04 80 	movabs $0x8004217ecf,%rbx
  800420d8fd:	00 00 00 
  800420d900:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420d904:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d90b:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420d912:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d919:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420d920:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420d924:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420d92b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420d932:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420d939:	00 00 00 
  800420d93c:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420d943:	76 13                	jbe    800420d958 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420d945:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420d94c:	00 00 00 
  800420d94f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420d953:	e9 08 01 00 00       	jmpq   800420da60 <debuginfo_rip+0x1c0>
	} else {
		if(curenv != lastenv) {
  800420d958:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420d95f:	00 00 00 
  800420d962:	ff d0                	callq  *%rax
  800420d964:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420d96b:	00 00 00 
  800420d96e:	48 98                	cltq   
  800420d970:	48 c1 e0 03          	shl    $0x3,%rax
  800420d974:	48 89 c2             	mov    %rax,%rdx
  800420d977:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d97b:	48 29 c2             	sub    %rax,%rdx
  800420d97e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d982:	48 83 c0 08          	add    $0x8,%rax
  800420d986:	48 8b 10             	mov    (%rax),%rdx
  800420d989:	48 b8 98 f2 6b 04 80 	movabs $0x80046bf298,%rax
  800420d990:	00 00 00 
  800420d993:	48 8b 00             	mov    (%rax),%rax
  800420d996:	48 39 c2             	cmp    %rax,%rdx
  800420d999:	0f 84 85 00 00 00    	je     800420da24 <debuginfo_rip+0x184>
			find_debug_sections((uintptr_t)curenv->elf);
  800420d99f:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420d9a6:	00 00 00 
  800420d9a9:	ff d0                	callq  *%rax
  800420d9ab:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420d9b2:	00 00 00 
  800420d9b5:	48 98                	cltq   
  800420d9b7:	48 c1 e0 03          	shl    $0x3,%rax
  800420d9bb:	48 89 c2             	mov    %rax,%rdx
  800420d9be:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d9c2:	48 29 c2             	sub    %rax,%rdx
  800420d9c5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d9c9:	48 83 c0 08          	add    $0x8,%rax
  800420d9cd:	48 8b 00             	mov    (%rax),%rax
  800420d9d0:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420d9d7:	48 89 c7             	mov    %rax,%rdi
  800420d9da:	48 b8 a2 43 21 04 80 	movabs $0x80042143a2,%rax
  800420d9e1:	00 00 00 
  800420d9e4:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420d9e6:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420d9ed:	00 00 00 
  800420d9f0:	ff d0                	callq  *%rax
  800420d9f2:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420d9f9:	00 00 00 
  800420d9fc:	48 98                	cltq   
  800420d9fe:	48 c1 e0 03          	shl    $0x3,%rax
  800420da02:	48 89 c2             	mov    %rax,%rdx
  800420da05:	48 c1 e2 04          	shl    $0x4,%rdx
  800420da09:	48 29 c2             	sub    %rax,%rdx
  800420da0c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420da10:	48 83 c0 08          	add    $0x8,%rax
  800420da14:	48 8b 10             	mov    (%rax),%rdx
  800420da17:	48 b8 98 f2 6b 04 80 	movabs $0x80046bf298,%rax
  800420da1e:	00 00 00 
  800420da21:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420da24:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  800420da2b:	00 00 00 
  800420da2e:	ff d0                	callq  *%rax
  800420da30:	48 b9 20 10 6c 04 80 	movabs $0x80046c1020,%rcx
  800420da37:	00 00 00 
  800420da3a:	48 98                	cltq   
  800420da3c:	48 c1 e0 03          	shl    $0x3,%rax
  800420da40:	48 89 c2             	mov    %rax,%rdx
  800420da43:	48 c1 e2 04          	shl    $0x4,%rdx
  800420da47:	48 29 c2             	sub    %rax,%rdx
  800420da4a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420da4e:	48 83 c0 08          	add    $0x8,%rax
  800420da52:	48 8b 00             	mov    (%rax),%rax
  800420da55:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420da5c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420da60:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420da67:	00 00 00 
  800420da6a:	48 8b 00             	mov    (%rax),%rax
  800420da6d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da71:	48 89 d6             	mov    %rdx,%rsi
  800420da74:	48 89 c7             	mov    %rax,%rdi
  800420da77:	48 b8 8b fa 20 04 80 	movabs $0x800420fa8b,%rax
  800420da7e:	00 00 00 
  800420da81:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420da83:	48 bf d9 7e 21 04 80 	movabs $0x8004217ed9,%rdi
  800420da8a:	00 00 00 
  800420da8d:	48 b8 22 43 21 04 80 	movabs $0x8004214322,%rax
  800420da94:	00 00 00 
  800420da97:	ff d0                	callq  *%rax
  800420da99:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420da9d:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420daa4:	00 00 00 
  800420daa7:	48 8b 00             	mov    (%rax),%rax
  800420daaa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420daae:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420dab2:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420dab6:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dabd:	00 00 00 
  800420dac0:	48 8b 00             	mov    (%rax),%rax
  800420dac3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dac7:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420dacb:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420dacf:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dad6:	00 00 00 
  800420dad9:	48 8b 00             	mov    (%rax),%rax
  800420dadc:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420dae0:	48 85 c0             	test   %rax,%rax
  800420dae3:	75 35                	jne    800420db1a <debuginfo_rip+0x27a>
  800420dae5:	48 b9 e5 7e 21 04 80 	movabs $0x8004217ee5,%rcx
  800420daec:	00 00 00 
  800420daef:	48 ba ac 7e 21 04 80 	movabs $0x8004217eac,%rdx
  800420daf6:	00 00 00 
  800420daf9:	be 37 01 00 00       	mov    $0x137,%esi
  800420dafe:	48 bf c1 7e 21 04 80 	movabs $0x8004217ec1,%rdi
  800420db05:	00 00 00 
  800420db08:	b8 00 00 00 00       	mov    $0x0,%eax
  800420db0d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420db14:	00 00 00 
  800420db17:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420db1a:	e9 6f 01 00 00       	jmpq   800420dc8e <debuginfo_rip+0x3ee>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420db1f:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420db26:	00 00 00 
  800420db29:	48 8b 00             	mov    (%rax),%rax
  800420db2c:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420db30:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420db37:	be 00 00 00 00       	mov    $0x0,%esi
  800420db3c:	48 89 c7             	mov    %rax,%rdi
  800420db3f:	48 b8 13 0c 21 04 80 	movabs $0x8004210c13,%rax
  800420db46:	00 00 00 
  800420db49:	ff d0                	callq  *%rax
  800420db4b:	83 f8 04             	cmp    $0x4,%eax
  800420db4e:	75 05                	jne    800420db55 <debuginfo_rip+0x2b5>
			continue;
  800420db50:	e9 39 01 00 00       	jmpq   800420dc8e <debuginfo_rip+0x3ee>

		cudie.cu_header = &cu;
  800420db55:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420db59:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420db60:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420db67:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420db6b:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420db72:	00 00 00 
  800420db75:	48 8b 00             	mov    (%rax),%rax
  800420db78:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420db7f:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420db86:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420db8a:	48 89 c7             	mov    %rax,%rdi
  800420db8d:	48 b8 57 0e 21 04 80 	movabs $0x8004210e57,%rax
  800420db94:	00 00 00 
  800420db97:	ff d0                	callq  *%rax
  800420db99:	83 f8 04             	cmp    $0x4,%eax
  800420db9c:	75 05                	jne    800420dba3 <debuginfo_rip+0x303>
			continue;
  800420db9e:	e9 eb 00 00 00       	jmpq   800420dc8e <debuginfo_rip+0x3ee>

		die.cu_header = &cu;
  800420dba3:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420dba7:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420dbae:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420dbb5:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420dbbc:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420dbc3:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420dbca:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dbd1:	48 89 ce             	mov    %rcx,%rsi
  800420dbd4:	48 89 c7             	mov    %rax,%rdi
  800420dbd7:	48 b8 3a d1 20 04 80 	movabs $0x800420d13a,%rax
  800420dbde:	00 00 00 
  800420dbe1:	ff d0                	callq  *%rax
  800420dbe3:	85 c0                	test   %eax,%eax
  800420dbe5:	74 30                	je     800420dc17 <debuginfo_rip+0x377>
				goto find_done;
  800420dbe7:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420dbe8:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dbef:	00 00 00 
  800420dbf2:	48 8b 00             	mov    (%rax),%rax
  800420dbf5:	be 00 00 00 00       	mov    $0x0,%esi
  800420dbfa:	48 89 c7             	mov    %rax,%rdi
  800420dbfd:	48 b8 2f 35 21 04 80 	movabs $0x800421352f,%rax
  800420dc04:	00 00 00 
  800420dc07:	ff d0                	callq  *%rax
  800420dc09:	83 f8 01             	cmp    $0x1,%eax
  800420dc0c:	0f 85 bb 00 00 00    	jne    800420dccd <debuginfo_rip+0x42d>
  800420dc12:	e9 ac 00 00 00       	jmpq   800420dcc3 <debuginfo_rip+0x423>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420dc17:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dc1e:	00 00 00 
  800420dc21:	48 8b 00             	mov    (%rax),%rax
  800420dc24:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420dc28:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420dc2f:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420dc36:	48 89 c7             	mov    %rax,%rdi
  800420dc39:	48 b8 13 0c 21 04 80 	movabs $0x8004210c13,%rax
  800420dc40:	00 00 00 
  800420dc43:	ff d0                	callq  *%rax
  800420dc45:	85 c0                	test   %eax,%eax
  800420dc47:	79 02                	jns    800420dc4b <debuginfo_rip+0x3ab>
				break; 
  800420dc49:	eb 43                	jmp    800420dc8e <debuginfo_rip+0x3ee>
			die = die2;
  800420dc4b:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420dc52:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420dc59:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420dc5e:	48 89 ce             	mov    %rcx,%rsi
  800420dc61:	48 89 c7             	mov    %rax,%rdi
  800420dc64:	48 b8 ed ed 20 04 80 	movabs $0x800420eded,%rax
  800420dc6b:	00 00 00 
  800420dc6e:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420dc70:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420dc74:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420dc7b:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420dc82:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420dc89:	e9 2e ff ff ff       	jmpq   800420dbbc <debuginfo_rip+0x31c>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420dc8e:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dc95:	00 00 00 
  800420dc98:	48 8b 00             	mov    (%rax),%rax
  800420dc9b:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420dc9f:	48 89 d6             	mov    %rdx,%rsi
  800420dca2:	48 89 c7             	mov    %rax,%rdi
  800420dca5:	48 b8 6d fb 20 04 80 	movabs $0x800420fb6d,%rax
  800420dcac:	00 00 00 
  800420dcaf:	ff d0                	callq  *%rax
  800420dcb1:	85 c0                	test   %eax,%eax
  800420dcb3:	0f 84 66 fe ff ff    	je     800420db1f <debuginfo_rip+0x27f>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800420dcb9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420dcbe:	e9 a0 00 00 00       	jmpq   800420dd63 <debuginfo_rip+0x4c3>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420dcc3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420dcc8:	e9 96 00 00 00       	jmpq   800420dd63 <debuginfo_rip+0x4c3>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420dccd:	48 b8 80 b6 22 04 80 	movabs $0x800422b680,%rax
  800420dcd4:	00 00 00 
  800420dcd7:	48 8b 08             	mov    (%rax),%rcx
  800420dcda:	48 b8 78 b6 22 04 80 	movabs $0x800422b678,%rax
  800420dce1:	00 00 00 
  800420dce4:	48 8b 10             	mov    (%rax),%rdx
  800420dce7:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dcee:	00 00 00 
  800420dcf1:	48 8b 00             	mov    (%rax),%rax
  800420dcf4:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420dcfb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420dd01:	48 89 c7             	mov    %rax,%rdi
  800420dd04:	48 b8 98 10 21 04 80 	movabs $0x8004211098,%rax
  800420dd0b:	00 00 00 
  800420dd0e:	ff d0                	callq  *%rax
  800420dd10:	85 c0                	test   %eax,%eax
  800420dd12:	75 4a                	jne    800420dd5e <debuginfo_rip+0x4be>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420dd14:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dd1b:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420dd22:	48 b8 78 b6 22 04 80 	movabs $0x800422b678,%rax
  800420dd29:	00 00 00 
  800420dd2c:	48 8b 30             	mov    (%rax),%rsi
  800420dd2f:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420dd36:	00 00 00 
  800420dd39:	48 8b 00             	mov    (%rax),%rax
  800420dd3c:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420dd43:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420dd49:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420dd4f:	48 89 c7             	mov    %rax,%rdi
  800420dd52:	48 b8 a4 23 21 04 80 	movabs $0x80042123a4,%rax
  800420dd59:	00 00 00 
  800420dd5c:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420dd5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dd63:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420dd6a:	5b                   	pop    %rbx
  800420dd6b:	5d                   	pop    %rbp
  800420dd6c:	c3                   	retq   

000000800420dd6d <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420dd6d:	55                   	push   %rbp
  800420dd6e:	48 89 e5             	mov    %rsp,%rbp
  800420dd71:	53                   	push   %rbx
  800420dd72:	48 83 ec 38          	sub    $0x38,%rsp
  800420dd76:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dd7a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420dd7e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420dd82:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420dd85:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420dd89:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420dd8d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420dd90:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420dd94:	77 3b                	ja     800420ddd1 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420dd96:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420dd99:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420dd9d:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420dda0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dda4:	ba 00 00 00 00       	mov    $0x0,%edx
  800420dda9:	48 f7 f3             	div    %rbx
  800420ddac:	48 89 c2             	mov    %rax,%rdx
  800420ddaf:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420ddb2:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ddb5:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ddb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ddbd:	41 89 f9             	mov    %edi,%r9d
  800420ddc0:	48 89 c7             	mov    %rax,%rdi
  800420ddc3:	48 b8 6d dd 20 04 80 	movabs $0x800420dd6d,%rax
  800420ddca:	00 00 00 
  800420ddcd:	ff d0                	callq  *%rax
  800420ddcf:	eb 1e                	jmp    800420ddef <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ddd1:	eb 12                	jmp    800420dde5 <printnum+0x78>
			putch(padc, putdat);
  800420ddd3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ddd7:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420ddda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ddde:	48 89 ce             	mov    %rcx,%rsi
  800420dde1:	89 d7                	mov    %edx,%edi
  800420dde3:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420dde5:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420dde9:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420dded:	7f e4                	jg     800420ddd3 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420ddef:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ddf2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ddf6:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ddfb:	48 f7 f1             	div    %rcx
  800420ddfe:	48 89 d0             	mov    %rdx,%rax
  800420de01:	48 ba f0 80 21 04 80 	movabs $0x80042180f0,%rdx
  800420de08:	00 00 00 
  800420de0b:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420de0f:	0f be d0             	movsbl %al,%edx
  800420de12:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420de16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de1a:	48 89 ce             	mov    %rcx,%rsi
  800420de1d:	89 d7                	mov    %edx,%edi
  800420de1f:	ff d0                	callq  *%rax
}
  800420de21:	48 83 c4 38          	add    $0x38,%rsp
  800420de25:	5b                   	pop    %rbx
  800420de26:	5d                   	pop    %rbp
  800420de27:	c3                   	retq   

000000800420de28 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420de28:	55                   	push   %rbp
  800420de29:	48 89 e5             	mov    %rsp,%rbp
  800420de2c:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420de30:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420de34:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;
	if (lflag >= 2)
  800420de37:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420de3b:	7e 52                	jle    800420de8f <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420de3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de41:	8b 00                	mov    (%rax),%eax
  800420de43:	83 f8 30             	cmp    $0x30,%eax
  800420de46:	73 24                	jae    800420de6c <getuint+0x44>
  800420de48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de4c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420de50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de54:	8b 00                	mov    (%rax),%eax
  800420de56:	89 c0                	mov    %eax,%eax
  800420de58:	48 01 d0             	add    %rdx,%rax
  800420de5b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420de5f:	8b 12                	mov    (%rdx),%edx
  800420de61:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420de64:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420de68:	89 0a                	mov    %ecx,(%rdx)
  800420de6a:	eb 17                	jmp    800420de83 <getuint+0x5b>
  800420de6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de70:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420de74:	48 89 d0             	mov    %rdx,%rax
  800420de77:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420de7b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420de7f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420de83:	48 8b 00             	mov    (%rax),%rax
  800420de86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420de8a:	e9 a3 00 00 00       	jmpq   800420df32 <getuint+0x10a>
	else if (lflag)
  800420de8f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420de93:	74 4f                	je     800420dee4 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420de95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de99:	8b 00                	mov    (%rax),%eax
  800420de9b:	83 f8 30             	cmp    $0x30,%eax
  800420de9e:	73 24                	jae    800420dec4 <getuint+0x9c>
  800420dea0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dea4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420dea8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420deac:	8b 00                	mov    (%rax),%eax
  800420deae:	89 c0                	mov    %eax,%eax
  800420deb0:	48 01 d0             	add    %rdx,%rax
  800420deb3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420deb7:	8b 12                	mov    (%rdx),%edx
  800420deb9:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420debc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dec0:	89 0a                	mov    %ecx,(%rdx)
  800420dec2:	eb 17                	jmp    800420dedb <getuint+0xb3>
  800420dec4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dec8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420decc:	48 89 d0             	mov    %rdx,%rax
  800420decf:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ded3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ded7:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420dedb:	48 8b 00             	mov    (%rax),%rax
  800420dede:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420dee2:	eb 4e                	jmp    800420df32 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420dee4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dee8:	8b 00                	mov    (%rax),%eax
  800420deea:	83 f8 30             	cmp    $0x30,%eax
  800420deed:	73 24                	jae    800420df13 <getuint+0xeb>
  800420deef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420def3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420def7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420defb:	8b 00                	mov    (%rax),%eax
  800420defd:	89 c0                	mov    %eax,%eax
  800420deff:	48 01 d0             	add    %rdx,%rax
  800420df02:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df06:	8b 12                	mov    (%rdx),%edx
  800420df08:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420df0b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df0f:	89 0a                	mov    %ecx,(%rdx)
  800420df11:	eb 17                	jmp    800420df2a <getuint+0x102>
  800420df13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df17:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420df1b:	48 89 d0             	mov    %rdx,%rax
  800420df1e:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420df22:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df26:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420df2a:	8b 00                	mov    (%rax),%eax
  800420df2c:	89 c0                	mov    %eax,%eax
  800420df2e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420df32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420df36:	c9                   	leaveq 
  800420df37:	c3                   	retq   

000000800420df38 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420df38:	55                   	push   %rbp
  800420df39:	48 89 e5             	mov    %rsp,%rbp
  800420df3c:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420df40:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420df44:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420df47:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420df4b:	7e 52                	jle    800420df9f <getint+0x67>
		x=va_arg(*ap, long long);
  800420df4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df51:	8b 00                	mov    (%rax),%eax
  800420df53:	83 f8 30             	cmp    $0x30,%eax
  800420df56:	73 24                	jae    800420df7c <getint+0x44>
  800420df58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df5c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420df60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df64:	8b 00                	mov    (%rax),%eax
  800420df66:	89 c0                	mov    %eax,%eax
  800420df68:	48 01 d0             	add    %rdx,%rax
  800420df6b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df6f:	8b 12                	mov    (%rdx),%edx
  800420df71:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420df74:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df78:	89 0a                	mov    %ecx,(%rdx)
  800420df7a:	eb 17                	jmp    800420df93 <getint+0x5b>
  800420df7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df80:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420df84:	48 89 d0             	mov    %rdx,%rax
  800420df87:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420df8b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df8f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420df93:	48 8b 00             	mov    (%rax),%rax
  800420df96:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420df9a:	e9 a3 00 00 00       	jmpq   800420e042 <getint+0x10a>
	else if (lflag)
  800420df9f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420dfa3:	74 4f                	je     800420dff4 <getint+0xbc>
		x=va_arg(*ap, long);
  800420dfa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfa9:	8b 00                	mov    (%rax),%eax
  800420dfab:	83 f8 30             	cmp    $0x30,%eax
  800420dfae:	73 24                	jae    800420dfd4 <getint+0x9c>
  800420dfb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfb4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420dfb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfbc:	8b 00                	mov    (%rax),%eax
  800420dfbe:	89 c0                	mov    %eax,%eax
  800420dfc0:	48 01 d0             	add    %rdx,%rax
  800420dfc3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dfc7:	8b 12                	mov    (%rdx),%edx
  800420dfc9:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420dfcc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dfd0:	89 0a                	mov    %ecx,(%rdx)
  800420dfd2:	eb 17                	jmp    800420dfeb <getint+0xb3>
  800420dfd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfd8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420dfdc:	48 89 d0             	mov    %rdx,%rax
  800420dfdf:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420dfe3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dfe7:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420dfeb:	48 8b 00             	mov    (%rax),%rax
  800420dfee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420dff2:	eb 4e                	jmp    800420e042 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420dff4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dff8:	8b 00                	mov    (%rax),%eax
  800420dffa:	83 f8 30             	cmp    $0x30,%eax
  800420dffd:	73 24                	jae    800420e023 <getint+0xeb>
  800420dfff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e003:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e007:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e00b:	8b 00                	mov    (%rax),%eax
  800420e00d:	89 c0                	mov    %eax,%eax
  800420e00f:	48 01 d0             	add    %rdx,%rax
  800420e012:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e016:	8b 12                	mov    (%rdx),%edx
  800420e018:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e01b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e01f:	89 0a                	mov    %ecx,(%rdx)
  800420e021:	eb 17                	jmp    800420e03a <getint+0x102>
  800420e023:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e027:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e02b:	48 89 d0             	mov    %rdx,%rax
  800420e02e:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e032:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e036:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e03a:	8b 00                	mov    (%rax),%eax
  800420e03c:	48 98                	cltq   
  800420e03e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420e042:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e046:	c9                   	leaveq 
  800420e047:	c3                   	retq   

000000800420e048 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420e048:	55                   	push   %rbp
  800420e049:	48 89 e5             	mov    %rsp,%rbp
  800420e04c:	41 54                	push   %r12
  800420e04e:	53                   	push   %rbx
  800420e04f:	48 83 ec 60          	sub    $0x60,%rsp
  800420e053:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420e057:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420e05b:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e05f:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420e063:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e067:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420e06b:	48 8b 0a             	mov    (%rdx),%rcx
  800420e06e:	48 89 08             	mov    %rcx,(%rax)
  800420e071:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e075:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e079:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e07d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e081:	eb 17                	jmp    800420e09a <vprintfmt+0x52>
			if (ch == '\0')
  800420e083:	85 db                	test   %ebx,%ebx
  800420e085:	0f 84 df 04 00 00    	je     800420e56a <vprintfmt+0x522>
				return;
			putch(ch, putdat);
  800420e08b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e08f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e093:	48 89 d6             	mov    %rdx,%rsi
  800420e096:	89 df                	mov    %ebx,%edi
  800420e098:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e09a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e09e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e0a2:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e0a6:	0f b6 00             	movzbl (%rax),%eax
  800420e0a9:	0f b6 d8             	movzbl %al,%ebx
  800420e0ac:	83 fb 25             	cmp    $0x25,%ebx
  800420e0af:	75 d2                	jne    800420e083 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420e0b1:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420e0b5:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420e0bc:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420e0c3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420e0ca:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420e0d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e0d5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e0d9:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e0dd:	0f b6 00             	movzbl (%rax),%eax
  800420e0e0:	0f b6 d8             	movzbl %al,%ebx
  800420e0e3:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420e0e6:	83 f8 55             	cmp    $0x55,%eax
  800420e0e9:	0f 87 47 04 00 00    	ja     800420e536 <vprintfmt+0x4ee>
  800420e0ef:	89 c0                	mov    %eax,%eax
  800420e0f1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420e0f8:	00 
  800420e0f9:	48 b8 18 81 21 04 80 	movabs $0x8004218118,%rax
  800420e100:	00 00 00 
  800420e103:	48 01 d0             	add    %rdx,%rax
  800420e106:	48 8b 00             	mov    (%rax),%rax
  800420e109:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420e10b:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420e10f:	eb c0                	jmp    800420e0d1 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420e111:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420e115:	eb ba                	jmp    800420e0d1 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420e117:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420e11e:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420e121:	89 d0                	mov    %edx,%eax
  800420e123:	c1 e0 02             	shl    $0x2,%eax
  800420e126:	01 d0                	add    %edx,%eax
  800420e128:	01 c0                	add    %eax,%eax
  800420e12a:	01 d8                	add    %ebx,%eax
  800420e12c:	83 e8 30             	sub    $0x30,%eax
  800420e12f:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420e132:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e136:	0f b6 00             	movzbl (%rax),%eax
  800420e139:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420e13c:	83 fb 2f             	cmp    $0x2f,%ebx
  800420e13f:	7e 0c                	jle    800420e14d <vprintfmt+0x105>
  800420e141:	83 fb 39             	cmp    $0x39,%ebx
  800420e144:	7f 07                	jg     800420e14d <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420e146:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420e14b:	eb d1                	jmp    800420e11e <vprintfmt+0xd6>
			goto process_precision;
  800420e14d:	eb 58                	jmp    800420e1a7 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420e14f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e152:	83 f8 30             	cmp    $0x30,%eax
  800420e155:	73 17                	jae    800420e16e <vprintfmt+0x126>
  800420e157:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e15b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e15e:	89 c0                	mov    %eax,%eax
  800420e160:	48 01 d0             	add    %rdx,%rax
  800420e163:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e166:	83 c2 08             	add    $0x8,%edx
  800420e169:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e16c:	eb 0f                	jmp    800420e17d <vprintfmt+0x135>
  800420e16e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e172:	48 89 d0             	mov    %rdx,%rax
  800420e175:	48 83 c2 08          	add    $0x8,%rdx
  800420e179:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e17d:	8b 00                	mov    (%rax),%eax
  800420e17f:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420e182:	eb 23                	jmp    800420e1a7 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420e184:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e188:	79 0c                	jns    800420e196 <vprintfmt+0x14e>
				width = 0;
  800420e18a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420e191:	e9 3b ff ff ff       	jmpq   800420e0d1 <vprintfmt+0x89>
  800420e196:	e9 36 ff ff ff       	jmpq   800420e0d1 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420e19b:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420e1a2:	e9 2a ff ff ff       	jmpq   800420e0d1 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420e1a7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e1ab:	79 12                	jns    800420e1bf <vprintfmt+0x177>
				width = precision, precision = -1;
  800420e1ad:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e1b0:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420e1b3:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420e1ba:	e9 12 ff ff ff       	jmpq   800420e0d1 <vprintfmt+0x89>
  800420e1bf:	e9 0d ff ff ff       	jmpq   800420e0d1 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420e1c4:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420e1c8:	e9 04 ff ff ff       	jmpq   800420e0d1 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420e1cd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e1d0:	83 f8 30             	cmp    $0x30,%eax
  800420e1d3:	73 17                	jae    800420e1ec <vprintfmt+0x1a4>
  800420e1d5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e1d9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e1dc:	89 c0                	mov    %eax,%eax
  800420e1de:	48 01 d0             	add    %rdx,%rax
  800420e1e1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e1e4:	83 c2 08             	add    $0x8,%edx
  800420e1e7:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e1ea:	eb 0f                	jmp    800420e1fb <vprintfmt+0x1b3>
  800420e1ec:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e1f0:	48 89 d0             	mov    %rdx,%rax
  800420e1f3:	48 83 c2 08          	add    $0x8,%rdx
  800420e1f7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e1fb:	8b 10                	mov    (%rax),%edx
  800420e1fd:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420e201:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e205:	48 89 ce             	mov    %rcx,%rsi
  800420e208:	89 d7                	mov    %edx,%edi
  800420e20a:	ff d0                	callq  *%rax
			break;
  800420e20c:	e9 53 03 00 00       	jmpq   800420e564 <vprintfmt+0x51c>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420e211:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e214:	83 f8 30             	cmp    $0x30,%eax
  800420e217:	73 17                	jae    800420e230 <vprintfmt+0x1e8>
  800420e219:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e21d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e220:	89 c0                	mov    %eax,%eax
  800420e222:	48 01 d0             	add    %rdx,%rax
  800420e225:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e228:	83 c2 08             	add    $0x8,%edx
  800420e22b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e22e:	eb 0f                	jmp    800420e23f <vprintfmt+0x1f7>
  800420e230:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e234:	48 89 d0             	mov    %rdx,%rax
  800420e237:	48 83 c2 08          	add    $0x8,%rdx
  800420e23b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e23f:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420e241:	85 db                	test   %ebx,%ebx
  800420e243:	79 02                	jns    800420e247 <vprintfmt+0x1ff>
				err = -err;
  800420e245:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420e247:	83 fb 15             	cmp    $0x15,%ebx
  800420e24a:	7f 16                	jg     800420e262 <vprintfmt+0x21a>
  800420e24c:	48 b8 40 80 21 04 80 	movabs $0x8004218040,%rax
  800420e253:	00 00 00 
  800420e256:	48 63 d3             	movslq %ebx,%rdx
  800420e259:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420e25d:	4d 85 e4             	test   %r12,%r12
  800420e260:	75 2e                	jne    800420e290 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420e262:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e266:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e26a:	89 d9                	mov    %ebx,%ecx
  800420e26c:	48 ba 01 81 21 04 80 	movabs $0x8004218101,%rdx
  800420e273:	00 00 00 
  800420e276:	48 89 c7             	mov    %rax,%rdi
  800420e279:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e27e:	49 b8 73 e5 20 04 80 	movabs $0x800420e573,%r8
  800420e285:	00 00 00 
  800420e288:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420e28b:	e9 d4 02 00 00       	jmpq   800420e564 <vprintfmt+0x51c>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420e290:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e294:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e298:	4c 89 e1             	mov    %r12,%rcx
  800420e29b:	48 ba 0a 81 21 04 80 	movabs $0x800421810a,%rdx
  800420e2a2:	00 00 00 
  800420e2a5:	48 89 c7             	mov    %rax,%rdi
  800420e2a8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e2ad:	49 b8 73 e5 20 04 80 	movabs $0x800420e573,%r8
  800420e2b4:	00 00 00 
  800420e2b7:	41 ff d0             	callq  *%r8
			break;
  800420e2ba:	e9 a5 02 00 00       	jmpq   800420e564 <vprintfmt+0x51c>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420e2bf:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e2c2:	83 f8 30             	cmp    $0x30,%eax
  800420e2c5:	73 17                	jae    800420e2de <vprintfmt+0x296>
  800420e2c7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e2cb:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e2ce:	89 c0                	mov    %eax,%eax
  800420e2d0:	48 01 d0             	add    %rdx,%rax
  800420e2d3:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e2d6:	83 c2 08             	add    $0x8,%edx
  800420e2d9:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e2dc:	eb 0f                	jmp    800420e2ed <vprintfmt+0x2a5>
  800420e2de:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e2e2:	48 89 d0             	mov    %rdx,%rax
  800420e2e5:	48 83 c2 08          	add    $0x8,%rdx
  800420e2e9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e2ed:	4c 8b 20             	mov    (%rax),%r12
  800420e2f0:	4d 85 e4             	test   %r12,%r12
  800420e2f3:	75 0a                	jne    800420e2ff <vprintfmt+0x2b7>
				p = "(null)";
  800420e2f5:	49 bc 0d 81 21 04 80 	movabs $0x800421810d,%r12
  800420e2fc:	00 00 00 
			if (width > 0 && padc != '-')
  800420e2ff:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e303:	7e 3f                	jle    800420e344 <vprintfmt+0x2fc>
  800420e305:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420e309:	74 39                	je     800420e344 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420e30b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e30e:	48 98                	cltq   
  800420e310:	48 89 c6             	mov    %rax,%rsi
  800420e313:	4c 89 e7             	mov    %r12,%rdi
  800420e316:	48 b8 74 e9 20 04 80 	movabs $0x800420e974,%rax
  800420e31d:	00 00 00 
  800420e320:	ff d0                	callq  *%rax
  800420e322:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420e325:	eb 17                	jmp    800420e33e <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420e327:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420e32b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420e32f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e333:	48 89 ce             	mov    %rcx,%rsi
  800420e336:	89 d7                	mov    %edx,%edi
  800420e338:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420e33a:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e33e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e342:	7f e3                	jg     800420e327 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420e344:	eb 37                	jmp    800420e37d <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420e346:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420e34a:	74 1e                	je     800420e36a <vprintfmt+0x322>
  800420e34c:	83 fb 1f             	cmp    $0x1f,%ebx
  800420e34f:	7e 05                	jle    800420e356 <vprintfmt+0x30e>
  800420e351:	83 fb 7e             	cmp    $0x7e,%ebx
  800420e354:	7e 14                	jle    800420e36a <vprintfmt+0x322>
					putch('?', putdat);
  800420e356:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e35a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e35e:	48 89 d6             	mov    %rdx,%rsi
  800420e361:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420e366:	ff d0                	callq  *%rax
  800420e368:	eb 0f                	jmp    800420e379 <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420e36a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e36e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e372:	48 89 d6             	mov    %rdx,%rsi
  800420e375:	89 df                	mov    %ebx,%edi
  800420e377:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420e379:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e37d:	4c 89 e0             	mov    %r12,%rax
  800420e380:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420e384:	0f b6 00             	movzbl (%rax),%eax
  800420e387:	0f be d8             	movsbl %al,%ebx
  800420e38a:	85 db                	test   %ebx,%ebx
  800420e38c:	74 10                	je     800420e39e <vprintfmt+0x356>
  800420e38e:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e392:	78 b2                	js     800420e346 <vprintfmt+0x2fe>
  800420e394:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420e398:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e39c:	79 a8                	jns    800420e346 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e39e:	eb 16                	jmp    800420e3b6 <vprintfmt+0x36e>
				putch(' ', putdat);
  800420e3a0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e3a4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e3a8:	48 89 d6             	mov    %rdx,%rsi
  800420e3ab:	bf 20 00 00 00       	mov    $0x20,%edi
  800420e3b0:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e3b2:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e3b6:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e3ba:	7f e4                	jg     800420e3a0 <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420e3bc:	e9 a3 01 00 00       	jmpq   800420e564 <vprintfmt+0x51c>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420e3c1:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e3c5:	be 03 00 00 00       	mov    $0x3,%esi
  800420e3ca:	48 89 c7             	mov    %rax,%rdi
  800420e3cd:	48 b8 38 df 20 04 80 	movabs $0x800420df38,%rax
  800420e3d4:	00 00 00 
  800420e3d7:	ff d0                	callq  *%rax
  800420e3d9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420e3dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3e1:	48 85 c0             	test   %rax,%rax
  800420e3e4:	79 1d                	jns    800420e403 <vprintfmt+0x3bb>
				putch('-', putdat);
  800420e3e6:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e3ea:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e3ee:	48 89 d6             	mov    %rdx,%rsi
  800420e3f1:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420e3f6:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420e3f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3fc:	48 f7 d8             	neg    %rax
  800420e3ff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420e403:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e40a:	e9 e8 00 00 00       	jmpq   800420e4f7 <vprintfmt+0x4af>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420e40f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e413:	be 03 00 00 00       	mov    $0x3,%esi
  800420e418:	48 89 c7             	mov    %rax,%rdi
  800420e41b:	48 b8 28 de 20 04 80 	movabs $0x800420de28,%rax
  800420e422:	00 00 00 
  800420e425:	ff d0                	callq  *%rax
  800420e427:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420e42b:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e432:	e9 c0 00 00 00       	jmpq   800420e4f7 <vprintfmt+0x4af>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
  800420e437:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e43b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e43f:	48 89 d6             	mov    %rdx,%rsi
  800420e442:	bf 58 00 00 00       	mov    $0x58,%edi
  800420e447:	ff d0                	callq  *%rax
			putch('X', putdat);
  800420e449:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e44d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e451:	48 89 d6             	mov    %rdx,%rsi
  800420e454:	bf 58 00 00 00       	mov    $0x58,%edi
  800420e459:	ff d0                	callq  *%rax
			putch('X', putdat);
  800420e45b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e45f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e463:	48 89 d6             	mov    %rdx,%rsi
  800420e466:	bf 58 00 00 00       	mov    $0x58,%edi
  800420e46b:	ff d0                	callq  *%rax
			break;
  800420e46d:	e9 f2 00 00 00       	jmpq   800420e564 <vprintfmt+0x51c>

			// pointer
		case 'p':
			putch('0', putdat);
  800420e472:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e476:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e47a:	48 89 d6             	mov    %rdx,%rsi
  800420e47d:	bf 30 00 00 00       	mov    $0x30,%edi
  800420e482:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420e484:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e488:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e48c:	48 89 d6             	mov    %rdx,%rsi
  800420e48f:	bf 78 00 00 00       	mov    $0x78,%edi
  800420e494:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420e496:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e499:	83 f8 30             	cmp    $0x30,%eax
  800420e49c:	73 17                	jae    800420e4b5 <vprintfmt+0x46d>
  800420e49e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e4a2:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e4a5:	89 c0                	mov    %eax,%eax
  800420e4a7:	48 01 d0             	add    %rdx,%rax
  800420e4aa:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e4ad:	83 c2 08             	add    $0x8,%edx
  800420e4b0:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e4b3:	eb 0f                	jmp    800420e4c4 <vprintfmt+0x47c>
				(uintptr_t) va_arg(aq, void *);
  800420e4b5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e4b9:	48 89 d0             	mov    %rdx,%rax
  800420e4bc:	48 83 c2 08          	add    $0x8,%rdx
  800420e4c0:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e4c4:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e4c7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420e4cb:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420e4d2:	eb 23                	jmp    800420e4f7 <vprintfmt+0x4af>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420e4d4:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e4d8:	be 03 00 00 00       	mov    $0x3,%esi
  800420e4dd:	48 89 c7             	mov    %rax,%rdi
  800420e4e0:	48 b8 28 de 20 04 80 	movabs $0x800420de28,%rax
  800420e4e7:	00 00 00 
  800420e4ea:	ff d0                	callq  *%rax
  800420e4ec:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420e4f0:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420e4f7:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420e4fc:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420e4ff:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420e502:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e506:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e50a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e50e:	45 89 c1             	mov    %r8d,%r9d
  800420e511:	41 89 f8             	mov    %edi,%r8d
  800420e514:	48 89 c7             	mov    %rax,%rdi
  800420e517:	48 b8 6d dd 20 04 80 	movabs $0x800420dd6d,%rax
  800420e51e:	00 00 00 
  800420e521:	ff d0                	callq  *%rax
			break;
  800420e523:	eb 3f                	jmp    800420e564 <vprintfmt+0x51c>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420e525:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e529:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e52d:	48 89 d6             	mov    %rdx,%rsi
  800420e530:	89 df                	mov    %ebx,%edi
  800420e532:	ff d0                	callq  *%rax
			break;
  800420e534:	eb 2e                	jmp    800420e564 <vprintfmt+0x51c>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420e536:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e53a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e53e:	48 89 d6             	mov    %rdx,%rsi
  800420e541:	bf 25 00 00 00       	mov    $0x25,%edi
  800420e546:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420e548:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e54d:	eb 05                	jmp    800420e554 <vprintfmt+0x50c>
  800420e54f:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e554:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e558:	48 83 e8 01          	sub    $0x1,%rax
  800420e55c:	0f b6 00             	movzbl (%rax),%eax
  800420e55f:	3c 25                	cmp    $0x25,%al
  800420e561:	75 ec                	jne    800420e54f <vprintfmt+0x507>
				/* do nothing */;
			break;
  800420e563:	90                   	nop
		}
	}
  800420e564:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e565:	e9 30 fb ff ff       	jmpq   800420e09a <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420e56a:	48 83 c4 60          	add    $0x60,%rsp
  800420e56e:	5b                   	pop    %rbx
  800420e56f:	41 5c                	pop    %r12
  800420e571:	5d                   	pop    %rbp
  800420e572:	c3                   	retq   

000000800420e573 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420e573:	55                   	push   %rbp
  800420e574:	48 89 e5             	mov    %rsp,%rbp
  800420e577:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420e57e:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420e585:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420e58c:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e593:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e59a:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e5a1:	84 c0                	test   %al,%al
  800420e5a3:	74 20                	je     800420e5c5 <printfmt+0x52>
  800420e5a5:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e5a9:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e5ad:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e5b1:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e5b5:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e5b9:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e5bd:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e5c1:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e5c5:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420e5cc:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420e5d3:	00 00 00 
  800420e5d6:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420e5dd:	00 00 00 
  800420e5e0:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e5e4:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420e5eb:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e5f2:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420e5f9:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420e600:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420e607:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420e60e:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420e615:	48 89 c7             	mov    %rax,%rdi
  800420e618:	48 b8 48 e0 20 04 80 	movabs $0x800420e048,%rax
  800420e61f:	00 00 00 
  800420e622:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420e624:	c9                   	leaveq 
  800420e625:	c3                   	retq   

000000800420e626 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420e626:	55                   	push   %rbp
  800420e627:	48 89 e5             	mov    %rsp,%rbp
  800420e62a:	48 83 ec 10          	sub    $0x10,%rsp
  800420e62e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420e631:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420e635:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e639:	8b 40 10             	mov    0x10(%rax),%eax
  800420e63c:	8d 50 01             	lea    0x1(%rax),%edx
  800420e63f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e643:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420e646:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e64a:	48 8b 10             	mov    (%rax),%rdx
  800420e64d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e651:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e655:	48 39 c2             	cmp    %rax,%rdx
  800420e658:	73 17                	jae    800420e671 <sprintputch+0x4b>
		*b->buf++ = ch;
  800420e65a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e65e:	48 8b 00             	mov    (%rax),%rax
  800420e661:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420e665:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e669:	48 89 0a             	mov    %rcx,(%rdx)
  800420e66c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420e66f:	88 10                	mov    %dl,(%rax)
}
  800420e671:	c9                   	leaveq 
  800420e672:	c3                   	retq   

000000800420e673 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420e673:	55                   	push   %rbp
  800420e674:	48 89 e5             	mov    %rsp,%rbp
  800420e677:	48 83 ec 50          	sub    $0x50,%rsp
  800420e67b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420e67f:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420e682:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420e686:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420e68a:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420e68e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e692:	48 8b 0a             	mov    (%rdx),%rcx
  800420e695:	48 89 08             	mov    %rcx,(%rax)
  800420e698:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e69c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e6a0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e6a4:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420e6a8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e6ac:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420e6b0:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420e6b3:	48 98                	cltq   
  800420e6b5:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420e6b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e6bd:	48 01 d0             	add    %rdx,%rax
  800420e6c0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420e6c4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420e6cb:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e6d0:	74 06                	je     800420e6d8 <vsnprintf+0x65>
  800420e6d2:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420e6d6:	7f 07                	jg     800420e6df <vsnprintf+0x6c>
		return -E_INVAL;
  800420e6d8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e6dd:	eb 2f                	jmp    800420e70e <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420e6df:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e6e3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e6e7:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420e6eb:	48 89 c6             	mov    %rax,%rsi
  800420e6ee:	48 bf 26 e6 20 04 80 	movabs $0x800420e626,%rdi
  800420e6f5:	00 00 00 
  800420e6f8:	48 b8 48 e0 20 04 80 	movabs $0x800420e048,%rax
  800420e6ff:	00 00 00 
  800420e702:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420e704:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e708:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420e70b:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420e70e:	c9                   	leaveq 
  800420e70f:	c3                   	retq   

000000800420e710 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420e710:	55                   	push   %rbp
  800420e711:	48 89 e5             	mov    %rsp,%rbp
  800420e714:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420e71b:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420e722:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420e728:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e72f:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e736:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e73d:	84 c0                	test   %al,%al
  800420e73f:	74 20                	je     800420e761 <snprintf+0x51>
  800420e741:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e745:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e749:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e74d:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e751:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e755:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e759:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e75d:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e761:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420e768:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420e76f:	00 00 00 
  800420e772:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420e779:	00 00 00 
  800420e77c:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e780:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420e787:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e78e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420e795:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420e79c:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420e7a3:	48 8b 0a             	mov    (%rdx),%rcx
  800420e7a6:	48 89 08             	mov    %rcx,(%rax)
  800420e7a9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e7ad:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e7b1:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e7b5:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420e7b9:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420e7c0:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420e7c7:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420e7cd:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420e7d4:	48 89 c7             	mov    %rax,%rdi
  800420e7d7:	48 b8 73 e6 20 04 80 	movabs $0x800420e673,%rax
  800420e7de:	00 00 00 
  800420e7e1:	ff d0                	callq  *%rax
  800420e7e3:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420e7e9:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420e7ef:	c9                   	leaveq 
  800420e7f0:	c3                   	retq   

000000800420e7f1 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420e7f1:	55                   	push   %rbp
  800420e7f2:	48 89 e5             	mov    %rsp,%rbp
  800420e7f5:	48 83 ec 20          	sub    $0x20,%rsp
  800420e7f9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420e7fd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e802:	74 22                	je     800420e826 <readline+0x35>
		cprintf("%s", prompt);
  800420e804:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e808:	48 89 c6             	mov    %rax,%rsi
  800420e80b:	48 bf c8 83 21 04 80 	movabs $0x80042183c8,%rdi
  800420e812:	00 00 00 
  800420e815:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e81a:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420e821:	00 00 00 
  800420e824:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420e826:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420e82d:	bf 00 00 00 00       	mov    $0x0,%edi
  800420e832:	48 b8 18 12 20 04 80 	movabs $0x8004201218,%rax
  800420e839:	00 00 00 
  800420e83c:	ff d0                	callq  *%rax
  800420e83e:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420e841:	48 b8 f6 11 20 04 80 	movabs $0x80042011f6,%rax
  800420e848:	00 00 00 
  800420e84b:	ff d0                	callq  *%rax
  800420e84d:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420e850:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420e854:	79 30                	jns    800420e886 <readline+0x95>
			if (c != -E_EOF)
  800420e856:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420e85a:	74 20                	je     800420e87c <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420e85c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e85f:	89 c6                	mov    %eax,%esi
  800420e861:	48 bf cb 83 21 04 80 	movabs $0x80042183cb,%rdi
  800420e868:	00 00 00 
  800420e86b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e870:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800420e877:	00 00 00 
  800420e87a:	ff d2                	callq  *%rdx
			return NULL;
  800420e87c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e881:	e9 be 00 00 00       	jmpq   800420e944 <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420e886:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420e88a:	74 06                	je     800420e892 <readline+0xa1>
  800420e88c:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420e890:	75 26                	jne    800420e8b8 <readline+0xc7>
  800420e892:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e896:	7e 20                	jle    800420e8b8 <readline+0xc7>
			if (echoing)
  800420e898:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e89c:	74 11                	je     800420e8af <readline+0xbe>
				cputchar('\b');
  800420e89e:	bf 08 00 00 00       	mov    $0x8,%edi
  800420e8a3:	48 b8 d8 11 20 04 80 	movabs $0x80042011d8,%rax
  800420e8aa:	00 00 00 
  800420e8ad:	ff d0                	callq  *%rax
			i--;
  800420e8af:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420e8b3:	e9 87 00 00 00       	jmpq   800420e93f <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420e8b8:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420e8bc:	7e 3f                	jle    800420e8fd <readline+0x10c>
  800420e8be:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420e8c5:	7f 36                	jg     800420e8fd <readline+0x10c>
			if (echoing)
  800420e8c7:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e8cb:	74 11                	je     800420e8de <readline+0xed>
				cputchar(c);
  800420e8cd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e8d0:	89 c7                	mov    %eax,%edi
  800420e8d2:	48 b8 d8 11 20 04 80 	movabs $0x80042011d8,%rax
  800420e8d9:	00 00 00 
  800420e8dc:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420e8de:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e8e1:	8d 50 01             	lea    0x1(%rax),%edx
  800420e8e4:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420e8e7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420e8ea:	89 d1                	mov    %edx,%ecx
  800420e8ec:	48 ba a0 f2 6b 04 80 	movabs $0x80046bf2a0,%rdx
  800420e8f3:	00 00 00 
  800420e8f6:	48 98                	cltq   
  800420e8f8:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420e8fb:	eb 42                	jmp    800420e93f <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420e8fd:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420e901:	74 06                	je     800420e909 <readline+0x118>
  800420e903:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420e907:	75 36                	jne    800420e93f <readline+0x14e>
			if (echoing)
  800420e909:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e90d:	74 11                	je     800420e920 <readline+0x12f>
				cputchar('\n');
  800420e90f:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420e914:	48 b8 d8 11 20 04 80 	movabs $0x80042011d8,%rax
  800420e91b:	00 00 00 
  800420e91e:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420e920:	48 ba a0 f2 6b 04 80 	movabs $0x80046bf2a0,%rdx
  800420e927:	00 00 00 
  800420e92a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e92d:	48 98                	cltq   
  800420e92f:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420e933:	48 b8 a0 f2 6b 04 80 	movabs $0x80046bf2a0,%rax
  800420e93a:	00 00 00 
  800420e93d:	eb 05                	jmp    800420e944 <readline+0x153>
		}
	}
  800420e93f:	e9 fd fe ff ff       	jmpq   800420e841 <readline+0x50>
}
  800420e944:	c9                   	leaveq 
  800420e945:	c3                   	retq   

000000800420e946 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420e946:	55                   	push   %rbp
  800420e947:	48 89 e5             	mov    %rsp,%rbp
  800420e94a:	48 83 ec 18          	sub    $0x18,%rsp
  800420e94e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420e952:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420e959:	eb 09                	jmp    800420e964 <strlen+0x1e>
		n++;
  800420e95b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420e95f:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e968:	0f b6 00             	movzbl (%rax),%eax
  800420e96b:	84 c0                	test   %al,%al
  800420e96d:	75 ec                	jne    800420e95b <strlen+0x15>
		n++;
	return n;
  800420e96f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420e972:	c9                   	leaveq 
  800420e973:	c3                   	retq   

000000800420e974 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420e974:	55                   	push   %rbp
  800420e975:	48 89 e5             	mov    %rsp,%rbp
  800420e978:	48 83 ec 20          	sub    $0x20,%rsp
  800420e97c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e980:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420e984:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420e98b:	eb 0e                	jmp    800420e99b <strnlen+0x27>
		n++;
  800420e98d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420e991:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e996:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420e99b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e9a0:	74 0b                	je     800420e9ad <strnlen+0x39>
  800420e9a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9a6:	0f b6 00             	movzbl (%rax),%eax
  800420e9a9:	84 c0                	test   %al,%al
  800420e9ab:	75 e0                	jne    800420e98d <strnlen+0x19>
		n++;
	return n;
  800420e9ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420e9b0:	c9                   	leaveq 
  800420e9b1:	c3                   	retq   

000000800420e9b2 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420e9b2:	55                   	push   %rbp
  800420e9b3:	48 89 e5             	mov    %rsp,%rbp
  800420e9b6:	48 83 ec 20          	sub    $0x20,%rsp
  800420e9ba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e9be:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420e9c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420e9ca:	90                   	nop
  800420e9cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9cf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e9d3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e9d7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e9db:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420e9df:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420e9e3:	0f b6 12             	movzbl (%rdx),%edx
  800420e9e6:	88 10                	mov    %dl,(%rax)
  800420e9e8:	0f b6 00             	movzbl (%rax),%eax
  800420e9eb:	84 c0                	test   %al,%al
  800420e9ed:	75 dc                	jne    800420e9cb <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420e9ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e9f3:	c9                   	leaveq 
  800420e9f4:	c3                   	retq   

000000800420e9f5 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420e9f5:	55                   	push   %rbp
  800420e9f6:	48 89 e5             	mov    %rsp,%rbp
  800420e9f9:	48 83 ec 20          	sub    $0x20,%rsp
  800420e9fd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ea01:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420ea05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea09:	48 89 c7             	mov    %rax,%rdi
  800420ea0c:	48 b8 46 e9 20 04 80 	movabs $0x800420e946,%rax
  800420ea13:	00 00 00 
  800420ea16:	ff d0                	callq  *%rax
  800420ea18:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420ea1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ea1e:	48 63 d0             	movslq %eax,%rdx
  800420ea21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea25:	48 01 c2             	add    %rax,%rdx
  800420ea28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ea2c:	48 89 c6             	mov    %rax,%rsi
  800420ea2f:	48 89 d7             	mov    %rdx,%rdi
  800420ea32:	48 b8 b2 e9 20 04 80 	movabs $0x800420e9b2,%rax
  800420ea39:	00 00 00 
  800420ea3c:	ff d0                	callq  *%rax
	return dst;
  800420ea3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420ea42:	c9                   	leaveq 
  800420ea43:	c3                   	retq   

000000800420ea44 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420ea44:	55                   	push   %rbp
  800420ea45:	48 89 e5             	mov    %rsp,%rbp
  800420ea48:	48 83 ec 28          	sub    $0x28,%rsp
  800420ea4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ea50:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ea54:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420ea58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea5c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420ea60:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ea67:	00 
  800420ea68:	eb 2a                	jmp    800420ea94 <strncpy+0x50>
		*dst++ = *src;
  800420ea6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea6e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ea72:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ea76:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ea7a:	0f b6 12             	movzbl (%rdx),%edx
  800420ea7d:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420ea7f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ea83:	0f b6 00             	movzbl (%rax),%eax
  800420ea86:	84 c0                	test   %al,%al
  800420ea88:	74 05                	je     800420ea8f <strncpy+0x4b>
			src++;
  800420ea8a:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420ea8f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ea94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ea98:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420ea9c:	72 cc                	jb     800420ea6a <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420ea9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420eaa2:	c9                   	leaveq 
  800420eaa3:	c3                   	retq   

000000800420eaa4 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420eaa4:	55                   	push   %rbp
  800420eaa5:	48 89 e5             	mov    %rsp,%rbp
  800420eaa8:	48 83 ec 28          	sub    $0x28,%rsp
  800420eaac:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eab0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420eab4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420eab8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eabc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420eac0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420eac5:	74 3d                	je     800420eb04 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420eac7:	eb 1d                	jmp    800420eae6 <strlcpy+0x42>
			*dst++ = *src++;
  800420eac9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eacd:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ead1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ead5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ead9:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420eadd:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420eae1:	0f b6 12             	movzbl (%rdx),%edx
  800420eae4:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420eae6:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420eaeb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420eaf0:	74 0b                	je     800420eafd <strlcpy+0x59>
  800420eaf2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eaf6:	0f b6 00             	movzbl (%rax),%eax
  800420eaf9:	84 c0                	test   %al,%al
  800420eafb:	75 cc                	jne    800420eac9 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420eafd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb01:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420eb04:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb0c:	48 29 c2             	sub    %rax,%rdx
  800420eb0f:	48 89 d0             	mov    %rdx,%rax
}
  800420eb12:	c9                   	leaveq 
  800420eb13:	c3                   	retq   

000000800420eb14 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420eb14:	55                   	push   %rbp
  800420eb15:	48 89 e5             	mov    %rsp,%rbp
  800420eb18:	48 83 ec 10          	sub    $0x10,%rsp
  800420eb1c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420eb20:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420eb24:	eb 0a                	jmp    800420eb30 <strcmp+0x1c>
		p++, q++;
  800420eb26:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420eb2b:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420eb30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb34:	0f b6 00             	movzbl (%rax),%eax
  800420eb37:	84 c0                	test   %al,%al
  800420eb39:	74 12                	je     800420eb4d <strcmp+0x39>
  800420eb3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb3f:	0f b6 10             	movzbl (%rax),%edx
  800420eb42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eb46:	0f b6 00             	movzbl (%rax),%eax
  800420eb49:	38 c2                	cmp    %al,%dl
  800420eb4b:	74 d9                	je     800420eb26 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420eb4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb51:	0f b6 00             	movzbl (%rax),%eax
  800420eb54:	0f b6 d0             	movzbl %al,%edx
  800420eb57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eb5b:	0f b6 00             	movzbl (%rax),%eax
  800420eb5e:	0f b6 c0             	movzbl %al,%eax
  800420eb61:	29 c2                	sub    %eax,%edx
  800420eb63:	89 d0                	mov    %edx,%eax
}
  800420eb65:	c9                   	leaveq 
  800420eb66:	c3                   	retq   

000000800420eb67 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420eb67:	55                   	push   %rbp
  800420eb68:	48 89 e5             	mov    %rsp,%rbp
  800420eb6b:	48 83 ec 18          	sub    $0x18,%rsp
  800420eb6f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420eb73:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420eb77:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420eb7b:	eb 0f                	jmp    800420eb8c <strncmp+0x25>
		n--, p++, q++;
  800420eb7d:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420eb82:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420eb87:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420eb8c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420eb91:	74 1d                	je     800420ebb0 <strncmp+0x49>
  800420eb93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb97:	0f b6 00             	movzbl (%rax),%eax
  800420eb9a:	84 c0                	test   %al,%al
  800420eb9c:	74 12                	je     800420ebb0 <strncmp+0x49>
  800420eb9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eba2:	0f b6 10             	movzbl (%rax),%edx
  800420eba5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eba9:	0f b6 00             	movzbl (%rax),%eax
  800420ebac:	38 c2                	cmp    %al,%dl
  800420ebae:	74 cd                	je     800420eb7d <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420ebb0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ebb5:	75 07                	jne    800420ebbe <strncmp+0x57>
		return 0;
  800420ebb7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ebbc:	eb 18                	jmp    800420ebd6 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420ebbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ebc2:	0f b6 00             	movzbl (%rax),%eax
  800420ebc5:	0f b6 d0             	movzbl %al,%edx
  800420ebc8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ebcc:	0f b6 00             	movzbl (%rax),%eax
  800420ebcf:	0f b6 c0             	movzbl %al,%eax
  800420ebd2:	29 c2                	sub    %eax,%edx
  800420ebd4:	89 d0                	mov    %edx,%eax
}
  800420ebd6:	c9                   	leaveq 
  800420ebd7:	c3                   	retq   

000000800420ebd8 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420ebd8:	55                   	push   %rbp
  800420ebd9:	48 89 e5             	mov    %rsp,%rbp
  800420ebdc:	48 83 ec 0c          	sub    $0xc,%rsp
  800420ebe0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ebe4:	89 f0                	mov    %esi,%eax
  800420ebe6:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420ebe9:	eb 17                	jmp    800420ec02 <strchr+0x2a>
		if (*s == c)
  800420ebeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ebef:	0f b6 00             	movzbl (%rax),%eax
  800420ebf2:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420ebf5:	75 06                	jne    800420ebfd <strchr+0x25>
			return (char *) s;
  800420ebf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ebfb:	eb 15                	jmp    800420ec12 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420ebfd:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ec02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec06:	0f b6 00             	movzbl (%rax),%eax
  800420ec09:	84 c0                	test   %al,%al
  800420ec0b:	75 de                	jne    800420ebeb <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420ec0d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ec12:	c9                   	leaveq 
  800420ec13:	c3                   	retq   

000000800420ec14 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420ec14:	55                   	push   %rbp
  800420ec15:	48 89 e5             	mov    %rsp,%rbp
  800420ec18:	48 83 ec 0c          	sub    $0xc,%rsp
  800420ec1c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ec20:	89 f0                	mov    %esi,%eax
  800420ec22:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420ec25:	eb 13                	jmp    800420ec3a <strfind+0x26>
		if (*s == c)
  800420ec27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec2b:	0f b6 00             	movzbl (%rax),%eax
  800420ec2e:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420ec31:	75 02                	jne    800420ec35 <strfind+0x21>
			break;
  800420ec33:	eb 10                	jmp    800420ec45 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420ec35:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ec3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec3e:	0f b6 00             	movzbl (%rax),%eax
  800420ec41:	84 c0                	test   %al,%al
  800420ec43:	75 e2                	jne    800420ec27 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420ec45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ec49:	c9                   	leaveq 
  800420ec4a:	c3                   	retq   

000000800420ec4b <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420ec4b:	55                   	push   %rbp
  800420ec4c:	48 89 e5             	mov    %rsp,%rbp
  800420ec4f:	48 83 ec 18          	sub    $0x18,%rsp
  800420ec53:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ec57:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420ec5a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420ec5e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ec63:	75 06                	jne    800420ec6b <memset+0x20>
		return v;
  800420ec65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec69:	eb 69                	jmp    800420ecd4 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420ec6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec6f:	83 e0 03             	and    $0x3,%eax
  800420ec72:	48 85 c0             	test   %rax,%rax
  800420ec75:	75 48                	jne    800420ecbf <memset+0x74>
  800420ec77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec7b:	83 e0 03             	and    $0x3,%eax
  800420ec7e:	48 85 c0             	test   %rax,%rax
  800420ec81:	75 3c                	jne    800420ecbf <memset+0x74>
		c &= 0xFF;
  800420ec83:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420ec8a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ec8d:	c1 e0 18             	shl    $0x18,%eax
  800420ec90:	89 c2                	mov    %eax,%edx
  800420ec92:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ec95:	c1 e0 10             	shl    $0x10,%eax
  800420ec98:	09 c2                	or     %eax,%edx
  800420ec9a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ec9d:	c1 e0 08             	shl    $0x8,%eax
  800420eca0:	09 d0                	or     %edx,%eax
  800420eca2:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420eca5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eca9:	48 c1 e8 02          	shr    $0x2,%rax
  800420ecad:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420ecb0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ecb4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ecb7:	48 89 d7             	mov    %rdx,%rdi
  800420ecba:	fc                   	cld    
  800420ecbb:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420ecbd:	eb 11                	jmp    800420ecd0 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420ecbf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ecc3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ecc6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ecca:	48 89 d7             	mov    %rdx,%rdi
  800420eccd:	fc                   	cld    
  800420ecce:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420ecd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ecd4:	c9                   	leaveq 
  800420ecd5:	c3                   	retq   

000000800420ecd6 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420ecd6:	55                   	push   %rbp
  800420ecd7:	48 89 e5             	mov    %rsp,%rbp
  800420ecda:	48 83 ec 28          	sub    $0x28,%rsp
  800420ecde:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ece2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ece6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420ecea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ecee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420ecf2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecf6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420ecfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ecfe:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420ed02:	0f 83 88 00 00 00    	jae    800420ed90 <memmove+0xba>
  800420ed08:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed0c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ed10:	48 01 d0             	add    %rdx,%rax
  800420ed13:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420ed17:	76 77                	jbe    800420ed90 <memmove+0xba>
		s += n;
  800420ed19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed1d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420ed21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed25:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420ed29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed2d:	83 e0 03             	and    $0x3,%eax
  800420ed30:	48 85 c0             	test   %rax,%rax
  800420ed33:	75 3b                	jne    800420ed70 <memmove+0x9a>
  800420ed35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed39:	83 e0 03             	and    $0x3,%eax
  800420ed3c:	48 85 c0             	test   %rax,%rax
  800420ed3f:	75 2f                	jne    800420ed70 <memmove+0x9a>
  800420ed41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed45:	83 e0 03             	and    $0x3,%eax
  800420ed48:	48 85 c0             	test   %rax,%rax
  800420ed4b:	75 23                	jne    800420ed70 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420ed4d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed51:	48 83 e8 04          	sub    $0x4,%rax
  800420ed55:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ed59:	48 83 ea 04          	sub    $0x4,%rdx
  800420ed5d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ed61:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420ed65:	48 89 c7             	mov    %rax,%rdi
  800420ed68:	48 89 d6             	mov    %rdx,%rsi
  800420ed6b:	fd                   	std    
  800420ed6c:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420ed6e:	eb 1d                	jmp    800420ed8d <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420ed70:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed74:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420ed78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed7c:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420ed80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed84:	48 89 d7             	mov    %rdx,%rdi
  800420ed87:	48 89 c1             	mov    %rax,%rcx
  800420ed8a:	fd                   	std    
  800420ed8b:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420ed8d:	fc                   	cld    
  800420ed8e:	eb 57                	jmp    800420ede7 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420ed90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed94:	83 e0 03             	and    $0x3,%eax
  800420ed97:	48 85 c0             	test   %rax,%rax
  800420ed9a:	75 36                	jne    800420edd2 <memmove+0xfc>
  800420ed9c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eda0:	83 e0 03             	and    $0x3,%eax
  800420eda3:	48 85 c0             	test   %rax,%rax
  800420eda6:	75 2a                	jne    800420edd2 <memmove+0xfc>
  800420eda8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420edac:	83 e0 03             	and    $0x3,%eax
  800420edaf:	48 85 c0             	test   %rax,%rax
  800420edb2:	75 1e                	jne    800420edd2 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420edb4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420edb8:	48 c1 e8 02          	shr    $0x2,%rax
  800420edbc:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420edbf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edc3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420edc7:	48 89 c7             	mov    %rax,%rdi
  800420edca:	48 89 d6             	mov    %rdx,%rsi
  800420edcd:	fc                   	cld    
  800420edce:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420edd0:	eb 15                	jmp    800420ede7 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420edd2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edd6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420edda:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420edde:	48 89 c7             	mov    %rax,%rdi
  800420ede1:	48 89 d6             	mov    %rdx,%rsi
  800420ede4:	fc                   	cld    
  800420ede5:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420ede7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420edeb:	c9                   	leaveq 
  800420edec:	c3                   	retq   

000000800420eded <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420eded:	55                   	push   %rbp
  800420edee:	48 89 e5             	mov    %rsp,%rbp
  800420edf1:	48 83 ec 18          	sub    $0x18,%rsp
  800420edf5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420edf9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420edfd:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420ee01:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee05:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420ee09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee0d:	48 89 ce             	mov    %rcx,%rsi
  800420ee10:	48 89 c7             	mov    %rax,%rdi
  800420ee13:	48 b8 d6 ec 20 04 80 	movabs $0x800420ecd6,%rax
  800420ee1a:	00 00 00 
  800420ee1d:	ff d0                	callq  *%rax
}
  800420ee1f:	c9                   	leaveq 
  800420ee20:	c3                   	retq   

000000800420ee21 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420ee21:	55                   	push   %rbp
  800420ee22:	48 89 e5             	mov    %rsp,%rbp
  800420ee25:	48 83 ec 28          	sub    $0x28,%rsp
  800420ee29:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ee2d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ee31:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420ee35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420ee3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ee41:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420ee45:	eb 36                	jmp    800420ee7d <memcmp+0x5c>
		if (*s1 != *s2)
  800420ee47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee4b:	0f b6 10             	movzbl (%rax),%edx
  800420ee4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee52:	0f b6 00             	movzbl (%rax),%eax
  800420ee55:	38 c2                	cmp    %al,%dl
  800420ee57:	74 1a                	je     800420ee73 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420ee59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee5d:	0f b6 00             	movzbl (%rax),%eax
  800420ee60:	0f b6 d0             	movzbl %al,%edx
  800420ee63:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee67:	0f b6 00             	movzbl (%rax),%eax
  800420ee6a:	0f b6 c0             	movzbl %al,%eax
  800420ee6d:	29 c2                	sub    %eax,%edx
  800420ee6f:	89 d0                	mov    %edx,%eax
  800420ee71:	eb 20                	jmp    800420ee93 <memcmp+0x72>
		s1++, s2++;
  800420ee73:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ee78:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420ee7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ee81:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420ee85:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420ee89:	48 85 c0             	test   %rax,%rax
  800420ee8c:	75 b9                	jne    800420ee47 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420ee8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ee93:	c9                   	leaveq 
  800420ee94:	c3                   	retq   

000000800420ee95 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420ee95:	55                   	push   %rbp
  800420ee96:	48 89 e5             	mov    %rsp,%rbp
  800420ee99:	48 83 ec 28          	sub    $0x28,%rsp
  800420ee9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eea1:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420eea4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420eea8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eeac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eeb0:	48 01 d0             	add    %rdx,%rax
  800420eeb3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420eeb7:	eb 15                	jmp    800420eece <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420eeb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eebd:	0f b6 10             	movzbl (%rax),%edx
  800420eec0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420eec3:	38 c2                	cmp    %al,%dl
  800420eec5:	75 02                	jne    800420eec9 <memfind+0x34>
			break;
  800420eec7:	eb 0f                	jmp    800420eed8 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420eec9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420eece:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eed2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420eed6:	72 e1                	jb     800420eeb9 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420eed8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420eedc:	c9                   	leaveq 
  800420eedd:	c3                   	retq   

000000800420eede <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420eede:	55                   	push   %rbp
  800420eedf:	48 89 e5             	mov    %rsp,%rbp
  800420eee2:	48 83 ec 34          	sub    $0x34,%rsp
  800420eee6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420eeea:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420eeee:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420eef1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420eef8:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420eeff:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420ef00:	eb 05                	jmp    800420ef07 <strtol+0x29>
		s++;
  800420ef02:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420ef07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef0b:	0f b6 00             	movzbl (%rax),%eax
  800420ef0e:	3c 20                	cmp    $0x20,%al
  800420ef10:	74 f0                	je     800420ef02 <strtol+0x24>
  800420ef12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef16:	0f b6 00             	movzbl (%rax),%eax
  800420ef19:	3c 09                	cmp    $0x9,%al
  800420ef1b:	74 e5                	je     800420ef02 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420ef1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef21:	0f b6 00             	movzbl (%rax),%eax
  800420ef24:	3c 2b                	cmp    $0x2b,%al
  800420ef26:	75 07                	jne    800420ef2f <strtol+0x51>
		s++;
  800420ef28:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ef2d:	eb 17                	jmp    800420ef46 <strtol+0x68>
	else if (*s == '-')
  800420ef2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef33:	0f b6 00             	movzbl (%rax),%eax
  800420ef36:	3c 2d                	cmp    $0x2d,%al
  800420ef38:	75 0c                	jne    800420ef46 <strtol+0x68>
		s++, neg = 1;
  800420ef3a:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ef3f:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420ef46:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ef4a:	74 06                	je     800420ef52 <strtol+0x74>
  800420ef4c:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420ef50:	75 28                	jne    800420ef7a <strtol+0x9c>
  800420ef52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef56:	0f b6 00             	movzbl (%rax),%eax
  800420ef59:	3c 30                	cmp    $0x30,%al
  800420ef5b:	75 1d                	jne    800420ef7a <strtol+0x9c>
  800420ef5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef61:	48 83 c0 01          	add    $0x1,%rax
  800420ef65:	0f b6 00             	movzbl (%rax),%eax
  800420ef68:	3c 78                	cmp    $0x78,%al
  800420ef6a:	75 0e                	jne    800420ef7a <strtol+0x9c>
		s += 2, base = 16;
  800420ef6c:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420ef71:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420ef78:	eb 2c                	jmp    800420efa6 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420ef7a:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ef7e:	75 19                	jne    800420ef99 <strtol+0xbb>
  800420ef80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef84:	0f b6 00             	movzbl (%rax),%eax
  800420ef87:	3c 30                	cmp    $0x30,%al
  800420ef89:	75 0e                	jne    800420ef99 <strtol+0xbb>
		s++, base = 8;
  800420ef8b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ef90:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420ef97:	eb 0d                	jmp    800420efa6 <strtol+0xc8>
	else if (base == 0)
  800420ef99:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ef9d:	75 07                	jne    800420efa6 <strtol+0xc8>
		base = 10;
  800420ef9f:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420efa6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efaa:	0f b6 00             	movzbl (%rax),%eax
  800420efad:	3c 2f                	cmp    $0x2f,%al
  800420efaf:	7e 1d                	jle    800420efce <strtol+0xf0>
  800420efb1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efb5:	0f b6 00             	movzbl (%rax),%eax
  800420efb8:	3c 39                	cmp    $0x39,%al
  800420efba:	7f 12                	jg     800420efce <strtol+0xf0>
			dig = *s - '0';
  800420efbc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efc0:	0f b6 00             	movzbl (%rax),%eax
  800420efc3:	0f be c0             	movsbl %al,%eax
  800420efc6:	83 e8 30             	sub    $0x30,%eax
  800420efc9:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420efcc:	eb 4e                	jmp    800420f01c <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420efce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efd2:	0f b6 00             	movzbl (%rax),%eax
  800420efd5:	3c 60                	cmp    $0x60,%al
  800420efd7:	7e 1d                	jle    800420eff6 <strtol+0x118>
  800420efd9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efdd:	0f b6 00             	movzbl (%rax),%eax
  800420efe0:	3c 7a                	cmp    $0x7a,%al
  800420efe2:	7f 12                	jg     800420eff6 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420efe4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efe8:	0f b6 00             	movzbl (%rax),%eax
  800420efeb:	0f be c0             	movsbl %al,%eax
  800420efee:	83 e8 57             	sub    $0x57,%eax
  800420eff1:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420eff4:	eb 26                	jmp    800420f01c <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420eff6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420effa:	0f b6 00             	movzbl (%rax),%eax
  800420effd:	3c 40                	cmp    $0x40,%al
  800420efff:	7e 48                	jle    800420f049 <strtol+0x16b>
  800420f001:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f005:	0f b6 00             	movzbl (%rax),%eax
  800420f008:	3c 5a                	cmp    $0x5a,%al
  800420f00a:	7f 3d                	jg     800420f049 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420f00c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f010:	0f b6 00             	movzbl (%rax),%eax
  800420f013:	0f be c0             	movsbl %al,%eax
  800420f016:	83 e8 37             	sub    $0x37,%eax
  800420f019:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420f01c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f01f:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420f022:	7c 02                	jl     800420f026 <strtol+0x148>
			break;
  800420f024:	eb 23                	jmp    800420f049 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420f026:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f02b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420f02e:	48 98                	cltq   
  800420f030:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420f035:	48 89 c2             	mov    %rax,%rdx
  800420f038:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f03b:	48 98                	cltq   
  800420f03d:	48 01 d0             	add    %rdx,%rax
  800420f040:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420f044:	e9 5d ff ff ff       	jmpq   800420efa6 <strtol+0xc8>

	if (endptr)
  800420f049:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f04e:	74 0b                	je     800420f05b <strtol+0x17d>
		*endptr = (char *) s;
  800420f050:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f054:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f058:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420f05b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f05f:	74 09                	je     800420f06a <strtol+0x18c>
  800420f061:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f065:	48 f7 d8             	neg    %rax
  800420f068:	eb 04                	jmp    800420f06e <strtol+0x190>
  800420f06a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f06e:	c9                   	leaveq 
  800420f06f:	c3                   	retq   

000000800420f070 <strstr>:

char * strstr(const char *in, const char *str)
{
  800420f070:	55                   	push   %rbp
  800420f071:	48 89 e5             	mov    %rsp,%rbp
  800420f074:	48 83 ec 30          	sub    $0x30,%rsp
  800420f078:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f07c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420f080:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f084:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f088:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420f08c:	0f b6 00             	movzbl (%rax),%eax
  800420f08f:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420f092:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420f096:	75 06                	jne    800420f09e <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420f098:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f09c:	eb 6b                	jmp    800420f109 <strstr+0x99>

	len = strlen(str);
  800420f09e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f0a2:	48 89 c7             	mov    %rax,%rdi
  800420f0a5:	48 b8 46 e9 20 04 80 	movabs $0x800420e946,%rax
  800420f0ac:	00 00 00 
  800420f0af:	ff d0                	callq  *%rax
  800420f0b1:	48 98                	cltq   
  800420f0b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420f0b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0bb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f0bf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420f0c3:	0f b6 00             	movzbl (%rax),%eax
  800420f0c6:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420f0c9:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420f0cd:	75 07                	jne    800420f0d6 <strstr+0x66>
				return (char *) 0;
  800420f0cf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f0d4:	eb 33                	jmp    800420f109 <strstr+0x99>
		} while (sc != c);
  800420f0d6:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420f0da:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420f0dd:	75 d8                	jne    800420f0b7 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420f0df:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f0e3:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420f0e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0eb:	48 89 ce             	mov    %rcx,%rsi
  800420f0ee:	48 89 c7             	mov    %rax,%rdi
  800420f0f1:	48 b8 67 eb 20 04 80 	movabs $0x800420eb67,%rax
  800420f0f8:	00 00 00 
  800420f0fb:	ff d0                	callq  *%rax
  800420f0fd:	85 c0                	test   %eax,%eax
  800420f0ff:	75 b6                	jne    800420f0b7 <strstr+0x47>

	return (char *) (in - 1);
  800420f101:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f105:	48 83 e8 01          	sub    $0x1,%rax
}
  800420f109:	c9                   	leaveq 
  800420f10a:	c3                   	retq   

000000800420f10b <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420f10b:	55                   	push   %rbp
  800420f10c:	48 89 e5             	mov    %rsp,%rbp
  800420f10f:	48 83 ec 24          	sub    $0x24,%rsp
  800420f113:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f117:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f11b:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420f11e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f122:	48 8b 10             	mov    (%rax),%rdx
  800420f125:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f129:	48 01 d0             	add    %rdx,%rax
  800420f12c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f130:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f137:	00 
	switch (bytes_to_read) {
  800420f138:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f13b:	83 f8 02             	cmp    $0x2,%eax
  800420f13e:	0f 84 ab 00 00 00    	je     800420f1ef <_dwarf_read_lsb+0xe4>
  800420f144:	83 f8 02             	cmp    $0x2,%eax
  800420f147:	7f 0e                	jg     800420f157 <_dwarf_read_lsb+0x4c>
  800420f149:	83 f8 01             	cmp    $0x1,%eax
  800420f14c:	0f 84 b3 00 00 00    	je     800420f205 <_dwarf_read_lsb+0xfa>
  800420f152:	e9 d9 00 00 00       	jmpq   800420f230 <_dwarf_read_lsb+0x125>
  800420f157:	83 f8 04             	cmp    $0x4,%eax
  800420f15a:	74 65                	je     800420f1c1 <_dwarf_read_lsb+0xb6>
  800420f15c:	83 f8 08             	cmp    $0x8,%eax
  800420f15f:	0f 85 cb 00 00 00    	jne    800420f230 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420f165:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f169:	48 83 c0 04          	add    $0x4,%rax
  800420f16d:	0f b6 00             	movzbl (%rax),%eax
  800420f170:	0f b6 c0             	movzbl %al,%eax
  800420f173:	48 c1 e0 20          	shl    $0x20,%rax
  800420f177:	48 89 c2             	mov    %rax,%rdx
  800420f17a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f17e:	48 83 c0 05          	add    $0x5,%rax
  800420f182:	0f b6 00             	movzbl (%rax),%eax
  800420f185:	0f b6 c0             	movzbl %al,%eax
  800420f188:	48 c1 e0 28          	shl    $0x28,%rax
  800420f18c:	48 09 d0             	or     %rdx,%rax
  800420f18f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420f193:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f197:	48 83 c0 06          	add    $0x6,%rax
  800420f19b:	0f b6 00             	movzbl (%rax),%eax
  800420f19e:	0f b6 c0             	movzbl %al,%eax
  800420f1a1:	48 c1 e0 30          	shl    $0x30,%rax
  800420f1a5:	48 89 c2             	mov    %rax,%rdx
  800420f1a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1ac:	48 83 c0 07          	add    $0x7,%rax
  800420f1b0:	0f b6 00             	movzbl (%rax),%eax
  800420f1b3:	0f b6 c0             	movzbl %al,%eax
  800420f1b6:	48 c1 e0 38          	shl    $0x38,%rax
  800420f1ba:	48 09 d0             	or     %rdx,%rax
  800420f1bd:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420f1c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1c5:	48 83 c0 02          	add    $0x2,%rax
  800420f1c9:	0f b6 00             	movzbl (%rax),%eax
  800420f1cc:	0f b6 c0             	movzbl %al,%eax
  800420f1cf:	48 c1 e0 10          	shl    $0x10,%rax
  800420f1d3:	48 89 c2             	mov    %rax,%rdx
  800420f1d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1da:	48 83 c0 03          	add    $0x3,%rax
  800420f1de:	0f b6 00             	movzbl (%rax),%eax
  800420f1e1:	0f b6 c0             	movzbl %al,%eax
  800420f1e4:	48 c1 e0 18          	shl    $0x18,%rax
  800420f1e8:	48 09 d0             	or     %rdx,%rax
  800420f1eb:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420f1ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1f3:	48 83 c0 01          	add    $0x1,%rax
  800420f1f7:	0f b6 00             	movzbl (%rax),%eax
  800420f1fa:	0f b6 c0             	movzbl %al,%eax
  800420f1fd:	48 c1 e0 08          	shl    $0x8,%rax
  800420f201:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420f205:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f209:	0f b6 00             	movzbl (%rax),%eax
  800420f20c:	0f b6 c0             	movzbl %al,%eax
  800420f20f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f213:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420f214:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f218:	48 8b 10             	mov    (%rax),%rdx
  800420f21b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f21e:	48 98                	cltq   
  800420f220:	48 01 c2             	add    %rax,%rdx
  800420f223:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f227:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f22a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f22e:	eb 05                	jmp    800420f235 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420f230:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420f235:	c9                   	leaveq 
  800420f236:	c3                   	retq   

000000800420f237 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420f237:	55                   	push   %rbp
  800420f238:	48 89 e5             	mov    %rsp,%rbp
  800420f23b:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f23f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f243:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f246:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f24a:	48 8b 00             	mov    (%rax),%rax
  800420f24d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f251:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f258:	00 
	switch (bytes_to_read) {
  800420f259:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f25c:	83 f8 02             	cmp    $0x2,%eax
  800420f25f:	0f 84 ab 00 00 00    	je     800420f310 <_dwarf_decode_lsb+0xd9>
  800420f265:	83 f8 02             	cmp    $0x2,%eax
  800420f268:	7f 0e                	jg     800420f278 <_dwarf_decode_lsb+0x41>
  800420f26a:	83 f8 01             	cmp    $0x1,%eax
  800420f26d:	0f 84 b3 00 00 00    	je     800420f326 <_dwarf_decode_lsb+0xef>
  800420f273:	e9 d9 00 00 00       	jmpq   800420f351 <_dwarf_decode_lsb+0x11a>
  800420f278:	83 f8 04             	cmp    $0x4,%eax
  800420f27b:	74 65                	je     800420f2e2 <_dwarf_decode_lsb+0xab>
  800420f27d:	83 f8 08             	cmp    $0x8,%eax
  800420f280:	0f 85 cb 00 00 00    	jne    800420f351 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420f286:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f28a:	48 83 c0 04          	add    $0x4,%rax
  800420f28e:	0f b6 00             	movzbl (%rax),%eax
  800420f291:	0f b6 c0             	movzbl %al,%eax
  800420f294:	48 c1 e0 20          	shl    $0x20,%rax
  800420f298:	48 89 c2             	mov    %rax,%rdx
  800420f29b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f29f:	48 83 c0 05          	add    $0x5,%rax
  800420f2a3:	0f b6 00             	movzbl (%rax),%eax
  800420f2a6:	0f b6 c0             	movzbl %al,%eax
  800420f2a9:	48 c1 e0 28          	shl    $0x28,%rax
  800420f2ad:	48 09 d0             	or     %rdx,%rax
  800420f2b0:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420f2b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2b8:	48 83 c0 06          	add    $0x6,%rax
  800420f2bc:	0f b6 00             	movzbl (%rax),%eax
  800420f2bf:	0f b6 c0             	movzbl %al,%eax
  800420f2c2:	48 c1 e0 30          	shl    $0x30,%rax
  800420f2c6:	48 89 c2             	mov    %rax,%rdx
  800420f2c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2cd:	48 83 c0 07          	add    $0x7,%rax
  800420f2d1:	0f b6 00             	movzbl (%rax),%eax
  800420f2d4:	0f b6 c0             	movzbl %al,%eax
  800420f2d7:	48 c1 e0 38          	shl    $0x38,%rax
  800420f2db:	48 09 d0             	or     %rdx,%rax
  800420f2de:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420f2e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2e6:	48 83 c0 02          	add    $0x2,%rax
  800420f2ea:	0f b6 00             	movzbl (%rax),%eax
  800420f2ed:	0f b6 c0             	movzbl %al,%eax
  800420f2f0:	48 c1 e0 10          	shl    $0x10,%rax
  800420f2f4:	48 89 c2             	mov    %rax,%rdx
  800420f2f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2fb:	48 83 c0 03          	add    $0x3,%rax
  800420f2ff:	0f b6 00             	movzbl (%rax),%eax
  800420f302:	0f b6 c0             	movzbl %al,%eax
  800420f305:	48 c1 e0 18          	shl    $0x18,%rax
  800420f309:	48 09 d0             	or     %rdx,%rax
  800420f30c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420f310:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f314:	48 83 c0 01          	add    $0x1,%rax
  800420f318:	0f b6 00             	movzbl (%rax),%eax
  800420f31b:	0f b6 c0             	movzbl %al,%eax
  800420f31e:	48 c1 e0 08          	shl    $0x8,%rax
  800420f322:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420f326:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f32a:	0f b6 00             	movzbl (%rax),%eax
  800420f32d:	0f b6 c0             	movzbl %al,%eax
  800420f330:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f334:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420f335:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f339:	48 8b 10             	mov    (%rax),%rdx
  800420f33c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f33f:	48 98                	cltq   
  800420f341:	48 01 c2             	add    %rax,%rdx
  800420f344:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f348:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f34b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f34f:	eb 05                	jmp    800420f356 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420f351:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420f356:	c9                   	leaveq 
  800420f357:	c3                   	retq   

000000800420f358 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420f358:	55                   	push   %rbp
  800420f359:	48 89 e5             	mov    %rsp,%rbp
  800420f35c:	48 83 ec 24          	sub    $0x24,%rsp
  800420f360:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f364:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f368:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420f36b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f36f:	48 8b 10             	mov    (%rax),%rdx
  800420f372:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f376:	48 01 d0             	add    %rdx,%rax
  800420f379:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420f37d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f380:	83 f8 02             	cmp    $0x2,%eax
  800420f383:	74 35                	je     800420f3ba <_dwarf_read_msb+0x62>
  800420f385:	83 f8 02             	cmp    $0x2,%eax
  800420f388:	7f 0a                	jg     800420f394 <_dwarf_read_msb+0x3c>
  800420f38a:	83 f8 01             	cmp    $0x1,%eax
  800420f38d:	74 18                	je     800420f3a7 <_dwarf_read_msb+0x4f>
  800420f38f:	e9 53 01 00 00       	jmpq   800420f4e7 <_dwarf_read_msb+0x18f>
  800420f394:	83 f8 04             	cmp    $0x4,%eax
  800420f397:	74 49                	je     800420f3e2 <_dwarf_read_msb+0x8a>
  800420f399:	83 f8 08             	cmp    $0x8,%eax
  800420f39c:	0f 84 96 00 00 00    	je     800420f438 <_dwarf_read_msb+0xe0>
  800420f3a2:	e9 40 01 00 00       	jmpq   800420f4e7 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800420f3a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3ab:	0f b6 00             	movzbl (%rax),%eax
  800420f3ae:	0f b6 c0             	movzbl %al,%eax
  800420f3b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f3b5:	e9 34 01 00 00       	jmpq   800420f4ee <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f3ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3be:	48 83 c0 01          	add    $0x1,%rax
  800420f3c2:	0f b6 00             	movzbl (%rax),%eax
  800420f3c5:	0f b6 d0             	movzbl %al,%edx
  800420f3c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3cc:	0f b6 00             	movzbl (%rax),%eax
  800420f3cf:	0f b6 c0             	movzbl %al,%eax
  800420f3d2:	48 c1 e0 08          	shl    $0x8,%rax
  800420f3d6:	48 09 d0             	or     %rdx,%rax
  800420f3d9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f3dd:	e9 0c 01 00 00       	jmpq   800420f4ee <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f3e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3e6:	48 83 c0 03          	add    $0x3,%rax
  800420f3ea:	0f b6 00             	movzbl (%rax),%eax
  800420f3ed:	0f b6 c0             	movzbl %al,%eax
  800420f3f0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f3f4:	48 83 c2 02          	add    $0x2,%rdx
  800420f3f8:	0f b6 12             	movzbl (%rdx),%edx
  800420f3fb:	0f b6 d2             	movzbl %dl,%edx
  800420f3fe:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f402:	48 09 d0             	or     %rdx,%rax
  800420f405:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f409:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f40d:	48 83 c0 01          	add    $0x1,%rax
  800420f411:	0f b6 00             	movzbl (%rax),%eax
  800420f414:	0f b6 c0             	movzbl %al,%eax
  800420f417:	48 c1 e0 10          	shl    $0x10,%rax
  800420f41b:	48 89 c2             	mov    %rax,%rdx
  800420f41e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f422:	0f b6 00             	movzbl (%rax),%eax
  800420f425:	0f b6 c0             	movzbl %al,%eax
  800420f428:	48 c1 e0 18          	shl    $0x18,%rax
  800420f42c:	48 09 d0             	or     %rdx,%rax
  800420f42f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f433:	e9 b6 00 00 00       	jmpq   800420f4ee <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f438:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f43c:	48 83 c0 07          	add    $0x7,%rax
  800420f440:	0f b6 00             	movzbl (%rax),%eax
  800420f443:	0f b6 c0             	movzbl %al,%eax
  800420f446:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f44a:	48 83 c2 06          	add    $0x6,%rdx
  800420f44e:	0f b6 12             	movzbl (%rdx),%edx
  800420f451:	0f b6 d2             	movzbl %dl,%edx
  800420f454:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f458:	48 09 d0             	or     %rdx,%rax
  800420f45b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f45f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f463:	48 83 c0 05          	add    $0x5,%rax
  800420f467:	0f b6 00             	movzbl (%rax),%eax
  800420f46a:	0f b6 c0             	movzbl %al,%eax
  800420f46d:	48 c1 e0 10          	shl    $0x10,%rax
  800420f471:	48 89 c2             	mov    %rax,%rdx
  800420f474:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f478:	48 83 c0 04          	add    $0x4,%rax
  800420f47c:	0f b6 00             	movzbl (%rax),%eax
  800420f47f:	0f b6 c0             	movzbl %al,%eax
  800420f482:	48 c1 e0 18          	shl    $0x18,%rax
  800420f486:	48 09 d0             	or     %rdx,%rax
  800420f489:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f48d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f491:	48 83 c0 03          	add    $0x3,%rax
  800420f495:	0f b6 00             	movzbl (%rax),%eax
  800420f498:	0f b6 c0             	movzbl %al,%eax
  800420f49b:	48 c1 e0 20          	shl    $0x20,%rax
  800420f49f:	48 89 c2             	mov    %rax,%rdx
  800420f4a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4a6:	48 83 c0 02          	add    $0x2,%rax
  800420f4aa:	0f b6 00             	movzbl (%rax),%eax
  800420f4ad:	0f b6 c0             	movzbl %al,%eax
  800420f4b0:	48 c1 e0 28          	shl    $0x28,%rax
  800420f4b4:	48 09 d0             	or     %rdx,%rax
  800420f4b7:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f4bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4bf:	48 83 c0 01          	add    $0x1,%rax
  800420f4c3:	0f b6 00             	movzbl (%rax),%eax
  800420f4c6:	0f b6 c0             	movzbl %al,%eax
  800420f4c9:	48 c1 e0 30          	shl    $0x30,%rax
  800420f4cd:	48 89 c2             	mov    %rax,%rdx
  800420f4d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4d4:	0f b6 00             	movzbl (%rax),%eax
  800420f4d7:	0f b6 c0             	movzbl %al,%eax
  800420f4da:	48 c1 e0 38          	shl    $0x38,%rax
  800420f4de:	48 09 d0             	or     %rdx,%rax
  800420f4e1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f4e5:	eb 07                	jmp    800420f4ee <_dwarf_read_msb+0x196>
	default:
		return (0);
  800420f4e7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f4ec:	eb 1a                	jmp    800420f508 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800420f4ee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f4f2:	48 8b 10             	mov    (%rax),%rdx
  800420f4f5:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f4f8:	48 98                	cltq   
  800420f4fa:	48 01 c2             	add    %rax,%rdx
  800420f4fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f501:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f504:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f508:	c9                   	leaveq 
  800420f509:	c3                   	retq   

000000800420f50a <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420f50a:	55                   	push   %rbp
  800420f50b:	48 89 e5             	mov    %rsp,%rbp
  800420f50e:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f512:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f516:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f519:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f51d:	48 8b 00             	mov    (%rax),%rax
  800420f520:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f524:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f52b:	00 
	switch (bytes_to_read) {
  800420f52c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f52f:	83 f8 02             	cmp    $0x2,%eax
  800420f532:	74 35                	je     800420f569 <_dwarf_decode_msb+0x5f>
  800420f534:	83 f8 02             	cmp    $0x2,%eax
  800420f537:	7f 0a                	jg     800420f543 <_dwarf_decode_msb+0x39>
  800420f539:	83 f8 01             	cmp    $0x1,%eax
  800420f53c:	74 18                	je     800420f556 <_dwarf_decode_msb+0x4c>
  800420f53e:	e9 53 01 00 00       	jmpq   800420f696 <_dwarf_decode_msb+0x18c>
  800420f543:	83 f8 04             	cmp    $0x4,%eax
  800420f546:	74 49                	je     800420f591 <_dwarf_decode_msb+0x87>
  800420f548:	83 f8 08             	cmp    $0x8,%eax
  800420f54b:	0f 84 96 00 00 00    	je     800420f5e7 <_dwarf_decode_msb+0xdd>
  800420f551:	e9 40 01 00 00       	jmpq   800420f696 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420f556:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f55a:	0f b6 00             	movzbl (%rax),%eax
  800420f55d:	0f b6 c0             	movzbl %al,%eax
  800420f560:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f564:	e9 34 01 00 00       	jmpq   800420f69d <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f569:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f56d:	48 83 c0 01          	add    $0x1,%rax
  800420f571:	0f b6 00             	movzbl (%rax),%eax
  800420f574:	0f b6 d0             	movzbl %al,%edx
  800420f577:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f57b:	0f b6 00             	movzbl (%rax),%eax
  800420f57e:	0f b6 c0             	movzbl %al,%eax
  800420f581:	48 c1 e0 08          	shl    $0x8,%rax
  800420f585:	48 09 d0             	or     %rdx,%rax
  800420f588:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f58c:	e9 0c 01 00 00       	jmpq   800420f69d <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f591:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f595:	48 83 c0 03          	add    $0x3,%rax
  800420f599:	0f b6 00             	movzbl (%rax),%eax
  800420f59c:	0f b6 c0             	movzbl %al,%eax
  800420f59f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5a3:	48 83 c2 02          	add    $0x2,%rdx
  800420f5a7:	0f b6 12             	movzbl (%rdx),%edx
  800420f5aa:	0f b6 d2             	movzbl %dl,%edx
  800420f5ad:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f5b1:	48 09 d0             	or     %rdx,%rax
  800420f5b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f5b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5bc:	48 83 c0 01          	add    $0x1,%rax
  800420f5c0:	0f b6 00             	movzbl (%rax),%eax
  800420f5c3:	0f b6 c0             	movzbl %al,%eax
  800420f5c6:	48 c1 e0 10          	shl    $0x10,%rax
  800420f5ca:	48 89 c2             	mov    %rax,%rdx
  800420f5cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5d1:	0f b6 00             	movzbl (%rax),%eax
  800420f5d4:	0f b6 c0             	movzbl %al,%eax
  800420f5d7:	48 c1 e0 18          	shl    $0x18,%rax
  800420f5db:	48 09 d0             	or     %rdx,%rax
  800420f5de:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f5e2:	e9 b6 00 00 00       	jmpq   800420f69d <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f5e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5eb:	48 83 c0 07          	add    $0x7,%rax
  800420f5ef:	0f b6 00             	movzbl (%rax),%eax
  800420f5f2:	0f b6 c0             	movzbl %al,%eax
  800420f5f5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5f9:	48 83 c2 06          	add    $0x6,%rdx
  800420f5fd:	0f b6 12             	movzbl (%rdx),%edx
  800420f600:	0f b6 d2             	movzbl %dl,%edx
  800420f603:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f607:	48 09 d0             	or     %rdx,%rax
  800420f60a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f60e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f612:	48 83 c0 05          	add    $0x5,%rax
  800420f616:	0f b6 00             	movzbl (%rax),%eax
  800420f619:	0f b6 c0             	movzbl %al,%eax
  800420f61c:	48 c1 e0 10          	shl    $0x10,%rax
  800420f620:	48 89 c2             	mov    %rax,%rdx
  800420f623:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f627:	48 83 c0 04          	add    $0x4,%rax
  800420f62b:	0f b6 00             	movzbl (%rax),%eax
  800420f62e:	0f b6 c0             	movzbl %al,%eax
  800420f631:	48 c1 e0 18          	shl    $0x18,%rax
  800420f635:	48 09 d0             	or     %rdx,%rax
  800420f638:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f63c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f640:	48 83 c0 03          	add    $0x3,%rax
  800420f644:	0f b6 00             	movzbl (%rax),%eax
  800420f647:	0f b6 c0             	movzbl %al,%eax
  800420f64a:	48 c1 e0 20          	shl    $0x20,%rax
  800420f64e:	48 89 c2             	mov    %rax,%rdx
  800420f651:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f655:	48 83 c0 02          	add    $0x2,%rax
  800420f659:	0f b6 00             	movzbl (%rax),%eax
  800420f65c:	0f b6 c0             	movzbl %al,%eax
  800420f65f:	48 c1 e0 28          	shl    $0x28,%rax
  800420f663:	48 09 d0             	or     %rdx,%rax
  800420f666:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f66a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f66e:	48 83 c0 01          	add    $0x1,%rax
  800420f672:	0f b6 00             	movzbl (%rax),%eax
  800420f675:	0f b6 c0             	movzbl %al,%eax
  800420f678:	48 c1 e0 30          	shl    $0x30,%rax
  800420f67c:	48 89 c2             	mov    %rax,%rdx
  800420f67f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f683:	0f b6 00             	movzbl (%rax),%eax
  800420f686:	0f b6 c0             	movzbl %al,%eax
  800420f689:	48 c1 e0 38          	shl    $0x38,%rax
  800420f68d:	48 09 d0             	or     %rdx,%rax
  800420f690:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f694:	eb 07                	jmp    800420f69d <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420f696:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f69b:	eb 1a                	jmp    800420f6b7 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420f69d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6a1:	48 8b 10             	mov    (%rax),%rdx
  800420f6a4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f6a7:	48 98                	cltq   
  800420f6a9:	48 01 c2             	add    %rax,%rdx
  800420f6ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6b0:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f6b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f6b7:	c9                   	leaveq 
  800420f6b8:	c3                   	retq   

000000800420f6b9 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f6b9:	55                   	push   %rbp
  800420f6ba:	48 89 e5             	mov    %rsp,%rbp
  800420f6bd:	48 83 ec 30          	sub    $0x30,%rsp
  800420f6c1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f6c5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800420f6c9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f6d0:	00 
	uint8_t b;
	int shift = 0;
  800420f6d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f6d8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f6dc:	48 8b 10             	mov    (%rax),%rdx
  800420f6df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f6e3:	48 01 d0             	add    %rdx,%rax
  800420f6e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f6ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6ee:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f6f2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f6f6:	0f b6 00             	movzbl (%rax),%eax
  800420f6f9:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f6fc:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f700:	83 e0 7f             	and    $0x7f,%eax
  800420f703:	89 c2                	mov    %eax,%edx
  800420f705:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f708:	89 c1                	mov    %eax,%ecx
  800420f70a:	d3 e2                	shl    %cl,%edx
  800420f70c:	89 d0                	mov    %edx,%eax
  800420f70e:	48 98                	cltq   
  800420f710:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f714:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f718:	48 8b 00             	mov    (%rax),%rax
  800420f71b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f71f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f723:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f726:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f72a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f72e:	84 c0                	test   %al,%al
  800420f730:	78 b8                	js     800420f6ea <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800420f732:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f736:	7f 1f                	jg     800420f757 <_dwarf_read_sleb128+0x9e>
  800420f738:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f73c:	83 e0 40             	and    $0x40,%eax
  800420f73f:	85 c0                	test   %eax,%eax
  800420f741:	74 14                	je     800420f757 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800420f743:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f746:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f74b:	89 c1                	mov    %eax,%ecx
  800420f74d:	d3 e2                	shl    %cl,%edx
  800420f74f:	89 d0                	mov    %edx,%eax
  800420f751:	48 98                	cltq   
  800420f753:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  800420f757:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f75b:	c9                   	leaveq 
  800420f75c:	c3                   	retq   

000000800420f75d <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f75d:	55                   	push   %rbp
  800420f75e:	48 89 e5             	mov    %rsp,%rbp
  800420f761:	48 83 ec 30          	sub    $0x30,%rsp
  800420f765:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f769:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800420f76d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f774:	00 
	uint8_t b;
	int shift = 0;
  800420f775:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f77c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f780:	48 8b 10             	mov    (%rax),%rdx
  800420f783:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f787:	48 01 d0             	add    %rdx,%rax
  800420f78a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f78e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f792:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f796:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f79a:	0f b6 00             	movzbl (%rax),%eax
  800420f79d:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f7a0:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f7a4:	83 e0 7f             	and    $0x7f,%eax
  800420f7a7:	89 c2                	mov    %eax,%edx
  800420f7a9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f7ac:	89 c1                	mov    %eax,%ecx
  800420f7ae:	d3 e2                	shl    %cl,%edx
  800420f7b0:	89 d0                	mov    %edx,%eax
  800420f7b2:	48 98                	cltq   
  800420f7b4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f7b8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f7bc:	48 8b 00             	mov    (%rax),%rax
  800420f7bf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f7c3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f7c7:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f7ca:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f7ce:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f7d2:	84 c0                	test   %al,%al
  800420f7d4:	78 b8                	js     800420f78e <_dwarf_read_uleb128+0x31>

	return (ret);
  800420f7d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f7da:	c9                   	leaveq 
  800420f7db:	c3                   	retq   

000000800420f7dc <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420f7dc:	55                   	push   %rbp
  800420f7dd:	48 89 e5             	mov    %rsp,%rbp
  800420f7e0:	48 83 ec 28          	sub    $0x28,%rsp
  800420f7e4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800420f7e8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f7ef:	00 
	uint8_t b;
	int shift = 0;
  800420f7f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420f7f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f7fb:	48 8b 00             	mov    (%rax),%rax
  800420f7fe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f802:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f806:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f80a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f80e:	0f b6 00             	movzbl (%rax),%eax
  800420f811:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f814:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f818:	83 e0 7f             	and    $0x7f,%eax
  800420f81b:	89 c2                	mov    %eax,%edx
  800420f81d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f820:	89 c1                	mov    %eax,%ecx
  800420f822:	d3 e2                	shl    %cl,%edx
  800420f824:	89 d0                	mov    %edx,%eax
  800420f826:	48 98                	cltq   
  800420f828:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420f82c:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f830:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f834:	84 c0                	test   %al,%al
  800420f836:	78 ca                	js     800420f802 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800420f838:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f83c:	7f 1f                	jg     800420f85d <_dwarf_decode_sleb128+0x81>
  800420f83e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f842:	83 e0 40             	and    $0x40,%eax
  800420f845:	85 c0                	test   %eax,%eax
  800420f847:	74 14                	je     800420f85d <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800420f849:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f84c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f851:	89 c1                	mov    %eax,%ecx
  800420f853:	d3 e2                	shl    %cl,%edx
  800420f855:	89 d0                	mov    %edx,%eax
  800420f857:	48 98                	cltq   
  800420f859:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800420f85d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f861:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f865:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f868:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f86c:	c9                   	leaveq 
  800420f86d:	c3                   	retq   

000000800420f86e <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420f86e:	55                   	push   %rbp
  800420f86f:	48 89 e5             	mov    %rsp,%rbp
  800420f872:	48 83 ec 28          	sub    $0x28,%rsp
  800420f876:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  800420f87a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f881:	00 
	uint8_t b;
	int shift = 0;
  800420f882:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420f889:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f88d:	48 8b 00             	mov    (%rax),%rax
  800420f890:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f894:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f898:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f89c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f8a0:	0f b6 00             	movzbl (%rax),%eax
  800420f8a3:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f8a6:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f8aa:	83 e0 7f             	and    $0x7f,%eax
  800420f8ad:	89 c2                	mov    %eax,%edx
  800420f8af:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f8b2:	89 c1                	mov    %eax,%ecx
  800420f8b4:	d3 e2                	shl    %cl,%edx
  800420f8b6:	89 d0                	mov    %edx,%eax
  800420f8b8:	48 98                	cltq   
  800420f8ba:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420f8be:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f8c2:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f8c6:	84 c0                	test   %al,%al
  800420f8c8:	78 ca                	js     800420f894 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800420f8ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f8ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f8d2:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f8d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f8d9:	c9                   	leaveq 
  800420f8da:	c3                   	retq   

000000800420f8db <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420f8db:	55                   	push   %rbp
  800420f8dc:	48 89 e5             	mov    %rsp,%rbp
  800420f8df:	48 83 ec 28          	sub    $0x28,%rsp
  800420f8e3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f8e7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f8eb:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420f8ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f8f3:	48 8b 10             	mov    (%rax),%rdx
  800420f8f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8fa:	48 01 d0             	add    %rdx,%rax
  800420f8fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f901:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f905:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420f909:	eb 17                	jmp    800420f922 <_dwarf_read_string+0x47>
		src++;
  800420f90b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420f910:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f914:	48 8b 00             	mov    (%rax),%rax
  800420f917:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f91b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f91f:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800420f922:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f926:	0f b6 00             	movzbl (%rax),%eax
  800420f929:	84 c0                	test   %al,%al
  800420f92b:	74 0d                	je     800420f93a <_dwarf_read_string+0x5f>
  800420f92d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f931:	48 8b 00             	mov    (%rax),%rax
  800420f934:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f938:	72 d1                	jb     800420f90b <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800420f93a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f93e:	0f b6 00             	movzbl (%rax),%eax
  800420f941:	84 c0                	test   %al,%al
  800420f943:	75 1f                	jne    800420f964 <_dwarf_read_string+0x89>
  800420f945:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f949:	48 8b 00             	mov    (%rax),%rax
  800420f94c:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f950:	73 12                	jae    800420f964 <_dwarf_read_string+0x89>
		(*offsetp)++;
  800420f952:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f956:	48 8b 00             	mov    (%rax),%rax
  800420f959:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f95d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f961:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f964:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f968:	c9                   	leaveq 
  800420f969:	c3                   	retq   

000000800420f96a <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420f96a:	55                   	push   %rbp
  800420f96b:	48 89 e5             	mov    %rsp,%rbp
  800420f96e:	48 83 ec 28          	sub    $0x28,%rsp
  800420f972:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f976:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f97a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420f97e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f982:	48 8b 10             	mov    (%rax),%rdx
  800420f985:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f989:	48 01 d0             	add    %rdx,%rax
  800420f98c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f990:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f994:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420f998:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f99c:	48 8b 10             	mov    (%rax),%rdx
  800420f99f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f9a3:	48 01 c2             	add    %rax,%rdx
  800420f9a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f9aa:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f9ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f9b1:	c9                   	leaveq 
  800420f9b2:	c3                   	retq   

000000800420f9b3 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420f9b3:	55                   	push   %rbp
  800420f9b4:	48 89 e5             	mov    %rsp,%rbp
  800420f9b7:	48 83 ec 20          	sub    $0x20,%rsp
  800420f9bb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  800420f9bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420f9c7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420f9cc:	75 35                	jne    800420fa03 <_dwarf_elf_get_byte_order+0x50>
  800420f9ce:	48 b9 e0 83 21 04 80 	movabs $0x80042183e0,%rcx
  800420f9d5:	00 00 00 
  800420f9d8:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  800420f9df:	00 00 00 
  800420f9e2:	be 29 01 00 00       	mov    $0x129,%esi
  800420f9e7:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  800420f9ee:	00 00 00 
  800420f9f1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f9f6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420f9fd:	00 00 00 
  800420fa00:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800420fa03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa07:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420fa0b:	0f b6 c0             	movzbl %al,%eax
  800420fa0e:	83 f8 02             	cmp    $0x2,%eax
  800420fa11:	75 07                	jne    800420fa1a <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800420fa13:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa18:	eb 05                	jmp    800420fa1f <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800420fa1a:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800420fa1f:	c9                   	leaveq 
  800420fa20:	c3                   	retq   

000000800420fa21 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420fa21:	55                   	push   %rbp
  800420fa22:	48 89 e5             	mov    %rsp,%rbp
  800420fa25:	48 83 ec 20          	sub    $0x20,%rsp
  800420fa29:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800420fa2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa31:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420fa35:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420fa3a:	75 35                	jne    800420fa71 <_dwarf_elf_get_pointer_size+0x50>
  800420fa3c:	48 b9 e0 83 21 04 80 	movabs $0x80042183e0,%rcx
  800420fa43:	00 00 00 
  800420fa46:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  800420fa4d:	00 00 00 
  800420fa50:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420fa55:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  800420fa5c:	00 00 00 
  800420fa5f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa64:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fa6b:	00 00 00 
  800420fa6e:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  800420fa71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa75:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420fa79:	3c 01                	cmp    $0x1,%al
  800420fa7b:	75 07                	jne    800420fa84 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  800420fa7d:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fa82:	eb 05                	jmp    800420fa89 <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800420fa84:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420fa89:	c9                   	leaveq 
  800420fa8a:	c3                   	retq   

000000800420fa8b <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420fa8b:	55                   	push   %rbp
  800420fa8c:	48 89 e5             	mov    %rsp,%rbp
  800420fa8f:	53                   	push   %rbx
  800420fa90:	48 83 ec 18          	sub    $0x18,%rsp
  800420fa94:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fa98:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420fa9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faa0:	ba 60 00 00 00       	mov    $0x60,%edx
  800420faa5:	be 00 00 00 00       	mov    $0x0,%esi
  800420faaa:	48 89 c7             	mov    %rax,%rdi
  800420faad:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  800420fab4:	00 00 00 
  800420fab7:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  800420fab9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fabd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  800420fac4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fac8:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420facf:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420fad0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fad4:	48 89 c7             	mov    %rax,%rdi
  800420fad7:	48 b8 21 fa 20 04 80 	movabs $0x800420fa21,%rax
  800420fade:	00 00 00 
  800420fae1:	ff d0                	callq  *%rax
  800420fae3:	0f b6 d0             	movzbl %al,%edx
  800420fae6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faea:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420faed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420faf1:	48 89 c7             	mov    %rax,%rdi
  800420faf4:	48 b8 b3 f9 20 04 80 	movabs $0x800420f9b3,%rax
  800420fafb:	00 00 00 
  800420fafe:	ff d0                	callq  *%rax
  800420fb00:	85 c0                	test   %eax,%eax
  800420fb02:	75 26                	jne    800420fb2a <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  800420fb04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb08:	48 b9 58 f3 20 04 80 	movabs $0x800420f358,%rcx
  800420fb0f:	00 00 00 
  800420fb12:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  800420fb16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb1a:	48 bb 0a f5 20 04 80 	movabs $0x800420f50a,%rbx
  800420fb21:	00 00 00 
  800420fb24:	48 89 58 20          	mov    %rbx,0x20(%rax)
  800420fb28:	eb 24                	jmp    800420fb4e <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  800420fb2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb2e:	48 b9 0b f1 20 04 80 	movabs $0x800420f10b,%rcx
  800420fb35:	00 00 00 
  800420fb38:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800420fb3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb40:	48 be 37 f2 20 04 80 	movabs $0x800420f237,%rsi
  800420fb47:	00 00 00 
  800420fb4a:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800420fb4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb52:	48 89 c7             	mov    %rax,%rdi
  800420fb55:	48 b8 58 10 21 04 80 	movabs $0x8004211058,%rax
  800420fb5c:	00 00 00 
  800420fb5f:	ff d0                	callq  *%rax
	return 0;
  800420fb61:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fb66:	48 83 c4 18          	add    $0x18,%rsp
  800420fb6a:	5b                   	pop    %rbx
  800420fb6b:	5d                   	pop    %rbp
  800420fb6c:	c3                   	retq   

000000800420fb6d <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420fb6d:	55                   	push   %rbp
  800420fb6e:	48 89 e5             	mov    %rsp,%rbp
  800420fb71:	48 83 ec 20          	sub    $0x20,%rsp
  800420fb75:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fb79:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420fb7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb81:	48 8b 10             	mov    (%rax),%rdx
  800420fb84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb88:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420fb8c:	48 39 c2             	cmp    %rax,%rdx
  800420fb8f:	76 0a                	jbe    800420fb9b <_get_next_cu+0x2e>
		return -1;
  800420fb91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fb96:	e9 6b 01 00 00       	jmpq   800420fd06 <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  800420fb9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb9f:	48 8b 00             	mov    (%rax),%rax
  800420fba2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420fba6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fbaa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fbae:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420fbb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbb6:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fbba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fbbe:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fbc2:	48 89 d1             	mov    %rdx,%rcx
  800420fbc5:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fbc9:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fbce:	48 89 cf             	mov    %rcx,%rdi
  800420fbd1:	ff d0                	callq  *%rax
  800420fbd3:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  800420fbd6:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420fbda:	75 2a                	jne    800420fc06 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420fbdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbe0:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fbe4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fbe8:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fbec:	48 89 d1             	mov    %rdx,%rcx
  800420fbef:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fbf3:	ba 08 00 00 00       	mov    $0x8,%edx
  800420fbf8:	48 89 cf             	mov    %rcx,%rdi
  800420fbfb:	ff d0                	callq  *%rax
  800420fbfd:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800420fc00:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420fc04:	eb 04                	jmp    800420fc0a <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  800420fc06:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  800420fc0a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc0e:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420fc12:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420fc15:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fc18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fc1c:	48 01 c2             	add    %rax,%rdx
  800420fc1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc23:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420fc26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc2a:	48 8b 10             	mov    (%rax),%rdx
  800420fc2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc31:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420fc35:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fc38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc3c:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420fc3f:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420fc43:	75 07                	jne    800420fc4c <_get_next_cu+0xdf>
  800420fc45:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fc4a:	eb 05                	jmp    800420fc51 <_get_next_cu+0xe4>
  800420fc4c:	b8 0c 00 00 00       	mov    $0xc,%eax
  800420fc51:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fc55:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420fc58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc5c:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fc60:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fc64:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fc68:	48 89 d1             	mov    %rdx,%rcx
  800420fc6b:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fc6f:	ba 02 00 00 00       	mov    $0x2,%edx
  800420fc74:	48 89 cf             	mov    %rcx,%rdi
  800420fc77:	ff d0                	callq  *%rax
  800420fc79:	89 c2                	mov    %eax,%edx
  800420fc7b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc7f:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420fc83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc87:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fc8b:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420fc8f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fc93:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800420fc97:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fc9b:	48 89 cf             	mov    %rcx,%rdi
  800420fc9e:	ff d0                	callq  *%rax
  800420fca0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fca4:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420fca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcac:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fcb0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fcb4:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fcb8:	48 89 d1             	mov    %rdx,%rcx
  800420fcbb:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fcbf:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fcc4:	48 89 cf             	mov    %rcx,%rdi
  800420fcc7:	ff d0                	callq  *%rax
  800420fcc9:	89 c2                	mov    %eax,%edx
  800420fccb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fccf:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420fcd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fcd6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fcda:	66 83 f8 01          	cmp    $0x1,%ax
  800420fcde:	76 0e                	jbe    800420fcee <_get_next_cu+0x181>
  800420fce0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fce4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fce8:	66 83 f8 04          	cmp    $0x4,%ax
  800420fcec:	76 07                	jbe    800420fcf5 <_get_next_cu+0x188>
		return -1;
  800420fcee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fcf3:	eb 11                	jmp    800420fd06 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  800420fcf5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fcf9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fcfd:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420fd01:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fd06:	c9                   	leaveq 
  800420fd07:	c3                   	retq   

000000800420fd08 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420fd08:	55                   	push   %rbp
  800420fd09:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420fd0c:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420fd10:	0f b6 c8             	movzbl %al,%ecx
  800420fd13:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420fd17:	0f b7 d0             	movzwl %ax,%edx
  800420fd1a:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420fd1e:	48 89 c6             	mov    %rax,%rsi
  800420fd21:	48 bf 12 84 21 04 80 	movabs $0x8004218412,%rdi
  800420fd28:	00 00 00 
  800420fd2b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fd30:	49 b8 ea 86 20 04 80 	movabs $0x80042086ea,%r8
  800420fd37:	00 00 00 
  800420fd3a:	41 ff d0             	callq  *%r8
}
  800420fd3d:	5d                   	pop    %rbp
  800420fd3e:	c3                   	retq   

000000800420fd3f <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420fd3f:	55                   	push   %rbp
  800420fd40:	48 89 e5             	mov    %rsp,%rbp
  800420fd43:	48 83 ec 60          	sub    $0x60,%rsp
  800420fd47:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420fd4b:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420fd4f:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420fd53:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  800420fd57:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420fd5c:	75 35                	jne    800420fd93 <_dwarf_abbrev_parse+0x54>
  800420fd5e:	48 b9 21 84 21 04 80 	movabs $0x8004218421,%rcx
  800420fd65:	00 00 00 
  800420fd68:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  800420fd6f:	00 00 00 
  800420fd72:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420fd77:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  800420fd7e:	00 00 00 
  800420fd81:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fd86:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fd8d:	00 00 00 
  800420fd90:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  800420fd93:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420fd98:	75 35                	jne    800420fdcf <_dwarf_abbrev_parse+0x90>
  800420fd9a:	48 b9 2d 84 21 04 80 	movabs $0x800421842d,%rcx
  800420fda1:	00 00 00 
  800420fda4:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  800420fdab:	00 00 00 
  800420fdae:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420fdb3:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  800420fdba:	00 00 00 
  800420fdbd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fdc2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fdc9:	00 00 00 
  800420fdcc:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  800420fdcf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fdd3:	48 8b 10             	mov    (%rax),%rdx
  800420fdd6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fdda:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fdde:	48 39 c2             	cmp    %rax,%rdx
  800420fde1:	72 0a                	jb     800420fded <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420fde3:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fde8:	e9 d3 01 00 00       	jmpq   800420ffc0 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  800420fded:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fdf1:	48 8b 00             	mov    (%rax),%rax
  800420fdf4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420fdf8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fdfc:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fe00:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fe04:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe08:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fe0c:	48 89 d6             	mov    %rdx,%rsi
  800420fe0f:	48 89 c7             	mov    %rax,%rdi
  800420fe12:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  800420fe19:	00 00 00 
  800420fe1c:	ff d0                	callq  *%rax
  800420fe1e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  800420fe22:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fe27:	75 15                	jne    800420fe3e <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800420fe29:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fe2d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  800420fe34:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fe39:	e9 82 01 00 00       	jmpq   800420ffc0 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fe3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe42:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fe46:	48 89 d6             	mov    %rdx,%rsi
  800420fe49:	48 89 c7             	mov    %rax,%rdi
  800420fe4c:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  800420fe53:	00 00 00 
  800420fe56:	ff d0                	callq  *%rax
  800420fe58:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800420fe5c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fe60:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe64:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420fe68:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420fe6c:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fe71:	48 89 cf             	mov    %rcx,%rdi
  800420fe74:	ff d0                	callq  *%rax
  800420fe76:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  800420fe79:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fe7d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe81:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  800420fe84:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fe88:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fe8c:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  800420fe90:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fe94:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800420fe98:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  800420fe9b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fe9f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fea3:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  800420fea7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420feab:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  800420feb2:	00 
	abp->ab_atnum    = 0;
  800420feb3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420feb7:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  800420febe:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  800420febf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fec3:	48 8b 00             	mov    (%rax),%rax
  800420fec6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420feca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fece:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fed2:	48 89 d6             	mov    %rdx,%rsi
  800420fed5:	48 89 c7             	mov    %rax,%rdi
  800420fed8:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  800420fedf:	00 00 00 
  800420fee2:	ff d0                	callq  *%rax
  800420fee4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fee8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420feec:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fef0:	48 89 d6             	mov    %rdx,%rsi
  800420fef3:	48 89 c7             	mov    %rax,%rdi
  800420fef6:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  800420fefd:	00 00 00 
  800420ff00:	ff d0                	callq  *%rax
  800420ff02:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800420ff06:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420ff0b:	0f 84 89 00 00 00    	je     800420ff9a <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  800420ff11:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ff15:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ff19:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420ff1d:	48 89 d0             	mov    %rdx,%rax
  800420ff20:	48 01 c0             	add    %rax,%rax
  800420ff23:	48 01 d0             	add    %rdx,%rax
  800420ff26:	48 c1 e0 03          	shl    $0x3,%rax
  800420ff2a:	48 01 c8             	add    %rcx,%rax
  800420ff2d:	48 8d 50 30          	lea    0x30(%rax),%rdx
  800420ff31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ff35:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800420ff38:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ff3c:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ff40:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420ff44:	48 89 d0             	mov    %rdx,%rax
  800420ff47:	48 01 c0             	add    %rax,%rax
  800420ff4a:	48 01 d0             	add    %rdx,%rax
  800420ff4d:	48 c1 e0 03          	shl    $0x3,%rax
  800420ff51:	48 01 c8             	add    %rcx,%rax
  800420ff54:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800420ff58:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ff5c:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  800420ff5f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ff63:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ff67:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420ff6b:	48 89 d0             	mov    %rdx,%rax
  800420ff6e:	48 01 c0             	add    %rax,%rax
  800420ff71:	48 01 d0             	add    %rdx,%rax
  800420ff74:	48 c1 e0 03          	shl    $0x3,%rax
  800420ff78:	48 01 c8             	add    %rcx,%rax
  800420ff7b:	48 8d 50 40          	lea    0x40(%rax),%rdx
  800420ff7f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ff83:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  800420ff86:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ff8a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ff8e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ff92:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ff96:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800420ff9a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420ff9f:	0f 85 1a ff ff ff    	jne    800420febf <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  800420ffa5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ffa9:	48 8b 00             	mov    (%rax),%rax
  800420ffac:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  800420ffb0:	48 89 c2             	mov    %rax,%rdx
  800420ffb3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ffb7:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  800420ffbb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ffc0:	c9                   	leaveq 
  800420ffc1:	c3                   	retq   

000000800420ffc2 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  800420ffc2:	55                   	push   %rbp
  800420ffc3:	48 89 e5             	mov    %rsp,%rbp
  800420ffc6:	48 83 ec 70          	sub    $0x70,%rsp
  800420ffca:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420ffce:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420ffd2:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  800420ffd6:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420ffdb:	75 0a                	jne    800420ffe7 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  800420ffdd:	b8 04 00 00 00       	mov    $0x4,%eax
  800420ffe2:	e9 0a 01 00 00       	jmpq   80042100f1 <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  800420ffe7:	48 bf 38 84 21 04 80 	movabs $0x8004218438,%rdi
  800420ffee:	00 00 00 
  800420fff1:	48 b8 22 43 21 04 80 	movabs $0x8004214322,%rax
  800420fff8:	00 00 00 
  800420fffb:	ff d0                	callq  *%rax
  800420fffd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004210001:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210006:	75 35                	jne    800421003d <_dwarf_abbrev_find+0x7b>
  8004210008:	48 b9 2d 84 21 04 80 	movabs $0x800421842d,%rcx
  800421000f:	00 00 00 
  8004210012:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210019:	00 00 00 
  800421001c:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004210021:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210028:	00 00 00 
  800421002b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210030:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210037:	00 00 00 
  800421003a:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  800421003d:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210041:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  8004210045:	e9 8d 00 00 00       	jmpq   80042100d7 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800421004a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800421004e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210052:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  8004210056:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421005a:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  800421005e:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210062:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  8004210066:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800421006b:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  800421006f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210074:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  8004210078:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800421007d:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004210081:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210086:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  800421008a:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800421008f:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004210093:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  8004210098:	48 89 c7             	mov    %rax,%rdi
  800421009b:	48 b8 3f fd 20 04 80 	movabs $0x800420fd3f,%rax
  80042100a2:	00 00 00 
  80042100a5:	ff d0                	callq  *%rax
  80042100a7:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  80042100aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042100ae:	74 05                	je     80042100b5 <_dwarf_abbrev_find+0xf3>
			return (ret);
  80042100b0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042100b3:	eb 3c                	jmp    80042100f1 <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  80042100b5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042100b9:	48 8b 00             	mov    (%rax),%rax
  80042100bc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042100c0:	75 07                	jne    80042100c9 <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  80042100c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042100c7:	eb 28                	jmp    80042100f1 <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  80042100c9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042100cd:	48 8b 00             	mov    (%rax),%rax
  80042100d0:	48 85 c0             	test   %rax,%rax
  80042100d3:	75 02                	jne    80042100d7 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  80042100d5:	eb 15                	jmp    80042100ec <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  80042100d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042100db:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042100df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100e3:	48 39 c2             	cmp    %rax,%rdx
  80042100e6:	0f 87 5e ff ff ff    	ja     800421004a <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  80042100ec:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042100f1:	c9                   	leaveq 
  80042100f2:	c3                   	retq   

00000080042100f3 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  80042100f3:	55                   	push   %rbp
  80042100f4:	48 89 e5             	mov    %rsp,%rbp
  80042100f7:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  80042100fe:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004210105:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421010c:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004210113:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800421011a:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004210121:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004210128:	48 bf 46 84 21 04 80 	movabs $0x8004218446,%rdi
  800421012f:	00 00 00 
  8004210132:	48 b8 22 43 21 04 80 	movabs $0x8004214322,%rax
  8004210139:	00 00 00 
  800421013c:	ff d0                	callq  *%rax
  800421013e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004210142:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210146:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421014a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  800421014e:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004210155:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210159:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  800421015c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  8004210163:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800421016a:	ba 60 00 00 00       	mov    $0x60,%edx
  800421016f:	be 00 00 00 00       	mov    $0x0,%esi
  8004210174:	48 89 c7             	mov    %rax,%rdi
  8004210177:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  800421017e:	00 00 00 
  8004210181:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  8004210183:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421018a:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  8004210191:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210198:	48 8b 00             	mov    (%rax),%rax
  800421019b:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  800421019f:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042101a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042101aa:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  80042101ae:	8b 45 10             	mov    0x10(%rbp),%eax
  80042101b1:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  80042101b4:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80042101bb:	00 

	switch (form) {
  80042101bc:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  80042101c3:	20 
  80042101c4:	0f 87 82 04 00 00    	ja     800421064c <_dwarf_attr_init+0x559>
  80042101ca:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042101d1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042101d8:	00 
  80042101d9:	48 b8 70 84 21 04 80 	movabs $0x8004218470,%rax
  80042101e0:	00 00 00 
  80042101e3:	48 01 d0             	add    %rdx,%rax
  80042101e6:	48 8b 00             	mov    (%rax),%rax
  80042101e9:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042101eb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042101f2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042101f6:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042101fd:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004210201:	0f b6 d2             	movzbl %dl,%edx
  8004210204:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421020b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421020f:	48 89 cf             	mov    %rcx,%rdi
  8004210212:	ff d0                	callq  *%rax
  8004210214:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210218:	e9 37 04 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800421021d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210224:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210228:	48 89 d6             	mov    %rdx,%rsi
  800421022b:	48 89 c7             	mov    %rax,%rdi
  800421022e:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  8004210235:	00 00 00 
  8004210238:	ff d0                	callq  *%rax
  800421023a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421023e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210242:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210249:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421024d:	48 89 ce             	mov    %rcx,%rsi
  8004210250:	48 89 c7             	mov    %rax,%rdi
  8004210253:	48 b8 6a f9 20 04 80 	movabs $0x800420f96a,%rax
  800421025a:	00 00 00 
  800421025d:	ff d0                	callq  *%rax
  800421025f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210263:	e9 ec 03 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004210268:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421026f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210273:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421027a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421027e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210283:	48 89 cf             	mov    %rcx,%rdi
  8004210286:	ff d0                	callq  *%rax
  8004210288:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421028c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210290:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210297:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421029b:	48 89 ce             	mov    %rcx,%rsi
  800421029e:	48 89 c7             	mov    %rax,%rdi
  80042102a1:	48 b8 6a f9 20 04 80 	movabs $0x800420f96a,%rax
  80042102a8:	00 00 00 
  80042102ab:	ff d0                	callq  *%rax
  80042102ad:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042102b1:	e9 9e 03 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042102b6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042102bd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042102c1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042102c8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042102cc:	ba 02 00 00 00       	mov    $0x2,%edx
  80042102d1:	48 89 cf             	mov    %rcx,%rdi
  80042102d4:	ff d0                	callq  *%rax
  80042102d6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042102da:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042102de:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042102e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102e9:	48 89 ce             	mov    %rcx,%rsi
  80042102ec:	48 89 c7             	mov    %rax,%rdi
  80042102ef:	48 b8 6a f9 20 04 80 	movabs $0x800420f96a,%rax
  80042102f6:	00 00 00 
  80042102f9:	ff d0                	callq  *%rax
  80042102fb:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042102ff:	e9 50 03 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004210304:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421030b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421030f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210316:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421031a:	ba 04 00 00 00       	mov    $0x4,%edx
  800421031f:	48 89 cf             	mov    %rcx,%rdi
  8004210322:	ff d0                	callq  *%rax
  8004210324:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210328:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421032c:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210333:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210337:	48 89 ce             	mov    %rcx,%rsi
  800421033a:	48 89 c7             	mov    %rax,%rdi
  800421033d:	48 b8 6a f9 20 04 80 	movabs $0x800420f96a,%rax
  8004210344:	00 00 00 
  8004210347:	ff d0                	callq  *%rax
  8004210349:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421034d:	e9 02 03 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004210352:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210359:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421035d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210364:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210368:	ba 01 00 00 00       	mov    $0x1,%edx
  800421036d:	48 89 cf             	mov    %rcx,%rdi
  8004210370:	ff d0                	callq  *%rax
  8004210372:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210376:	e9 d9 02 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800421037b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210382:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210386:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421038d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210391:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210396:	48 89 cf             	mov    %rcx,%rdi
  8004210399:	ff d0                	callq  *%rax
  800421039b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421039f:	e9 b0 02 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042103a4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042103ab:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042103af:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042103b6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042103ba:	ba 04 00 00 00       	mov    $0x4,%edx
  80042103bf:	48 89 cf             	mov    %rcx,%rdi
  80042103c2:	ff d0                	callq  *%rax
  80042103c4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042103c8:	e9 87 02 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  80042103cd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042103d4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042103d8:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042103df:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042103e3:	ba 08 00 00 00       	mov    $0x8,%edx
  80042103e8:	48 89 cf             	mov    %rcx,%rdi
  80042103eb:	ff d0                	callq  *%rax
  80042103ed:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042103f1:	e9 5e 02 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  80042103f6:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042103fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210401:	48 89 d6             	mov    %rdx,%rsi
  8004210404:	48 89 c7             	mov    %rax,%rdi
  8004210407:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  800421040e:	00 00 00 
  8004210411:	ff d0                	callq  *%rax
  8004210413:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800421041a:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  8004210421:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004210428:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421042f:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210436:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421043d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210444:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  800421044b:	4d 89 c1             	mov    %r8,%r9
  800421044e:	49 89 f8             	mov    %rdi,%r8
  8004210451:	48 89 c7             	mov    %rax,%rdi
  8004210454:	48 b8 f3 00 21 04 80 	movabs $0x80042100f3,%rax
  800421045b:	00 00 00 
  800421045e:	ff d0                	callq  *%rax
  8004210460:	e9 1d 03 00 00       	jmpq   8004210782 <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  8004210465:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800421046c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210470:	66 83 f8 02          	cmp    $0x2,%ax
  8004210474:	75 2f                	jne    80042104a5 <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004210476:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421047d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210481:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210488:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421048c:	0f b6 d2             	movzbl %dl,%edx
  800421048f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210496:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421049a:	48 89 cf             	mov    %rcx,%rdi
  800421049d:	ff d0                	callq  *%rax
  800421049f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042104a3:	eb 39                	jmp    80042104de <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  80042104a5:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042104ac:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042104b0:	66 83 f8 03          	cmp    $0x3,%ax
  80042104b4:	75 28                	jne    80042104de <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042104b6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042104bd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042104c1:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042104c5:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042104cc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042104d0:	48 89 cf             	mov    %rcx,%rdi
  80042104d3:	ff d0                	callq  *%rax
  80042104d5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042104d9:	e9 76 01 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
  80042104de:	e9 71 01 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  80042104e3:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042104ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104ee:	48 89 d6             	mov    %rdx,%rsi
  80042104f1:	48 89 c7             	mov    %rax,%rdi
  80042104f4:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  80042104fb:	00 00 00 
  80042104fe:	ff d0                	callq  *%rax
  8004210500:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210504:	e9 4b 01 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004210509:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210510:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210514:	48 89 d6             	mov    %rdx,%rsi
  8004210517:	48 89 c7             	mov    %rax,%rdi
  800421051a:	48 b8 b9 f6 20 04 80 	movabs $0x800420f6b9,%rax
  8004210521:	00 00 00 
  8004210524:	ff d0                	callq  *%rax
  8004210526:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421052a:	e9 25 01 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800421052f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210536:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421053a:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800421053e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210545:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210549:	48 89 cf             	mov    %rcx,%rdi
  800421054c:	ff d0                	callq  *%rax
  800421054e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210552:	e9 fd 00 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004210557:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421055b:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800421055f:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421056a:	48 89 ce             	mov    %rcx,%rsi
  800421056d:	48 89 c7             	mov    %rax,%rdi
  8004210570:	48 b8 db f8 20 04 80 	movabs $0x800420f8db,%rax
  8004210577:	00 00 00 
  800421057a:	ff d0                	callq  *%rax
  800421057c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210580:	e9 cf 00 00 00       	jmpq   8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004210585:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421058c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210590:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004210594:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421059b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421059f:	48 89 cf             	mov    %rcx,%rdi
  80042105a2:	ff d0                	callq  *%rax
  80042105a4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  80042105a8:	48 bf 52 84 21 04 80 	movabs $0x8004218452,%rdi
  80042105af:	00 00 00 
  80042105b2:	48 b8 22 43 21 04 80 	movabs $0x8004214322,%rax
  80042105b9:	00 00 00 
  80042105bc:	ff d0                	callq  *%rax
  80042105be:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  80042105c2:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042105c7:	75 35                	jne    80042105fe <_dwarf_attr_init+0x50b>
  80042105c9:	48 b9 5d 84 21 04 80 	movabs $0x800421845d,%rcx
  80042105d0:	00 00 00 
  80042105d3:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  80042105da:	00 00 00 
  80042105dd:	be 51 02 00 00       	mov    $0x251,%esi
  80042105e2:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  80042105e9:	00 00 00 
  80042105ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042105f1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042105f8:	00 00 00 
  80042105fb:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  80042105fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210602:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210606:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421060a:	48 01 d0             	add    %rdx,%rax
  800421060d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210611:	eb 41                	jmp    8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004210613:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800421061a:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  800421061b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421061f:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210626:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421062a:	48 89 ce             	mov    %rcx,%rsi
  800421062d:	48 89 c7             	mov    %rax,%rdi
  8004210630:	48 b8 6a f9 20 04 80 	movabs $0x800420f96a,%rax
  8004210637:	00 00 00 
  800421063a:	ff d0                	callq  *%rax
  800421063c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210640:	eb 12                	jmp    8004210654 <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004210642:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  8004210649:	00 
		break;
  800421064a:	eb 08                	jmp    8004210654 <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  800421064c:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004210653:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  8004210654:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210658:	0f 85 21 01 00 00    	jne    800421077f <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  800421065e:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  8004210665:	09 
  8004210666:	74 1e                	je     8004210686 <_dwarf_attr_init+0x593>
  8004210668:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  800421066f:	0a 
  8004210670:	74 14                	je     8004210686 <_dwarf_attr_init+0x593>
  8004210672:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  8004210679:	03 
  800421067a:	74 0a                	je     8004210686 <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  800421067c:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  8004210683:	04 
  8004210684:	75 10                	jne    8004210696 <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  8004210686:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421068a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  800421068e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210692:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  8004210696:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421069a:	48 83 f8 03          	cmp    $0x3,%rax
  800421069e:	75 39                	jne    80042106d9 <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  80042106a0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042106a4:	48 83 f8 08          	cmp    $0x8,%rax
  80042106a8:	74 1c                	je     80042106c6 <_dwarf_attr_init+0x5d3>
  80042106aa:	48 83 f8 0e          	cmp    $0xe,%rax
  80042106ae:	74 02                	je     80042106b2 <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  80042106b0:	eb 27                	jmp    80042106d9 <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  80042106b2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042106b6:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042106bd:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042106c4:	eb 13                	jmp    80042106d9 <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  80042106c6:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042106ca:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042106d1:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042106d8:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  80042106d9:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042106e0:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  80042106e7:	8d 48 01             	lea    0x1(%rax),%ecx
  80042106ea:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  80042106f1:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  80042106f7:	0f b6 c0             	movzbl %al,%eax
  80042106fa:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004210701:	48 63 d0             	movslq %eax,%rdx
  8004210704:	48 89 d0             	mov    %rdx,%rax
  8004210707:	48 01 c0             	add    %rax,%rax
  800421070a:	48 01 d0             	add    %rdx,%rax
  800421070d:	48 c1 e0 05          	shl    $0x5,%rax
  8004210711:	48 01 c8             	add    %rcx,%rax
  8004210714:	48 05 70 03 00 00    	add    $0x370,%rax
  800421071a:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004210721:	48 89 10             	mov    %rdx,(%rax)
  8004210724:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800421072b:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421072f:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004210733:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004210737:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421073b:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421073f:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004210743:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004210747:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421074b:	48 89 50 28          	mov    %rdx,0x28(%rax)
  800421074f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210753:	48 89 50 30          	mov    %rdx,0x30(%rax)
  8004210757:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421075b:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421075f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210763:	48 89 50 40          	mov    %rdx,0x40(%rax)
  8004210767:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800421076b:	48 89 50 48          	mov    %rdx,0x48(%rax)
  800421076f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210773:	48 89 50 50          	mov    %rdx,0x50(%rax)
  8004210777:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421077b:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  800421077f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210782:	c9                   	leaveq 
  8004210783:	c3                   	retq   

0000008004210784 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004210784:	55                   	push   %rbp
  8004210785:	48 89 e5             	mov    %rsp,%rbp
  8004210788:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  800421078f:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  8004210796:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  800421079d:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042107a4:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  80042107aa:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  80042107b1:	00 
  80042107b2:	75 35                	jne    80042107e9 <dwarf_search_die_within_cu+0x65>
  80042107b4:	48 b9 78 85 21 04 80 	movabs $0x8004218578,%rcx
  80042107bb:	00 00 00 
  80042107be:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  80042107c5:	00 00 00 
  80042107c8:	be 86 02 00 00       	mov    $0x286,%esi
  80042107cd:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  80042107d4:	00 00 00 
  80042107d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042107dc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042107e3:	00 00 00 
  80042107e6:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  80042107e9:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  80042107f0:	00 
  80042107f1:	75 35                	jne    8004210828 <dwarf_search_die_within_cu+0xa4>
  80042107f3:	48 b9 7c 85 21 04 80 	movabs $0x800421857c,%rcx
  80042107fa:	00 00 00 
  80042107fd:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210804:	00 00 00 
  8004210807:	be 88 02 00 00       	mov    $0x288,%esi
  800421080c:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210813:	00 00 00 
  8004210816:	b8 00 00 00 00       	mov    $0x0,%eax
  800421081b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210822:	00 00 00 
  8004210825:	41 ff d0             	callq  *%r8

	level = 1;
  8004210828:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800421082f:	e9 17 02 00 00       	jmpq   8004210a4b <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  8004210834:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800421083b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  800421083f:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210846:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421084a:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  8004210851:	48 89 d6             	mov    %rdx,%rsi
  8004210854:	48 89 c7             	mov    %rax,%rdi
  8004210857:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  800421085e:	00 00 00 
  8004210861:	ff d0                	callq  *%rax
  8004210863:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  8004210867:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421086c:	75 22                	jne    8004210890 <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  800421086e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210872:	74 09                	je     800421087d <dwarf_search_die_within_cu+0xf9>
  8004210874:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800421087b:	75 0a                	jne    8004210887 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  800421087d:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210882:	e9 f4 01 00 00       	jmpq   8004210a7b <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  8004210887:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  800421088b:	e9 bb 01 00 00       	jmpq   8004210a4b <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  8004210890:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004210897:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421089b:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042108a2:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  80042108a6:	48 89 34 24          	mov    %rsi,(%rsp)
  80042108aa:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  80042108ae:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  80042108b3:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  80042108b7:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  80042108bc:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  80042108c0:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  80042108c5:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  80042108c9:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  80042108ce:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  80042108d2:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  80042108d7:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  80042108db:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  80042108e0:	48 89 ce             	mov    %rcx,%rsi
  80042108e3:	48 89 c7             	mov    %rax,%rdi
  80042108e6:	48 b8 c2 ff 20 04 80 	movabs $0x800420ffc2,%rax
  80042108ed:	00 00 00 
  80042108f0:	ff d0                	callq  *%rax
  80042108f2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042108f5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042108f9:	74 08                	je     8004210903 <dwarf_search_die_within_cu+0x17f>
			return (ret);
  80042108fb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042108fe:	e9 78 01 00 00       	jmpq   8004210a7b <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  8004210903:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421090a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421090e:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  8004210911:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210918:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421091c:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  8004210920:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210927:	48 8d 78 20          	lea    0x20(%rax),%rdi
  800421092b:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004210932:	b8 66 00 00 00       	mov    $0x66,%eax
  8004210937:	48 89 d6             	mov    %rdx,%rsi
  800421093a:	48 89 c1             	mov    %rax,%rcx
  800421093d:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  8004210940:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210947:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  800421094e:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  8004210955:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421095c:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004210960:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004210967:	e9 8e 00 00 00       	jmpq   80042109fa <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  800421096c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421096f:	48 63 d0             	movslq %eax,%rdx
  8004210972:	48 89 d0             	mov    %rdx,%rax
  8004210975:	48 01 c0             	add    %rax,%rax
  8004210978:	48 01 d0             	add    %rdx,%rax
  800421097b:	48 c1 e0 03          	shl    $0x3,%rax
  800421097f:	48 01 e8             	add    %rbp,%rax
  8004210982:	48 2d 18 03 00 00    	sub    $0x318,%rax
  8004210988:	48 8b 08             	mov    (%rax),%rcx
  800421098b:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  8004210992:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210995:	48 63 d0             	movslq %eax,%rdx
  8004210998:	48 89 d0             	mov    %rdx,%rax
  800421099b:	48 01 c0             	add    %rax,%rax
  800421099e:	48 01 d0             	add    %rdx,%rax
  80042109a1:	48 c1 e0 03          	shl    $0x3,%rax
  80042109a5:	48 83 c0 30          	add    $0x30,%rax
  80042109a9:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  80042109ad:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  80042109b4:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  80042109bb:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042109c2:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  80042109c9:	49 89 c9             	mov    %rcx,%r9
  80042109cc:	49 89 f8             	mov    %rdi,%r8
  80042109cf:	48 89 d1             	mov    %rdx,%rcx
  80042109d2:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  80042109d6:	48 89 c7             	mov    %rax,%rdi
  80042109d9:	48 b8 f3 00 21 04 80 	movabs $0x80042100f3,%rax
  80042109e0:	00 00 00 
  80042109e3:	ff d0                	callq  *%rax
  80042109e5:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042109e8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042109ec:	74 08                	je     80042109f6 <dwarf_search_die_within_cu+0x272>
				return (ret);
  80042109ee:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042109f1:	e9 85 00 00 00       	jmpq   8004210a7b <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  80042109f6:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  80042109fa:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042109fd:	48 63 d0             	movslq %eax,%rdx
  8004210a00:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004210a07:	48 39 c2             	cmp    %rax,%rdx
  8004210a0a:	0f 82 5c ff ff ff    	jb     800421096c <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004210a10:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004210a17:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210a1e:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  8004210a22:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004210a29:	74 19                	je     8004210a44 <dwarf_search_die_within_cu+0x2c0>
  8004210a2b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210a2f:	7e 13                	jle    8004210a44 <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004210a31:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004210a38:	3c 01                	cmp    $0x1,%al
  8004210a3a:	75 06                	jne    8004210a42 <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  8004210a3c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004210a40:	eb 09                	jmp    8004210a4b <dwarf_search_die_within_cu+0x2c7>
  8004210a42:	eb 07                	jmp    8004210a4b <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004210a44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210a49:	eb 30                	jmp    8004210a7b <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004210a4b:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004210a4f:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210a56:	48 39 c2             	cmp    %rax,%rdx
  8004210a59:	76 1b                	jbe    8004210a76 <dwarf_search_die_within_cu+0x2f2>
  8004210a5b:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210a62:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210a66:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210a6d:	48 39 c2             	cmp    %rax,%rdx
  8004210a70:	0f 87 be fd ff ff    	ja     8004210834 <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  8004210a76:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210a7b:	c9                   	leaveq 
  8004210a7c:	c3                   	retq   

0000008004210a7d <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  8004210a7d:	55                   	push   %rbp
  8004210a7e:	48 89 e5             	mov    %rsp,%rbp
  8004210a81:	48 83 ec 60          	sub    $0x60,%rsp
  8004210a85:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210a89:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210a8d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  8004210a91:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210a96:	75 35                	jne    8004210acd <dwarf_offdie+0x50>
  8004210a98:	48 b9 78 85 21 04 80 	movabs $0x8004218578,%rcx
  8004210a9f:	00 00 00 
  8004210aa2:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210aa9:	00 00 00 
  8004210aac:	be c4 02 00 00       	mov    $0x2c4,%esi
  8004210ab1:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210ab8:	00 00 00 
  8004210abb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ac0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210ac7:	00 00 00 
  8004210aca:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210acd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210ad2:	75 35                	jne    8004210b09 <dwarf_offdie+0x8c>
  8004210ad4:	48 b9 7c 85 21 04 80 	movabs $0x800421857c,%rcx
  8004210adb:	00 00 00 
  8004210ade:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210ae5:	00 00 00 
  8004210ae8:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004210aed:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210af4:	00 00 00 
  8004210af7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210afc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210b03:	00 00 00 
  8004210b06:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004210b09:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004210b0d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210b11:	76 66                	jbe    8004210b79 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004210b13:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210b17:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004210b1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210b1f:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  8004210b23:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004210b27:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004210b2b:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004210b30:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  8004210b34:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004210b39:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004210b3d:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004210b42:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  8004210b46:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004210b4b:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004210b4f:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004210b54:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  8004210b58:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  8004210b5d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004210b62:	48 89 c7             	mov    %rax,%rdi
  8004210b65:	48 b8 84 07 21 04 80 	movabs $0x8004210784,%rax
  8004210b6c:	00 00 00 
  8004210b6f:	ff d0                	callq  *%rax
  8004210b71:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  8004210b74:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210b77:	eb 05                	jmp    8004210b7e <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004210b79:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210b7e:	c9                   	leaveq 
  8004210b7f:	c3                   	retq   

0000008004210b80 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004210b80:	55                   	push   %rbp
  8004210b81:	48 89 e5             	mov    %rsp,%rbp
  8004210b84:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210b88:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210b8c:	89 f0                	mov    %esi,%eax
  8004210b8e:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  8004210b92:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210b99:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004210b9a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004210ba1:	eb 57                	jmp    8004210bfa <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  8004210ba3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210ba7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210baa:	48 63 d0             	movslq %eax,%rdx
  8004210bad:	48 89 d0             	mov    %rdx,%rax
  8004210bb0:	48 01 c0             	add    %rax,%rax
  8004210bb3:	48 01 d0             	add    %rdx,%rax
  8004210bb6:	48 c1 e0 05          	shl    $0x5,%rax
  8004210bba:	48 01 c8             	add    %rcx,%rax
  8004210bbd:	48 05 80 03 00 00    	add    $0x380,%rax
  8004210bc3:	48 8b 10             	mov    (%rax),%rdx
  8004210bc6:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004210bca:	48 39 c2             	cmp    %rax,%rdx
  8004210bcd:	75 27                	jne    8004210bf6 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004210bcf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210bd2:	48 63 d0             	movslq %eax,%rdx
  8004210bd5:	48 89 d0             	mov    %rdx,%rax
  8004210bd8:	48 01 c0             	add    %rax,%rax
  8004210bdb:	48 01 d0             	add    %rdx,%rax
  8004210bde:	48 c1 e0 05          	shl    $0x5,%rax
  8004210be2:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004210be9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210bed:	48 01 d0             	add    %rdx,%rax
  8004210bf0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004210bf4:	eb 17                	jmp    8004210c0d <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004210bf6:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004210bfa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210bfe:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004210c05:	0f b6 c0             	movzbl %al,%eax
  8004210c08:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004210c0b:	7f 96                	jg     8004210ba3 <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004210c0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210c11:	c9                   	leaveq 
  8004210c12:	c3                   	retq   

0000008004210c13 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004210c13:	55                   	push   %rbp
  8004210c14:	48 89 e5             	mov    %rsp,%rbp
  8004210c17:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004210c1b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210c1f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210c23:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004210c27:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004210c2b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210c30:	75 35                	jne    8004210c67 <dwarf_siblingof+0x54>
  8004210c32:	48 b9 78 85 21 04 80 	movabs $0x8004218578,%rcx
  8004210c39:	00 00 00 
  8004210c3c:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210c43:	00 00 00 
  8004210c46:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004210c4b:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210c52:	00 00 00 
  8004210c55:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c5a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210c61:	00 00 00 
  8004210c64:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210c67:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210c6c:	75 35                	jne    8004210ca3 <dwarf_siblingof+0x90>
  8004210c6e:	48 b9 7c 85 21 04 80 	movabs $0x800421857c,%rcx
  8004210c75:	00 00 00 
  8004210c78:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210c7f:	00 00 00 
  8004210c82:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004210c87:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210c8e:	00 00 00 
  8004210c91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c96:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210c9d:	00 00 00 
  8004210ca0:	41 ff d0             	callq  *%r8
	assert(cu);
  8004210ca3:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004210ca8:	75 35                	jne    8004210cdf <dwarf_siblingof+0xcc>
  8004210caa:	48 b9 84 85 21 04 80 	movabs $0x8004218584,%rcx
  8004210cb1:	00 00 00 
  8004210cb4:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210cbb:	00 00 00 
  8004210cbe:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004210cc3:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210cca:	00 00 00 
  8004210ccd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210cd2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210cd9:	00 00 00 
  8004210cdc:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004210cdf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210ce4:	75 65                	jne    8004210d4b <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004210ce6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210cea:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004210cee:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210cf2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210cf6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210cfa:	48 8b 38             	mov    (%rax),%rdi
  8004210cfd:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210d01:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004210d05:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210d0a:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004210d0e:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210d13:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004210d17:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210d1c:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004210d20:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210d25:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004210d29:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210d2e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210d32:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210d37:	48 89 cf             	mov    %rcx,%rdi
  8004210d3a:	48 b8 7d 0a 21 04 80 	movabs $0x8004210a7d,%rax
  8004210d41:	00 00 00 
  8004210d44:	ff d0                	callq  *%rax
  8004210d46:	e9 0a 01 00 00       	jmpq   8004210e55 <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004210d4b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004210d52:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d56:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004210d5a:	84 c0                	test   %al,%al
  8004210d5c:	75 0e                	jne    8004210d6c <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  8004210d5e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d62:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210d66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210d6a:	eb 6b                	jmp    8004210dd7 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004210d6c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d70:	be 01 00 00 00       	mov    $0x1,%esi
  8004210d75:	48 89 c7             	mov    %rax,%rdi
  8004210d78:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  8004210d7f:	00 00 00 
  8004210d82:	ff d0                	callq  *%rax
  8004210d84:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004210d88:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210d8d:	74 35                	je     8004210dc4 <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  8004210d8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d93:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210d97:	48 83 f8 10          	cmp    $0x10,%rax
  8004210d9b:	74 19                	je     8004210db6 <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  8004210d9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210da1:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210da5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210da9:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210dad:	48 01 d0             	add    %rdx,%rax
  8004210db0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210db4:	eb 21                	jmp    8004210dd7 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  8004210db6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210dba:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210dbe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210dc2:	eb 13                	jmp    8004210dd7 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  8004210dc4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210dc8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210dcc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004210dd0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004210dd7:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004210dda:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210dde:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004210de2:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004210de6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210dea:	4c 8b 00             	mov    (%rax),%r8
  8004210ded:	4c 89 04 24          	mov    %r8,(%rsp)
  8004210df1:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004210df5:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004210dfa:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004210dfe:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004210e03:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004210e07:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004210e0c:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004210e10:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004210e15:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004210e19:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004210e1e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210e22:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210e27:	48 b8 84 07 21 04 80 	movabs $0x8004210784,%rax
  8004210e2e:	00 00 00 
  8004210e31:	ff d0                	callq  *%rax
  8004210e33:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  8004210e36:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004210e3a:	75 07                	jne    8004210e43 <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  8004210e3c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210e41:	eb 12                	jmp    8004210e55 <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  8004210e43:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210e47:	74 07                	je     8004210e50 <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  8004210e49:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210e4e:	eb 05                	jmp    8004210e55 <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  8004210e50:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210e55:	c9                   	leaveq 
  8004210e56:	c3                   	retq   

0000008004210e57 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004210e57:	55                   	push   %rbp
  8004210e58:	48 89 e5             	mov    %rsp,%rbp
  8004210e5b:	48 83 ec 70          	sub    $0x70,%rsp
  8004210e5f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210e63:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210e67:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210e6b:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004210e6f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210e74:	75 35                	jne    8004210eab <dwarf_child+0x54>
  8004210e76:	48 b9 87 85 21 04 80 	movabs $0x8004218587,%rcx
  8004210e7d:	00 00 00 
  8004210e80:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210e87:	00 00 00 
  8004210e8a:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004210e8f:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210e96:	00 00 00 
  8004210e99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e9e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210ea5:	00 00 00 
  8004210ea8:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210eab:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210eb0:	75 35                	jne    8004210ee7 <dwarf_child+0x90>
  8004210eb2:	48 b9 7c 85 21 04 80 	movabs $0x800421857c,%rcx
  8004210eb9:	00 00 00 
  8004210ebc:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210ec3:	00 00 00 
  8004210ec6:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004210ecb:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210ed2:	00 00 00 
  8004210ed5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210eda:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210ee1:	00 00 00 
  8004210ee4:	41 ff d0             	callq  *%r8
	assert(dbg);
  8004210ee7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210eec:	75 35                	jne    8004210f23 <dwarf_child+0xcc>
  8004210eee:	48 b9 78 85 21 04 80 	movabs $0x8004218578,%rcx
  8004210ef5:	00 00 00 
  8004210ef8:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210eff:	00 00 00 
  8004210f02:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004210f07:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210f0e:	00 00 00 
  8004210f11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210f16:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210f1d:	00 00 00 
  8004210f20:	41 ff d0             	callq  *%r8
	assert(cu);
  8004210f23:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210f28:	75 35                	jne    8004210f5f <dwarf_child+0x108>
  8004210f2a:	48 b9 84 85 21 04 80 	movabs $0x8004218584,%rcx
  8004210f31:	00 00 00 
  8004210f34:	48 ba ea 83 21 04 80 	movabs $0x80042183ea,%rdx
  8004210f3b:	00 00 00 
  8004210f3e:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004210f43:	48 bf ff 83 21 04 80 	movabs $0x80042183ff,%rdi
  8004210f4a:	00 00 00 
  8004210f4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210f52:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210f59:	00 00 00 
  8004210f5c:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004210f5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f63:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004210f67:	84 c0                	test   %al,%al
  8004210f69:	75 0a                	jne    8004210f75 <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  8004210f6b:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210f70:	e9 84 00 00 00       	jmpq   8004210ff9 <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004210f75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f79:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004210f7d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210f81:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004210f85:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210f89:	48 8b 08             	mov    (%rax),%rcx
  8004210f8c:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004210f90:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004210f94:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004210f99:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004210f9d:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004210fa2:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004210fa6:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004210fab:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210faf:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004210fb4:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004210fb8:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004210fbd:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210fc1:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210fc6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004210fcb:	48 b8 84 07 21 04 80 	movabs $0x8004210784,%rax
  8004210fd2:	00 00 00 
  8004210fd5:	ff d0                	callq  *%rax
  8004210fd7:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  8004210fda:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004210fde:	75 07                	jne    8004210fe7 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004210fe0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210fe5:	eb 12                	jmp    8004210ff9 <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  8004210fe7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210feb:	74 07                	je     8004210ff4 <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  8004210fed:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210ff2:	eb 05                	jmp    8004210ff9 <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  8004210ff4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210ff9:	c9                   	leaveq 
  8004210ffa:	c3                   	retq   

0000008004210ffb <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004210ffb:	55                   	push   %rbp
  8004210ffc:	48 89 e5             	mov    %rsp,%rbp
  8004210fff:	48 83 ec 20          	sub    $0x20,%rsp
  8004211003:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004211007:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421100b:	48 8b 00             	mov    (%rax),%rax
  800421100e:	48 89 c7             	mov    %rax,%rdi
  8004211011:	48 b8 22 43 21 04 80 	movabs $0x8004214322,%rax
  8004211018:	00 00 00 
  800421101b:	ff d0                	callq  *%rax
  800421101d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004211021:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211025:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211029:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421102d:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  8004211031:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211035:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211039:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421103d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  8004211041:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211045:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211049:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421104d:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004211051:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211056:	c9                   	leaveq 
  8004211057:	c3                   	retq   

0000008004211058 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004211058:	55                   	push   %rbp
  8004211059:	48 89 e5             	mov    %rsp,%rbp
  800421105c:	48 83 ec 08          	sub    $0x8,%rsp
  8004211060:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004211064:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211068:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  800421106e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211072:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004211078:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421107c:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004211082:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211086:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  800421108c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211090:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004211096:	c9                   	leaveq 
  8004211097:	c3                   	retq   

0000008004211098 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  8004211098:	55                   	push   %rbp
  8004211099:	48 89 e5             	mov    %rsp,%rbp
  800421109c:	48 83 ec 40          	sub    $0x40,%rsp
  80042110a0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042110a4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042110a8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042110ac:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80042110b0:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  80042110b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110b8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  80042110bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110c0:	ba 80 00 00 00       	mov    $0x80,%edx
  80042110c5:	be 00 00 00 00       	mov    $0x0,%esi
  80042110ca:	48 89 c7             	mov    %rax,%rdi
  80042110cd:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  80042110d4:	00 00 00 
  80042110d7:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  80042110d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110dd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042110e1:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  80042110e5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042110ea:	75 07                	jne    80042110f3 <dwarf_get_fde_at_pc+0x5b>
		return (DW_DLV_ERROR);
  80042110ec:	b8 01 00 00 00       	mov    $0x1,%eax
  80042110f1:	eb 75                	jmp    8004211168 <dwarf_get_fde_at_pc+0xd0>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  80042110f3:	eb 59                	jmp    800421114e <dwarf_get_fde_at_pc+0xb6>
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  80042110f5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042110f9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042110fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211101:	be 01 00 00 00       	mov    $0x1,%esi
  8004211106:	48 89 c7             	mov    %rax,%rdi
  8004211109:	48 b8 ad 32 21 04 80 	movabs $0x80042132ad,%rax
  8004211110:	00 00 00 
  8004211113:	ff d0                	callq  *%rax
  8004211115:	85 c0                	test   %eax,%eax
  8004211117:	79 07                	jns    8004211120 <dwarf_get_fde_at_pc+0x88>
		{
			return DW_DLV_NO_ENTRY;
  8004211119:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421111e:	eb 48                	jmp    8004211168 <dwarf_get_fde_at_pc+0xd0>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211120:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211124:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211128:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421112c:	77 20                	ja     800421114e <dwarf_get_fde_at_pc+0xb6>
  800421112e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211132:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  8004211136:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421113a:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800421113e:	48 01 d0             	add    %rdx,%rax
  8004211141:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211145:	76 07                	jbe    800421114e <dwarf_get_fde_at_pc+0xb6>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  8004211147:	b8 00 00 00 00       	mov    $0x0,%eax
  800421114c:	eb 1a                	jmp    8004211168 <dwarf_get_fde_at_pc+0xd0>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  800421114e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211152:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004211156:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421115a:	48 8b 40 40          	mov    0x40(%rax),%rax
  800421115e:	48 39 c2             	cmp    %rax,%rdx
  8004211161:	72 92                	jb     80042110f5 <dwarf_get_fde_at_pc+0x5d>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  8004211163:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004211168:	c9                   	leaveq 
  8004211169:	c3                   	retq   

000000800421116a <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  800421116a:	55                   	push   %rbp
  800421116b:	48 89 e5             	mov    %rsp,%rbp
  800421116e:	53                   	push   %rbx
  800421116f:	48 83 ec 38          	sub    $0x38,%rsp
  8004211173:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211177:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421117b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421117f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	int i;

	assert(dest != NULL);
  8004211183:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211188:	75 35                	jne    80042111bf <_dwarf_frame_regtable_copy+0x55>
  800421118a:	48 b9 9a 85 21 04 80 	movabs $0x800421859a,%rcx
  8004211191:	00 00 00 
  8004211194:	48 ba a7 85 21 04 80 	movabs $0x80042185a7,%rdx
  800421119b:	00 00 00 
  800421119e:	be 57 00 00 00       	mov    $0x57,%esi
  80042111a3:	48 bf bc 85 21 04 80 	movabs $0x80042185bc,%rdi
  80042111aa:	00 00 00 
  80042111ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042111b2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042111b9:	00 00 00 
  80042111bc:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  80042111bf:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042111c4:	75 35                	jne    80042111fb <_dwarf_frame_regtable_copy+0x91>
  80042111c6:	48 b9 d2 85 21 04 80 	movabs $0x80042185d2,%rcx
  80042111cd:	00 00 00 
  80042111d0:	48 ba a7 85 21 04 80 	movabs $0x80042185a7,%rdx
  80042111d7:	00 00 00 
  80042111da:	be 58 00 00 00       	mov    $0x58,%esi
  80042111df:	48 bf bc 85 21 04 80 	movabs $0x80042185bc,%rdi
  80042111e6:	00 00 00 
  80042111e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042111ee:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042111f5:	00 00 00 
  80042111f8:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  80042111fb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042111ff:	48 8b 00             	mov    (%rax),%rax
  8004211202:	48 85 c0             	test   %rax,%rax
  8004211205:	75 39                	jne    8004211240 <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  8004211207:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421120b:	48 bb e0 f6 6b 04 80 	movabs $0x80046bf6e0,%rbx
  8004211212:	00 00 00 
  8004211215:	48 89 18             	mov    %rbx,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004211218:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421121c:	48 8b 00             	mov    (%rax),%rax
  800421121f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211223:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  8004211227:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  800421122b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421122f:	48 8b 00             	mov    (%rax),%rax
  8004211232:	48 bb 20 f9 6b 04 80 	movabs $0x80046bf920,%rbx
  8004211239:	00 00 00 
  800421123c:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  8004211240:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004211244:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211248:	48 8b 00             	mov    (%rax),%rax
  800421124b:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211250:	48 89 ce             	mov    %rcx,%rsi
  8004211253:	48 89 c7             	mov    %rax,%rdi
  8004211256:	48 b8 ed ed 20 04 80 	movabs $0x800420eded,%rax
  800421125d:	00 00 00 
  8004211260:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211262:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004211269:	eb 5a                	jmp    80042112c5 <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  800421126b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421126f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211273:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211276:	48 63 d0             	movslq %eax,%rdx
  8004211279:	48 89 d0             	mov    %rdx,%rax
  800421127c:	48 01 c0             	add    %rax,%rax
  800421127f:	48 01 d0             	add    %rdx,%rax
  8004211282:	48 c1 e0 03          	shl    $0x3,%rax
  8004211286:	48 01 c1             	add    %rax,%rcx
  8004211289:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421128d:	48 8b 00             	mov    (%rax),%rax
  8004211290:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211294:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211297:	48 63 d0             	movslq %eax,%rdx
  800421129a:	48 89 d0             	mov    %rdx,%rax
  800421129d:	48 01 c0             	add    %rax,%rax
  80042112a0:	48 01 d0             	add    %rdx,%rax
  80042112a3:	48 c1 e0 03          	shl    $0x3,%rax
  80042112a7:	48 01 f0             	add    %rsi,%rax
  80042112aa:	ba 18 00 00 00       	mov    $0x18,%edx
  80042112af:	48 89 ce             	mov    %rcx,%rsi
  80042112b2:	48 89 c7             	mov    %rax,%rdi
  80042112b5:	48 b8 ed ed 20 04 80 	movabs $0x800420eded,%rax
  80042112bc:	00 00 00 
  80042112bf:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  80042112c1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042112c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042112c9:	48 8b 00             	mov    (%rax),%rax
  80042112cc:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042112d0:	0f b7 c0             	movzwl %ax,%eax
  80042112d3:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042112d6:	7e 10                	jle    80042112e8 <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  80042112d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112dc:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042112e0:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042112e3:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042112e6:	7f 83                	jg     800421126b <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  80042112e8:	eb 32                	jmp    800421131c <_dwarf_frame_regtable_copy+0x1b2>
		(*dest)->rt3_rules[i].dw_regnum =
  80042112ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042112ee:	48 8b 00             	mov    (%rax),%rax
  80042112f1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042112f5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042112f8:	48 63 d0             	movslq %eax,%rdx
  80042112fb:	48 89 d0             	mov    %rdx,%rax
  80042112fe:	48 01 c0             	add    %rax,%rax
  8004211301:	48 01 d0             	add    %rdx,%rax
  8004211304:	48 c1 e0 03          	shl    $0x3,%rax
  8004211308:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  800421130c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211310:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  8004211314:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004211318:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800421131c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211320:	48 8b 00             	mov    (%rax),%rax
  8004211323:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211327:	0f b7 c0             	movzwl %ax,%eax
  800421132a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421132d:	7f bb                	jg     80042112ea <_dwarf_frame_regtable_copy+0x180>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  800421132f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211334:	48 83 c4 38          	add    $0x38,%rsp
  8004211338:	5b                   	pop    %rbx
  8004211339:	5d                   	pop    %rbp
  800421133a:	c3                   	retq   

000000800421133b <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  800421133b:	55                   	push   %rbp
  800421133c:	48 89 e5             	mov    %rsp,%rbp
  800421133f:	53                   	push   %rbx
  8004211340:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004211347:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  800421134b:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  800421134f:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004211353:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004211357:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  800421135e:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  8004211365:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  800421136c:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004211373:	00 
  8004211374:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211378:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  800421137c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211380:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211384:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004211387:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421138b:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421138f:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004211393:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211397:	48 89 c7             	mov    %rax,%rdi
  800421139a:	48 b8 6a 11 21 04 80 	movabs $0x800421116a,%rax
  80042113a1:	00 00 00 
  80042113a4:	ff d0                	callq  *%rax
	p = insts;
  80042113a6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042113aa:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  80042113ae:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042113b2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042113b6:	48 01 d0             	add    %rdx,%rax
  80042113b9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  80042113bd:	e9 3a 0d 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		if (*p == DW_CFA_nop) {
  80042113c2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042113c6:	0f b6 00             	movzbl (%rax),%eax
  80042113c9:	84 c0                	test   %al,%al
  80042113cb:	75 11                	jne    80042113de <_dwarf_frame_run_inst+0xa3>
			p++;
  80042113cd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042113d1:	48 83 c0 01          	add    $0x1,%rax
  80042113d5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  80042113d9:	e9 1e 0d 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		}

		high2 = *p & 0xc0;
  80042113de:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042113e2:	0f b6 00             	movzbl (%rax),%eax
  80042113e5:	83 e0 c0             	and    $0xffffffc0,%eax
  80042113e8:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  80042113eb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042113ef:	0f b6 00             	movzbl (%rax),%eax
  80042113f2:	83 e0 3f             	and    $0x3f,%eax
  80042113f5:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  80042113f8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042113fc:	48 83 c0 01          	add    $0x1,%rax
  8004211400:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  8004211404:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004211408:	0f 84 a1 01 00 00    	je     80042115af <_dwarf_frame_run_inst+0x274>
			switch (high2) {
  800421140e:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004211412:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004211417:	74 38                	je     8004211451 <_dwarf_frame_run_inst+0x116>
  8004211419:	3d c0 00 00 00       	cmp    $0xc0,%eax
  800421141e:	0f 84 01 01 00 00    	je     8004211525 <_dwarf_frame_run_inst+0x1ea>
  8004211424:	83 f8 40             	cmp    $0x40,%eax
  8004211427:	0f 85 71 01 00 00    	jne    800421159e <_dwarf_frame_run_inst+0x263>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  800421142d:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004211431:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211438:	ff 
  8004211439:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  800421143d:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004211441:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211445:	73 05                	jae    800421144c <_dwarf_frame_run_inst+0x111>
			                goto program_done;
  8004211447:	e9 be 0c 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			        break;
  800421144c:	e9 59 01 00 00       	jmpq   80042115aa <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_offset:
			        *row_pc = pc;
  8004211451:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211455:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211459:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  800421145c:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211460:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211464:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211468:	66 39 c2             	cmp    %ax,%dx
  800421146b:	72 0c                	jb     8004211479 <_dwarf_frame_run_inst+0x13e>
  800421146d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211474:	e9 91 0c 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			        RL[low6].dw_offset_relevant = 1;
  8004211479:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421147d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211481:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211485:	48 89 d0             	mov    %rdx,%rax
  8004211488:	48 01 c0             	add    %rax,%rax
  800421148b:	48 01 d0             	add    %rdx,%rax
  800421148e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211492:	48 01 c8             	add    %rcx,%rax
  8004211495:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004211498:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421149c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042114a0:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042114a4:	48 89 d0             	mov    %rdx,%rax
  80042114a7:	48 01 c0             	add    %rax,%rax
  80042114aa:	48 01 d0             	add    %rdx,%rax
  80042114ad:	48 c1 e0 03          	shl    $0x3,%rax
  80042114b1:	48 01 c8             	add    %rcx,%rax
  80042114b4:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  80042114b8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042114bc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042114c0:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042114c4:	48 89 d0             	mov    %rdx,%rax
  80042114c7:	48 01 c0             	add    %rax,%rax
  80042114ca:	48 01 d0             	add    %rdx,%rax
  80042114cd:	48 c1 e0 03          	shl    $0x3,%rax
  80042114d1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042114d5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042114d9:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042114dd:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  80042114e1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042114e5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042114e9:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042114ed:	48 89 d0             	mov    %rdx,%rax
  80042114f0:	48 01 c0             	add    %rax,%rax
  80042114f3:	48 01 d0             	add    %rdx,%rax
  80042114f6:	48 c1 e0 03          	shl    $0x3,%rax
  80042114fa:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  80042114fe:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211502:	48 89 c7             	mov    %rax,%rdi
  8004211505:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  800421150c:	00 00 00 
  800421150f:	ff d0                	callq  *%rax
  8004211511:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211518:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  800421151c:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  8004211520:	e9 85 00 00 00       	jmpq   80042115aa <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_restore:
			        *row_pc = pc;
  8004211525:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211529:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421152d:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  8004211530:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211534:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211538:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421153c:	66 39 c2             	cmp    %ax,%dx
  800421153f:	72 0c                	jb     800421154d <_dwarf_frame_run_inst+0x212>
  8004211541:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211548:	e9 bd 0b 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			        memcpy(&RL[low6], &INITRL[low6],
  800421154d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211551:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211555:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211559:	48 89 d0             	mov    %rdx,%rax
  800421155c:	48 01 c0             	add    %rax,%rax
  800421155f:	48 01 d0             	add    %rdx,%rax
  8004211562:	48 c1 e0 03          	shl    $0x3,%rax
  8004211566:	48 01 c1             	add    %rax,%rcx
  8004211569:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421156d:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211571:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211575:	48 89 d0             	mov    %rdx,%rax
  8004211578:	48 01 c0             	add    %rax,%rax
  800421157b:	48 01 d0             	add    %rdx,%rax
  800421157e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211582:	48 01 f0             	add    %rsi,%rax
  8004211585:	ba 18 00 00 00       	mov    $0x18,%edx
  800421158a:	48 89 ce             	mov    %rcx,%rsi
  800421158d:	48 89 c7             	mov    %rax,%rdi
  8004211590:	48 b8 ed ed 20 04 80 	movabs $0x800420eded,%rax
  8004211597:	00 00 00 
  800421159a:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  800421159c:	eb 0c                	jmp    80042115aa <_dwarf_frame_run_inst+0x26f>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800421159e:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  80042115a5:	e9 60 0b 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			}

			continue;
  80042115aa:	e9 4d 0b 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		}

		switch (low6) {
  80042115af:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042115b3:	83 f8 16             	cmp    $0x16,%eax
  80042115b6:	0f 87 37 0b 00 00    	ja     80042120f3 <_dwarf_frame_run_inst+0xdb8>
  80042115bc:	89 c0                	mov    %eax,%eax
  80042115be:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042115c5:	00 
  80042115c6:	48 b8 e0 85 21 04 80 	movabs $0x80042185e0,%rax
  80042115cd:	00 00 00 
  80042115d0:	48 01 d0             	add    %rdx,%rax
  80042115d3:	48 8b 00             	mov    (%rax),%rax
  80042115d6:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  80042115d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042115dc:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042115e0:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042115e4:	8b 4a 28             	mov    0x28(%rdx),%ecx
  80042115e7:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042115eb:	89 ce                	mov    %ecx,%esi
  80042115ed:	48 89 d7             	mov    %rdx,%rdi
  80042115f0:	ff d0                	callq  *%rax
  80042115f2:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042115f6:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042115fa:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042115fe:	73 05                	jae    8004211605 <_dwarf_frame_run_inst+0x2ca>
			        goto program_done;
  8004211600:	e9 05 0b 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			break;
  8004211605:	e9 f2 0a 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  800421160a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421160e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211612:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211616:	be 01 00 00 00       	mov    $0x1,%esi
  800421161b:	48 89 d7             	mov    %rdx,%rdi
  800421161e:	ff d0                	callq  *%rax
  8004211620:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211627:	ff 
  8004211628:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800421162c:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004211630:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211634:	73 05                	jae    800421163b <_dwarf_frame_run_inst+0x300>
			        goto program_done;
  8004211636:	e9 cf 0a 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			break;
  800421163b:	e9 bc 0a 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  8004211640:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211644:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211648:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421164c:	be 02 00 00 00       	mov    $0x2,%esi
  8004211651:	48 89 d7             	mov    %rdx,%rdi
  8004211654:	ff d0                	callq  *%rax
  8004211656:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421165d:	ff 
  800421165e:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004211662:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004211666:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421166a:	73 05                	jae    8004211671 <_dwarf_frame_run_inst+0x336>
			        goto program_done;
  800421166c:	e9 99 0a 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			break;
  8004211671:	e9 86 0a 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  8004211676:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421167a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421167e:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211682:	be 04 00 00 00       	mov    $0x4,%esi
  8004211687:	48 89 d7             	mov    %rdx,%rdi
  800421168a:	ff d0                	callq  *%rax
  800421168c:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211693:	ff 
  8004211694:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004211698:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421169c:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042116a0:	73 05                	jae    80042116a7 <_dwarf_frame_run_inst+0x36c>
			        goto program_done;
  80042116a2:	e9 63 0a 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			break;
  80042116a7:	e9 50 0a 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  80042116ac:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042116b0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042116b4:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042116b7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042116bb:	48 89 c7             	mov    %rax,%rdi
  80042116be:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  80042116c5:	00 00 00 
  80042116c8:	ff d0                	callq  *%rax
  80042116ca:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  80042116ce:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042116d2:	48 89 c7             	mov    %rax,%rdi
  80042116d5:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  80042116dc:	00 00 00 
  80042116df:	ff d0                	callq  *%rax
  80042116e1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042116e5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116e9:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042116ed:	0f b7 c0             	movzwl %ax,%eax
  80042116f0:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042116f4:	77 0c                	ja     8004211702 <_dwarf_frame_run_inst+0x3c7>
  80042116f6:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042116fd:	e9 08 0a 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004211702:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211706:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421170a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421170e:	48 89 d0             	mov    %rdx,%rax
  8004211711:	48 01 c0             	add    %rax,%rax
  8004211714:	48 01 d0             	add    %rdx,%rax
  8004211717:	48 c1 e0 03          	shl    $0x3,%rax
  800421171b:	48 01 c8             	add    %rcx,%rax
  800421171e:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004211721:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211725:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211729:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421172d:	48 89 d0             	mov    %rdx,%rax
  8004211730:	48 01 c0             	add    %rax,%rax
  8004211733:	48 01 d0             	add    %rdx,%rax
  8004211736:	48 c1 e0 03          	shl    $0x3,%rax
  800421173a:	48 01 c8             	add    %rcx,%rax
  800421173d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211741:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211745:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211749:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421174d:	48 89 d0             	mov    %rdx,%rax
  8004211750:	48 01 c0             	add    %rax,%rax
  8004211753:	48 01 d0             	add    %rdx,%rax
  8004211756:	48 c1 e0 03          	shl    $0x3,%rax
  800421175a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421175e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211762:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211766:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  800421176a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421176e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211772:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211776:	48 89 d0             	mov    %rdx,%rax
  8004211779:	48 01 c0             	add    %rax,%rax
  800421177c:	48 01 d0             	add    %rdx,%rax
  800421177f:	48 c1 e0 03          	shl    $0x3,%rax
  8004211783:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211787:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421178e:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004211793:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211797:	e9 60 09 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  800421179c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042117a0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042117a4:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042117a7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042117ab:	48 89 c7             	mov    %rax,%rdi
  80042117ae:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  80042117b5:	00 00 00 
  80042117b8:	ff d0                	callq  *%rax
  80042117ba:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042117be:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117c2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042117c6:	0f b7 c0             	movzwl %ax,%eax
  80042117c9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042117cd:	77 0c                	ja     80042117db <_dwarf_frame_run_inst+0x4a0>
  80042117cf:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042117d6:	e9 2f 09 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			memcpy(&RL[reg], &INITRL[reg],
  80042117db:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042117df:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042117e3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042117e7:	48 89 d0             	mov    %rdx,%rax
  80042117ea:	48 01 c0             	add    %rax,%rax
  80042117ed:	48 01 d0             	add    %rdx,%rax
  80042117f0:	48 c1 e0 03          	shl    $0x3,%rax
  80042117f4:	48 01 c1             	add    %rax,%rcx
  80042117f7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117fb:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042117ff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211803:	48 89 d0             	mov    %rdx,%rax
  8004211806:	48 01 c0             	add    %rax,%rax
  8004211809:	48 01 d0             	add    %rdx,%rax
  800421180c:	48 c1 e0 03          	shl    $0x3,%rax
  8004211810:	48 01 f0             	add    %rsi,%rax
  8004211813:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211818:	48 89 ce             	mov    %rcx,%rsi
  800421181b:	48 89 c7             	mov    %rax,%rdi
  800421181e:	48 b8 ed ed 20 04 80 	movabs $0x800420eded,%rax
  8004211825:	00 00 00 
  8004211828:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  800421182a:	e9 cd 08 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_undefined:
			*row_pc = pc;
  800421182f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211833:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211837:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800421183a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421183e:	48 89 c7             	mov    %rax,%rdi
  8004211841:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211848:	00 00 00 
  800421184b:	ff d0                	callq  *%rax
  800421184d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211851:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211855:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211859:	0f b7 c0             	movzwl %ax,%eax
  800421185c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211860:	77 0c                	ja     800421186e <_dwarf_frame_run_inst+0x533>
  8004211862:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211869:	e9 9c 08 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800421186e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211872:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211876:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421187a:	48 89 d0             	mov    %rdx,%rax
  800421187d:	48 01 c0             	add    %rax,%rax
  8004211880:	48 01 d0             	add    %rdx,%rax
  8004211883:	48 c1 e0 03          	shl    $0x3,%rax
  8004211887:	48 01 c8             	add    %rcx,%rax
  800421188a:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  800421188d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211891:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211895:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211899:	48 89 d0             	mov    %rdx,%rax
  800421189c:	48 01 c0             	add    %rax,%rax
  800421189f:	48 01 d0             	add    %rdx,%rax
  80042118a2:	48 c1 e0 03          	shl    $0x3,%rax
  80042118a6:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042118aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042118ae:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80042118b2:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  80042118b6:	e9 41 08 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  80042118bb:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042118bf:	48 89 c7             	mov    %rax,%rdi
  80042118c2:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  80042118c9:	00 00 00 
  80042118cc:	ff d0                	callq  *%rax
  80042118ce:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042118d2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118d6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042118da:	0f b7 c0             	movzwl %ax,%eax
  80042118dd:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042118e1:	77 0c                	ja     80042118ef <_dwarf_frame_run_inst+0x5b4>
  80042118e3:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042118ea:	e9 1b 08 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  80042118ef:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118f3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042118f7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042118fb:	48 89 d0             	mov    %rdx,%rax
  80042118fe:	48 01 c0             	add    %rax,%rax
  8004211901:	48 01 d0             	add    %rdx,%rax
  8004211904:	48 c1 e0 03          	shl    $0x3,%rax
  8004211908:	48 01 c8             	add    %rcx,%rax
  800421190b:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  800421190e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211912:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211916:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421191a:	48 89 d0             	mov    %rdx,%rax
  800421191d:	48 01 c0             	add    %rax,%rax
  8004211920:	48 01 d0             	add    %rdx,%rax
  8004211923:	48 c1 e0 03          	shl    $0x3,%rax
  8004211927:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421192b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421192f:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  8004211933:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004211937:	e9 c0 07 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_register:
			*row_pc = pc;
  800421193c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211940:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211944:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211947:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421194b:	48 89 c7             	mov    %rax,%rdi
  800421194e:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211955:	00 00 00 
  8004211958:	ff d0                	callq  *%rax
  800421195a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  800421195e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211962:	48 89 c7             	mov    %rax,%rdi
  8004211965:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  800421196c:	00 00 00 
  800421196f:	ff d0                	callq  *%rax
  8004211971:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211975:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211979:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421197d:	0f b7 c0             	movzwl %ax,%eax
  8004211980:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211984:	77 0c                	ja     8004211992 <_dwarf_frame_run_inst+0x657>
  8004211986:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421198d:	e9 78 07 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004211992:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211996:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421199a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421199e:	48 89 d0             	mov    %rdx,%rax
  80042119a1:	48 01 c0             	add    %rax,%rax
  80042119a4:	48 01 d0             	add    %rdx,%rax
  80042119a7:	48 c1 e0 03          	shl    $0x3,%rax
  80042119ab:	48 01 c8             	add    %rcx,%rax
  80042119ae:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  80042119b1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119b5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042119b9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042119bd:	48 89 d0             	mov    %rdx,%rax
  80042119c0:	48 01 c0             	add    %rax,%rax
  80042119c3:	48 01 d0             	add    %rdx,%rax
  80042119c6:	48 c1 e0 03          	shl    $0x3,%rax
  80042119ca:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042119ce:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042119d2:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  80042119d6:	e9 21 07 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  80042119db:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042119df:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042119e3:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  80042119e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042119eb:	48 89 c7             	mov    %rax,%rdi
  80042119ee:	48 b8 6a 11 21 04 80 	movabs $0x800421116a,%rax
  80042119f5:	00 00 00 
  80042119f8:	ff d0                	callq  *%rax
			break;
  80042119fa:	e9 fd 06 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_state:
			*row_pc = pc;
  80042119ff:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211a03:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211a07:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004211a0a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004211a0e:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211a12:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004211a16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211a1a:	48 89 c7             	mov    %rax,%rdi
  8004211a1d:	48 b8 6a 11 21 04 80 	movabs $0x800421116a,%rax
  8004211a24:	00 00 00 
  8004211a27:	ff d0                	callq  *%rax
			break;
  8004211a29:	e9 ce 06 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  8004211a2e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211a32:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211a36:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211a39:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a3d:	48 89 c7             	mov    %rax,%rdi
  8004211a40:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211a47:	00 00 00 
  8004211a4a:	ff d0                	callq  *%rax
  8004211a4c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004211a50:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a54:	48 89 c7             	mov    %rax,%rdi
  8004211a57:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211a5e:	00 00 00 
  8004211a61:	ff d0                	callq  *%rax
  8004211a63:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211a67:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a6b:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211a6e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a72:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004211a76:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a7a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a7e:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004211a82:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a86:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211a8a:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211a8e:	e9 69 06 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  8004211a93:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211a97:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211a9b:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211a9e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211aa2:	48 89 c7             	mov    %rax,%rdi
  8004211aa5:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211aac:	00 00 00 
  8004211aaf:	ff d0                	callq  *%rax
  8004211ab1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  8004211ab5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ab9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211abd:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  8004211ac1:	e9 36 06 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  8004211ac6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211aca:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211ace:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  8004211ad1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ad5:	48 89 c7             	mov    %rax,%rdi
  8004211ad8:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211adf:	00 00 00 
  8004211ae2:	ff d0                	callq  *%rax
  8004211ae4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211ae8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211aec:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211aef:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211af3:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004211af7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211afb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211aff:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211b03:	e9 f4 05 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  8004211b08:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211b0c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211b10:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  8004211b13:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b17:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004211b1a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b1e:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004211b22:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004211b26:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211b2a:	48 89 c7             	mov    %rax,%rdi
  8004211b2d:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211b34:	00 00 00 
  8004211b37:	ff d0                	callq  *%rax
  8004211b39:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  8004211b3d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b41:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211b45:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  8004211b49:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211b4d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b51:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211b55:	48 01 d0             	add    %rdx,%rax
  8004211b58:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004211b5c:	e9 9b 05 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_expression:
			*row_pc = pc;
  8004211b61:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211b65:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211b69:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211b6c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211b70:	48 89 c7             	mov    %rax,%rdi
  8004211b73:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211b7a:	00 00 00 
  8004211b7d:	ff d0                	callq  *%rax
  8004211b7f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211b83:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b87:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211b8b:	0f b7 c0             	movzwl %ax,%eax
  8004211b8e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211b92:	77 0c                	ja     8004211ba0 <_dwarf_frame_run_inst+0x865>
  8004211b94:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211b9b:	e9 6a 05 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004211ba0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ba4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ba8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211bac:	48 89 d0             	mov    %rdx,%rax
  8004211baf:	48 01 c0             	add    %rax,%rax
  8004211bb2:	48 01 d0             	add    %rdx,%rax
  8004211bb5:	48 c1 e0 03          	shl    $0x3,%rax
  8004211bb9:	48 01 c8             	add    %rcx,%rax
  8004211bbc:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004211bbf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211bc3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211bc7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211bcb:	48 89 d0             	mov    %rdx,%rax
  8004211bce:	48 01 c0             	add    %rax,%rax
  8004211bd1:	48 01 d0             	add    %rdx,%rax
  8004211bd4:	48 c1 e0 03          	shl    $0x3,%rax
  8004211bd8:	48 01 c8             	add    %rcx,%rax
  8004211bdb:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004211bdf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211be3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211be7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211beb:	48 89 d0             	mov    %rdx,%rax
  8004211bee:	48 01 c0             	add    %rax,%rax
  8004211bf1:	48 01 d0             	add    %rdx,%rax
  8004211bf4:	48 c1 e0 03          	shl    $0x3,%rax
  8004211bf8:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004211bfc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211c00:	48 89 c7             	mov    %rax,%rdi
  8004211c03:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211c0a:	00 00 00 
  8004211c0d:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004211c0f:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004211c13:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c17:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c1b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c1f:	48 89 d0             	mov    %rdx,%rax
  8004211c22:	48 01 c0             	add    %rax,%rax
  8004211c25:	48 01 d0             	add    %rdx,%rax
  8004211c28:	48 c1 e0 03          	shl    $0x3,%rax
  8004211c2c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211c30:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211c34:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004211c38:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004211c3c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c40:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211c44:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c48:	48 89 d0             	mov    %rdx,%rax
  8004211c4b:	48 01 c0             	add    %rax,%rax
  8004211c4e:	48 01 d0             	add    %rdx,%rax
  8004211c51:	48 c1 e0 03          	shl    $0x3,%rax
  8004211c55:	48 01 f0             	add    %rsi,%rax
  8004211c58:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211c5c:	48 01 c8             	add    %rcx,%rax
  8004211c5f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004211c63:	e9 94 04 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  8004211c68:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211c6c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211c70:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211c73:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211c77:	48 89 c7             	mov    %rax,%rdi
  8004211c7a:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211c81:	00 00 00 
  8004211c84:	ff d0                	callq  *%rax
  8004211c86:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004211c8a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211c8e:	48 89 c7             	mov    %rax,%rdi
  8004211c91:	48 b8 dc f7 20 04 80 	movabs $0x800420f7dc,%rax
  8004211c98:	00 00 00 
  8004211c9b:	ff d0                	callq  *%rax
  8004211c9d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211ca1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ca5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211ca9:	0f b7 c0             	movzwl %ax,%eax
  8004211cac:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211cb0:	77 0c                	ja     8004211cbe <_dwarf_frame_run_inst+0x983>
  8004211cb2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211cb9:	e9 4c 04 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004211cbe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211cc2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211cc6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211cca:	48 89 d0             	mov    %rdx,%rax
  8004211ccd:	48 01 c0             	add    %rax,%rax
  8004211cd0:	48 01 d0             	add    %rdx,%rax
  8004211cd3:	48 c1 e0 03          	shl    $0x3,%rax
  8004211cd7:	48 01 c8             	add    %rcx,%rax
  8004211cda:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004211cdd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ce1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ce5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ce9:	48 89 d0             	mov    %rdx,%rax
  8004211cec:	48 01 c0             	add    %rax,%rax
  8004211cef:	48 01 d0             	add    %rdx,%rax
  8004211cf2:	48 c1 e0 03          	shl    $0x3,%rax
  8004211cf6:	48 01 c8             	add    %rcx,%rax
  8004211cf9:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211cfd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d01:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211d05:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d09:	48 89 d0             	mov    %rdx,%rax
  8004211d0c:	48 01 c0             	add    %rax,%rax
  8004211d0f:	48 01 d0             	add    %rdx,%rax
  8004211d12:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d16:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211d1a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211d1e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211d22:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004211d26:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d2a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211d2e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d32:	48 89 d0             	mov    %rdx,%rax
  8004211d35:	48 01 c0             	add    %rax,%rax
  8004211d38:	48 01 d0             	add    %rdx,%rax
  8004211d3b:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d3f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211d43:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211d4a:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211d4f:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211d53:	e9 a4 03 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  8004211d58:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211d5c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211d60:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211d63:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d67:	48 89 c7             	mov    %rax,%rdi
  8004211d6a:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211d71:	00 00 00 
  8004211d74:	ff d0                	callq  *%rax
  8004211d76:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004211d7a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d7e:	48 89 c7             	mov    %rax,%rdi
  8004211d81:	48 b8 dc f7 20 04 80 	movabs $0x800420f7dc,%rax
  8004211d88:	00 00 00 
  8004211d8b:	ff d0                	callq  *%rax
  8004211d8d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211d91:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d95:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211d98:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d9c:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004211da0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211da4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211da8:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004211dac:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211db0:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211db7:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211dbc:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211dc0:	e9 37 03 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  8004211dc5:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211dc9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211dcd:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  8004211dd0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211dd4:	48 89 c7             	mov    %rax,%rdi
  8004211dd7:	48 b8 dc f7 20 04 80 	movabs $0x800420f7dc,%rax
  8004211dde:	00 00 00 
  8004211de1:	ff d0                	callq  *%rax
  8004211de3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211de7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211deb:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211dee:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211df2:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004211df6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211dfa:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211e01:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211e06:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211e0a:	e9 ed 02 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset:
			*row_pc = pc;
  8004211e0f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211e13:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211e17:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211e1a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211e1e:	48 89 c7             	mov    %rax,%rdi
  8004211e21:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211e28:	00 00 00 
  8004211e2b:	ff d0                	callq  *%rax
  8004211e2d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004211e31:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211e35:	48 89 c7             	mov    %rax,%rdi
  8004211e38:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211e3f:	00 00 00 
  8004211e42:	ff d0                	callq  *%rax
  8004211e44:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211e48:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e4c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211e50:	0f b7 c0             	movzwl %ax,%eax
  8004211e53:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211e57:	77 0c                	ja     8004211e65 <_dwarf_frame_run_inst+0xb2a>
  8004211e59:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211e60:	e9 a5 02 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004211e65:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e69:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e6d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e71:	48 89 d0             	mov    %rdx,%rax
  8004211e74:	48 01 c0             	add    %rax,%rax
  8004211e77:	48 01 d0             	add    %rdx,%rax
  8004211e7a:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e7e:	48 01 c8             	add    %rcx,%rax
  8004211e81:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004211e84:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e88:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e8c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e90:	48 89 d0             	mov    %rdx,%rax
  8004211e93:	48 01 c0             	add    %rax,%rax
  8004211e96:	48 01 d0             	add    %rdx,%rax
  8004211e99:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e9d:	48 01 c8             	add    %rcx,%rax
  8004211ea0:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211ea4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ea8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211eac:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211eb0:	48 89 d0             	mov    %rdx,%rax
  8004211eb3:	48 01 c0             	add    %rax,%rax
  8004211eb6:	48 01 d0             	add    %rdx,%rax
  8004211eb9:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ebd:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211ec1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211ec5:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211ec9:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004211ecd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ed1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ed5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ed9:	48 89 d0             	mov    %rdx,%rax
  8004211edc:	48 01 c0             	add    %rax,%rax
  8004211edf:	48 01 d0             	add    %rdx,%rax
  8004211ee2:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ee6:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211eea:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211ef1:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004211ef6:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211efa:	e9 fd 01 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  8004211eff:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211f03:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211f07:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211f0a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211f0e:	48 89 c7             	mov    %rax,%rdi
  8004211f11:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004211f18:	00 00 00 
  8004211f1b:	ff d0                	callq  *%rax
  8004211f1d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004211f21:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211f25:	48 89 c7             	mov    %rax,%rdi
  8004211f28:	48 b8 dc f7 20 04 80 	movabs $0x800420f7dc,%rax
  8004211f2f:	00 00 00 
  8004211f32:	ff d0                	callq  *%rax
  8004211f34:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211f38:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f3c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211f40:	0f b7 c0             	movzwl %ax,%eax
  8004211f43:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211f47:	77 0c                	ja     8004211f55 <_dwarf_frame_run_inst+0xc1a>
  8004211f49:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211f50:	e9 b5 01 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004211f55:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f59:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f5d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f61:	48 89 d0             	mov    %rdx,%rax
  8004211f64:	48 01 c0             	add    %rax,%rax
  8004211f67:	48 01 d0             	add    %rdx,%rax
  8004211f6a:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f6e:	48 01 c8             	add    %rcx,%rax
  8004211f71:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004211f74:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f78:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f7c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f80:	48 89 d0             	mov    %rdx,%rax
  8004211f83:	48 01 c0             	add    %rax,%rax
  8004211f86:	48 01 d0             	add    %rdx,%rax
  8004211f89:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f8d:	48 01 c8             	add    %rcx,%rax
  8004211f90:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211f94:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f98:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f9c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211fa0:	48 89 d0             	mov    %rdx,%rax
  8004211fa3:	48 01 c0             	add    %rax,%rax
  8004211fa6:	48 01 d0             	add    %rdx,%rax
  8004211fa9:	48 c1 e0 03          	shl    $0x3,%rax
  8004211fad:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211fb1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211fb5:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211fb9:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004211fbd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211fc1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211fc5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211fc9:	48 89 d0             	mov    %rdx,%rax
  8004211fcc:	48 01 c0             	add    %rax,%rax
  8004211fcf:	48 01 d0             	add    %rdx,%rax
  8004211fd2:	48 c1 e0 03          	shl    $0x3,%rax
  8004211fd6:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211fda:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211fe1:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211fe6:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211fea:	e9 0d 01 00 00       	jmpq   80042120fc <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_expression:
			*row_pc = pc;
  8004211fef:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211ff3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211ff7:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211ffa:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ffe:	48 89 c7             	mov    %rax,%rdi
  8004212001:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004212008:	00 00 00 
  800421200b:	ff d0                	callq  *%rax
  800421200d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212011:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212015:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212019:	0f b7 c0             	movzwl %ax,%eax
  800421201c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212020:	77 0c                	ja     800421202e <_dwarf_frame_run_inst+0xcf3>
  8004212022:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212029:	e9 dc 00 00 00       	jmpq   800421210a <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800421202e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212032:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212036:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421203a:	48 89 d0             	mov    %rdx,%rax
  800421203d:	48 01 c0             	add    %rax,%rax
  8004212040:	48 01 d0             	add    %rdx,%rax
  8004212043:	48 c1 e0 03          	shl    $0x3,%rax
  8004212047:	48 01 c8             	add    %rcx,%rax
  800421204a:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  800421204d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212051:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212055:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212059:	48 89 d0             	mov    %rdx,%rax
  800421205c:	48 01 c0             	add    %rax,%rax
  800421205f:	48 01 d0             	add    %rdx,%rax
  8004212062:	48 c1 e0 03          	shl    $0x3,%rax
  8004212066:	48 01 c8             	add    %rcx,%rax
  8004212069:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  800421206d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212071:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212075:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212079:	48 89 d0             	mov    %rdx,%rax
  800421207c:	48 01 c0             	add    %rax,%rax
  800421207f:	48 01 d0             	add    %rdx,%rax
  8004212082:	48 c1 e0 03          	shl    $0x3,%rax
  8004212086:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  800421208a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421208e:	48 89 c7             	mov    %rax,%rdi
  8004212091:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004212098:	00 00 00 
  800421209b:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  800421209d:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  80042120a1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120a5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120a9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042120ad:	48 89 d0             	mov    %rdx,%rax
  80042120b0:	48 01 c0             	add    %rax,%rax
  80042120b3:	48 01 d0             	add    %rdx,%rax
  80042120b6:	48 c1 e0 03          	shl    $0x3,%rax
  80042120ba:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042120be:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042120c2:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  80042120c6:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042120ca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120ce:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042120d2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042120d6:	48 89 d0             	mov    %rdx,%rax
  80042120d9:	48 01 c0             	add    %rax,%rax
  80042120dc:	48 01 d0             	add    %rdx,%rax
  80042120df:	48 c1 e0 03          	shl    $0x3,%rax
  80042120e3:	48 01 f0             	add    %rsi,%rax
  80042120e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042120ea:	48 01 c8             	add    %rcx,%rax
  80042120ed:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  80042120f1:	eb 09                	jmp    80042120fc <_dwarf_frame_run_inst+0xdc1>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  80042120f3:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  80042120fa:	eb 0e                	jmp    800421210a <_dwarf_frame_run_inst+0xdcf>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  80042120fc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212100:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212104:	0f 82 b8 f2 ff ff    	jb     80042113c2 <_dwarf_frame_run_inst+0x87>
			goto program_done;
		}
	}

program_done:
	return (ret);
  800421210a:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  800421210d:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004212114:	5b                   	pop    %rbx
  8004212115:	5d                   	pop    %rbp
  8004212116:	c3                   	retq   

0000008004212117 <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  8004212117:	55                   	push   %rbp
  8004212118:	48 89 e5             	mov    %rsp,%rbp
  800421211b:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  800421211f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212123:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212127:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421212b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800421212f:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004212133:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  8004212137:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  800421213c:	75 35                	jne    8004212173 <_dwarf_frame_get_internal_table+0x5c>
  800421213e:	48 b9 98 86 21 04 80 	movabs $0x8004218698,%rcx
  8004212145:	00 00 00 
  8004212148:	48 ba a7 85 21 04 80 	movabs $0x80042185a7,%rdx
  800421214f:	00 00 00 
  8004212152:	be 83 01 00 00       	mov    $0x183,%esi
  8004212157:	48 bf bc 85 21 04 80 	movabs $0x80042185bc,%rdi
  800421215e:	00 00 00 
  8004212161:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212166:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800421216d:	00 00 00 
  8004212170:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  8004212173:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212178:	75 35                	jne    80042121af <_dwarf_frame_get_internal_table+0x98>
  800421217a:	48 b9 a7 86 21 04 80 	movabs $0x80042186a7,%rcx
  8004212181:	00 00 00 
  8004212184:	48 ba a7 85 21 04 80 	movabs $0x80042185a7,%rdx
  800421218b:	00 00 00 
  800421218e:	be 86 01 00 00       	mov    $0x186,%esi
  8004212193:	48 bf bc 85 21 04 80 	movabs $0x80042185bc,%rdi
  800421219a:	00 00 00 
  800421219d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042121a2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042121a9:	00 00 00 
  80042121ac:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  80042121af:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042121b3:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042121b7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  80042121bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042121bf:	ba 18 00 00 00       	mov    $0x18,%edx
  80042121c4:	be 00 00 00 00       	mov    $0x0,%esi
  80042121c9:	48 89 c7             	mov    %rax,%rdi
  80042121cc:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  80042121d3:	00 00 00 
  80042121d6:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  80042121d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042121dc:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042121e0:	0f b7 d0             	movzwl %ax,%edx
  80042121e3:	48 89 d0             	mov    %rdx,%rax
  80042121e6:	48 01 c0             	add    %rax,%rax
  80042121e9:	48 01 d0             	add    %rdx,%rax
  80042121ec:	48 c1 e0 03          	shl    $0x3,%rax
  80042121f0:	48 89 c2             	mov    %rax,%rdx
  80042121f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042121f7:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042121fb:	be 00 00 00 00       	mov    $0x0,%esi
  8004212200:	48 89 c7             	mov    %rax,%rdi
  8004212203:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  800421220a:	00 00 00 
  800421220d:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  800421220f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004212216:	eb 2f                	jmp    8004212247 <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  8004212218:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421221c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212220:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212223:	48 63 d0             	movslq %eax,%rdx
  8004212226:	48 89 d0             	mov    %rdx,%rax
  8004212229:	48 01 c0             	add    %rax,%rax
  800421222c:	48 01 d0             	add    %rdx,%rax
  800421222f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212233:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212237:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421223b:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  800421223f:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004212243:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004212247:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421224b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421224f:	0f b7 c0             	movzwl %ax,%eax
  8004212252:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212255:	7f c1                	jg     8004212218 <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  8004212257:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421225b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421225f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  8004212263:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212268:	75 35                	jne    800421229f <_dwarf_frame_get_internal_table+0x188>
  800421226a:	48 b9 b3 86 21 04 80 	movabs $0x80042186b3,%rcx
  8004212271:	00 00 00 
  8004212274:	48 ba a7 85 21 04 80 	movabs $0x80042185a7,%rdx
  800421227b:	00 00 00 
  800421227e:	be 95 01 00 00       	mov    $0x195,%esi
  8004212283:	48 bf bc 85 21 04 80 	movabs $0x80042185bc,%rdi
  800421228a:	00 00 00 
  800421228d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212292:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004212299:	00 00 00 
  800421229c:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  800421229f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122a3:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042122a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122ab:	4c 8b 40 38          	mov    0x38(%rax),%r8
  80042122af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122b3:	48 8b 48 70          	mov    0x70(%rax),%rcx
  80042122b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122bb:	48 8b 50 68          	mov    0x68(%rax),%rdx
  80042122bf:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042122c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042122c7:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  80042122cb:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  80042122d0:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  80042122d4:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  80042122d9:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  80042122e0:	ff ff 
  80042122e2:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80042122e9:	00 
  80042122ea:	48 89 c7             	mov    %rax,%rdi
  80042122ed:	48 b8 3b 13 21 04 80 	movabs $0x800421133b,%rax
  80042122f4:	00 00 00 
  80042122f7:	ff d0                	callq  *%rax
  80042122f9:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  80042122fc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212300:	74 08                	je     800421230a <_dwarf_frame_get_internal_table+0x1f3>
		return (ret);
  8004212302:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212305:	e9 98 00 00 00       	jmpq   80042123a2 <_dwarf_frame_get_internal_table+0x28b>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  800421230a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421230e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212312:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004212316:	77 6f                	ja     8004212387 <_dwarf_frame_get_internal_table+0x270>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004212318:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421231c:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004212320:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212324:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004212328:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421232c:	4c 8b 50 38          	mov    0x38(%rax),%r10
  8004212330:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212334:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004212338:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421233c:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004212340:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004212344:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212348:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  800421234c:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004212351:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004212355:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  800421235a:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  800421235e:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004212363:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212367:	4d 89 d0             	mov    %r10,%r8
  800421236a:	48 89 c7             	mov    %rax,%rdi
  800421236d:	48 b8 3b 13 21 04 80 	movabs $0x800421133b,%rax
  8004212374:	00 00 00 
  8004212377:	ff d0                	callq  *%rax
  8004212379:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  800421237c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212380:	74 05                	je     8004212387 <_dwarf_frame_get_internal_table+0x270>
			return (ret);
  8004212382:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212385:	eb 1b                	jmp    80042123a2 <_dwarf_frame_get_internal_table+0x28b>
	}

	*ret_rt = rt;
  8004212387:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421238b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421238f:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  8004212392:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212396:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421239a:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  800421239d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042123a2:	c9                   	leaveq 
  80042123a3:	c3                   	retq   

00000080042123a4 <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  80042123a4:	55                   	push   %rbp
  80042123a5:	48 89 e5             	mov    %rsp,%rbp
  80042123a8:	48 83 ec 50          	sub    $0x50,%rsp
  80042123ac:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042123b0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042123b4:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042123b8:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042123bc:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  80042123c0:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  80042123c4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042123c9:	74 07                	je     80042123d2 <dwarf_get_fde_info_for_all_regs+0x2e>
  80042123cb:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042123d0:	75 0a                	jne    80042123dc <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  80042123d2:	b8 01 00 00 00       	mov    $0x1,%eax
  80042123d7:	e9 eb 02 00 00       	jmpq   80042126c7 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	assert(dbg != NULL);
  80042123dc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042123e1:	75 35                	jne    8004212418 <dwarf_get_fde_info_for_all_regs+0x74>
  80042123e3:	48 b9 a7 86 21 04 80 	movabs $0x80042186a7,%rcx
  80042123ea:	00 00 00 
  80042123ed:	48 ba a7 85 21 04 80 	movabs $0x80042185a7,%rdx
  80042123f4:	00 00 00 
  80042123f7:	be bf 01 00 00       	mov    $0x1bf,%esi
  80042123fc:	48 bf bc 85 21 04 80 	movabs $0x80042185bc,%rdi
  8004212403:	00 00 00 
  8004212406:	b8 00 00 00 00       	mov    $0x0,%eax
  800421240b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004212412:	00 00 00 
  8004212415:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  8004212418:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421241c:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212420:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004212424:	77 19                	ja     800421243f <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  8004212426:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421242a:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800421242e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212432:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212436:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  8004212439:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800421243d:	77 0a                	ja     8004212449 <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  800421243f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212444:	e9 7e 02 00 00       	jmpq   80042126c7 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  8004212449:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  800421244d:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  8004212451:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  8004212455:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212459:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421245d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212461:	4d 89 c1             	mov    %r8,%r9
  8004212464:	49 89 f8             	mov    %rdi,%r8
  8004212467:	48 89 c7             	mov    %rax,%rdi
  800421246a:	48 b8 17 21 21 04 80 	movabs $0x8004212117,%rax
  8004212471:	00 00 00 
  8004212474:	ff d0                	callq  *%rax
  8004212476:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  8004212479:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421247d:	74 0a                	je     8004212489 <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  800421247f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212484:	e9 3e 02 00 00       	jmpq   80042126c7 <dwarf_get_fde_info_for_all_regs+0x323>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  8004212489:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421248d:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212491:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  8004212495:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  800421249a:	0f 87 b1 00 00 00    	ja     8004212551 <dwarf_get_fde_info_for_all_regs+0x1ad>
		reg_table->rules[cfa].dw_offset_relevant =
  80042124a0:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  80042124a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124a8:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  80042124ab:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042124af:	48 63 c9             	movslq %ecx,%rcx
  80042124b2:	48 83 c1 01          	add    $0x1,%rcx
  80042124b6:	48 c1 e1 04          	shl    $0x4,%rcx
  80042124ba:	48 01 ca             	add    %rcx,%rdx
  80042124bd:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  80042124bf:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80042124c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124c7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80042124cb:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042124cf:	48 63 c9             	movslq %ecx,%rcx
  80042124d2:	48 83 c1 01          	add    $0x1,%rcx
  80042124d6:	48 c1 e1 04          	shl    $0x4,%rcx
  80042124da:	48 01 ca             	add    %rcx,%rdx
  80042124dd:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  80042124e0:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80042124e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124e8:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042124ec:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042124f0:	48 63 c9             	movslq %ecx,%rcx
  80042124f3:	48 83 c1 01          	add    $0x1,%rcx
  80042124f7:	48 c1 e1 04          	shl    $0x4,%rcx
  80042124fb:	48 01 ca             	add    %rcx,%rdx
  80042124fe:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004212502:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212506:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421250a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421250e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212512:	48 63 c9             	movslq %ecx,%rcx
  8004212515:	48 83 c1 01          	add    $0x1,%rcx
  8004212519:	48 c1 e1 04          	shl    $0x4,%rcx
  800421251d:	48 01 ca             	add    %rcx,%rdx
  8004212520:	48 83 c2 08          	add    $0x8,%rdx
  8004212524:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  8004212527:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  800421252b:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800421252f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212533:	48 63 d2             	movslq %edx,%rdx
  8004212536:	48 83 c2 01          	add    $0x1,%rdx
  800421253a:	48 c1 e2 04          	shl    $0x4,%rdx
  800421253e:	48 01 d0             	add    %rdx,%rax
  8004212541:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212545:	48 8b 00             	mov    (%rax),%rax
  8004212548:	48 89 01             	mov    %rax,(%rcx)
  800421254b:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  800421254f:	eb 3c                	jmp    800421258d <dwarf_get_fde_info_for_all_regs+0x1e9>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  8004212551:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212555:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  8004212558:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421255c:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  800421255e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212562:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  8004212566:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421256a:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  800421256d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212571:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  8004212575:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212579:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  800421257d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212581:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212585:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212589:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800421258d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004212594:	e9 fd 00 00 00       	jmpq   8004212696 <dwarf_get_fde_info_for_all_regs+0x2f2>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  8004212599:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  800421259d:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042125a0:	75 05                	jne    80042125a7 <dwarf_get_fde_info_for_all_regs+0x203>
			continue;
  80042125a2:	e9 eb 00 00 00       	jmpq   8004212692 <dwarf_get_fde_info_for_all_regs+0x2ee>

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  80042125a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042125ab:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042125af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042125b2:	48 63 d0             	movslq %eax,%rdx
  80042125b5:	48 89 d0             	mov    %rdx,%rax
  80042125b8:	48 01 c0             	add    %rax,%rax
  80042125bb:	48 01 d0             	add    %rdx,%rax
  80042125be:	48 c1 e0 03          	shl    $0x3,%rax
  80042125c2:	48 01 c8             	add    %rcx,%rax
  80042125c5:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  80042125c8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042125cc:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042125cf:	48 63 c9             	movslq %ecx,%rcx
  80042125d2:	48 83 c1 01          	add    $0x1,%rcx
  80042125d6:	48 c1 e1 04          	shl    $0x4,%rcx
  80042125da:	48 01 ca             	add    %rcx,%rdx
  80042125dd:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  80042125df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042125e3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042125e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042125ea:	48 63 d0             	movslq %eax,%rdx
  80042125ed:	48 89 d0             	mov    %rdx,%rax
  80042125f0:	48 01 c0             	add    %rax,%rax
  80042125f3:	48 01 d0             	add    %rdx,%rax
  80042125f6:	48 c1 e0 03          	shl    $0x3,%rax
  80042125fa:	48 01 c8             	add    %rcx,%rax
  80042125fd:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  8004212601:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212605:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212608:	48 63 c9             	movslq %ecx,%rcx
  800421260b:	48 83 c1 01          	add    $0x1,%rcx
  800421260f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212613:	48 01 ca             	add    %rcx,%rdx
  8004212616:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004212619:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421261d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212621:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212624:	48 63 d0             	movslq %eax,%rdx
  8004212627:	48 89 d0             	mov    %rdx,%rax
  800421262a:	48 01 c0             	add    %rax,%rax
  800421262d:	48 01 d0             	add    %rdx,%rax
  8004212630:	48 c1 e0 03          	shl    $0x3,%rax
  8004212634:	48 01 c8             	add    %rcx,%rax
  8004212637:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  800421263b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421263f:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212642:	48 63 c9             	movslq %ecx,%rcx
  8004212645:	48 83 c1 01          	add    $0x1,%rcx
  8004212649:	48 c1 e1 04          	shl    $0x4,%rcx
  800421264d:	48 01 ca             	add    %rcx,%rdx
  8004212650:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  8004212654:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212658:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421265c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421265f:	48 63 d0             	movslq %eax,%rdx
  8004212662:	48 89 d0             	mov    %rdx,%rax
  8004212665:	48 01 c0             	add    %rax,%rax
  8004212668:	48 01 d0             	add    %rdx,%rax
  800421266b:	48 c1 e0 03          	shl    $0x3,%rax
  800421266f:	48 01 c8             	add    %rcx,%rax
  8004212672:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  8004212676:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421267a:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421267d:	48 63 c9             	movslq %ecx,%rcx
  8004212680:	48 83 c1 01          	add    $0x1,%rcx
  8004212684:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212688:	48 01 ca             	add    %rcx,%rdx
  800421268b:	48 83 c2 08          	add    $0x8,%rdx
  800421268f:	48 89 02             	mov    %rax,(%rdx)

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  8004212692:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004212696:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  800421269a:	7f 14                	jg     80042126b0 <dwarf_get_fde_info_for_all_regs+0x30c>
  800421269c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042126a0:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  80042126a4:	0f b7 c0             	movzwl %ax,%eax
  80042126a7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042126aa:	0f 8f e9 fe ff ff    	jg     8004212599 <dwarf_get_fde_info_for_all_regs+0x1f5>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  80042126b0:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042126b5:	74 0b                	je     80042126c2 <dwarf_get_fde_info_for_all_regs+0x31e>
  80042126b7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042126bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042126bf:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  80042126c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042126c7:	c9                   	leaveq 
  80042126c8:	c3                   	retq   

00000080042126c9 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042126c9:	55                   	push   %rbp
  80042126ca:	48 89 e5             	mov    %rsp,%rbp
  80042126cd:	48 83 ec 40          	sub    $0x40,%rsp
  80042126d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042126d5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042126d9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042126dd:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80042126e1:	44 89 c0             	mov    %r8d,%eax
  80042126e4:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  80042126e8:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  80042126eb:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  80042126ef:	75 0a                	jne    80042126fb <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  80042126f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042126f6:	e9 e6 01 00 00       	jmpq   80042128e1 <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  80042126fb:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042126ff:	83 e0 f0             	and    $0xfffffff0,%eax
  8004212702:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004212705:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004212709:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421270d:	83 f8 0c             	cmp    $0xc,%eax
  8004212710:	0f 87 72 01 00 00    	ja     8004212888 <_dwarf_frame_read_lsb_encoded+0x1bf>
  8004212716:	89 c0                	mov    %eax,%eax
  8004212718:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421271f:	00 
  8004212720:	48 b8 c0 86 21 04 80 	movabs $0x80042186c0,%rax
  8004212727:	00 00 00 
  800421272a:	48 01 d0             	add    %rdx,%rax
  800421272d:	48 8b 00             	mov    (%rax),%rax
  8004212730:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  8004212732:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212736:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421273a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421273e:	8b 52 28             	mov    0x28(%rdx),%edx
  8004212741:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212745:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212749:	48 89 cf             	mov    %rcx,%rdi
  800421274c:	ff d0                	callq  *%rax
  800421274e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212752:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212755:	e9 35 01 00 00       	jmpq   800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  800421275a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421275e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212762:	48 89 d6             	mov    %rdx,%rsi
  8004212765:	48 89 c7             	mov    %rax,%rdi
  8004212768:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  800421276f:	00 00 00 
  8004212772:	ff d0                	callq  *%rax
  8004212774:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212778:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421277b:	e9 0f 01 00 00       	jmpq   800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  8004212780:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212784:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212788:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421278c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212790:	ba 02 00 00 00       	mov    $0x2,%edx
  8004212795:	48 89 cf             	mov    %rcx,%rdi
  8004212798:	ff d0                	callq  *%rax
  800421279a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421279e:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042127a1:	e9 e9 00 00 00       	jmpq   800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  80042127a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127aa:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127ae:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042127b2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042127b6:	ba 04 00 00 00       	mov    $0x4,%edx
  80042127bb:	48 89 cf             	mov    %rcx,%rdi
  80042127be:	ff d0                	callq  *%rax
  80042127c0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042127c4:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042127c7:	e9 c3 00 00 00       	jmpq   800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  80042127cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127d0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127d4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042127d8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042127dc:	ba 08 00 00 00       	mov    $0x8,%edx
  80042127e1:	48 89 cf             	mov    %rcx,%rdi
  80042127e4:	ff d0                	callq  *%rax
  80042127e6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042127ea:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042127ed:	e9 9d 00 00 00       	jmpq   800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  80042127f2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042127f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042127fa:	48 89 d6             	mov    %rdx,%rsi
  80042127fd:	48 89 c7             	mov    %rax,%rdi
  8004212800:	48 b8 b9 f6 20 04 80 	movabs $0x800420f6b9,%rax
  8004212807:	00 00 00 
  800421280a:	ff d0                	callq  *%rax
  800421280c:	48 89 c2             	mov    %rax,%rdx
  800421280f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212813:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004212816:	eb 77                	jmp    800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004212818:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421281c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212820:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212824:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212828:	ba 02 00 00 00       	mov    $0x2,%edx
  800421282d:	48 89 cf             	mov    %rcx,%rdi
  8004212830:	ff d0                	callq  *%rax
  8004212832:	48 0f bf d0          	movswq %ax,%rdx
  8004212836:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421283a:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421283d:	eb 50                	jmp    800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  800421283f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212843:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212847:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421284b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421284f:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212854:	48 89 cf             	mov    %rcx,%rdi
  8004212857:	ff d0                	callq  *%rax
  8004212859:	48 63 d0             	movslq %eax,%rdx
  800421285c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212860:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004212863:	eb 2a                	jmp    800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  8004212865:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212869:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421286d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212871:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212875:	ba 08 00 00 00       	mov    $0x8,%edx
  800421287a:	48 89 cf             	mov    %rcx,%rdi
  800421287d:	ff d0                	callq  *%rax
  800421287f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212883:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212886:	eb 07                	jmp    800421288f <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212888:	b8 14 00 00 00       	mov    $0x14,%eax
  800421288d:	eb 52                	jmp    80042128e1 <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  800421288f:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004212893:	75 47                	jne    80042128dc <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004212895:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212899:	83 f8 01             	cmp    $0x1,%eax
  800421289c:	7c 3d                	jl     80042128db <_dwarf_frame_read_lsb_encoded+0x212>
  800421289e:	83 f8 04             	cmp    $0x4,%eax
  80042128a1:	7e 0a                	jle    80042128ad <_dwarf_frame_read_lsb_encoded+0x1e4>
  80042128a3:	83 e8 09             	sub    $0x9,%eax
  80042128a6:	83 f8 03             	cmp    $0x3,%eax
  80042128a9:	77 30                	ja     80042128db <_dwarf_frame_read_lsb_encoded+0x212>
  80042128ab:	eb 17                	jmp    80042128c4 <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  80042128ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042128b1:	48 8b 10             	mov    (%rax),%rdx
  80042128b4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042128b8:	48 01 c2             	add    %rax,%rdx
  80042128bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042128bf:	48 89 10             	mov    %rdx,(%rax)
			break;
  80042128c2:	eb 18                	jmp    80042128dc <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  80042128c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042128c8:	48 8b 10             	mov    (%rax),%rdx
  80042128cb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042128cf:	48 01 c2             	add    %rax,%rdx
  80042128d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042128d6:	48 89 10             	mov    %rdx,(%rax)
			break;
  80042128d9:	eb 01                	jmp    80042128dc <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  80042128db:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  80042128dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042128e1:	c9                   	leaveq 
  80042128e2:	c3                   	retq   

00000080042128e3 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  80042128e3:	55                   	push   %rbp
  80042128e4:	48 89 e5             	mov    %rsp,%rbp
  80042128e7:	48 83 ec 50          	sub    $0x50,%rsp
  80042128eb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042128ef:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042128f3:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  80042128f7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042128fb:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042128ff:	48 85 c0             	test   %rax,%rax
  8004212902:	74 0f                	je     8004212913 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004212904:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212908:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421290c:	0f b6 00             	movzbl (%rax),%eax
  800421290f:	3c 7a                	cmp    $0x7a,%al
  8004212911:	74 35                	je     8004212948 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  8004212913:	48 b9 28 87 21 04 80 	movabs $0x8004218728,%rcx
  800421291a:	00 00 00 
  800421291d:	48 ba a7 85 21 04 80 	movabs $0x80042185a7,%rdx
  8004212924:	00 00 00 
  8004212927:	be 4a 02 00 00       	mov    $0x24a,%esi
  800421292c:	48 bf bc 85 21 04 80 	movabs $0x80042185bc,%rdi
  8004212933:	00 00 00 
  8004212936:	b8 00 00 00 00       	mov    $0x0,%eax
  800421293b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004212942:	00 00 00 
  8004212945:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  8004212948:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421294c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212950:	48 83 c0 01          	add    $0x1,%rax
  8004212954:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004212958:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421295c:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212960:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  8004212964:	e9 af 00 00 00       	jmpq   8004212a18 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  8004212969:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421296d:	0f b6 00             	movzbl (%rax),%eax
  8004212970:	0f b6 c0             	movzbl %al,%eax
  8004212973:	83 f8 50             	cmp    $0x50,%eax
  8004212976:	74 18                	je     8004212990 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004212978:	83 f8 52             	cmp    $0x52,%eax
  800421297b:	74 77                	je     80042129f4 <_dwarf_frame_parse_lsb_cie_augment+0x111>
  800421297d:	83 f8 4c             	cmp    $0x4c,%eax
  8004212980:	0f 85 86 00 00 00    	jne    8004212a0c <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004212986:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  800421298b:	e9 83 00 00 00       	jmpq   8004212a13 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004212990:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212994:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212998:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800421299c:	0f b6 00             	movzbl (%rax),%eax
  800421299f:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  80042129a2:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80042129a9:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042129aa:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  80042129af:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  80042129b3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042129b7:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  80042129bb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042129bf:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042129c3:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042129c7:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042129cd:	48 89 c7             	mov    %rax,%rdi
  80042129d0:	48 b8 c9 26 21 04 80 	movabs $0x80042126c9,%rax
  80042129d7:	00 00 00 
  80042129da:	ff d0                	callq  *%rax
  80042129dc:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  80042129df:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80042129e3:	74 05                	je     80042129ea <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  80042129e5:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042129e8:	eb 42                	jmp    8004212a2c <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  80042129ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042129ee:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  80042129f2:	eb 1f                	jmp    8004212a13 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  80042129f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042129f8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042129fc:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004212a00:	0f b6 10             	movzbl (%rax),%edx
  8004212a03:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212a07:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004212a0a:	eb 07                	jmp    8004212a13 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212a0c:	b8 14 00 00 00       	mov    $0x14,%eax
  8004212a11:	eb 19                	jmp    8004212a2c <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  8004212a13:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004212a18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212a1c:	0f b6 00             	movzbl (%rax),%eax
  8004212a1f:	84 c0                	test   %al,%al
  8004212a21:	0f 85 42 ff ff ff    	jne    8004212969 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  8004212a27:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212a2c:	c9                   	leaveq 
  8004212a2d:	c3                   	retq   

0000008004212a2e <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  8004212a2e:	55                   	push   %rbp
  8004212a2f:	48 89 e5             	mov    %rsp,%rbp
  8004212a32:	48 83 ec 60          	sub    $0x60,%rsp
  8004212a36:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212a3a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212a3e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212a42:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212a46:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  8004212a4a:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004212a4f:	75 35                	jne    8004212a86 <_dwarf_frame_set_cie+0x58>
  8004212a51:	48 b9 5d 87 21 04 80 	movabs $0x800421875d,%rcx
  8004212a58:	00 00 00 
  8004212a5b:	48 ba a7 85 21 04 80 	movabs $0x80042185a7,%rdx
  8004212a62:	00 00 00 
  8004212a65:	be 7b 02 00 00       	mov    $0x27b,%esi
  8004212a6a:	48 bf bc 85 21 04 80 	movabs $0x80042185bc,%rdi
  8004212a71:	00 00 00 
  8004212a74:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212a79:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004212a80:	00 00 00 
  8004212a83:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004212a86:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212a8a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004212a8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a92:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212a96:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004212a99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212a9d:	48 8b 10             	mov    (%rax),%rdx
  8004212aa0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212aa4:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212aa8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212aac:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ab0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212ab4:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212ab8:	48 89 d1             	mov    %rdx,%rcx
  8004212abb:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212abf:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212ac4:	48 89 cf             	mov    %rcx,%rdi
  8004212ac7:	ff d0                	callq  *%rax
  8004212ac9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212acd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212ad2:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212ad6:	75 2e                	jne    8004212b06 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004212ad8:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004212adf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ae3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ae7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212aeb:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212aef:	48 89 d1             	mov    %rdx,%rcx
  8004212af2:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212af6:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212afb:	48 89 cf             	mov    %rcx,%rdi
  8004212afe:	ff d0                	callq  *%rax
  8004212b00:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212b04:	eb 07                	jmp    8004212b0d <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004212b06:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004212b0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b11:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212b15:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212b19:	48 8b 00             	mov    (%rax),%rax
  8004212b1c:	48 29 c2             	sub    %rax,%rdx
  8004212b1f:	48 89 d0             	mov    %rdx,%rax
  8004212b22:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212b26:	73 0a                	jae    8004212b32 <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212b28:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212b2d:	e9 5d 03 00 00       	jmpq   8004212e8f <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004212b32:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b36:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212b3a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212b3e:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212b42:	48 89 d1             	mov    %rdx,%rcx
  8004212b45:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212b48:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212b4c:	48 89 cf             	mov    %rcx,%rdi
  8004212b4f:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004212b51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b55:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212b59:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212b5d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b61:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212b65:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212b69:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212b6d:	48 89 d1             	mov    %rdx,%rcx
  8004212b70:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212b74:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212b79:	48 89 cf             	mov    %rcx,%rdi
  8004212b7c:	ff d0                	callq  *%rax
  8004212b7e:	89 c2                	mov    %eax,%edx
  8004212b80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b84:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212b88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b8c:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212b90:	66 83 f8 01          	cmp    $0x1,%ax
  8004212b94:	74 26                	je     8004212bbc <_dwarf_frame_set_cie+0x18e>
  8004212b96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b9a:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212b9e:	66 83 f8 03          	cmp    $0x3,%ax
  8004212ba2:	74 18                	je     8004212bbc <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  8004212ba4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ba8:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212bac:	66 83 f8 04          	cmp    $0x4,%ax
  8004212bb0:	74 0a                	je     8004212bbc <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004212bb2:	b8 16 00 00 00       	mov    $0x16,%eax
  8004212bb7:	e9 d3 02 00 00       	jmpq   8004212e8f <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212bbc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212bc0:	48 8b 10             	mov    (%rax),%rdx
  8004212bc3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212bc7:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212bcb:	48 01 d0             	add    %rdx,%rax
  8004212bce:	48 89 c2             	mov    %rax,%rdx
  8004212bd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212bd5:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004212bd9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212bdd:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212be1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004212be5:	90                   	nop
  8004212be6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212bea:	48 8b 00             	mov    (%rax),%rax
  8004212bed:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004212bf1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212bf5:	48 89 0a             	mov    %rcx,(%rdx)
  8004212bf8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212bfc:	48 01 d0             	add    %rdx,%rax
  8004212bff:	0f b6 00             	movzbl (%rax),%eax
  8004212c02:	84 c0                	test   %al,%al
  8004212c04:	75 e0                	jne    8004212be6 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004212c06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c0a:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212c0e:	0f b6 00             	movzbl (%rax),%eax
  8004212c11:	84 c0                	test   %al,%al
  8004212c13:	74 48                	je     8004212c5d <_dwarf_frame_set_cie+0x22f>
  8004212c15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c19:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212c1d:	0f b6 00             	movzbl (%rax),%eax
  8004212c20:	3c 7a                	cmp    $0x7a,%al
  8004212c22:	74 39                	je     8004212c5d <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004212c24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c28:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212c2c:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212c30:	75 07                	jne    8004212c39 <_dwarf_frame_set_cie+0x20b>
  8004212c32:	b8 04 00 00 00       	mov    $0x4,%eax
  8004212c37:	eb 05                	jmp    8004212c3e <_dwarf_frame_set_cie+0x210>
  8004212c39:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004212c3e:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004212c41:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c45:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004212c49:	48 01 c2             	add    %rax,%rdx
  8004212c4c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212c50:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004212c53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212c58:	e9 32 02 00 00       	jmpq   8004212e8f <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004212c5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c61:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212c65:	48 be 65 87 21 04 80 	movabs $0x8004218765,%rsi
  8004212c6c:	00 00 00 
  8004212c6f:	48 89 c7             	mov    %rax,%rdi
  8004212c72:	48 b8 70 f0 20 04 80 	movabs $0x800420f070,%rax
  8004212c79:	00 00 00 
  8004212c7c:	ff d0                	callq  *%rax
  8004212c7e:	48 85 c0             	test   %rax,%rax
  8004212c81:	74 28                	je     8004212cab <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004212c83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c87:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c8b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c8f:	8b 52 28             	mov    0x28(%rdx),%edx
  8004212c92:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004212c96:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004212c9a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212c9e:	48 89 cf             	mov    %rcx,%rdi
  8004212ca1:	ff d0                	callq  *%rax
  8004212ca3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212ca7:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212cab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212caf:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212cb3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212cb7:	48 89 d6             	mov    %rdx,%rsi
  8004212cba:	48 89 c7             	mov    %rax,%rdi
  8004212cbd:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  8004212cc4:	00 00 00 
  8004212cc7:	ff d0                	callq  *%rax
  8004212cc9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212ccd:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212cd1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212cd5:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212cd9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212cdd:	48 89 d6             	mov    %rdx,%rsi
  8004212ce0:	48 89 c7             	mov    %rax,%rdi
  8004212ce3:	48 b8 b9 f6 20 04 80 	movabs $0x800420f6b9,%rax
  8004212cea:	00 00 00 
  8004212ced:	ff d0                	callq  *%rax
  8004212cef:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212cf3:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004212cf7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cfb:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212cff:	66 83 f8 01          	cmp    $0x1,%ax
  8004212d03:	75 2b                	jne    8004212d30 <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212d05:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d09:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212d0d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212d11:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212d15:	48 89 d1             	mov    %rdx,%rcx
  8004212d18:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212d1c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212d21:	48 89 cf             	mov    %rcx,%rdi
  8004212d24:	ff d0                	callq  *%rax
  8004212d26:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212d2a:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004212d2e:	eb 26                	jmp    8004212d56 <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212d30:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d34:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212d38:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212d3c:	48 89 d6             	mov    %rdx,%rsi
  8004212d3f:	48 89 c7             	mov    %rax,%rdi
  8004212d42:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  8004212d49:	00 00 00 
  8004212d4c:	ff d0                	callq  *%rax
  8004212d4e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212d52:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004212d56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d5a:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212d5e:	0f b6 00             	movzbl (%rax),%eax
  8004212d61:	3c 7a                	cmp    $0x7a,%al
  8004212d63:	0f 85 93 00 00 00    	jne    8004212dfc <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212d69:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d6d:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212d71:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212d75:	48 89 d6             	mov    %rdx,%rsi
  8004212d78:	48 89 c7             	mov    %rax,%rdi
  8004212d7b:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  8004212d82:	00 00 00 
  8004212d85:	ff d0                	callq  *%rax
  8004212d87:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212d8b:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212d8f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d93:	48 8b 10             	mov    (%rax),%rdx
  8004212d96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d9a:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212d9e:	48 01 d0             	add    %rdx,%rax
  8004212da1:	48 89 c2             	mov    %rax,%rdx
  8004212da4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212da8:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004212dac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212db0:	48 8b 10             	mov    (%rax),%rdx
  8004212db3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212db7:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004212dbb:	48 01 c2             	add    %rax,%rdx
  8004212dbe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212dc2:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004212dc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212dc9:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004212dcd:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212dd1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212dd5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212dd9:	48 89 ce             	mov    %rcx,%rsi
  8004212ddc:	48 89 c7             	mov    %rax,%rdi
  8004212ddf:	48 b8 e3 28 21 04 80 	movabs $0x80042128e3,%rax
  8004212de6:	00 00 00 
  8004212de9:	ff d0                	callq  *%rax
  8004212deb:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004212dee:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212df2:	74 08                	je     8004212dfc <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  8004212df4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212df7:	e9 93 00 00 00       	jmpq   8004212e8f <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212dfc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e00:	48 8b 10             	mov    (%rax),%rdx
  8004212e03:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e07:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212e0b:	48 01 d0             	add    %rdx,%rax
  8004212e0e:	48 89 c2             	mov    %rax,%rdx
  8004212e11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e15:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004212e19:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212e1d:	75 2a                	jne    8004212e49 <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004212e1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e23:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212e27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212e2b:	48 01 c2             	add    %rax,%rdx
  8004212e2e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e32:	48 8b 00             	mov    (%rax),%rax
  8004212e35:	48 29 c2             	sub    %rax,%rdx
  8004212e38:	48 89 d0             	mov    %rdx,%rax
  8004212e3b:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004212e3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e43:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004212e47:	eb 28                	jmp    8004212e71 <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004212e49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e4d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212e51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212e55:	48 01 c2             	add    %rax,%rdx
  8004212e58:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e5c:	48 8b 00             	mov    (%rax),%rax
  8004212e5f:	48 29 c2             	sub    %rax,%rdx
  8004212e62:	48 89 d0             	mov    %rdx,%rax
  8004212e65:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004212e69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e6d:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004212e71:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e75:	48 8b 10             	mov    (%rax),%rdx
  8004212e78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e7c:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004212e80:	48 01 c2             	add    %rax,%rdx
  8004212e83:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e87:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004212e8a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212e8f:	c9                   	leaveq 
  8004212e90:	c3                   	retq   

0000008004212e91 <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004212e91:	55                   	push   %rbp
  8004212e92:	48 89 e5             	mov    %rsp,%rbp
  8004212e95:	48 83 ec 70          	sub    $0x70,%rsp
  8004212e99:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212e9d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212ea1:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212ea5:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212ea9:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004212ead:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004212eb1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212eb5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004212eb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ebd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212ec1:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212ec4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212ec8:	48 8b 10             	mov    (%rax),%rdx
  8004212ecb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ecf:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212ed3:	48 01 d0             	add    %rdx,%rax
  8004212ed6:	48 89 c2             	mov    %rax,%rdx
  8004212ed9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212edd:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004212ee1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212ee5:	48 8b 10             	mov    (%rax),%rdx
  8004212ee8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212eec:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212ef0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ef4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ef8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212efc:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212f00:	48 89 d1             	mov    %rdx,%rcx
  8004212f03:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004212f07:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212f0c:	48 89 cf             	mov    %rcx,%rdi
  8004212f0f:	ff d0                	callq  *%rax
  8004212f11:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212f15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212f1a:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212f1e:	75 2e                	jne    8004212f4e <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  8004212f20:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004212f27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f2b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212f2f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212f33:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212f37:	48 89 d1             	mov    %rdx,%rcx
  8004212f3a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004212f3e:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212f43:	48 89 cf             	mov    %rcx,%rdi
  8004212f46:	ff d0                	callq  *%rax
  8004212f48:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212f4c:	eb 07                	jmp    8004212f55 <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004212f4e:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004212f55:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f59:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212f5d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212f61:	48 8b 00             	mov    (%rax),%rax
  8004212f64:	48 29 c2             	sub    %rax,%rdx
  8004212f67:	48 89 d0             	mov    %rdx,%rax
  8004212f6a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212f6e:	73 0a                	jae    8004212f7a <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212f70:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212f75:	e9 ca 02 00 00       	jmpq   8004213244 <_dwarf_frame_set_fde+0x3b3>
	}

	fde->fde_length = length;
  8004212f7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f7e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212f82:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004212f86:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004212f8a:	74 5e                	je     8004212fea <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212f8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f90:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212f94:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212f98:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212f9c:	48 89 d1             	mov    %rdx,%rcx
  8004212f9f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004212fa3:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212fa8:	48 89 cf             	mov    %rcx,%rdi
  8004212fab:	ff d0                	callq  *%rax
  8004212fad:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212fb1:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004212fb5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212fb9:	48 8b 10             	mov    (%rax),%rdx
  8004212fbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fc0:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212fc4:	48 29 c2             	sub    %rax,%rdx
  8004212fc7:	48 89 d0             	mov    %rdx,%rax
  8004212fca:	48 83 e8 04          	sub    $0x4,%rax
  8004212fce:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004212fd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fd6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212fda:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212fde:	75 3d                	jne    800421301d <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004212fe0:	b8 13 00 00 00       	mov    $0x13,%eax
  8004212fe5:	e9 5a 02 00 00       	jmpq   8004213244 <_dwarf_frame_set_fde+0x3b3>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004212fea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212fee:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ff2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212ff6:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212ffa:	48 89 d1             	mov    %rdx,%rcx
  8004212ffd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213000:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213004:	48 89 cf             	mov    %rcx,%rdi
  8004213007:	ff d0                	callq  *%rax
  8004213009:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421300d:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004213011:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213015:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213019:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  800421301d:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213021:	0f 84 c9 00 00 00    	je     80042130f0 <_dwarf_frame_set_fde+0x25f>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213027:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421302b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421302f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213033:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213036:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  800421303a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421303e:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213042:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  8004213046:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421304a:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421304e:	48 89 c2             	mov    %rax,%rdx
  8004213051:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004213055:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213059:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421305d:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213061:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213065:	48 89 c7             	mov    %rax,%rdi
  8004213068:	48 b8 c9 26 21 04 80 	movabs $0x80042126c9,%rax
  800421306f:	00 00 00 
  8004213072:	ff d0                	callq  *%rax
  8004213074:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004213077:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421307b:	74 08                	je     8004213085 <_dwarf_frame_set_fde+0x1f4>
			return (ret);
  800421307d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213080:	e9 bf 01 00 00       	jmpq   8004213244 <_dwarf_frame_set_fde+0x3b3>
		fde->fde_initloc = val;
  8004213085:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213089:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421308d:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  8004213091:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213095:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213099:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  800421309d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130a1:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042130a5:	48 89 c2             	mov    %rax,%rdx
  80042130a8:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042130ac:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80042130b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130b4:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  80042130b8:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042130bc:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042130c2:	48 89 c7             	mov    %rax,%rdi
  80042130c5:	48 b8 c9 26 21 04 80 	movabs $0x80042126c9,%rax
  80042130cc:	00 00 00 
  80042130cf:	ff d0                	callq  *%rax
  80042130d1:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  80042130d4:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042130d8:	74 08                	je     80042130e2 <_dwarf_frame_set_fde+0x251>
			return (ret);
  80042130da:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042130dd:	e9 62 01 00 00       	jmpq   8004213244 <_dwarf_frame_set_fde+0x3b3>
		fde->fde_adrange = val;
  80042130e2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042130e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130ea:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042130ee:	eb 50                	jmp    8004213140 <_dwarf_frame_set_fde+0x2af>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042130f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130f4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042130f8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042130fc:	8b 52 28             	mov    0x28(%rdx),%edx
  80042130ff:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213103:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213107:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421310b:	48 89 cf             	mov    %rcx,%rdi
  800421310e:	ff d0                	callq  *%rax
  8004213110:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213114:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213118:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421311c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213120:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213124:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213127:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421312b:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  800421312f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213133:	48 89 cf             	mov    %rcx,%rdi
  8004213136:	ff d0                	callq  *%rax
  8004213138:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421313c:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004213140:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213144:	74 6b                	je     80042131b1 <_dwarf_frame_set_fde+0x320>
  8004213146:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421314a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421314e:	0f b6 00             	movzbl (%rax),%eax
  8004213151:	3c 7a                	cmp    $0x7a,%al
  8004213153:	75 5c                	jne    80042131b1 <_dwarf_frame_set_fde+0x320>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213155:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213159:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421315d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004213161:	48 89 d6             	mov    %rdx,%rsi
  8004213164:	48 89 c7             	mov    %rax,%rdi
  8004213167:	48 b8 5d f7 20 04 80 	movabs $0x800420f75d,%rax
  800421316e:	00 00 00 
  8004213171:	ff d0                	callq  *%rax
  8004213173:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213177:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421317b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421317f:	48 8b 10             	mov    (%rax),%rdx
  8004213182:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213186:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421318a:	48 01 d0             	add    %rdx,%rax
  800421318d:	48 89 c2             	mov    %rax,%rdx
  8004213190:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213194:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004213198:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421319c:	48 8b 10             	mov    (%rax),%rdx
  800421319f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131a3:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042131a7:	48 01 c2             	add    %rax,%rdx
  80042131aa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131ae:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042131b1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131b5:	48 8b 10             	mov    (%rax),%rdx
  80042131b8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042131bc:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042131c0:	48 01 d0             	add    %rdx,%rax
  80042131c3:	48 89 c2             	mov    %rax,%rdx
  80042131c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131ca:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  80042131ce:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042131d2:	75 2a                	jne    80042131fe <_dwarf_frame_set_fde+0x36d>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  80042131d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131d8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042131dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042131e0:	48 01 c2             	add    %rax,%rdx
  80042131e3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131e7:	48 8b 00             	mov    (%rax),%rax
  80042131ea:	48 29 c2             	sub    %rax,%rdx
  80042131ed:	48 89 d0             	mov    %rdx,%rax
  80042131f0:	48 8d 50 04          	lea    0x4(%rax),%rdx
  80042131f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131f8:	48 89 50 58          	mov    %rdx,0x58(%rax)
  80042131fc:	eb 28                	jmp    8004213226 <_dwarf_frame_set_fde+0x395>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  80042131fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213202:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213206:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421320a:	48 01 c2             	add    %rax,%rdx
  800421320d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213211:	48 8b 00             	mov    (%rax),%rax
  8004213214:	48 29 c2             	sub    %rax,%rdx
  8004213217:	48 89 d0             	mov    %rdx,%rax
  800421321a:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  800421321e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213222:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004213226:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421322a:	48 8b 10             	mov    (%rax),%rdx
  800421322d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213231:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213235:	48 01 c2             	add    %rax,%rdx
  8004213238:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421323c:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  800421323f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213244:	c9                   	leaveq 
  8004213245:	c3                   	retq   

0000008004213246 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004213246:	55                   	push   %rbp
  8004213247:	48 89 e5             	mov    %rsp,%rbp
  800421324a:	48 83 ec 20          	sub    $0x20,%rsp
  800421324e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213252:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  8004213256:	48 b8 a0 f6 6b 04 80 	movabs $0x80046bf6a0,%rax
  800421325d:	00 00 00 
  8004213260:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  8004213264:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213268:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421326c:	48 85 c0             	test   %rax,%rax
  800421326f:	74 07                	je     8004213278 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  8004213271:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213276:	eb 33                	jmp    80042132ab <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004213278:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421327c:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  8004213280:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213284:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004213288:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421328c:	48 b9 60 ff 6b 04 80 	movabs $0x80046bff60,%rcx
  8004213293:	00 00 00 
  8004213296:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  800421329a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421329e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042132a2:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  80042132a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042132ab:	c9                   	leaveq 
  80042132ac:	c3                   	retq   

00000080042132ad <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  80042132ad:	55                   	push   %rbp
  80042132ae:	48 89 e5             	mov    %rsp,%rbp
  80042132b1:	48 83 ec 60          	sub    $0x60,%rsp
  80042132b5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042132b9:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  80042132bc:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042132c0:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  80042132c4:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042132cb:	00 00 00 
  80042132ce:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  80042132d2:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  80042132d9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132dd:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042132e1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  80042132e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132e9:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042132ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042132f1:	48 39 c2             	cmp    %rax,%rdx
  80042132f4:	0f 86 fe 01 00 00    	jbe    80042134f8 <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  80042132fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042132fe:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004213302:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213306:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421330a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421330e:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213312:	48 89 d1             	mov    %rdx,%rcx
  8004213315:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004213319:	ba 04 00 00 00       	mov    $0x4,%edx
  800421331e:	48 89 cf             	mov    %rcx,%rdi
  8004213321:	ff d0                	callq  *%rax
  8004213323:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004213327:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421332c:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213330:	75 2e                	jne    8004213360 <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  8004213332:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004213339:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421333d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213341:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213345:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213349:	48 89 d1             	mov    %rdx,%rcx
  800421334c:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004213350:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213355:	48 89 cf             	mov    %rcx,%rdi
  8004213358:	ff d0                	callq  *%rax
  800421335a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421335e:	eb 07                	jmp    8004213367 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  8004213360:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004213367:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421336b:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421336f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213373:	48 29 c2             	sub    %rax,%rdx
  8004213376:	48 89 d0             	mov    %rdx,%rax
  8004213379:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421337d:	72 0d                	jb     800421338c <_dwarf_get_next_fde+0xdf>
  800421337f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213384:	75 10                	jne    8004213396 <_dwarf_get_next_fde+0xe9>
  8004213386:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421338a:	75 0a                	jne    8004213396 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800421338c:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213391:	e9 67 01 00 00       	jmpq   80042134fd <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004213396:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421339a:	74 11                	je     80042133ad <_dwarf_get_next_fde+0x100>
  800421339c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042133a1:	75 0a                	jne    80042133ad <_dwarf_get_next_fde+0x100>
			return(-1);
  80042133a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042133a8:	e9 50 01 00 00       	jmpq   80042134fd <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  80042133ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042133b1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042133b5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042133b9:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042133bd:	48 89 d1             	mov    %rdx,%rcx
  80042133c0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042133c3:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042133c7:	48 89 cf             	mov    %rcx,%rdi
  80042133ca:	ff d0                	callq  *%rax
  80042133cc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  80042133d0:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042133d4:	74 79                	je     800421344f <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  80042133d6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042133db:	75 32                	jne    800421340f <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042133dd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133e1:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042133e5:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042133e9:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042133ed:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042133f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042133f5:	49 89 f8             	mov    %rdi,%r8
  80042133f8:	48 89 c7             	mov    %rax,%rdi
  80042133fb:	48 b8 2e 2a 21 04 80 	movabs $0x8004212a2e,%rax
  8004213402:	00 00 00 
  8004213405:	ff d0                	callq  *%rax
  8004213407:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421340a:	e9 c8 00 00 00       	jmpq   80042134d7 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  800421340f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213413:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004213417:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800421341b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421341f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213423:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213427:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421342b:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421342f:	4d 89 c1             	mov    %r8,%r9
  8004213432:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004213438:	48 89 c7             	mov    %rax,%rdi
  800421343b:	48 b8 91 2e 21 04 80 	movabs $0x8004212e91,%rax
  8004213442:	00 00 00 
  8004213445:	ff d0                	callq  *%rax
  8004213447:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421344a:	e9 88 00 00 00       	jmpq   80042134d7 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  800421344f:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213453:	75 0b                	jne    8004213460 <_dwarf_get_next_fde+0x1b3>
  8004213455:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421345a:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421345e:	74 0d                	je     800421346d <_dwarf_get_next_fde+0x1c0>
  8004213460:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004213464:	75 36                	jne    800421349c <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004213466:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  800421346b:	75 2f                	jne    800421349c <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  800421346d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213471:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004213475:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004213479:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421347d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004213481:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213485:	49 89 f8             	mov    %rdi,%r8
  8004213488:	48 89 c7             	mov    %rax,%rdi
  800421348b:	48 b8 2e 2a 21 04 80 	movabs $0x8004212a2e,%rax
  8004213492:	00 00 00 
  8004213495:	ff d0                	callq  *%rax
  8004213497:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421349a:	eb 3b                	jmp    80042134d7 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  800421349c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042134a0:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042134a4:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042134a8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042134ac:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042134b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042134b4:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042134b8:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042134bc:	4d 89 c1             	mov    %r8,%r9
  80042134bf:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042134c5:	48 89 c7             	mov    %rax,%rdi
  80042134c8:	48 b8 91 2e 21 04 80 	movabs $0x8004212e91,%rax
  80042134cf:	00 00 00 
  80042134d2:	ff d0                	callq  *%rax
  80042134d4:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  80042134d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80042134db:	74 07                	je     80042134e4 <_dwarf_get_next_fde+0x237>
			return(-1);
  80042134dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042134e2:	eb 19                	jmp    80042134fd <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  80042134e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042134e8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  80042134ec:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042134f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042134f4:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  80042134f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042134fd:	c9                   	leaveq 
  80042134fe:	c3                   	retq   

00000080042134ff <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  80042134ff:	55                   	push   %rbp
  8004213500:	48 89 e5             	mov    %rsp,%rbp
  8004213503:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004213507:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421350b:	89 f0                	mov    %esi,%eax
  800421350d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  8004213511:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213515:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213519:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  800421351d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213521:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004213525:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  8004213529:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  800421352d:	c9                   	leaveq 
  800421352e:	c3                   	retq   

000000800421352f <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  800421352f:	55                   	push   %rbp
  8004213530:	48 89 e5             	mov    %rsp,%rbp
  8004213533:	48 83 ec 10          	sub    $0x10,%rsp
  8004213537:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421353b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  800421353f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213544:	75 0a                	jne    8004213550 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004213546:	b8 01 00 00 00       	mov    $0x1,%eax
  800421354b:	e9 85 00 00 00       	jmpq   80042135d5 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  8004213550:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213554:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213558:	48 85 c0             	test   %rax,%rax
  800421355b:	75 25                	jne    8004213582 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  800421355d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213561:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213565:	48 89 d6             	mov    %rdx,%rsi
  8004213568:	48 89 c7             	mov    %rax,%rdi
  800421356b:	48 b8 46 32 21 04 80 	movabs $0x8004213246,%rax
  8004213572:	00 00 00 
  8004213575:	ff d0                	callq  *%rax
  8004213577:	85 c0                	test   %eax,%eax
  8004213579:	74 07                	je     8004213582 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  800421357b:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213580:	eb 53                	jmp    80042135d5 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  8004213582:	48 bf a0 b6 22 04 80 	movabs $0x800422b6a0,%rdi
  8004213589:	00 00 00 
  800421358c:	48 b8 fb 0f 21 04 80 	movabs $0x8004210ffb,%rax
  8004213593:	00 00 00 
  8004213596:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  8004213598:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421359c:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042135a3:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  80042135a4:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042135ab:	00 00 00 
  80042135ae:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042135b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042135b6:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  80042135ba:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042135c1:	00 00 00 
  80042135c4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042135c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042135cc:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  80042135d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042135d5:	c9                   	leaveq 
  80042135d6:	c3                   	retq   

00000080042135d7 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042135d7:	55                   	push   %rbp
  80042135d8:	48 89 e5             	mov    %rsp,%rbp
  80042135db:	53                   	push   %rbx
  80042135dc:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  80042135e3:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  80042135e7:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  80042135eb:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  80042135f2:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  80042135f9:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  8004213600:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004213607:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421360b:	48 83 c0 48          	add    $0x48,%rax
  800421360f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004213613:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421361a:	00 
  800421361b:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004213622:	00 
  8004213623:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  800421362a:	00 
  800421362b:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004213632:	00 
  8004213633:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213637:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421363b:	0f b6 c0             	movzbl %al,%eax
  800421363e:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004213641:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004213648:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  800421364f:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004213656:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  800421365d:	e9 0a 05 00 00       	jmpq   8004213b6c <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  8004213662:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213669:	0f b6 00             	movzbl (%rax),%eax
  800421366c:	84 c0                	test   %al,%al
  800421366e:	0f 85 78 01 00 00    	jne    80042137ec <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  8004213674:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421367b:	48 83 c0 01          	add    $0x1,%rax
  800421367f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004213686:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421368d:	48 89 c7             	mov    %rax,%rdi
  8004213690:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004213697:	00 00 00 
  800421369a:	ff d0                	callq  *%rax
  800421369c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  80042136a0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042136a7:	0f b6 00             	movzbl (%rax),%eax
  80042136aa:	0f b6 c0             	movzbl %al,%eax
  80042136ad:	83 f8 02             	cmp    $0x2,%eax
  80042136b0:	74 7a                	je     800421372c <_dwarf_lineno_run_program+0x155>
  80042136b2:	83 f8 03             	cmp    $0x3,%eax
  80042136b5:	0f 84 b3 00 00 00    	je     800421376e <_dwarf_lineno_run_program+0x197>
  80042136bb:	83 f8 01             	cmp    $0x1,%eax
  80042136be:	0f 85 09 01 00 00    	jne    80042137cd <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  80042136c4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042136cb:	48 83 c0 01          	add    $0x1,%rax
  80042136cf:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  80042136d6:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  80042136dd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042136e4:	00 
  80042136e5:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  80042136ec:	00 
  80042136ed:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  80042136f4:	00 
  80042136f5:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042136fc:	00 
  80042136fd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213701:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004213705:	0f b6 c0             	movzbl %al,%eax
  8004213708:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421370b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004213712:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004213719:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004213720:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004213727:	e9 bb 00 00 00       	jmpq   80042137e7 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  800421372c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213733:	48 83 c0 01          	add    $0x1,%rax
  8004213737:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  800421373e:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213745:	00 00 00 
  8004213748:	48 8b 00             	mov    (%rax),%rax
  800421374b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421374f:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004213753:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004213757:	0f b6 ca             	movzbl %dl,%ecx
  800421375a:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004213761:	89 ce                	mov    %ecx,%esi
  8004213763:	48 89 d7             	mov    %rdx,%rdi
  8004213766:	ff d0                	callq  *%rax
  8004213768:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  800421376c:	eb 79                	jmp    80042137e7 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  800421376e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213775:	48 83 c0 01          	add    $0x1,%rax
  8004213779:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004213780:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213787:	00 00 00 
  800421378a:	48 8b 08             	mov    (%rax),%rcx
  800421378d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004213794:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  800421379b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421379f:	49 89 c8             	mov    %rcx,%r8
  80042137a2:	48 89 d1             	mov    %rdx,%rcx
  80042137a5:	ba 00 00 00 00       	mov    $0x0,%edx
  80042137aa:	48 89 c7             	mov    %rax,%rdi
  80042137ad:	48 b8 8f 3b 21 04 80 	movabs $0x8004213b8f,%rax
  80042137b4:	00 00 00 
  80042137b7:	ff d0                	callq  *%rax
  80042137b9:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  80042137bc:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  80042137c0:	74 09                	je     80042137cb <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  80042137c2:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  80042137c3:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042137c6:	e9 ba 03 00 00       	jmpq   8004213b85 <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  80042137cb:	eb 1a                	jmp    80042137e7 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  80042137cd:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042137d4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042137d8:	48 01 d0             	add    %rdx,%rax
  80042137db:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042137e2:	e9 85 03 00 00       	jmpq   8004213b6c <_dwarf_lineno_run_program+0x595>
  80042137e7:	e9 80 03 00 00       	jmpq   8004213b6c <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  80042137ec:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042137f3:	0f b6 00             	movzbl (%rax),%eax
  80042137f6:	84 c0                	test   %al,%al
  80042137f8:	0f 84 3c 02 00 00    	je     8004213a3a <_dwarf_lineno_run_program+0x463>
  80042137fe:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213805:	0f b6 10             	movzbl (%rax),%edx
  8004213808:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421380c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213810:	38 c2                	cmp    %al,%dl
  8004213812:	0f 83 22 02 00 00    	jae    8004213a3a <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004213818:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421381f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213823:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  800421382a:	0f b6 00             	movzbl (%rax),%eax
  800421382d:	0f b6 c0             	movzbl %al,%eax
  8004213830:	83 f8 0c             	cmp    $0xc,%eax
  8004213833:	0f 87 fb 01 00 00    	ja     8004213a34 <_dwarf_lineno_run_program+0x45d>
  8004213839:	89 c0                	mov    %eax,%eax
  800421383b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004213842:	00 
  8004213843:	48 b8 68 87 21 04 80 	movabs $0x8004218768,%rax
  800421384a:	00 00 00 
  800421384d:	48 01 d0             	add    %rdx,%rax
  8004213850:	48 8b 00             	mov    (%rax),%rax
  8004213853:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004213855:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421385c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213860:	73 0a                	jae    800421386c <_dwarf_lineno_run_program+0x295>
  8004213862:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213867:	e9 19 03 00 00       	jmpq   8004213b85 <_dwarf_lineno_run_program+0x5ae>
  800421386c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213870:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213874:	48 89 10             	mov    %rdx,(%rax)
  8004213877:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421387b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213882:	00 
  8004213883:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213887:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421388b:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421388f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213893:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213897:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421389b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421389f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042138a3:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042138a7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042138ab:	8b 55 c8             	mov    -0x38(%rbp),%edx
  80042138ae:	89 50 28             	mov    %edx,0x28(%rax)
  80042138b1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042138b5:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042138b8:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042138bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042138bf:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042138c2:	89 50 30             	mov    %edx,0x30(%rax)
  80042138c5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042138c9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042138d0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042138d4:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042138d8:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  80042138df:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  80042138e6:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  80042138ed:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  80042138f4:	e9 3c 01 00 00       	jmpq   8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  80042138f9:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213900:	48 89 c7             	mov    %rax,%rdi
  8004213903:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  800421390a:	00 00 00 
  800421390d:	ff d0                	callq  *%rax
					li->li_minlen;
  800421390f:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004213913:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004213917:	0f b6 d2             	movzbl %dl,%edx
  800421391a:	48 0f af c2          	imul   %rdx,%rax
  800421391e:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  8004213922:	e9 0e 01 00 00       	jmpq   8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004213927:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421392e:	48 89 c7             	mov    %rax,%rdi
  8004213931:	48 b8 dc f7 20 04 80 	movabs $0x800420f7dc,%rax
  8004213938:	00 00 00 
  800421393b:	ff d0                	callq  *%rax
  800421393d:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  8004213941:	e9 ef 00 00 00       	jmpq   8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004213946:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421394d:	48 89 c7             	mov    %rax,%rdi
  8004213950:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004213957:	00 00 00 
  800421395a:	ff d0                	callq  *%rax
  800421395c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  8004213960:	e9 d0 00 00 00       	jmpq   8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  8004213965:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421396c:	48 89 c7             	mov    %rax,%rdi
  800421396f:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004213976:	00 00 00 
  8004213979:	ff d0                	callq  *%rax
  800421397b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  800421397f:	e9 b1 00 00 00       	jmpq   8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  8004213984:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004213988:	0f 94 c0             	sete   %al
  800421398b:	0f b6 c0             	movzbl %al,%eax
  800421398e:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  8004213991:	e9 9f 00 00 00       	jmpq   8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  8004213996:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  800421399d:	e9 93 00 00 00       	jmpq   8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  80042139a2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042139a6:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042139aa:	0f b6 c0             	movzbl %al,%eax
  80042139ad:	ba ff 00 00 00       	mov    $0xff,%edx
  80042139b2:	89 d1                	mov    %edx,%ecx
  80042139b4:	29 c1                	sub    %eax,%ecx
  80042139b6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042139ba:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042139be:	0f b6 d8             	movzbl %al,%ebx
  80042139c1:	89 c8                	mov    %ecx,%eax
  80042139c3:	99                   	cltd   
  80042139c4:	f7 fb                	idiv   %ebx
  80042139c6:	89 c2                	mov    %eax,%edx
  80042139c8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042139cc:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042139d0:	0f b6 c0             	movzbl %al,%eax
  80042139d3:	0f af c2             	imul   %edx,%eax
  80042139d6:	48 98                	cltq   
  80042139d8:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  80042139dc:	eb 57                	jmp    8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  80042139de:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  80042139e5:	00 00 00 
  80042139e8:	48 8b 00             	mov    (%rax),%rax
  80042139eb:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042139ef:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  80042139f6:	be 02 00 00 00       	mov    $0x2,%esi
  80042139fb:	48 89 d7             	mov    %rdx,%rdi
  80042139fe:	ff d0                	callq  *%rax
  8004213a00:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004213a04:	eb 2f                	jmp    8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004213a06:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  8004213a0d:	eb 26                	jmp    8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004213a0f:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  8004213a16:	eb 1d                	jmp    8004213a35 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004213a18:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213a1f:	48 89 c7             	mov    %rax,%rdi
  8004213a22:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004213a29:	00 00 00 
  8004213a2c:	ff d0                	callq  *%rax
  8004213a2e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  8004213a32:	eb 01                	jmp    8004213a35 <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  8004213a34:	90                   	nop
			}

		} else {
  8004213a35:	e9 32 01 00 00       	jmpq   8004213b6c <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  8004213a3a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213a3e:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  8004213a42:	0f be c8             	movsbl %al,%ecx
  8004213a45:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213a4c:	0f b6 00             	movzbl (%rax),%eax
  8004213a4f:	0f b6 d0             	movzbl %al,%edx
  8004213a52:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213a56:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213a5a:	0f b6 c0             	movzbl %al,%eax
  8004213a5d:	29 c2                	sub    %eax,%edx
  8004213a5f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213a63:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213a67:	0f b6 f0             	movzbl %al,%esi
  8004213a6a:	89 d0                	mov    %edx,%eax
  8004213a6c:	99                   	cltd   
  8004213a6d:	f7 fe                	idiv   %esi
  8004213a6f:	89 d0                	mov    %edx,%eax
  8004213a71:	01 c8                	add    %ecx,%eax
  8004213a73:	48 98                	cltq   
  8004213a75:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  8004213a79:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213a80:	0f b6 00             	movzbl (%rax),%eax
  8004213a83:	0f b6 d0             	movzbl %al,%edx
  8004213a86:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213a8a:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213a8e:	0f b6 c0             	movzbl %al,%eax
  8004213a91:	89 d1                	mov    %edx,%ecx
  8004213a93:	29 c1                	sub    %eax,%ecx
  8004213a95:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213a99:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213a9d:	0f b6 d8             	movzbl %al,%ebx
  8004213aa0:	89 c8                	mov    %ecx,%eax
  8004213aa2:	99                   	cltd   
  8004213aa3:	f7 fb                	idiv   %ebx
  8004213aa5:	89 c2                	mov    %eax,%edx
  8004213aa7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213aab:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213aaf:	0f b6 c0             	movzbl %al,%eax
  8004213ab2:	0f af c2             	imul   %edx,%eax
  8004213ab5:	48 98                	cltq   
  8004213ab7:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  8004213abb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213ac2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213ac6:	73 0a                	jae    8004213ad2 <_dwarf_lineno_run_program+0x4fb>
  8004213ac8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213acd:	e9 b3 00 00 00       	jmpq   8004213b85 <_dwarf_lineno_run_program+0x5ae>
  8004213ad2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ad6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213ada:	48 89 10             	mov    %rdx,(%rax)
  8004213add:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ae1:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213ae8:	00 
  8004213ae9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213aed:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213af1:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213af5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213af9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213afd:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213b01:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b05:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b09:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213b0d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b11:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004213b14:	89 50 28             	mov    %edx,0x28(%rax)
  8004213b17:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b1b:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004213b1e:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004213b21:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b25:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004213b28:	89 50 30             	mov    %edx,0x30(%rax)
  8004213b2b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213b2f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213b36:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213b3a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213b3e:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004213b45:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  8004213b4c:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  8004213b53:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  8004213b5a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213b61:	48 83 c0 01          	add    $0x1,%rax
  8004213b65:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004213b6c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213b73:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  8004213b7a:	0f 82 e2 fa ff ff    	jb     8004213662 <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004213b80:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  8004213b85:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004213b8c:	5b                   	pop    %rbx
  8004213b8d:	5d                   	pop    %rbp
  8004213b8e:	c3                   	retq   

0000008004213b8f <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004213b8f:	55                   	push   %rbp
  8004213b90:	48 89 e5             	mov    %rsp,%rbp
  8004213b93:	53                   	push   %rbx
  8004213b94:	48 83 ec 48          	sub    $0x48,%rsp
  8004213b98:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004213b9c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004213ba0:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004213ba4:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213ba8:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004213bac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213bb0:	48 8b 00             	mov    (%rax),%rax
  8004213bb3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004213bb7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213bbb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004213bbf:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004213bc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bc7:	48 89 c7             	mov    %rax,%rdi
  8004213bca:	48 b8 46 e9 20 04 80 	movabs $0x800420e946,%rax
  8004213bd1:	00 00 00 
  8004213bd4:	ff d0                	callq  *%rax
  8004213bd6:	48 98                	cltq   
  8004213bd8:	48 83 c0 01          	add    $0x1,%rax
  8004213bdc:	48 01 d8             	add    %rbx,%rax
  8004213bdf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004213be3:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213be7:	48 89 c7             	mov    %rax,%rdi
  8004213bea:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004213bf1:	00 00 00 
  8004213bf4:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004213bf6:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213bfa:	48 89 c7             	mov    %rax,%rdi
  8004213bfd:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004213c04:	00 00 00 
  8004213c07:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004213c09:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213c0d:	48 89 c7             	mov    %rax,%rdi
  8004213c10:	48 b8 6e f8 20 04 80 	movabs $0x800420f86e,%rax
  8004213c17:	00 00 00 
  8004213c1a:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004213c1c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213c20:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213c24:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004213c27:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213c2c:	48 83 c4 48          	add    $0x48,%rsp
  8004213c30:	5b                   	pop    %rbx
  8004213c31:	5d                   	pop    %rbp
  8004213c32:	c3                   	retq   

0000008004213c33 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004213c33:	55                   	push   %rbp
  8004213c34:	48 89 e5             	mov    %rsp,%rbp
  8004213c37:	53                   	push   %rbx
  8004213c38:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004213c3f:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004213c46:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004213c4d:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004213c54:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004213c5b:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004213c62:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004213c69:	00 
  8004213c6a:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004213c71:	00 
  8004213c72:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004213c79:	00 
  8004213c7a:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004213c81:	00 
  8004213c82:	48 b8 d0 87 21 04 80 	movabs $0x80042187d0,%rax
  8004213c89:	00 00 00 
  8004213c8c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004213c90:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004213c94:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004213c98:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004213c9f:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004213ca6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004213caa:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004213caf:	75 35                	jne    8004213ce6 <_dwarf_lineno_init+0xb3>
  8004213cb1:	48 b9 dc 87 21 04 80 	movabs $0x80042187dc,%rcx
  8004213cb8:	00 00 00 
  8004213cbb:	48 ba e7 87 21 04 80 	movabs $0x80042187e7,%rdx
  8004213cc2:	00 00 00 
  8004213cc5:	be 13 01 00 00       	mov    $0x113,%esi
  8004213cca:	48 bf fc 87 21 04 80 	movabs $0x80042187fc,%rdi
  8004213cd1:	00 00 00 
  8004213cd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213cd9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213ce0:	00 00 00 
  8004213ce3:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004213ce6:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213ced:	00 00 00 
  8004213cf0:	48 8b 00             	mov    (%rax),%rax
  8004213cf3:	48 85 c0             	test   %rax,%rax
  8004213cf6:	75 35                	jne    8004213d2d <_dwarf_lineno_init+0xfa>
  8004213cf8:	48 b9 13 88 21 04 80 	movabs $0x8004218813,%rcx
  8004213cff:	00 00 00 
  8004213d02:	48 ba e7 87 21 04 80 	movabs $0x80042187e7,%rdx
  8004213d09:	00 00 00 
  8004213d0c:	be 14 01 00 00       	mov    $0x114,%esi
  8004213d11:	48 bf fc 87 21 04 80 	movabs $0x80042187fc,%rdi
  8004213d18:	00 00 00 
  8004213d1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213d20:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213d27:	00 00 00 
  8004213d2a:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004213d2d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d31:	48 89 c7             	mov    %rax,%rdi
  8004213d34:	48 b8 fb 0f 21 04 80 	movabs $0x8004210ffb,%rax
  8004213d3b:	00 00 00 
  8004213d3e:	ff d0                	callq  *%rax
  8004213d40:	85 c0                	test   %eax,%eax
  8004213d42:	74 0a                	je     8004213d4e <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004213d44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213d49:	e9 4f 04 00 00       	jmpq   800421419d <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004213d4e:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004213d55:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004213d59:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213d60:	00 00 00 
  8004213d63:	48 8b 00             	mov    (%rax),%rax
  8004213d66:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d6a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213d6e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213d72:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213d79:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213d7e:	48 89 cf             	mov    %rcx,%rdi
  8004213d81:	ff d0                	callq  *%rax
  8004213d83:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004213d87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213d8c:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004213d90:	75 37                	jne    8004213dc9 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004213d92:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004213d99:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213da0:	00 00 00 
  8004213da3:	48 8b 00             	mov    (%rax),%rax
  8004213da6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213daa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213dae:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213db2:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213db9:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213dbe:	48 89 cf             	mov    %rcx,%rdi
  8004213dc1:	ff d0                	callq  *%rax
  8004213dc3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004213dc7:	eb 07                	jmp    8004213dd0 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004213dc9:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004213dd0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213dd4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213dd8:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213ddf:	48 29 c2             	sub    %rax,%rdx
  8004213de2:	48 89 d0             	mov    %rdx,%rax
  8004213de5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213de9:	73 0a                	jae    8004213df5 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004213deb:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004213df0:	e9 a8 03 00 00       	jmpq   800421419d <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004213df5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213df9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213dfd:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004213e00:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004213e07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e0b:	48 01 d0             	add    %rdx,%rax
  8004213e0e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004213e12:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213e19:	00 00 00 
  8004213e1c:	48 8b 00             	mov    (%rax),%rax
  8004213e1f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e23:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e27:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213e2b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213e32:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213e37:	48 89 cf             	mov    %rcx,%rdi
  8004213e3a:	ff d0                	callq  *%rax
  8004213e3c:	89 c2                	mov    %eax,%edx
  8004213e3e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213e42:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004213e46:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213e4d:	00 00 00 
  8004213e50:	48 8b 00             	mov    (%rax),%rax
  8004213e53:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e57:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e5b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213e5f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004213e62:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213e69:	48 89 cf             	mov    %rcx,%rdi
  8004213e6c:	ff d0                	callq  *%rax
  8004213e6e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213e72:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004213e76:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213e7d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004213e81:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213e88:	00 00 00 
  8004213e8b:	48 8b 00             	mov    (%rax),%rax
  8004213e8e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e92:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e96:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213e9a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213ea1:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213ea6:	48 89 cf             	mov    %rcx,%rdi
  8004213ea9:	ff d0                	callq  *%rax
  8004213eab:	89 c2                	mov    %eax,%edx
  8004213ead:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213eb1:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004213eb4:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213ebb:	00 00 00 
  8004213ebe:	48 8b 00             	mov    (%rax),%rax
  8004213ec1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ec5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ec9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213ecd:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213ed4:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213ed9:	48 89 cf             	mov    %rcx,%rdi
  8004213edc:	ff d0                	callq  *%rax
  8004213ede:	89 c2                	mov    %eax,%edx
  8004213ee0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213ee4:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004213ee7:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213eee:	00 00 00 
  8004213ef1:	48 8b 00             	mov    (%rax),%rax
  8004213ef4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ef8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213efc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f00:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213f07:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213f0c:	48 89 cf             	mov    %rcx,%rdi
  8004213f0f:	ff d0                	callq  *%rax
  8004213f11:	89 c2                	mov    %eax,%edx
  8004213f13:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f17:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004213f1a:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213f21:	00 00 00 
  8004213f24:	48 8b 00             	mov    (%rax),%rax
  8004213f27:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f2b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f2f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f33:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213f3a:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213f3f:	48 89 cf             	mov    %rcx,%rdi
  8004213f42:	ff d0                	callq  *%rax
  8004213f44:	89 c2                	mov    %eax,%edx
  8004213f46:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f4a:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004213f4d:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213f54:	00 00 00 
  8004213f57:	48 8b 00             	mov    (%rax),%rax
  8004213f5a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f5e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f62:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f66:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213f6d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213f72:	48 89 cf             	mov    %rcx,%rdi
  8004213f75:	ff d0                	callq  *%rax
  8004213f77:	89 c2                	mov    %eax,%edx
  8004213f79:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f7d:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004213f80:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f84:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004213f88:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004213f8b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f8f:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213f93:	0f b6 c0             	movzbl %al,%eax
  8004213f96:	83 e8 01             	sub    $0x1,%eax
  8004213f99:	39 c2                	cmp    %eax,%edx
  8004213f9b:	7d 0c                	jge    8004213fa9 <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213f9d:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004213fa4:	e9 f1 01 00 00       	jmpq   800421419a <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  8004213fa9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213fad:	48 bb a0 05 6c 04 80 	movabs $0x80046c05a0,%rbx
  8004213fb4:	00 00 00 
  8004213fb7:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004213fbb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004213fc2:	eb 41                	jmp    8004214005 <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004213fc4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213fc8:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213fcc:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004213fcf:	48 98                	cltq   
  8004213fd1:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004213fd5:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  8004213fdc:	00 00 00 
  8004213fdf:	48 8b 00             	mov    (%rax),%rax
  8004213fe2:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213fe6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213fea:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213fee:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213ff5:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213ffa:	48 89 cf             	mov    %rcx,%rdi
  8004213ffd:	ff d0                	callq  *%rax
  8004213fff:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214001:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004214005:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214009:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421400d:	0f b6 c0             	movzbl %al,%eax
  8004214010:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004214013:	7f af                	jg     8004213fc4 <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004214015:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421401c:	00 
	p = ds->ds_data + offset;
  800421401d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214021:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214025:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800421402c:	48 01 d0             	add    %rdx,%rax
  800421402f:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  8004214036:	eb 1f                	jmp    8004214057 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  8004214038:	90                   	nop
  8004214039:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214040:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214044:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  800421404b:	0f b6 00             	movzbl (%rax),%eax
  800421404e:	84 c0                	test   %al,%al
  8004214050:	75 e7                	jne    8004214039 <_dwarf_lineno_init+0x406>
			;
		length++;
  8004214052:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004214057:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421405e:	0f b6 00             	movzbl (%rax),%eax
  8004214061:	84 c0                	test   %al,%al
  8004214063:	75 d3                	jne    8004214038 <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004214065:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214069:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421406d:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004214071:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214078:	48 89 c2             	mov    %rax,%rdx
  800421407b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421407f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214083:	48 29 c2             	sub    %rax,%rdx
  8004214086:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421408a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421408e:	48 98                	cltq   
  8004214090:	48 39 c2             	cmp    %rax,%rdx
  8004214093:	7e 0c                	jle    80042140a1 <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214095:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  800421409c:	e9 f9 00 00 00       	jmpq   800421419a <_dwarf_lineno_init+0x567>
	}
	p++;
  80042140a1:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042140a8:	48 83 c0 01          	add    $0x1,%rax
  80042140ac:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  80042140b3:	eb 3c                	jmp    80042140f1 <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  80042140b5:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  80042140bc:	00 00 00 
  80042140bf:	48 8b 08             	mov    (%rax),%rcx
  80042140c2:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  80042140c9:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  80042140d0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140d4:	49 89 c8             	mov    %rcx,%r8
  80042140d7:	48 89 d1             	mov    %rdx,%rcx
  80042140da:	ba 00 00 00 00       	mov    $0x0,%edx
  80042140df:	48 89 c7             	mov    %rax,%rdi
  80042140e2:	48 b8 8f 3b 21 04 80 	movabs $0x8004213b8f,%rax
  80042140e9:	00 00 00 
  80042140ec:	ff d0                	callq  *%rax
  80042140ee:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  80042140f1:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042140f8:	0f b6 00             	movzbl (%rax),%eax
  80042140fb:	84 c0                	test   %al,%al
  80042140fd:	75 b6                	jne    80042140b5 <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  80042140ff:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214106:	48 83 c0 01          	add    $0x1,%rax
  800421410a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004214111:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214118:	48 89 c2             	mov    %rax,%rdx
  800421411b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421411f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214123:	48 29 c2             	sub    %rax,%rdx
  8004214126:	48 89 d0             	mov    %rdx,%rax
  8004214129:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  800421412d:	48 89 c2             	mov    %rax,%rdx
  8004214130:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214134:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214138:	48 39 c2             	cmp    %rax,%rdx
  800421413b:	74 09                	je     8004214146 <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  800421413d:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214144:	eb 54                	jmp    800421419a <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004214146:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421414a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421414e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214152:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004214156:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800421415d:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004214164:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  800421416b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800421416f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214173:	4d 89 c1             	mov    %r8,%r9
  8004214176:	49 89 f8             	mov    %rdi,%r8
  8004214179:	48 89 c7             	mov    %rax,%rdi
  800421417c:	48 b8 d7 35 21 04 80 	movabs $0x80042135d7,%rax
  8004214183:	00 00 00 
  8004214186:	ff d0                	callq  *%rax
  8004214188:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  800421418b:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421418f:	74 02                	je     8004214193 <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  8004214191:	eb 07                	jmp    800421419a <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  8004214193:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214198:	eb 03                	jmp    800421419d <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  800421419a:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  800421419d:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  80042141a4:	5b                   	pop    %rbx
  80042141a5:	5d                   	pop    %rbp
  80042141a6:	c3                   	retq   

00000080042141a7 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042141a7:	55                   	push   %rbp
  80042141a8:	48 89 e5             	mov    %rsp,%rbp
  80042141ab:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80042141b2:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  80042141b9:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  80042141c0:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  80042141c7:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  80042141ce:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  80042141d5:	00 
  80042141d6:	75 35                	jne    800421420d <dwarf_srclines+0x66>
  80042141d8:	48 b9 1f 88 21 04 80 	movabs $0x800421881f,%rcx
  80042141df:	00 00 00 
  80042141e2:	48 ba e7 87 21 04 80 	movabs $0x80042187e7,%rdx
  80042141e9:	00 00 00 
  80042141ec:	be 9a 01 00 00       	mov    $0x19a,%esi
  80042141f1:	48 bf fc 87 21 04 80 	movabs $0x80042187fc,%rdi
  80042141f8:	00 00 00 
  80042141fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214200:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214207:	00 00 00 
  800421420a:	41 ff d0             	callq  *%r8
	assert(linebuf);
  800421420d:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004214214:	00 
  8004214215:	75 35                	jne    800421424c <dwarf_srclines+0xa5>
  8004214217:	48 b9 23 88 21 04 80 	movabs $0x8004218823,%rcx
  800421421e:	00 00 00 
  8004214221:	48 ba e7 87 21 04 80 	movabs $0x80042187e7,%rdx
  8004214228:	00 00 00 
  800421422b:	be 9b 01 00 00       	mov    $0x19b,%esi
  8004214230:	48 bf fc 87 21 04 80 	movabs $0x80042187fc,%rdi
  8004214237:	00 00 00 
  800421423a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421423f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214246:	00 00 00 
  8004214249:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  800421424c:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004214253:	ba 88 00 00 00       	mov    $0x88,%edx
  8004214258:	be 00 00 00 00       	mov    $0x0,%esi
  800421425d:	48 89 c7             	mov    %rax,%rdi
  8004214260:	48 b8 4b ec 20 04 80 	movabs $0x800420ec4b,%rax
  8004214267:	00 00 00 
  800421426a:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  800421426c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214273:	be 10 00 00 00       	mov    $0x10,%esi
  8004214278:	48 89 c7             	mov    %rax,%rdi
  800421427b:	48 b8 80 0b 21 04 80 	movabs $0x8004210b80,%rax
  8004214282:	00 00 00 
  8004214285:	ff d0                	callq  *%rax
  8004214287:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421428b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214290:	75 0a                	jne    800421429c <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004214292:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214297:	e9 84 00 00 00       	jmpq   8004214320 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  800421429c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042142a0:	48 8b 70 28          	mov    0x28(%rax),%rsi
  80042142a4:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  80042142ab:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  80042142b2:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  80042142b9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042142c0:	49 89 f8             	mov    %rdi,%r8
  80042142c3:	48 89 c7             	mov    %rax,%rdi
  80042142c6:	48 b8 33 3c 21 04 80 	movabs $0x8004213c33,%rax
  80042142cd:	00 00 00 
  80042142d0:	ff d0                	callq  *%rax
  80042142d2:	85 c0                	test   %eax,%eax
  80042142d4:	74 07                	je     80042142dd <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  80042142d6:	b8 01 00 00 00       	mov    $0x1,%eax
  80042142db:	eb 43                	jmp    8004214320 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  80042142dd:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042142e4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042142e8:	48 89 10             	mov    %rdx,(%rax)
  80042142eb:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042142ef:	48 89 50 08          	mov    %rdx,0x8(%rax)
  80042142f3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042142f7:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042142fb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042142ff:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214303:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214307:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421430b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421430f:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004214313:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214317:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  800421431b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214320:	c9                   	leaveq 
  8004214321:	c3                   	retq   

0000008004214322 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004214322:	55                   	push   %rbp
  8004214323:	48 89 e5             	mov    %rsp,%rbp
  8004214326:	48 83 ec 20          	sub    $0x20,%rsp
  800421432a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  800421432e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004214335:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004214336:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421433d:	eb 57                	jmp    8004214396 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  800421433f:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214346:	00 00 00 
  8004214349:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421434c:	48 63 d2             	movslq %edx,%rdx
  800421434f:	48 c1 e2 05          	shl    $0x5,%rdx
  8004214353:	48 01 d0             	add    %rdx,%rax
  8004214356:	48 8b 00             	mov    (%rax),%rax
  8004214359:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421435d:	48 89 d6             	mov    %rdx,%rsi
  8004214360:	48 89 c7             	mov    %rax,%rdi
  8004214363:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  800421436a:	00 00 00 
  800421436d:	ff d0                	callq  *%rax
  800421436f:	85 c0                	test   %eax,%eax
  8004214371:	75 1f                	jne    8004214392 <_dwarf_find_section+0x70>
			ret = (section_info + i);
  8004214373:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214376:	48 98                	cltq   
  8004214378:	48 c1 e0 05          	shl    $0x5,%rax
  800421437c:	48 89 c2             	mov    %rax,%rdx
  800421437f:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214386:	00 00 00 
  8004214389:	48 01 d0             	add    %rdx,%rax
  800421438c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004214390:	eb 0a                	jmp    800421439c <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004214392:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214396:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421439a:	7e a3                	jle    800421433f <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  800421439c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042143a0:	c9                   	leaveq 
  80042143a1:	c3                   	retq   

00000080042143a2 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  80042143a2:	55                   	push   %rbp
  80042143a3:	48 89 e5             	mov    %rsp,%rbp
  80042143a6:	48 83 ec 40          	sub    $0x40,%rsp
  80042143aa:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  80042143ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042143b2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  80042143b6:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  80042143bd:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  80042143be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143c2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042143c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143ca:	48 01 d0             	add    %rdx,%rax
  80042143cd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  80042143d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143d5:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80042143d9:	0f b7 c0             	movzwl %ax,%eax
  80042143dc:	48 c1 e0 06          	shl    $0x6,%rax
  80042143e0:	48 89 c2             	mov    %rax,%rdx
  80042143e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042143e7:	48 01 d0             	add    %rdx,%rax
  80042143ea:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  80042143ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143f2:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042143f6:	0f b7 c0             	movzwl %ax,%eax
  80042143f9:	48 c1 e0 06          	shl    $0x6,%rax
  80042143fd:	48 89 c2             	mov    %rax,%rdx
  8004214400:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214404:	48 01 d0             	add    %rdx,%rax
  8004214407:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  800421440b:	e9 4b 02 00 00       	jmpq   800421465b <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004214410:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214414:	8b 00                	mov    (%rax),%eax
  8004214416:	89 c2                	mov    %eax,%edx
  8004214418:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421441c:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004214420:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214424:	48 01 c8             	add    %rcx,%rax
  8004214427:	48 01 d0             	add    %rdx,%rax
  800421442a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  800421442e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214432:	48 be 2b 88 21 04 80 	movabs $0x800421882b,%rsi
  8004214439:	00 00 00 
  800421443c:	48 89 c7             	mov    %rax,%rdi
  800421443f:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  8004214446:	00 00 00 
  8004214449:	ff d0                	callq  *%rax
  800421444b:	85 c0                	test   %eax,%eax
  800421444d:	75 4b                	jne    800421449a <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  800421444f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214453:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  800421445a:	00 00 00 
  800421445d:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  8004214461:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214468:	00 00 00 
  800421446b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421446f:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  8004214473:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214477:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421447b:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214482:	00 00 00 
  8004214485:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  8004214489:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421448d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214491:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214495:	e9 bc 01 00 00       	jmpq   8004214656 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  800421449a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421449e:	48 be 37 88 21 04 80 	movabs $0x8004218837,%rsi
  80042144a5:	00 00 00 
  80042144a8:	48 89 c7             	mov    %rax,%rdi
  80042144ab:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  80042144b2:	00 00 00 
  80042144b5:	ff d0                	callq  *%rax
  80042144b7:	85 c0                	test   %eax,%eax
  80042144b9:	75 4b                	jne    8004214506 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  80042144bb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042144bf:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042144c6:	00 00 00 
  80042144c9:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  80042144cd:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042144d4:	00 00 00 
  80042144d7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042144db:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  80042144df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042144e3:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042144e7:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042144ee:	00 00 00 
  80042144f1:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  80042144f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042144f9:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042144fd:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214501:	e9 50 01 00 00       	jmpq   8004214656 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004214506:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421450a:	48 be 4f 88 21 04 80 	movabs $0x800421884f,%rsi
  8004214511:	00 00 00 
  8004214514:	48 89 c7             	mov    %rax,%rdi
  8004214517:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  800421451e:	00 00 00 
  8004214521:	ff d0                	callq  *%rax
  8004214523:	85 c0                	test   %eax,%eax
  8004214525:	75 4b                	jne    8004214572 <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004214527:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421452b:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214532:	00 00 00 
  8004214535:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004214539:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214540:	00 00 00 
  8004214543:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214547:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  800421454b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421454f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214553:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  800421455a:	00 00 00 
  800421455d:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  8004214561:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214565:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214569:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421456d:	e9 e4 00 00 00       	jmpq   8004214656 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  8004214572:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214576:	48 be 45 88 21 04 80 	movabs $0x8004218845,%rsi
  800421457d:	00 00 00 
  8004214580:	48 89 c7             	mov    %rax,%rdi
  8004214583:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  800421458a:	00 00 00 
  800421458d:	ff d0                	callq  *%rax
  800421458f:	85 c0                	test   %eax,%eax
  8004214591:	75 53                	jne    80042145e6 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  8004214593:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214597:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421459b:	48 89 c2             	mov    %rax,%rdx
  800421459e:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042145a5:	00 00 00 
  80042145a8:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  80042145ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042145b0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042145b4:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042145bb:	00 00 00 
  80042145be:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  80042145c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042145c6:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042145ca:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042145d1:	00 00 00 
  80042145d4:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  80042145d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042145dc:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042145e0:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042145e4:	eb 70                	jmp    8004214656 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  80042145e6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145ea:	48 be 5b 88 21 04 80 	movabs $0x800421885b,%rsi
  80042145f1:	00 00 00 
  80042145f4:	48 89 c7             	mov    %rax,%rdi
  80042145f7:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  80042145fe:	00 00 00 
  8004214601:	ff d0                	callq  *%rax
  8004214603:	85 c0                	test   %eax,%eax
  8004214605:	75 4f                	jne    8004214656 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004214607:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421460b:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214612:	00 00 00 
  8004214615:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  800421461c:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214623:	00 00 00 
  8004214626:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421462a:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004214631:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214635:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214639:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214640:	00 00 00 
  8004214643:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  800421464a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421464e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214652:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  8004214656:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  800421465b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421465f:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004214663:	0f 82 a7 fd ff ff    	jb     8004214410 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  8004214669:	c9                   	leaveq 
  800421466a:	c3                   	retq   

000000800421466b <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  800421466b:	55                   	push   %rbp
  800421466c:	48 89 e5             	mov    %rsp,%rbp
  800421466f:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004214676:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  800421467d:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  8004214684:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  800421468b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214690:	ba 14 00 00 00       	mov    $0x14,%edx
  8004214695:	48 89 f7             	mov    %rsi,%rdi
  8004214698:	48 89 d1             	mov    %rdx,%rcx
  800421469b:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  800421469e:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  80042146a5:	00 
  80042146a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042146aa:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  80042146b1:	48 01 d0             	add    %rdx,%rax
  80042146b4:	48 83 e8 01          	sub    $0x1,%rax
  80042146b8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042146bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042146c0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042146c5:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042146c9:	48 89 d0             	mov    %rdx,%rax
  80042146cc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042146d0:	48 29 c2             	sub    %rax,%rdx
  80042146d3:	48 89 d0             	mov    %rdx,%rax
  80042146d6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  80042146da:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  80042146e1:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  80042146e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042146e9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  80042146ed:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80042146f4:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  80042146f5:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  80042146fc:	00 00 00 
  80042146ff:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004214706:	75 11                	jne    8004214719 <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004214708:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421470f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214713:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214717:	eb 26                	jmp    800421473f <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004214719:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214720:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004214724:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421472b:	48 01 c2             	add    %rax,%rdx
  800421472e:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004214735:	ff ff ff 
  8004214738:	48 01 d0             	add    %rdx,%rax
  800421473b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  800421473f:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214746:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800421474a:	0f b7 c0             	movzwl %ax,%eax
  800421474d:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  8004214750:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214757:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  800421475b:	0f b7 c0             	movzwl %ax,%eax
  800421475e:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  8004214761:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214768:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  800421476c:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421476f:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004214773:	48 63 f0             	movslq %eax,%rsi
  8004214776:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421477a:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214781:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214785:	48 89 c7             	mov    %rax,%rdi
  8004214788:	48 b8 aa 4d 21 04 80 	movabs $0x8004214daa,%rax
  800421478f:	00 00 00 
  8004214792:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004214794:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214798:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  800421479c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042147a0:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042147a6:	48 89 c2             	mov    %rax,%rdx
  80042147a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042147ad:	48 29 d0             	sub    %rdx,%rax
  80042147b0:	48 89 c2             	mov    %rax,%rdx
  80042147b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042147b7:	48 01 d0             	add    %rdx,%rax
  80042147ba:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  80042147be:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042147c5:	eb 24                	jmp    80042147eb <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  80042147c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042147ca:	48 98                	cltq   
  80042147cc:	48 c1 e0 06          	shl    $0x6,%rax
  80042147d0:	48 89 c2             	mov    %rax,%rdx
  80042147d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042147d7:	48 01 c2             	add    %rax,%rdx
  80042147da:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042147dd:	48 98                	cltq   
  80042147df:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  80042147e6:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  80042147e7:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042147eb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042147ee:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  80042147f1:	7c d4                	jl     80042147c7 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  80042147f3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042147f7:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80042147fb:	0f b7 c0             	movzwl %ax,%eax
  80042147fe:	48 98                	cltq   
  8004214800:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214807:	ff 
  8004214808:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  800421480c:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214813:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004214817:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421481b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421481f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214823:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214827:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421482e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214832:	48 01 c8             	add    %rcx,%rax
  8004214835:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421483c:	48 89 c7             	mov    %rax,%rdi
  800421483f:	48 b8 aa 4d 21 04 80 	movabs $0x8004214daa,%rax
  8004214846:	00 00 00 
  8004214849:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  800421484b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421484f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214853:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214857:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421485b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800421485f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214863:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214869:	48 29 c2             	sub    %rax,%rdx
  800421486c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214870:	48 01 c2             	add    %rax,%rdx
  8004214873:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214877:	48 01 d0             	add    %rdx,%rax
  800421487a:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  800421487e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214885:	e9 04 05 00 00       	jmpq   8004214d8e <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  800421488a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421488d:	48 98                	cltq   
  800421488f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214896:	ff 
  8004214897:	8b 00                	mov    (%rax),%eax
  8004214899:	89 c2                	mov    %eax,%edx
  800421489b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421489f:	48 01 d0             	add    %rdx,%rax
  80042148a2:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  80042148a6:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042148ad:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042148b2:	48 85 c0             	test   %rax,%rax
  80042148b5:	74 35                	je     80042148ec <read_section_headers+0x281>
  80042148b7:	48 b9 66 88 21 04 80 	movabs $0x8004218866,%rcx
  80042148be:	00 00 00 
  80042148c1:	48 ba 7f 88 21 04 80 	movabs $0x800421887f,%rdx
  80042148c8:	00 00 00 
  80042148cb:	be 86 00 00 00       	mov    $0x86,%esi
  80042148d0:	48 bf 94 88 21 04 80 	movabs $0x8004218894,%rdi
  80042148d7:	00 00 00 
  80042148da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042148df:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042148e6:	00 00 00 
  80042148e9:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  80042148ec:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042148f3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  80042148f7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042148fb:	48 be 2b 88 21 04 80 	movabs $0x800421882b,%rsi
  8004214902:	00 00 00 
  8004214905:	48 89 c7             	mov    %rax,%rdi
  8004214908:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  800421490f:	00 00 00 
  8004214912:	ff d0                	callq  *%rax
  8004214914:	85 c0                	test   %eax,%eax
  8004214916:	0f 85 d8 00 00 00    	jne    80042149f4 <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421491c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421491f:	48 98                	cltq   
  8004214921:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214928:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214929:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421492d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214930:	48 98                	cltq   
  8004214932:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214939:	ff 
  800421493a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421493e:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214945:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214949:	48 01 c8             	add    %rcx,%rax
  800421494c:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214953:	48 89 c7             	mov    %rax,%rdi
  8004214956:	48 b8 aa 4d 21 04 80 	movabs $0x8004214daa,%rax
  800421495d:	00 00 00 
  8004214960:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214962:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214965:	48 98                	cltq   
  8004214967:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421496e:	ff 
  800421496f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214973:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214976:	48 98                	cltq   
  8004214978:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421497f:	ff 
  8004214980:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214984:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004214988:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421498c:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214992:	48 29 c2             	sub    %rax,%rdx
  8004214995:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214999:	48 01 c2             	add    %rax,%rdx
  800421499c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042149a0:	48 01 c2             	add    %rax,%rdx
  80042149a3:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042149aa:	00 00 00 
  80042149ad:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  80042149b1:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042149b8:	00 00 00 
  80042149bb:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042149bf:	48 89 c2             	mov    %rax,%rdx
  80042149c2:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042149c9:	00 00 00 
  80042149cc:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  80042149d0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042149d3:	48 98                	cltq   
  80042149d5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042149dc:	ff 
  80042149dd:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042149e1:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  80042149e8:	00 00 00 
  80042149eb:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042149ef:	e9 96 03 00 00       	jmpq   8004214d8a <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  80042149f4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042149f8:	48 be 37 88 21 04 80 	movabs $0x8004218837,%rsi
  80042149ff:	00 00 00 
  8004214a02:	48 89 c7             	mov    %rax,%rdi
  8004214a05:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  8004214a0c:	00 00 00 
  8004214a0f:	ff d0                	callq  *%rax
  8004214a11:	85 c0                	test   %eax,%eax
  8004214a13:	0f 85 de 00 00 00    	jne    8004214af7 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214a19:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a1c:	48 98                	cltq   
  8004214a1e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214a25:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214a26:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214a2a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a2d:	48 98                	cltq   
  8004214a2f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214a36:	ff 
  8004214a37:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214a3b:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214a42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a46:	48 01 c8             	add    %rcx,%rax
  8004214a49:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214a50:	48 89 c7             	mov    %rax,%rdi
  8004214a53:	48 b8 aa 4d 21 04 80 	movabs $0x8004214daa,%rax
  8004214a5a:	00 00 00 
  8004214a5d:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214a5f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a62:	48 98                	cltq   
  8004214a64:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214a6b:	ff 
  8004214a6c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214a70:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a73:	48 98                	cltq   
  8004214a75:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214a7c:	ff 
  8004214a7d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a81:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004214a88:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214a8f:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214a95:	48 29 c2             	sub    %rax,%rdx
  8004214a98:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214a9c:	48 01 c2             	add    %rax,%rdx
  8004214a9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214aa3:	48 01 c2             	add    %rax,%rdx
  8004214aa6:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214aad:	00 00 00 
  8004214ab0:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004214ab4:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214abb:	00 00 00 
  8004214abe:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214ac2:	48 89 c2             	mov    %rax,%rdx
  8004214ac5:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214acc:	00 00 00 
  8004214acf:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004214ad3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214ad6:	48 98                	cltq   
  8004214ad8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214adf:	ff 
  8004214ae0:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214ae4:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214aeb:	00 00 00 
  8004214aee:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214af2:	e9 93 02 00 00       	jmpq   8004214d8a <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004214af7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214afb:	48 be 4f 88 21 04 80 	movabs $0x800421884f,%rsi
  8004214b02:	00 00 00 
  8004214b05:	48 89 c7             	mov    %rax,%rdi
  8004214b08:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  8004214b0f:	00 00 00 
  8004214b12:	ff d0                	callq  *%rax
  8004214b14:	85 c0                	test   %eax,%eax
  8004214b16:	0f 85 de 00 00 00    	jne    8004214bfa <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214b1c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b1f:	48 98                	cltq   
  8004214b21:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b28:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214b29:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214b2d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b30:	48 98                	cltq   
  8004214b32:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b39:	ff 
  8004214b3a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214b3e:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214b45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214b49:	48 01 c8             	add    %rcx,%rax
  8004214b4c:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214b53:	48 89 c7             	mov    %rax,%rdi
  8004214b56:	48 b8 aa 4d 21 04 80 	movabs $0x8004214daa,%rax
  8004214b5d:	00 00 00 
  8004214b60:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214b62:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b65:	48 98                	cltq   
  8004214b67:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b6e:	ff 
  8004214b6f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214b73:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b76:	48 98                	cltq   
  8004214b78:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b7f:	ff 
  8004214b80:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b84:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004214b8b:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004214b92:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214b98:	48 29 c2             	sub    %rax,%rdx
  8004214b9b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214b9f:	48 01 c2             	add    %rax,%rdx
  8004214ba2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214ba6:	48 01 c2             	add    %rax,%rdx
  8004214ba9:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214bb0:	00 00 00 
  8004214bb3:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004214bb7:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214bbe:	00 00 00 
  8004214bc1:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004214bc5:	48 89 c2             	mov    %rax,%rdx
  8004214bc8:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214bcf:	00 00 00 
  8004214bd2:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004214bd6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214bd9:	48 98                	cltq   
  8004214bdb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214be2:	ff 
  8004214be3:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214be7:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214bee:	00 00 00 
  8004214bf1:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004214bf5:	e9 90 01 00 00       	jmpq   8004214d8a <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004214bfa:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214bfe:	48 be 45 88 21 04 80 	movabs $0x8004218845,%rsi
  8004214c05:	00 00 00 
  8004214c08:	48 89 c7             	mov    %rax,%rdi
  8004214c0b:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  8004214c12:	00 00 00 
  8004214c15:	ff d0                	callq  *%rax
  8004214c17:	85 c0                	test   %eax,%eax
  8004214c19:	75 65                	jne    8004214c80 <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004214c1b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c1e:	48 98                	cltq   
  8004214c20:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c27:	ff 
  8004214c28:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214c2c:	48 89 c2             	mov    %rax,%rdx
  8004214c2f:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214c36:	00 00 00 
  8004214c39:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004214c3d:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214c44:	00 00 00 
  8004214c47:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004214c4b:	48 89 c2             	mov    %rax,%rdx
  8004214c4e:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214c55:	00 00 00 
  8004214c58:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004214c5c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c5f:	48 98                	cltq   
  8004214c61:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c68:	ff 
  8004214c69:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214c6d:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214c74:	00 00 00 
  8004214c77:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004214c7b:	e9 0a 01 00 00       	jmpq   8004214d8a <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004214c80:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214c84:	48 be 5b 88 21 04 80 	movabs $0x800421885b,%rsi
  8004214c8b:	00 00 00 
  8004214c8e:	48 89 c7             	mov    %rax,%rdi
  8004214c91:	48 b8 14 eb 20 04 80 	movabs $0x800420eb14,%rax
  8004214c98:	00 00 00 
  8004214c9b:	ff d0                	callq  *%rax
  8004214c9d:	85 c0                	test   %eax,%eax
  8004214c9f:	0f 85 e5 00 00 00    	jne    8004214d8a <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214ca5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214ca8:	48 98                	cltq   
  8004214caa:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214cb1:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214cb2:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214cb6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cb9:	48 98                	cltq   
  8004214cbb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214cc2:	ff 
  8004214cc3:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214cc7:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214cce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214cd2:	48 01 c8             	add    %rcx,%rax
  8004214cd5:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214cdc:	48 89 c7             	mov    %rax,%rdi
  8004214cdf:	48 b8 aa 4d 21 04 80 	movabs $0x8004214daa,%rax
  8004214ce6:	00 00 00 
  8004214ce9:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214ceb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cee:	48 98                	cltq   
  8004214cf0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214cf7:	ff 
  8004214cf8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214cfc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cff:	48 98                	cltq   
  8004214d01:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d08:	ff 
  8004214d09:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d0d:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004214d14:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214d1b:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214d21:	48 29 c2             	sub    %rax,%rdx
  8004214d24:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214d28:	48 01 c2             	add    %rax,%rdx
  8004214d2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214d2f:	48 01 c2             	add    %rax,%rdx
  8004214d32:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214d39:	00 00 00 
  8004214d3c:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004214d43:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214d4a:	00 00 00 
  8004214d4d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004214d54:	48 89 c2             	mov    %rax,%rdx
  8004214d57:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214d5e:	00 00 00 
  8004214d61:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004214d68:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d6b:	48 98                	cltq   
  8004214d6d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d74:	ff 
  8004214d75:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214d79:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004214d80:	00 00 00 
  8004214d83:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004214d8a:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214d8e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d91:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214d94:	0f 8c f0 fa ff ff    	jl     800421488a <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004214d9a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214d9e:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214da5:	48 01 d0             	add    %rdx,%rax
}
  8004214da8:	c9                   	leaveq 
  8004214da9:	c3                   	retq   

0000008004214daa <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004214daa:	55                   	push   %rbp
  8004214dab:	48 89 e5             	mov    %rsp,%rbp
  8004214dae:	48 83 ec 30          	sub    $0x30,%rsp
  8004214db2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214db6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004214dba:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004214dbe:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004214dc2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214dc6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004214dca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214dce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214dd2:	48 01 d0             	add    %rdx,%rax
  8004214dd5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004214dd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ddd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214de2:	48 85 c0             	test   %rax,%rax
  8004214de5:	74 35                	je     8004214e1c <readseg+0x72>
  8004214de7:	48 b9 a2 88 21 04 80 	movabs $0x80042188a2,%rcx
  8004214dee:	00 00 00 
  8004214df1:	48 ba 7f 88 21 04 80 	movabs $0x800421887f,%rdx
  8004214df8:	00 00 00 
  8004214dfb:	be c0 00 00 00       	mov    $0xc0,%esi
  8004214e00:	48 bf 94 88 21 04 80 	movabs $0x8004218894,%rdi
  8004214e07:	00 00 00 
  8004214e0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214e0f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214e16:	00 00 00 
  8004214e19:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004214e1c:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004214e23:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004214e24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214e28:	48 c1 e8 09          	shr    $0x9,%rax
  8004214e2c:	48 83 c0 01          	add    $0x1,%rax
  8004214e30:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004214e34:	eb 3c                	jmp    8004214e72 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004214e36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e3a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214e3e:	48 89 d6             	mov    %rdx,%rsi
  8004214e41:	48 89 c7             	mov    %rax,%rdi
  8004214e44:	48 b8 3a 4f 21 04 80 	movabs $0x8004214f3a,%rax
  8004214e4b:	00 00 00 
  8004214e4e:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004214e50:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004214e57:	00 
		*kvoffset += SECTSIZE;
  8004214e58:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e5c:	48 8b 00             	mov    (%rax),%rax
  8004214e5f:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004214e66:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e6a:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004214e6d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004214e72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e76:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004214e7a:	72 ba                	jb     8004214e36 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004214e7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214e80:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214e85:	48 89 c2             	mov    %rax,%rdx
  8004214e88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214e8c:	48 01 d0             	add    %rdx,%rax
  8004214e8f:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004214e95:	76 2f                	jbe    8004214ec6 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004214e97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e9b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214e9f:	48 89 d6             	mov    %rdx,%rsi
  8004214ea2:	48 89 c7             	mov    %rax,%rdi
  8004214ea5:	48 b8 3a 4f 21 04 80 	movabs $0x8004214f3a,%rax
  8004214eac:	00 00 00 
  8004214eaf:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004214eb1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214eb5:	48 8b 00             	mov    (%rax),%rax
  8004214eb8:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004214ebf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214ec3:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004214ec6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214eca:	48 8b 00             	mov    (%rax),%rax
  8004214ecd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214ed2:	48 85 c0             	test   %rax,%rax
  8004214ed5:	74 35                	je     8004214f0c <readseg+0x162>
  8004214ed7:	48 b9 b5 88 21 04 80 	movabs $0x80042188b5,%rcx
  8004214ede:	00 00 00 
  8004214ee1:	48 ba 7f 88 21 04 80 	movabs $0x800421887f,%rdx
  8004214ee8:	00 00 00 
  8004214eeb:	be d6 00 00 00       	mov    $0xd6,%esi
  8004214ef0:	48 bf 94 88 21 04 80 	movabs $0x8004218894,%rdi
  8004214ef7:	00 00 00 
  8004214efa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214eff:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214f06:	00 00 00 
  8004214f09:	41 ff d0             	callq  *%r8
}
  8004214f0c:	c9                   	leaveq 
  8004214f0d:	c3                   	retq   

0000008004214f0e <waitdisk>:

void
waitdisk(void)
{
  8004214f0e:	55                   	push   %rbp
  8004214f0f:	48 89 e5             	mov    %rsp,%rbp
  8004214f12:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004214f16:	90                   	nop
  8004214f17:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004214f1e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214f21:	89 c2                	mov    %eax,%edx
  8004214f23:	ec                   	in     (%dx),%al
  8004214f24:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004214f27:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004214f2b:	0f b6 c0             	movzbl %al,%eax
  8004214f2e:	25 c0 00 00 00       	and    $0xc0,%eax
  8004214f33:	83 f8 40             	cmp    $0x40,%eax
  8004214f36:	75 df                	jne    8004214f17 <waitdisk+0x9>
		/* do nothing */;
}
  8004214f38:	c9                   	leaveq 
  8004214f39:	c3                   	retq   

0000008004214f3a <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004214f3a:	55                   	push   %rbp
  8004214f3b:	48 89 e5             	mov    %rsp,%rbp
  8004214f3e:	48 83 ec 60          	sub    $0x60,%rsp
  8004214f42:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004214f46:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004214f4a:	48 b8 0e 4f 21 04 80 	movabs $0x8004214f0e,%rax
  8004214f51:	00 00 00 
  8004214f54:	ff d0                	callq  *%rax
  8004214f56:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004214f5d:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004214f61:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004214f65:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004214f68:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004214f69:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214f6d:	0f b6 c0             	movzbl %al,%eax
  8004214f70:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004214f77:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004214f7a:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004214f7e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214f81:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004214f82:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214f86:	48 c1 e8 08          	shr    $0x8,%rax
  8004214f8a:	0f b6 c0             	movzbl %al,%eax
  8004214f8d:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004214f94:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004214f97:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004214f9b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214f9e:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004214f9f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214fa3:	48 c1 e8 10          	shr    $0x10,%rax
  8004214fa7:	0f b6 c0             	movzbl %al,%eax
  8004214faa:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004214fb1:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004214fb4:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004214fb8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214fbb:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004214fbc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214fc0:	48 c1 e8 18          	shr    $0x18,%rax
  8004214fc4:	83 c8 e0             	or     $0xffffffe0,%eax
  8004214fc7:	0f b6 c0             	movzbl %al,%eax
  8004214fca:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004214fd1:	88 45 db             	mov    %al,-0x25(%rbp)
  8004214fd4:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004214fd8:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004214fdb:	ee                   	out    %al,(%dx)
  8004214fdc:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004214fe3:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004214fe7:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004214feb:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004214fee:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004214fef:	48 b8 0e 4f 21 04 80 	movabs $0x8004214f0e,%rax
  8004214ff6:	00 00 00 
  8004214ff9:	ff d0                	callq  *%rax
  8004214ffb:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004215002:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215006:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800421500a:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004215011:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215014:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004215018:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421501b:	48 89 ce             	mov    %rcx,%rsi
  800421501e:	48 89 f7             	mov    %rsi,%rdi
  8004215021:	89 c1                	mov    %eax,%ecx
  8004215023:	fc                   	cld    
  8004215024:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004215026:	89 c8                	mov    %ecx,%eax
  8004215028:	48 89 fe             	mov    %rdi,%rsi
  800421502b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421502f:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004215032:	c9                   	leaveq 
  8004215033:	c3                   	retq   
  8004215034:	0f 1f 40 00          	nopl   0x0(%rax)

0000008004215038 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004215038:	fa                   	cli    
	xorw    %ax, %ax
  8004215039:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  800421503b:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421503d:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421503f:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004215041:	0f 01 16             	lgdt   (%rsi)
  8004215044:	e0 70                	loopne 80042150b6 <start64+0x10>
	movl    %cr0, %eax
  8004215046:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215049:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  800421504d:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004215050:	ea                   	(bad)  
  8004215051:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004215055 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004215055:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215059:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421505b:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421505d:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  800421505f:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215063:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215065:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004215067:	b8 20 00 00 00       	mov    $0x20,%eax

	movl %eax,%cr4
  800421506c:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  800421506f:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 421c136 <_start+0x401c12a>
	movl    %cr0, %eax
  8004215076:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215079:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  800421507c:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  800421507f:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004215084:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004215087:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  800421508c:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  800421508e:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004215092:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004215094:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004215097:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  800421509c:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  800421509f:	ea                   	(bad)  
  80042150a0:	6e                   	outsb  %ds:(%rsi),(%dx)
  80042150a1:	70 00                	jo     80042150a3 <start32+0x4e>
  80042150a3:	00 08                	add    %cl,(%rax)
	...

00000080042150a6 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  80042150a6:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  80042150aa:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042150ac:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042150ae:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  80042150b0:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  80042150b4:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  80042150b6:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  80042150b8:	48 a1 18 f7 6b 04 80 	movabs 0x80046bf718,%rax
  80042150bf:	00 00 00 
	movq    %rax,%rsp
  80042150c2:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  80042150c5:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  80042150cc:	48 b8 e8 03 20 04 80 	movabs $0x80042003e8,%rax
  80042150d3:	00 00 00 
	call    *%rax
  80042150d6:	ff d0                	callq  *%rax

00000080042150d8 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  80042150d8:	eb fe                	jmp    80042150d8 <spin>
  80042150da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000080042150e0 <gdt>:
	...
  80042150e8:	ff                   	(bad)  
  80042150e9:	ff 00                	incl   (%rax)
  80042150eb:	00 00                	add    %al,(%rax)
  80042150ed:	9a                   	(bad)  
  80042150ee:	af                   	scas   %es:(%rdi),%eax
  80042150ef:	00 ff                	add    %bh,%bh
  80042150f1:	ff 00                	incl   (%rax)
  80042150f3:	00 00                	add    %al,(%rax)
  80042150f5:	92                   	xchg   %eax,%edx
  80042150f6:	af                   	scas   %es:(%rdi),%eax
	...

00000080042150f8 <gdtdesc>:
  80042150f8:	17                   	(bad)  
  80042150f9:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  80042150ff:	90                   	nop

0000008004215100 <gdt32>:
	...
  8004215108:	ff                   	(bad)  
  8004215109:	ff 00                	incl   (%rax)
  800421510b:	00 00                	add    %al,(%rax)
  800421510d:	9a                   	(bad)  
  800421510e:	cf                   	iret   
  800421510f:	00 ff                	add    %bh,%bh
  8004215111:	ff 00                	incl   (%rax)
  8004215113:	00 00                	add    %al,(%rax)
  8004215115:	92                   	xchg   %eax,%edx
  8004215116:	cf                   	iret   
	...

0000008004215118 <gdt32desc>:
  8004215118:	17                   	(bad)  
  8004215119:	00 c8                	add    %cl,%al
  800421511b:	70 00                	jo     800421511d <gdt32desc+0x5>
	...

000000800421511e <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  800421511e:	90                   	nop

000000800421511f <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  800421511f:	55                   	push   %rbp
  8004215120:	48 89 e5             	mov    %rsp,%rbp
  8004215123:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215127:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421512b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  800421512e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004215135:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421513c:	eb 1a                	jmp    8004215158 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  800421513e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215141:	48 63 d0             	movslq %eax,%rdx
  8004215144:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215148:	48 01 d0             	add    %rdx,%rax
  800421514b:	0f b6 00             	movzbl (%rax),%eax
  800421514e:	0f b6 c0             	movzbl %al,%eax
  8004215151:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004215154:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215158:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421515b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  800421515e:	7c de                	jl     800421513e <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004215160:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004215163:	c9                   	leaveq 
  8004215164:	c3                   	retq   

0000008004215165 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004215165:	55                   	push   %rbp
  8004215166:	48 89 e5             	mov    %rsp,%rbp
  8004215169:	48 83 ec 40          	sub    $0x40,%rsp
  800421516d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215171:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004215174:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215178:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421517c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215180:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215184:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215187:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421518a:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004215191:	00 00 00 
  8004215194:	48 8b 00             	mov    (%rax),%rax
  8004215197:	48 39 c2             	cmp    %rax,%rdx
  800421519a:	72 32                	jb     80042151ce <mpsearch1+0x69>
  800421519c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042151a0:	48 89 c1             	mov    %rax,%rcx
  80042151a3:	48 ba d0 88 21 04 80 	movabs $0x80042188d0,%rdx
  80042151aa:	00 00 00 
  80042151ad:	be 58 00 00 00       	mov    $0x58,%esi
  80042151b2:	48 bf f3 88 21 04 80 	movabs $0x80042188f3,%rdi
  80042151b9:	00 00 00 
  80042151bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042151c1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042151c8:	00 00 00 
  80042151cb:	41 ff d0             	callq  *%r8
  80042151ce:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042151d5:	00 00 00 
  80042151d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042151dc:	48 01 d0             	add    %rdx,%rax
  80042151df:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042151e3:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042151e6:	48 63 d0             	movslq %eax,%rdx
  80042151e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042151ed:	48 01 d0             	add    %rdx,%rax
  80042151f0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042151f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042151f8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042151fc:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042151ff:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215202:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004215209:	00 00 00 
  800421520c:	48 8b 00             	mov    (%rax),%rax
  800421520f:	48 39 c2             	cmp    %rax,%rdx
  8004215212:	72 32                	jb     8004215246 <mpsearch1+0xe1>
  8004215214:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215218:	48 89 c1             	mov    %rax,%rcx
  800421521b:	48 ba d0 88 21 04 80 	movabs $0x80042188d0,%rdx
  8004215222:	00 00 00 
  8004215225:	be 58 00 00 00       	mov    $0x58,%esi
  800421522a:	48 bf f3 88 21 04 80 	movabs $0x80042188f3,%rdi
  8004215231:	00 00 00 
  8004215234:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215239:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004215240:	00 00 00 
  8004215243:	41 ff d0             	callq  *%r8
  8004215246:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421524d:	00 00 00 
  8004215250:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215254:	48 01 d0             	add    %rdx,%rax
  8004215257:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  800421525b:	eb 4d                	jmp    80042152aa <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421525d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215261:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215266:	48 be 03 89 21 04 80 	movabs $0x8004218903,%rsi
  800421526d:	00 00 00 
  8004215270:	48 89 c7             	mov    %rax,%rdi
  8004215273:	48 b8 21 ee 20 04 80 	movabs $0x800420ee21,%rax
  800421527a:	00 00 00 
  800421527d:	ff d0                	callq  *%rax
  800421527f:	85 c0                	test   %eax,%eax
  8004215281:	75 22                	jne    80042152a5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004215283:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215287:	be 10 00 00 00       	mov    $0x10,%esi
  800421528c:	48 89 c7             	mov    %rax,%rdi
  800421528f:	48 b8 1f 51 21 04 80 	movabs $0x800421511f,%rax
  8004215296:	00 00 00 
  8004215299:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421529b:	84 c0                	test   %al,%al
  800421529d:	75 06                	jne    80042152a5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  800421529f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042152a3:	eb 14                	jmp    80042152b9 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  80042152a5:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  80042152aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042152ae:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042152b2:	72 a9                	jb     800421525d <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  80042152b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042152b9:	c9                   	leaveq 
  80042152ba:	c3                   	retq   

00000080042152bb <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  80042152bb:	55                   	push   %rbp
  80042152bc:	48 89 e5             	mov    %rsp,%rbp
  80042152bf:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  80042152c3:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042152ca:	00 
  80042152cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042152cf:	48 c1 e8 0c          	shr    $0xc,%rax
  80042152d3:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042152d6:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042152d9:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  80042152e0:	00 00 00 
  80042152e3:	48 8b 00             	mov    (%rax),%rax
  80042152e6:	48 39 c2             	cmp    %rax,%rdx
  80042152e9:	72 32                	jb     800421531d <mpsearch+0x62>
  80042152eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042152ef:	48 89 c1             	mov    %rax,%rcx
  80042152f2:	48 ba d0 88 21 04 80 	movabs $0x80042188d0,%rdx
  80042152f9:	00 00 00 
  80042152fc:	be 70 00 00 00       	mov    $0x70,%esi
  8004215301:	48 bf f3 88 21 04 80 	movabs $0x80042188f3,%rdi
  8004215308:	00 00 00 
  800421530b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215310:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004215317:	00 00 00 
  800421531a:	41 ff d0             	callq  *%r8
  800421531d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215324:	00 00 00 
  8004215327:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421532b:	48 01 d0             	add    %rdx,%rax
  800421532e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004215332:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215336:	48 83 c0 0e          	add    $0xe,%rax
  800421533a:	0f b7 00             	movzwl (%rax),%eax
  800421533d:	0f b7 c0             	movzwl %ax,%eax
  8004215340:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004215343:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004215347:	74 2c                	je     8004215375 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004215349:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  800421534d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215350:	be 00 04 00 00       	mov    $0x400,%esi
  8004215355:	48 89 c7             	mov    %rax,%rdi
  8004215358:	48 b8 65 51 21 04 80 	movabs $0x8004215165,%rax
  800421535f:	00 00 00 
  8004215362:	ff d0                	callq  *%rax
  8004215364:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004215368:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421536d:	74 49                	je     80042153b8 <mpsearch+0xfd>
			return mp;
  800421536f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215373:	eb 59                	jmp    80042153ce <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004215375:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215379:	48 83 c0 13          	add    $0x13,%rax
  800421537d:	0f b7 00             	movzwl (%rax),%eax
  8004215380:	0f b7 c0             	movzwl %ax,%eax
  8004215383:	c1 e0 0a             	shl    $0xa,%eax
  8004215386:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004215389:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421538c:	2d 00 04 00 00       	sub    $0x400,%eax
  8004215391:	89 c0                	mov    %eax,%eax
  8004215393:	be 00 04 00 00       	mov    $0x400,%esi
  8004215398:	48 89 c7             	mov    %rax,%rdi
  800421539b:	48 b8 65 51 21 04 80 	movabs $0x8004215165,%rax
  80042153a2:	00 00 00 
  80042153a5:	ff d0                	callq  *%rax
  80042153a7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042153ab:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042153b0:	74 06                	je     80042153b8 <mpsearch+0xfd>
			return mp;
  80042153b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042153b6:	eb 16                	jmp    80042153ce <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  80042153b8:	be 00 00 01 00       	mov    $0x10000,%esi
  80042153bd:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  80042153c2:	48 b8 65 51 21 04 80 	movabs $0x8004215165,%rax
  80042153c9:	00 00 00 
  80042153cc:	ff d0                	callq  *%rax
}
  80042153ce:	c9                   	leaveq 
  80042153cf:	c3                   	retq   

00000080042153d0 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  80042153d0:	55                   	push   %rbp
  80042153d1:	48 89 e5             	mov    %rsp,%rbp
  80042153d4:	48 83 ec 30          	sub    $0x30,%rsp
  80042153d8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  80042153dc:	48 b8 bb 52 21 04 80 	movabs $0x80042152bb,%rax
  80042153e3:	00 00 00 
  80042153e6:	ff d0                	callq  *%rax
  80042153e8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042153ec:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042153f1:	75 0a                	jne    80042153fd <mpconfig+0x2d>
		return NULL;
  80042153f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042153f8:	e9 f6 01 00 00       	jmpq   80042155f3 <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  80042153fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215401:	8b 40 04             	mov    0x4(%rax),%eax
  8004215404:	85 c0                	test   %eax,%eax
  8004215406:	74 0c                	je     8004215414 <mpconfig+0x44>
  8004215408:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421540c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004215410:	84 c0                	test   %al,%al
  8004215412:	74 25                	je     8004215439 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004215414:	48 bf 08 89 21 04 80 	movabs $0x8004218908,%rdi
  800421541b:	00 00 00 
  800421541e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215423:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800421542a:	00 00 00 
  800421542d:	ff d2                	callq  *%rdx
		return NULL;
  800421542f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215434:	e9 ba 01 00 00       	jmpq   80042155f3 <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004215439:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421543d:	8b 40 04             	mov    0x4(%rax),%eax
  8004215440:	89 c0                	mov    %eax,%eax
  8004215442:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004215446:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421544a:	48 c1 e8 0c          	shr    $0xc,%rax
  800421544e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215451:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215454:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  800421545b:	00 00 00 
  800421545e:	48 8b 00             	mov    (%rax),%rax
  8004215461:	48 39 c2             	cmp    %rax,%rdx
  8004215464:	72 32                	jb     8004215498 <mpconfig+0xc8>
  8004215466:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421546a:	48 89 c1             	mov    %rax,%rcx
  800421546d:	48 ba d0 88 21 04 80 	movabs $0x80042188d0,%rdx
  8004215474:	00 00 00 
  8004215477:	be 91 00 00 00       	mov    $0x91,%esi
  800421547c:	48 bf f3 88 21 04 80 	movabs $0x80042188f3,%rdi
  8004215483:	00 00 00 
  8004215486:	b8 00 00 00 00       	mov    $0x0,%eax
  800421548b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004215492:	00 00 00 
  8004215495:	41 ff d0             	callq  *%r8
  8004215498:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421549f:	00 00 00 
  80042154a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042154a6:	48 01 d0             	add    %rdx,%rax
  80042154a9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  80042154ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042154b1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042154b6:	48 be 35 89 21 04 80 	movabs $0x8004218935,%rsi
  80042154bd:	00 00 00 
  80042154c0:	48 89 c7             	mov    %rax,%rdi
  80042154c3:	48 b8 21 ee 20 04 80 	movabs $0x800420ee21,%rax
  80042154ca:	00 00 00 
  80042154cd:	ff d0                	callq  *%rax
  80042154cf:	85 c0                	test   %eax,%eax
  80042154d1:	74 25                	je     80042154f8 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  80042154d3:	48 bf 40 89 21 04 80 	movabs $0x8004218940,%rdi
  80042154da:	00 00 00 
  80042154dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154e2:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042154e9:	00 00 00 
  80042154ec:	ff d2                	callq  *%rdx
		return NULL;
  80042154ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154f3:	e9 fb 00 00 00       	jmpq   80042155f3 <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  80042154f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042154fc:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004215500:	0f b7 d0             	movzwl %ax,%edx
  8004215503:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215507:	89 d6                	mov    %edx,%esi
  8004215509:	48 89 c7             	mov    %rax,%rdi
  800421550c:	48 b8 1f 51 21 04 80 	movabs $0x800421511f,%rax
  8004215513:	00 00 00 
  8004215516:	ff d0                	callq  *%rax
  8004215518:	84 c0                	test   %al,%al
  800421551a:	74 25                	je     8004215541 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  800421551c:	48 bf 78 89 21 04 80 	movabs $0x8004218978,%rdi
  8004215523:	00 00 00 
  8004215526:	b8 00 00 00 00       	mov    $0x0,%eax
  800421552b:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004215532:	00 00 00 
  8004215535:	ff d2                	callq  *%rdx
		return NULL;
  8004215537:	b8 00 00 00 00       	mov    $0x0,%eax
  800421553c:	e9 b2 00 00 00       	jmpq   80042155f3 <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004215541:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215545:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004215549:	3c 01                	cmp    $0x1,%al
  800421554b:	74 3b                	je     8004215588 <mpconfig+0x1b8>
  800421554d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215551:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004215555:	3c 04                	cmp    $0x4,%al
  8004215557:	74 2f                	je     8004215588 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004215559:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421555d:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004215561:	0f b6 c0             	movzbl %al,%eax
  8004215564:	89 c6                	mov    %eax,%esi
  8004215566:	48 bf a0 89 21 04 80 	movabs $0x80042189a0,%rdi
  800421556d:	00 00 00 
  8004215570:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215575:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  800421557c:	00 00 00 
  800421557f:	ff d2                	callq  *%rdx
		return NULL;
  8004215581:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215586:	eb 6b                	jmp    80042155f3 <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004215588:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421558c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004215590:	0f b7 c0             	movzwl %ax,%eax
  8004215593:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215597:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  800421559b:	0f b7 ca             	movzwl %dx,%ecx
  800421559e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042155a2:	48 01 ca             	add    %rcx,%rdx
  80042155a5:	89 c6                	mov    %eax,%esi
  80042155a7:	48 89 d7             	mov    %rdx,%rdi
  80042155aa:	48 b8 1f 51 21 04 80 	movabs $0x800421511f,%rax
  80042155b1:	00 00 00 
  80042155b4:	ff d0                	callq  *%rax
  80042155b6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042155ba:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  80042155be:	38 d0                	cmp    %dl,%al
  80042155c0:	74 22                	je     80042155e4 <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  80042155c2:	48 bf c0 89 21 04 80 	movabs $0x80042189c0,%rdi
  80042155c9:	00 00 00 
  80042155cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042155d1:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042155d8:	00 00 00 
  80042155db:	ff d2                	callq  *%rdx
		return NULL;
  80042155dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042155e2:	eb 0f                	jmp    80042155f3 <mpconfig+0x223>
	}
	*pmp = mp;
  80042155e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042155e8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042155ec:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  80042155ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  80042155f3:	c9                   	leaveq 
  80042155f4:	c3                   	retq   

00000080042155f5 <mp_init>:

void
mp_init(void)
{
  80042155f5:	55                   	push   %rbp
  80042155f6:	48 89 e5             	mov    %rsp,%rbp
  80042155f9:	53                   	push   %rbx
  80042155fa:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  80042155fe:	48 b8 e0 13 6c 04 80 	movabs $0x80046c13e0,%rax
  8004215605:	00 00 00 
  8004215608:	48 bb 20 10 6c 04 80 	movabs $0x80046c1020,%rbx
  800421560f:	00 00 00 
  8004215612:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004215615:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004215619:	48 89 c7             	mov    %rax,%rdi
  800421561c:	48 b8 d0 53 21 04 80 	movabs $0x80042153d0,%rax
  8004215623:	00 00 00 
  8004215626:	ff d0                	callq  *%rax
  8004215628:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421562c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004215631:	75 05                	jne    8004215638 <mp_init+0x43>
		return;
  8004215633:	e9 71 03 00 00       	jmpq   80042159a9 <mp_init+0x3b4>
	ismp = 1;
  8004215638:	48 b8 00 10 6c 04 80 	movabs $0x80046c1000,%rax
  800421563f:	00 00 00 
  8004215642:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004215648:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421564c:	8b 40 24             	mov    0x24(%rax),%eax
  800421564f:	89 c2                	mov    %eax,%edx
  8004215651:	48 b8 00 20 74 04 80 	movabs $0x8004742000,%rax
  8004215658:	00 00 00 
  800421565b:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  800421565e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215662:	48 83 c0 2c          	add    $0x2c,%rax
  8004215666:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421566a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004215671:	e9 18 02 00 00       	jmpq   800421588e <mp_init+0x299>
		switch (*p) {
  8004215676:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421567a:	0f b6 00             	movzbl (%rax),%eax
  800421567d:	0f b6 c0             	movzbl %al,%eax
  8004215680:	85 c0                	test   %eax,%eax
  8004215682:	74 16                	je     800421569a <mp_init+0xa5>
  8004215684:	85 c0                	test   %eax,%eax
  8004215686:	0f 88 b9 01 00 00    	js     8004215845 <mp_init+0x250>
  800421568c:	83 f8 04             	cmp    $0x4,%eax
  800421568f:	0f 8f b0 01 00 00    	jg     8004215845 <mp_init+0x250>
  8004215695:	e9 a4 01 00 00       	jmpq   800421583e <mp_init+0x249>
		case MPPROC:
			proc = (struct mpproc *)p;
  800421569a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421569e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  80042156a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042156a6:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042156aa:	0f b6 c0             	movzbl %al,%eax
  80042156ad:	83 e0 02             	and    $0x2,%eax
  80042156b0:	85 c0                	test   %eax,%eax
  80042156b2:	74 51                	je     8004215705 <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  80042156b4:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  80042156bb:	00 00 00 
  80042156be:	8b 00                	mov    (%rax),%eax
  80042156c0:	48 98                	cltq   
  80042156c2:	48 c1 e0 03          	shl    $0x3,%rax
  80042156c6:	48 89 c2             	mov    %rax,%rdx
  80042156c9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042156cd:	48 29 c2             	sub    %rax,%rdx
  80042156d0:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  80042156d7:	00 00 00 
  80042156da:	48 01 c2             	add    %rax,%rdx
  80042156dd:	48 b8 e0 13 6c 04 80 	movabs $0x80046c13e0,%rax
  80042156e4:	00 00 00 
  80042156e7:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  80042156ea:	48 bf ed 89 21 04 80 	movabs $0x80042189ed,%rdi
  80042156f1:	00 00 00 
  80042156f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042156f9:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004215700:	00 00 00 
  8004215703:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004215705:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  800421570c:	00 00 00 
  800421570f:	8b 00                	mov    (%rax),%eax
  8004215711:	83 f8 07             	cmp    $0x7,%eax
  8004215714:	0f 8f f5 00 00 00    	jg     800421580f <mp_init+0x21a>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  800421571a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421571e:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  8004215722:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215726:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421572a:	0f b6 f0             	movzbl %al,%esi
  800421572d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215731:	8b 78 08             	mov    0x8(%rax),%edi
  8004215734:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215738:	4c 8d 50 04          	lea    0x4(%rax),%r10
  800421573c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215740:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  8004215744:	0f b6 c8             	movzbl %al,%ecx
  8004215747:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421574b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800421574f:	0f b6 d0             	movzbl %al,%edx
  8004215752:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215756:	0f b6 00             	movzbl (%rax),%eax
  8004215759:	0f b6 c0             	movzbl %al,%eax
  800421575c:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004215761:	89 34 24             	mov    %esi,(%rsp)
  8004215764:	41 89 f9             	mov    %edi,%r9d
  8004215767:	4d 89 d0             	mov    %r10,%r8
  800421576a:	89 c6                	mov    %eax,%esi
  800421576c:	48 bf 00 8a 21 04 80 	movabs $0x8004218a00,%rdi
  8004215773:	00 00 00 
  8004215776:	b8 00 00 00 00       	mov    $0x0,%eax
  800421577b:	49 ba ea 86 20 04 80 	movabs $0x80042086ea,%r10
  8004215782:	00 00 00 
  8004215785:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  8004215788:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421578c:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004215790:	0f b6 c0             	movzbl %al,%eax
  8004215793:	83 e0 01             	and    $0x1,%eax
  8004215796:	85 c0                	test   %eax,%eax
  8004215798:	74 58                	je     80042157f2 <mp_init+0x1fd>
					cpus[ncpu].cpu_id = ncpu;
  800421579a:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  80042157a1:	00 00 00 
  80042157a4:	8b 10                	mov    (%rax),%edx
  80042157a6:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  80042157ad:	00 00 00 
  80042157b0:	8b 00                	mov    (%rax),%eax
  80042157b2:	89 c1                	mov    %eax,%ecx
  80042157b4:	48 be 20 10 6c 04 80 	movabs $0x80046c1020,%rsi
  80042157bb:	00 00 00 
  80042157be:	48 63 c2             	movslq %edx,%rax
  80042157c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042157c5:	48 89 c2             	mov    %rax,%rdx
  80042157c8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042157cc:	48 29 c2             	sub    %rax,%rdx
  80042157cf:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  80042157d3:	88 08                	mov    %cl,(%rax)
					ncpu++;
  80042157d5:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  80042157dc:	00 00 00 
  80042157df:	8b 00                	mov    (%rax),%eax
  80042157e1:	8d 50 01             	lea    0x1(%rax),%edx
  80042157e4:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  80042157eb:	00 00 00 
  80042157ee:	89 10                	mov    %edx,(%rax)
  80042157f0:	eb 45                	jmp    8004215837 <mp_init+0x242>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  80042157f2:	48 bf 50 8a 21 04 80 	movabs $0x8004218a50,%rdi
  80042157f9:	00 00 00 
  80042157fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215801:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004215808:	00 00 00 
  800421580b:	ff d2                	callq  *%rdx
  800421580d:	eb 28                	jmp    8004215837 <mp_init+0x242>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  800421580f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215813:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004215817:	0f b6 c0             	movzbl %al,%eax
  800421581a:	89 c6                	mov    %eax,%esi
  800421581c:	48 bf 80 8a 21 04 80 	movabs $0x8004218a80,%rdi
  8004215823:	00 00 00 
  8004215826:	b8 00 00 00 00       	mov    $0x0,%eax
  800421582b:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004215832:	00 00 00 
  8004215835:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004215837:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  800421583c:	eb 4c                	jmp    800421588a <mp_init+0x295>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  800421583e:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  8004215843:	eb 45                	jmp    800421588a <mp_init+0x295>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004215845:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215849:	0f b6 00             	movzbl (%rax),%eax
  800421584c:	0f b6 c0             	movzbl %al,%eax
  800421584f:	89 c6                	mov    %eax,%esi
  8004215851:	48 bf a8 8a 21 04 80 	movabs $0x8004218aa8,%rdi
  8004215858:	00 00 00 
  800421585b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215860:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004215867:	00 00 00 
  800421586a:	ff d2                	callq  *%rdx
			ismp = 0;
  800421586c:	48 b8 00 10 6c 04 80 	movabs $0x80046c1000,%rax
  8004215873:	00 00 00 
  8004215876:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  800421587c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215880:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215884:	0f b7 c0             	movzwl %ax,%eax
  8004215887:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  800421588a:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  800421588e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215892:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215896:	0f b7 c0             	movzwl %ax,%eax
  8004215899:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  800421589c:	0f 87 d4 fd ff ff    	ja     8004215676 <mp_init+0x81>
			i = conf->entry;
		}
	}


	bootcpu->cpu_status = CPU_STARTED;
  80042158a2:	48 b8 e0 13 6c 04 80 	movabs $0x80046c13e0,%rax
  80042158a9:	00 00 00 
  80042158ac:	48 8b 00             	mov    (%rax),%rax
  80042158af:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  80042158b6:	48 b8 00 10 6c 04 80 	movabs $0x80046c1000,%rax
  80042158bd:	00 00 00 
  80042158c0:	8b 00                	mov    (%rax),%eax
  80042158c2:	85 c0                	test   %eax,%eax
  80042158c4:	75 41                	jne    8004215907 <mp_init+0x312>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  80042158c6:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  80042158cd:	00 00 00 
  80042158d0:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  80042158d6:	48 b8 00 20 74 04 80 	movabs $0x8004742000,%rax
  80042158dd:	00 00 00 
  80042158e0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  80042158e7:	48 bf c8 8a 21 04 80 	movabs $0x8004218ac8,%rdi
  80042158ee:	00 00 00 
  80042158f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042158f6:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  80042158fd:	00 00 00 
  8004215900:	ff d2                	callq  *%rdx
		return;
  8004215902:	e9 a2 00 00 00       	jmpq   80042159a9 <mp_init+0x3b4>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004215907:	48 b8 e8 13 6c 04 80 	movabs $0x80046c13e8,%rax
  800421590e:	00 00 00 
  8004215911:	8b 10                	mov    (%rax),%edx
  8004215913:	48 b8 e0 13 6c 04 80 	movabs $0x80046c13e0,%rax
  800421591a:	00 00 00 
  800421591d:	48 8b 00             	mov    (%rax),%rax
  8004215920:	0f b6 00             	movzbl (%rax),%eax
  8004215923:	0f b6 c0             	movzbl %al,%eax
  8004215926:	89 c6                	mov    %eax,%esi
  8004215928:	48 bf f4 8a 21 04 80 	movabs $0x8004218af4,%rdi
  800421592f:	00 00 00 
  8004215932:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215937:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  800421593e:	00 00 00 
  8004215941:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004215943:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215947:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  800421594b:	84 c0                	test   %al,%al
  800421594d:	74 5a                	je     80042159a9 <mp_init+0x3b4>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  800421594f:	48 bf 18 8b 21 04 80 	movabs $0x8004218b18,%rdi
  8004215956:	00 00 00 
  8004215959:	b8 00 00 00 00       	mov    $0x0,%eax
  800421595e:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004215965:	00 00 00 
  8004215968:	ff d2                	callq  *%rdx
  800421596a:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004215971:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215975:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004215979:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421597c:	ee                   	out    %al,(%dx)
  800421597d:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215984:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215987:	89 c2                	mov    %eax,%edx
  8004215989:	ec                   	in     (%dx),%al
  800421598a:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  800421598d:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004215991:	83 c8 01             	or     $0x1,%eax
  8004215994:	0f b6 c0             	movzbl %al,%eax
  8004215997:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  800421599e:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042159a1:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042159a5:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042159a8:	ee                   	out    %al,(%dx)
	}
}
  80042159a9:	48 83 c4 58          	add    $0x58,%rsp
  80042159ad:	5b                   	pop    %rbx
  80042159ae:	5d                   	pop    %rbp
  80042159af:	c3                   	retq   

00000080042159b0 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  80042159b0:	55                   	push   %rbp
  80042159b1:	48 89 e5             	mov    %rsp,%rbp
  80042159b4:	48 83 ec 08          	sub    $0x8,%rsp
  80042159b8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042159bb:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  80042159be:	48 b8 08 20 74 04 80 	movabs $0x8004742008,%rax
  80042159c5:	00 00 00 
  80042159c8:	48 8b 00             	mov    (%rax),%rax
  80042159cb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042159ce:	48 63 d2             	movslq %edx,%rdx
  80042159d1:	48 c1 e2 02          	shl    $0x2,%rdx
  80042159d5:	48 01 c2             	add    %rax,%rdx
  80042159d8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042159db:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  80042159dd:	48 b8 08 20 74 04 80 	movabs $0x8004742008,%rax
  80042159e4:	00 00 00 
  80042159e7:	48 8b 00             	mov    (%rax),%rax
  80042159ea:	48 83 c0 20          	add    $0x20,%rax
  80042159ee:	8b 00                	mov    (%rax),%eax
}
  80042159f0:	c9                   	leaveq 
  80042159f1:	c3                   	retq   

00000080042159f2 <lapic_init>:

void
lapic_init(void)
{
  80042159f2:	55                   	push   %rbp
  80042159f3:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  80042159f6:	48 b8 00 20 74 04 80 	movabs $0x8004742000,%rax
  80042159fd:	00 00 00 
  8004215a00:	48 8b 00             	mov    (%rax),%rax
  8004215a03:	48 85 c0             	test   %rax,%rax
  8004215a06:	75 05                	jne    8004215a0d <lapic_init+0x1b>
		return;
  8004215a08:	e9 da 01 00 00       	jmpq   8004215be7 <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  8004215a0d:	48 b8 00 20 74 04 80 	movabs $0x8004742000,%rax
  8004215a14:	00 00 00 
  8004215a17:	48 8b 00             	mov    (%rax),%rax
  8004215a1a:	be 00 10 00 00       	mov    $0x1000,%esi
  8004215a1f:	48 89 c7             	mov    %rax,%rdi
  8004215a22:	48 b8 3a 33 20 04 80 	movabs $0x800420333a,%rax
  8004215a29:	00 00 00 
  8004215a2c:	ff d0                	callq  *%rax
  8004215a2e:	48 ba 08 20 74 04 80 	movabs $0x8004742008,%rdx
  8004215a35:	00 00 00 
  8004215a38:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  8004215a3b:	be 27 01 00 00       	mov    $0x127,%esi
  8004215a40:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004215a45:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215a4c:	00 00 00 
  8004215a4f:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004215a51:	be 0b 00 00 00       	mov    $0xb,%esi
  8004215a56:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004215a5b:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215a62:	00 00 00 
  8004215a65:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004215a67:	be 20 00 02 00       	mov    $0x20020,%esi
  8004215a6c:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215a71:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215a78:	00 00 00 
  8004215a7b:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004215a7d:	be 80 96 98 00       	mov    $0x989680,%esi
  8004215a82:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004215a87:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215a8e:	00 00 00 
  8004215a91:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004215a93:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004215a9a:	00 00 00 
  8004215a9d:	ff d0                	callq  *%rax
  8004215a9f:	48 98                	cltq   
  8004215aa1:	48 c1 e0 03          	shl    $0x3,%rax
  8004215aa5:	48 89 c2             	mov    %rax,%rdx
  8004215aa8:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215aac:	48 29 c2             	sub    %rax,%rdx
  8004215aaf:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  8004215ab6:	00 00 00 
  8004215ab9:	48 01 c2             	add    %rax,%rdx
  8004215abc:	48 b8 e0 13 6c 04 80 	movabs $0x80046c13e0,%rax
  8004215ac3:	00 00 00 
  8004215ac6:	48 8b 00             	mov    (%rax),%rax
  8004215ac9:	48 39 c2             	cmp    %rax,%rdx
  8004215acc:	74 16                	je     8004215ae4 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  8004215ace:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215ad3:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004215ad8:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215adf:	00 00 00 
  8004215ae2:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004215ae4:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215ae9:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004215aee:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215af5:	00 00 00 
  8004215af8:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004215afa:	48 b8 08 20 74 04 80 	movabs $0x8004742008,%rax
  8004215b01:	00 00 00 
  8004215b04:	48 8b 00             	mov    (%rax),%rax
  8004215b07:	48 83 c0 30          	add    $0x30,%rax
  8004215b0b:	8b 00                	mov    (%rax),%eax
  8004215b0d:	c1 e8 10             	shr    $0x10,%eax
  8004215b10:	0f b6 c0             	movzbl %al,%eax
  8004215b13:	83 f8 03             	cmp    $0x3,%eax
  8004215b16:	76 16                	jbe    8004215b2e <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  8004215b18:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215b1d:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004215b22:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215b29:	00 00 00 
  8004215b2c:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004215b2e:	be 33 00 00 00       	mov    $0x33,%esi
  8004215b33:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004215b38:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215b3f:	00 00 00 
  8004215b42:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004215b44:	be 00 00 00 00       	mov    $0x0,%esi
  8004215b49:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215b4e:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215b55:	00 00 00 
  8004215b58:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004215b5a:	be 00 00 00 00       	mov    $0x0,%esi
  8004215b5f:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215b64:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215b6b:	00 00 00 
  8004215b6e:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004215b70:	be 00 00 00 00       	mov    $0x0,%esi
  8004215b75:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215b7a:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215b81:	00 00 00 
  8004215b84:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004215b86:	be 00 00 00 00       	mov    $0x0,%esi
  8004215b8b:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215b90:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215b97:	00 00 00 
  8004215b9a:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004215b9c:	be 00 85 08 00       	mov    $0x88500,%esi
  8004215ba1:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215ba6:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215bad:	00 00 00 
  8004215bb0:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004215bb2:	90                   	nop
  8004215bb3:	48 b8 08 20 74 04 80 	movabs $0x8004742008,%rax
  8004215bba:	00 00 00 
  8004215bbd:	48 8b 00             	mov    (%rax),%rax
  8004215bc0:	48 05 00 03 00 00    	add    $0x300,%rax
  8004215bc6:	8b 00                	mov    (%rax),%eax
  8004215bc8:	25 00 10 00 00       	and    $0x1000,%eax
  8004215bcd:	85 c0                	test   %eax,%eax
  8004215bcf:	75 e2                	jne    8004215bb3 <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004215bd1:	be 00 00 00 00       	mov    $0x0,%esi
  8004215bd6:	bf 20 00 00 00       	mov    $0x20,%edi
  8004215bdb:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215be2:	00 00 00 
  8004215be5:	ff d0                	callq  *%rax
}
  8004215be7:	5d                   	pop    %rbp
  8004215be8:	c3                   	retq   

0000008004215be9 <cpunum>:

int
cpunum(void)
{
  8004215be9:	55                   	push   %rbp
  8004215bea:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215bed:	48 b8 08 20 74 04 80 	movabs $0x8004742008,%rax
  8004215bf4:	00 00 00 
  8004215bf7:	48 8b 00             	mov    (%rax),%rax
  8004215bfa:	48 85 c0             	test   %rax,%rax
  8004215bfd:	74 18                	je     8004215c17 <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004215bff:	48 b8 08 20 74 04 80 	movabs $0x8004742008,%rax
  8004215c06:	00 00 00 
  8004215c09:	48 8b 00             	mov    (%rax),%rax
  8004215c0c:	48 83 c0 20          	add    $0x20,%rax
  8004215c10:	8b 00                	mov    (%rax),%eax
  8004215c12:	c1 e8 18             	shr    $0x18,%eax
  8004215c15:	eb 05                	jmp    8004215c1c <cpunum+0x33>
	return 0;
  8004215c17:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215c1c:	5d                   	pop    %rbp
  8004215c1d:	c3                   	retq   

0000008004215c1e <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004215c1e:	55                   	push   %rbp
  8004215c1f:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215c22:	48 b8 08 20 74 04 80 	movabs $0x8004742008,%rax
  8004215c29:	00 00 00 
  8004215c2c:	48 8b 00             	mov    (%rax),%rax
  8004215c2f:	48 85 c0             	test   %rax,%rax
  8004215c32:	74 16                	je     8004215c4a <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004215c34:	be 00 00 00 00       	mov    $0x0,%esi
  8004215c39:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215c3e:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215c45:	00 00 00 
  8004215c48:	ff d0                	callq  *%rax
}
  8004215c4a:	5d                   	pop    %rbp
  8004215c4b:	c3                   	retq   

0000008004215c4c <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004215c4c:	55                   	push   %rbp
  8004215c4d:	48 89 e5             	mov    %rsp,%rbp
  8004215c50:	48 83 ec 04          	sub    $0x4,%rsp
  8004215c54:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004215c57:	c9                   	leaveq 
  8004215c58:	c3                   	retq   

0000008004215c59 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004215c59:	55                   	push   %rbp
  8004215c5a:	48 89 e5             	mov    %rsp,%rbp
  8004215c5d:	48 83 ec 40          	sub    $0x40,%rsp
  8004215c61:	89 f8                	mov    %edi,%eax
  8004215c63:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004215c66:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004215c69:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004215c70:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004215c74:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215c78:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215c7b:	ee                   	out    %al,(%dx)
  8004215c7c:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004215c83:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004215c87:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215c8b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215c8e:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004215c8f:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004215c96:	00 
  8004215c97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c9b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215c9f:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215ca2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215ca5:	48 b8 30 f7 6b 04 80 	movabs $0x80046bf730,%rax
  8004215cac:	00 00 00 
  8004215caf:	48 8b 00             	mov    (%rax),%rax
  8004215cb2:	48 39 c2             	cmp    %rax,%rdx
  8004215cb5:	72 32                	jb     8004215ce9 <lapic_startap+0x90>
  8004215cb7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215cbb:	48 89 c1             	mov    %rax,%rcx
  8004215cbe:	48 ba 60 8b 21 04 80 	movabs $0x8004218b60,%rdx
  8004215cc5:	00 00 00 
  8004215cc8:	be 98 00 00 00       	mov    $0x98,%esi
  8004215ccd:	48 bf 83 8b 21 04 80 	movabs $0x8004218b83,%rdi
  8004215cd4:	00 00 00 
  8004215cd7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215cdc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004215ce3:	00 00 00 
  8004215ce6:	41 ff d0             	callq  *%r8
  8004215ce9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215cf0:	00 00 00 
  8004215cf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215cf7:	48 01 d0             	add    %rdx,%rax
  8004215cfa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004215cfe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215d02:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004215d07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215d0b:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004215d0f:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004215d12:	c1 e8 04             	shr    $0x4,%eax
  8004215d15:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004215d18:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215d1c:	c1 e0 18             	shl    $0x18,%eax
  8004215d1f:	89 c6                	mov    %eax,%esi
  8004215d21:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215d26:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215d2d:	00 00 00 
  8004215d30:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004215d32:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004215d37:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215d3c:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215d43:	00 00 00 
  8004215d46:	ff d0                	callq  *%rax
	microdelay(200);
  8004215d48:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215d4d:	48 b8 4c 5c 21 04 80 	movabs $0x8004215c4c,%rax
  8004215d54:	00 00 00 
  8004215d57:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004215d59:	be 00 85 00 00       	mov    $0x8500,%esi
  8004215d5e:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215d63:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215d6a:	00 00 00 
  8004215d6d:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004215d6f:	bf 64 00 00 00       	mov    $0x64,%edi
  8004215d74:	48 b8 4c 5c 21 04 80 	movabs $0x8004215c4c,%rax
  8004215d7b:	00 00 00 
  8004215d7e:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215d80:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215d87:	eb 4b                	jmp    8004215dd4 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004215d89:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215d8d:	c1 e0 18             	shl    $0x18,%eax
  8004215d90:	89 c6                	mov    %eax,%esi
  8004215d92:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215d97:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215d9e:	00 00 00 
  8004215da1:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004215da3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004215da6:	c1 e8 0c             	shr    $0xc,%eax
  8004215da9:	80 cc 06             	or     $0x6,%ah
  8004215dac:	89 c6                	mov    %eax,%esi
  8004215dae:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215db3:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215dba:	00 00 00 
  8004215dbd:	ff d0                	callq  *%rax
		microdelay(200);
  8004215dbf:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215dc4:	48 b8 4c 5c 21 04 80 	movabs $0x8004215c4c,%rax
  8004215dcb:	00 00 00 
  8004215dce:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215dd0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215dd4:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004215dd8:	7e af                	jle    8004215d89 <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004215dda:	c9                   	leaveq 
  8004215ddb:	c3                   	retq   

0000008004215ddc <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004215ddc:	55                   	push   %rbp
  8004215ddd:	48 89 e5             	mov    %rsp,%rbp
  8004215de0:	48 83 ec 08          	sub    $0x8,%rsp
  8004215de4:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004215de7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215dea:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004215def:	89 c6                	mov    %eax,%esi
  8004215df1:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215df6:	48 b8 b0 59 21 04 80 	movabs $0x80042159b0,%rax
  8004215dfd:	00 00 00 
  8004215e00:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004215e02:	90                   	nop
  8004215e03:	48 b8 08 20 74 04 80 	movabs $0x8004742008,%rax
  8004215e0a:	00 00 00 
  8004215e0d:	48 8b 00             	mov    (%rax),%rax
  8004215e10:	48 05 00 03 00 00    	add    $0x300,%rax
  8004215e16:	8b 00                	mov    (%rax),%eax
  8004215e18:	25 00 10 00 00       	and    $0x1000,%eax
  8004215e1d:	85 c0                	test   %eax,%eax
  8004215e1f:	75 e2                	jne    8004215e03 <lapic_ipi+0x27>
		;
}
  8004215e21:	c9                   	leaveq 
  8004215e22:	c3                   	retq   

0000008004215e23 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004215e23:	55                   	push   %rbp
  8004215e24:	48 89 e5             	mov    %rsp,%rbp
  8004215e27:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215e2b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215e2f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004215e32:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215e36:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215e39:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004215e3d:	f0 87 02             	lock xchg %eax,(%rdx)
  8004215e40:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004215e43:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004215e46:	c9                   	leaveq 
  8004215e47:	c3                   	retq   

0000008004215e48 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004215e48:	55                   	push   %rbp
  8004215e49:	48 89 e5             	mov    %rsp,%rbp
  8004215e4c:	48 83 ec 28          	sub    $0x28,%rsp
  8004215e50:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004215e54:	48 89 e8             	mov    %rbp,%rax
  8004215e57:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004215e5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004215e5f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004215e63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215e6a:	eb 45                	jmp    8004215eb1 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004215e6c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215e71:	74 44                	je     8004215eb7 <get_caller_pcs+0x6f>
  8004215e73:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004215e7a:	00 00 00 
  8004215e7d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004215e81:	76 34                	jbe    8004215eb7 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004215e83:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215e86:	48 98                	cltq   
  8004215e88:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215e8f:	00 
  8004215e90:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215e94:	48 01 c2             	add    %rax,%rdx
  8004215e97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215e9b:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215e9f:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004215ea2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215ea6:	48 8b 00             	mov    (%rax),%rax
  8004215ea9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004215ead:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215eb1:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004215eb5:	7e b5                	jle    8004215e6c <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004215eb7:	eb 1f                	jmp    8004215ed8 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004215eb9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215ebc:	48 98                	cltq   
  8004215ebe:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215ec5:	00 
  8004215ec6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215eca:	48 01 d0             	add    %rdx,%rax
  8004215ecd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004215ed4:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215ed8:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004215edc:	7e db                	jle    8004215eb9 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004215ede:	c9                   	leaveq 
  8004215edf:	c3                   	retq   

0000008004215ee0 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004215ee0:	55                   	push   %rbp
  8004215ee1:	48 89 e5             	mov    %rsp,%rbp
  8004215ee4:	53                   	push   %rbx
  8004215ee5:	48 83 ec 18          	sub    $0x18,%rsp
  8004215ee9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004215eed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215ef1:	8b 00                	mov    (%rax),%eax
  8004215ef3:	85 c0                	test   %eax,%eax
  8004215ef5:	74 3d                	je     8004215f34 <holding+0x54>
  8004215ef7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215efb:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004215eff:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004215f06:	00 00 00 
  8004215f09:	ff d0                	callq  *%rax
  8004215f0b:	48 98                	cltq   
  8004215f0d:	48 c1 e0 03          	shl    $0x3,%rax
  8004215f11:	48 89 c2             	mov    %rax,%rdx
  8004215f14:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215f18:	48 29 c2             	sub    %rax,%rdx
  8004215f1b:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  8004215f22:	00 00 00 
  8004215f25:	48 01 d0             	add    %rdx,%rax
  8004215f28:	48 39 c3             	cmp    %rax,%rbx
  8004215f2b:	75 07                	jne    8004215f34 <holding+0x54>
  8004215f2d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215f32:	eb 05                	jmp    8004215f39 <holding+0x59>
  8004215f34:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215f39:	48 83 c4 18          	add    $0x18,%rsp
  8004215f3d:	5b                   	pop    %rbx
  8004215f3e:	5d                   	pop    %rbp
  8004215f3f:	c3                   	retq   

0000008004215f40 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004215f40:	55                   	push   %rbp
  8004215f41:	48 89 e5             	mov    %rsp,%rbp
  8004215f44:	48 83 ec 10          	sub    $0x10,%rsp
  8004215f48:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004215f4c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004215f50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f54:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004215f5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f5e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215f62:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004215f66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f6a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004215f71:	00 
#endif
}
  8004215f72:	c9                   	leaveq 
  8004215f73:	c3                   	retq   

0000008004215f74 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004215f74:	55                   	push   %rbp
  8004215f75:	48 89 e5             	mov    %rsp,%rbp
  8004215f78:	53                   	push   %rbx
  8004215f79:	48 83 ec 18          	sub    $0x18,%rsp
  8004215f7d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004215f81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f85:	48 89 c7             	mov    %rax,%rdi
  8004215f88:	48 b8 e0 5e 21 04 80 	movabs $0x8004215ee0,%rax
  8004215f8f:	00 00 00 
  8004215f92:	ff d0                	callq  *%rax
  8004215f94:	85 c0                	test   %eax,%eax
  8004215f96:	74 44                	je     8004215fdc <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004215f98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f9c:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004215fa0:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004215fa7:	00 00 00 
  8004215faa:	ff d0                	callq  *%rax
  8004215fac:	49 89 d8             	mov    %rbx,%r8
  8004215faf:	89 c1                	mov    %eax,%ecx
  8004215fb1:	48 ba a0 8b 21 04 80 	movabs $0x8004218ba0,%rdx
  8004215fb8:	00 00 00 
  8004215fbb:	be 41 00 00 00       	mov    $0x41,%esi
  8004215fc0:	48 bf ca 8b 21 04 80 	movabs $0x8004218bca,%rdi
  8004215fc7:	00 00 00 
  8004215fca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215fcf:	49 b9 ae 04 20 04 80 	movabs $0x80042004ae,%r9
  8004215fd6:	00 00 00 
  8004215fd9:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004215fdc:	eb 02                	jmp    8004215fe0 <spin_lock+0x6c>
		asm volatile ("pause");
  8004215fde:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004215fe0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215fe4:	be 01 00 00 00       	mov    $0x1,%esi
  8004215fe9:	48 89 c7             	mov    %rax,%rdi
  8004215fec:	48 b8 23 5e 21 04 80 	movabs $0x8004215e23,%rax
  8004215ff3:	00 00 00 
  8004215ff6:	ff d0                	callq  *%rax
  8004215ff8:	85 c0                	test   %eax,%eax
  8004215ffa:	75 e2                	jne    8004215fde <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004215ffc:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004216003:	00 00 00 
  8004216006:	ff d0                	callq  *%rax
  8004216008:	48 98                	cltq   
  800421600a:	48 c1 e0 03          	shl    $0x3,%rax
  800421600e:	48 89 c2             	mov    %rax,%rdx
  8004216011:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216015:	48 29 c2             	sub    %rax,%rdx
  8004216018:	48 b8 20 10 6c 04 80 	movabs $0x80046c1020,%rax
  800421601f:	00 00 00 
  8004216022:	48 01 c2             	add    %rax,%rdx
  8004216025:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216029:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  800421602d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216031:	48 83 c0 18          	add    $0x18,%rax
  8004216035:	48 89 c7             	mov    %rax,%rdi
  8004216038:	48 b8 48 5e 21 04 80 	movabs $0x8004215e48,%rax
  800421603f:	00 00 00 
  8004216042:	ff d0                	callq  *%rax
#endif
}
  8004216044:	48 83 c4 18          	add    $0x18,%rsp
  8004216048:	5b                   	pop    %rbx
  8004216049:	5d                   	pop    %rbp
  800421604a:	c3                   	retq   

000000800421604b <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  800421604b:	55                   	push   %rbp
  800421604c:	48 89 e5             	mov    %rsp,%rbp
  800421604f:	41 54                	push   %r12
  8004216051:	53                   	push   %rbx
  8004216052:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004216059:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004216060:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216067:	48 89 c7             	mov    %rax,%rdi
  800421606a:	48 b8 e0 5e 21 04 80 	movabs $0x8004215ee0,%rax
  8004216071:	00 00 00 
  8004216074:	ff d0                	callq  *%rax
  8004216076:	85 c0                	test   %eax,%eax
  8004216078:	0f 85 d2 01 00 00    	jne    8004216250 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  800421607e:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216085:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004216089:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004216090:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216095:	48 89 ce             	mov    %rcx,%rsi
  8004216098:	48 89 c7             	mov    %rax,%rdi
  800421609b:	48 b8 d6 ec 20 04 80 	movabs $0x800420ecd6,%rax
  80042160a2:	00 00 00 
  80042160a5:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  80042160a7:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042160ae:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042160b2:	48 85 c0             	test   %rax,%rax
  80042160b5:	75 39                	jne    80042160f0 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  80042160b7:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042160be:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042160c2:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  80042160c9:	00 00 00 
  80042160cc:	ff d0                	callq  *%rax
  80042160ce:	48 89 da             	mov    %rbx,%rdx
  80042160d1:	89 c6                	mov    %eax,%esi
  80042160d3:	48 bf e0 8b 21 04 80 	movabs $0x8004218be0,%rdi
  80042160da:	00 00 00 
  80042160dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042160e2:	48 b9 ea 86 20 04 80 	movabs $0x80042086ea,%rcx
  80042160e9:	00 00 00 
  80042160ec:	ff d1                	callq  *%rcx
  80042160ee:	eb 4d                	jmp    800421613d <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  80042160f0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042160f7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042160fb:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  80042160fe:	44 0f b6 e0          	movzbl %al,%r12d
  8004216102:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216109:	48 8b 58 08          	mov    0x8(%rax),%rbx
  800421610d:	48 b8 e9 5b 21 04 80 	movabs $0x8004215be9,%rax
  8004216114:	00 00 00 
  8004216117:	ff d0                	callq  *%rax
  8004216119:	44 89 e1             	mov    %r12d,%ecx
  800421611c:	48 89 da             	mov    %rbx,%rdx
  800421611f:	89 c6                	mov    %eax,%esi
  8004216121:	48 bf 20 8c 21 04 80 	movabs $0x8004218c20,%rdi
  8004216128:	00 00 00 
  800421612b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216130:	49 b8 ea 86 20 04 80 	movabs $0x80042086ea,%r8
  8004216137:	00 00 00 
  800421613a:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  800421613d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004216144:	e9 c3 00 00 00       	jmpq   800421620c <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004216149:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421614c:	48 98                	cltq   
  800421614e:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216155:	89 c0                	mov    %eax,%eax
  8004216157:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  800421615e:	48 89 d6             	mov    %rdx,%rsi
  8004216161:	48 89 c7             	mov    %rax,%rdi
  8004216164:	48 b8 a0 d8 20 04 80 	movabs $0x800420d8a0,%rax
  800421616b:	00 00 00 
  800421616e:	ff d0                	callq  *%rax
  8004216170:	85 c0                	test   %eax,%eax
  8004216172:	78 6b                	js     80042161df <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216174:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216177:	48 98                	cltq   
  8004216179:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216180:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216182:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216189:	48 29 c2             	sub    %rax,%rdx
  800421618c:	49 89 d0             	mov    %rdx,%r8
  800421618f:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004216196:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  800421619c:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  80042161a2:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  80042161a9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042161ac:	48 98                	cltq   
  80042161ae:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042161b5:	4c 89 04 24          	mov    %r8,(%rsp)
  80042161b9:	49 89 f9             	mov    %rdi,%r9
  80042161bc:	41 89 f0             	mov    %esi,%r8d
  80042161bf:	89 c6                	mov    %eax,%esi
  80042161c1:	48 bf 56 8c 21 04 80 	movabs $0x8004218c56,%rdi
  80042161c8:	00 00 00 
  80042161cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161d0:	49 ba ea 86 20 04 80 	movabs $0x80042086ea,%r10
  80042161d7:	00 00 00 
  80042161da:	41 ff d2             	callq  *%r10
  80042161dd:	eb 29                	jmp    8004216208 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  80042161df:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042161e2:	48 98                	cltq   
  80042161e4:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042161eb:	89 c6                	mov    %eax,%esi
  80042161ed:	48 bf 6d 8c 21 04 80 	movabs $0x8004218c6d,%rdi
  80042161f4:	00 00 00 
  80042161f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161fc:	48 ba ea 86 20 04 80 	movabs $0x80042086ea,%rdx
  8004216203:	00 00 00 
  8004216206:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216208:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800421620c:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004216210:	7f 14                	jg     8004216226 <spin_unlock+0x1db>
  8004216212:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216215:	48 98                	cltq   
  8004216217:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421621e:	85 c0                	test   %eax,%eax
  8004216220:	0f 85 23 ff ff ff    	jne    8004216149 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004216226:	48 ba 75 8c 21 04 80 	movabs $0x8004218c75,%rdx
  800421622d:	00 00 00 
  8004216230:	be 6b 00 00 00       	mov    $0x6b,%esi
  8004216235:	48 bf ca 8b 21 04 80 	movabs $0x8004218bca,%rdi
  800421623c:	00 00 00 
  800421623f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216244:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800421624b:	00 00 00 
  800421624e:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004216250:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216257:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  800421625e:	00 
	lk->cpu = 0;
  800421625f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216266:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421626d:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  800421626e:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216275:	be 00 00 00 00       	mov    $0x0,%esi
  800421627a:	48 89 c7             	mov    %rax,%rdi
  800421627d:	48 b8 23 5e 21 04 80 	movabs $0x8004215e23,%rax
  8004216284:	00 00 00 
  8004216287:	ff d0                	callq  *%rax
}
  8004216289:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004216290:	5b                   	pop    %rbx
  8004216291:	41 5c                	pop    %r12
  8004216293:	5d                   	pop    %rbp
  8004216294:	c3                   	retq   
